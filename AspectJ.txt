bug_id	summary	desc	report_time	report_timestamp	status	commit	commit_timestamp	files
423257	LTW - java.lang.VerifyError: Bad return type with generics and local variables	<Pyinson Data Over Head> Fixed. Dev build available: http://eclipse.org/aspectj/downloads.phpThanks for the great test case. Just tested the latest development build. I can confirm it is fixed.Thanks a lot for the quick fix! I'll be waiting for the 1.7.5 release then. 	2013-12-04 19:43:22	1386200000.0	resolved fixed	dd88d21	1386350000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java tests/bugs175/pr423257/AspectX.java tests/bugs175/pr423257/Test.java tests/src/org/aspectj/systemtest/AllTests17.java tests/src/org/aspectj/systemtest/ajc175/Ajc175Tests.java tests/src/org/aspectj/systemtest/ajc175/AllTestsAspectJ175.java tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java weaver/src/org/aspectj/weaver/bcel/asm/StackMapAdder.java
420210	Support additional message insert keys in declare error/warning	"It would be good to be able to insert the enclosing class name or enclosing member for a joinpoint. New keys:joinpoint.enclosingclassjoinpoint.enclosingmember // void Bar.foo(String)joinpoint.enclosingmember.name // foo Should those be in camelCase, like the message inserts documented at http://eclipse.org/aspectj/doc/next/README-169.html? Just noticed that only ""declaringType"" is in camel case.  All others are all lower. they are actually all case insensitive. So it is a doc issue, but not sure when a docs update will get done... "	2013-10-23 16:00:16	1382560000.0	resolved fixed	9319e34	1382560000.0	org.aspectj.matcher/src/org/aspectj/weaver/Checker.java tests/bugs174/extra_inserts/Code.java tests/src/org/aspectj/systemtest/ajc174/Ajc174Tests.java
419279	ajc option to change -Xlint level per-message without Xlintfile	The -Xlintfile option is not a great fit for controlling message across multiple build projects, specifically in my case from the pluginManagement section of a maven parent pom. The problem is that you need a local file to configure the per-message output levels (ignore/warning/error) when you really want to specify it in the build script or in a shared file.As an alternative to -Xlintfile, it would be handy to be able to change an Xlint warning level per message using command line options.For example:ajc -Xlint:adviceDidNotMatch=ignorewould override the XlintDefault.properties file for the adviceDidNotMatch message.With RegardsRob fixed. -Xlint: can take a comma separated list of name=value pairs. 	2013-10-11 15:20:08	1381520000.0	resolved fixed	b2cd5fa	1382560000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java org.aspectj.matcher/src/org/aspectj/weaver/Lint.java testing/newsrc/org/aspectj/testing/CompileSpec.java tests/bugs174/pr419279/Code.java tests/src/org/aspectj/systemtest/ajc174/Ajc174Tests.java
415266	LTW not working when JMX is enabled	"When I enable JMX remote management on a JVM along with AspectJ load-time weaving (LTW), our Aspect doesn't appear to get woven in.This are the JVM arguments:-Dvisualvm.display.name=JdbcTimingAspectTest -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.port=1024 -javaagent:/jars/aspectjweaver.jar -Dorg.aspectj.weaver.loadtime.configuration=com/trgr/cobalt/infrastructure/instrumentation/aspects/timing/jdbc/jdbcmonitor.xmlNote that if I don't enable JMX remote management (by remove the -Dcom.sun.management.jmxremote.* JVM arguments), the Aspect works fine. Note that according to this post on StackOverflow.com:http://stackoverflow.com/questions/17784939/aspectj-ltw-not-working-with-jmx-remoteA workaround is to add the following to the java arguments:-Xbootclasspath/p:libs/aspectjweaver-1.7.3.jarThis workaround seems like it could lead to other issues. Could someone comment on whether or not this would be the recommended workaround until a bug fix is available? The bug seems to be coming from this modification:https://github.com/eclipse/org.aspectj/commit/8a6608f4d5d1a2aa8aa49a0a38da66a54d53c917#L0R265When JMX is enabled, the first classloader is not the same as the ""myClassLoader"" (AppClassLoader). Therefore this conditions does not have the proper adaptor:if(loader.equals(myClassLoader)){    adaptor = myClassLoaderAdpator;} Adding the condition ""loader.equals(myClassLoader)"" would probably work.I didn't have time to test this solution. In theory running with the weaver on the bootclasspath should be ok.  The weaver may have access to weaving more types but as long as your aspects are carefully targeting what they need to weave you shouldn't weave anything else by accident. Sebastien, I'm interested in trying your proposed solution - but what is it?> if(loader.equals(myClassLoader)){>    adaptor = myClassLoaderAdpator;> } >> Adding the condition ""loader.equals(myClassLoader)"" would probably work.Did you mean add that condition? It is the same as the condition already there? (In reply to comment #4)> Sebastien, I'm interested in trying your proposed solution - but what is it?> > > if(loader.equals(myClassLoader)){> >    adaptor = myClassLoaderAdpator;> > } > >> > Adding the condition ""loader.equals(myClassLoader)"" would probably work.> > Did you mean add that condition? It is the same as the condition already> there?Hi Andrew,    I'm suggesting updating the condition:if(myClassLoaderAdpator == null){    myClassLoaderAdpator = adaptor;}to:if(myClassLoaderAdpator == null && loader.equals(myClassLoader)){    myClassLoaderAdpator = adaptor;}Basically, the code keeps a reference of its own classloader (myClassLoader) in order to keep a reference of its own adaptor. However it keeps the wrong reference if the first loaded class loader in this class is not its own (which seems to happen when JMX is activated).  > However it keeps the wrong> reference if the first loaded class loader in this class is not its own> (which seems to happen when JMX is activated).I mean it keeps the wrong adaptor reference. When it's time to weave the classloader that is kept in reference (myClassLoader) it uses the adaptor from this condition:if(loader.equals(myClassLoader)){    adaptor = myClassLoaderAdpator;} which is not the right one. Therefore the class loader is never weaved. A dev build is available with Sebastiens proposed change in:http://www.eclipse.org/downloads/download.php?file=/tools/aspectj/dev/aspectj-DEVELOPMENT-20130828153000.jar (In reply to Andrew Clement from comment #7)> A dev build is available with Sebastiens proposed change in:> > http://www.eclipse.org/downloads/download.php?file=/tools/aspectj/dev/> aspectj-DEVELOPMENT-20130828153000.jarAndy, I just verified that this build fixes the issue. With the new JAR, my Aspect gets weaved in even when remote JMX management is enabled.Thanks Andy and Sebastien for helping to fix this. What are the next steps to get this into an official AspectJ build? changes are now committed. in 1.7.4 "	2013-08-16 17:51:29	1376690000.0	resolved fixed	9e992d6	1380650000.0	loadtime/src/org/aspectj/weaver/loadtime/Aj.java
418129	Can't introduce annotation onto introduced method from trait-patterned aspect	"Created attachment 235865eclipse AspectJ testcaseAn aspect is introducing a field and a method.  Introducing an annotation onto the introduced field works fine; introducing an annotation onto the introduced **method** fails with the message ""The method '...' does not exist"" (where '...' is the method pattern).Aspect follows trait pattern:public interface Behavior { String hello(); }=====@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface Behaved {}=====public aspect Trait {	public interface I extends Behavior {}		declare parents: @Behaved * implements I;		private String I.name = getClass().getName();		public String I.hello() {		return ""hello"" + name;	}}=====@Behavedpublic class Target {	public static aspect A {		declare @field: * Target.name: @Tagged; // WORKY		declare @method: * Target.hello(..): @Tagged; // NO WORKY	}}=====@Target({ ElementType.TYPE, ElementType.METHOD, ElementType.FIELD,		ElementType.CONSTRUCTOR })@Retention(RetentionPolicy.RUNTIME)public @interface Tagged {}Test eclipse AspectJ project attached. This comes down to a FIXME in the code (BcelClassWeaver):weaveInAddedMethods(); // FIXME asc are these potentially affected by declare annotation?The added methods are those like the one here, the method added to the top most implementor of an interface when the ITD method was on an interface.The fix is not trivial. These added methods are not of the right type to pass to the matching code for the declare annotation patterns. Andy, I'm not sure what your comment means.  Are you saying that it's not really fixable? fixed. Not the cleanest impl but it works. Andy, can you trigger a snapshot build?http://repo.spring.io/snapshot/org/aspectj/aspectjrt/1.8.0.BUILD-SNAPSHOT/looks out of date and I'm having trouble building locally. Testing against 1.7.4.BUILD-SNAPSHOT worked jim-dandy.AJDT 1.8.0(.latest) complains, and understandably, since it uses aspectj from the 1.8 branch, which didn't receive this fix, as it went into master, which is where 1.7.4 is coming from. "	2013-09-26 14:31:09	1380220000.0	resolved fixed	2393bef	1380650000.0	tests/bugs174/pr418129/Target.java tests/bugs174/pr418129/Target2.java tests/bugs174/pr418129/Target3.java tests/bugs174/pr418129/Target4.java tests/src/org/aspectj/systemtest/ajc174/Ajc174Tests.java weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java weaver/src/org/aspectj/weaver/bcel/BcelWorld.java weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java
368046	configure a set of classloader for which weavers should not be created in an LTW scenario	Prototyped and tested for JspClassLoaders (see the thread 'aspectj and jsp load' on the mailing list).That was done through a system property but it would be easier via aop.xml.  However, this would be the first time we have an aop.xml setting that affects global operation of loadtime weaving.  When any classloader actually got far enough to load the aop.xmls it would discover this setting and from that point on it would be set.  In our JspClassLoader case this would mean that either some non-JspClassLoader is run early enough to discover this setting and turn it off for all JspClassLoaders or the first JspClassLoader will discover the setting and turn it off for all other JspClassLoaders.  I think we can live with that mode of operation. unsetting the target field which is currently set for something already released Pushed this into the 1.7 branch (so will be in the 1.7.4 release).Two config mechanics:1) System property, comma separated list of classnames:aj.weaving.loadersToSkip=com.foo.MyLoader,com.bar.SomeOtherLoader2) aop.xml, in the options value:-loadersToSkip:com.foo.MyLoader,com.bar.SomeOtherLoaderThe former has had more testing than the latter. If anyone tries this out let me know if the 2nd option is behaving.  As the aop.xml files are read *after* the weaver is initialized it is possible that (currently) the first loader of the type will get through, and only subsequent ones will not get a weaver. In a situation where you want to exclude 5000 Jsp loaders, if just 1 gets through that doesn't feel like a big deal, but this loophole should be closed later. 	2012-01-06 12:05:35	1325870000.0	resolved fixed	0c0adc5	1375160000.0	loadtime/src/org/aspectj/weaver/loadtime/Aj.java loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java loadtime/src/org/aspectj/weaver/loadtime/Options.java tests/bugs174/pr368046/Azpect.java tests/bugs174/pr368046/Code.java tests/src/org/aspectj/systemtest/ajc174/Ajc174Tests.java
413378	A constructor added by ITD cannot invoke the method of its super class	"AspectJ Development Tools	2.2.0.e37x-RELEASE-20120704-0900It seems *super.someMethod()* can not be correctly resolved in theconstructor added by ITD It can be compiled with no problem, but* at runtime, exception is raised.*The class which I'll add a new constructor to:public class Child extends Parent{    public String mParent = ""John"";        public Child(String parent) {        this.mParent = parent;    }        public String getParent()    {        return this.mParent;    }}As we can see, *Child * extends *Parent*class Parent has a method getAge()public class Parent {    private String mName = ""John"";    private int mAge = 50;        public int getAge(){        return mAge;    }}If I add a new constructor for the *Child * in my aspect.public aspect MyTest {    public Child.new(String parent, int age) {        this(parent);                System.out.println(""Get Age:"" + super.getAge());        System.out.println(""Child Name:"" + this.mParent);    }}The above aspect code will trigger an exception.Exception in thread ""main"" java.lang.NoSuchMethodError: com.test.Child.ajc$superDispatch$com_test_Child$getAge()I	at MyTest.ajc$postInterConstructor$MyTest$com_test_Child(MyTest.aj:13)	at com.test.Child.<init>(Child.java:1)	at MainProgram.main(MainProgram.java:14)Is this a limitation of AspectJ? Is this the only way to resolve thisissue?I also attach the src & compiled binary files Created attachment 233643sample source & weaved binary hmmm, looks like this problem has been in there forever. The infrastructure is all there but isn't wired up. I just wired it up - all fixed. Thanks for the test code! Thanks for the quick fix :) "	2013-07-20 02:22:28	1374300000.0	resolved fixed	302c14e	1374530000.0	tests/bugs174/pr413378/Code.java tests/src/org/aspectj/systemtest/AllTests17.java tests/src/org/aspectj/systemtest/ajc174/Ajc174Tests.java tests/src/org/aspectj/systemtest/ajc174/AllTestsAspectJ174.java weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java
407017	Stack trace being printed, but want to mute it	In org.aspectj.ajdt.internal.core.builder.AjState.getDelegate(ReferenceType), there is a call to printStackTrace().  On the AJDT build server, this exception is being printed and causing some noise.  Can you replace that call with a call to the IMessageHandler for the build? As exceptions shouldn't be happening, can you include the error message and the exception here? fixed up. 	2013-05-01 15:10:46	1367440000.0	resolved fixed	e6cb508	1372460000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java
408721	java.util.ConcurrentModificationException when multiple threads enter the weaver	I am using AspectJ 1.7.1.  Occasionally I see the following exception, which I believe is related to multiple threads initializing some internal state.java.util.ConcurrentModificationException: null       at java.util.ArrayList$Itr.checkForComodification(Unknown Source) ~[na:1.7.0_11]       at java.util.ArrayList$Itr.next(Unknown Source) ~[na:1.7.0_11]       at org.aspectj.weaver.ReferenceType.findDerivativeType(ReferenceType.java:1122) ~[aspectjweaver.jar:1.7.1]       at org.aspectj.weaver.TypeFactory.createParameterizedType(TypeFactory.java:44) ~[aspectjweaver.jar:1.7.1]       at org.aspectj.weaver.ResolvedType.parameterize(ResolvedType.java:2479) ~[aspectjweaver.jar:1.7.1]       at org.aspectj.weaver.ReferenceType.getDeclaredInterfaces(ReferenceType.java:673) ~[aspectjweaver.jar:1.7.1]       at org.aspectj.weaver.ResolvedType.getDirectSupertypes(ResolvedType.java:82) ~[aspectjweaver.jar:1.7.1]       at org.aspectj.weaver.patterns.TypePattern.matchesSubtypes(TypePattern.java:178) ~[aspectjweaver.jar:1.7.1]       at org.aspectj.weaver.patterns.ExactTypePattern.matchesSubtypes(ExactTypePattern.java:74) ~[aspectjweaver.jar:1.7.1]       at org.aspectj.weaver.patterns.TypePattern.matchesStatically(TypePattern.java:130) ~[aspectjweaver.jar:1.7.1]       at org.aspectj.weaver.patterns.KindedPointcut.fastMatch(KindedPointcut.java:130) ~[aspectjweaver.jar:1.7.1]       at org.aspectj.weaver.internal.tools.PointcutExpressionImpl.couldMatchJoinPointsInType(PointcutExpressionImpl.java:84) ~[aspectjweaver.jar:1.7.1]       at org.springframework.aop.aspectj.AspectJExpressionPointcut.matches(AspectJExpressionPointcut.java:250) ~[spring-aop.jar:3.2.1.RELEASE]       at org.springframework.aop.support.AopUtils.canApply(AopUtils.java:208) ~[spring-aop.jar:3.2.1.RELEASE]       at org.springframework.aop.support.AopUtils.canApply(AopUtils.java:262) ~[spring-aop.jar:3.2.1.RELEASE]       at org.springframework.aop.support.AopUtils.findAdvisorsThatCanApply(AopUtils.java:294) ~[spring-aop.jar:3.2.1.RELEASE]       at org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator.findAdvisorsThatCanApply(AbstractAdvisorAutoProxyCreator.java:118) ~[spring-aop.jar:3.2.1.RELEASE] fixed. I put synchronized blocks around access to that collection. 	2013-05-22 12:10:52	1369240000.0	resolved fixed	3f6e166	1372280000.0	org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java
404600	Unhandled RuntimeException	I'm getting an unhandled RuntimeException from STS 3.2.0.RELEASE:java.lang.RuntimeExceptionat org.aspectj.asm.AsmManager.sameType(AsmManager.java:897)at org.aspectj.asm.AsmManager.removeRelationshipsTargettingThisType(AsmManager.java:711)at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1033)at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.weaveQueuedEntries(AjPipeliningCompilerAdapter.java:514)at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.queueForWeavin ... ndation-domain/src\/main\/java<com.scispike.foundation.domain.trait.persistence*PersistableAspect.aj%com.scispike.foundation.domain.trait.persistence)Andy Clement, this can be reproduced in our private foundation repo's dev branch at commit d879446f2bfd83b51bf711d2931f4b28ce8c1901.After clicking ok on the exception dialog, there is an error marker on the package statement with text:Internal compiler error: java.lang.RuntimeException: Exception whilst walking up from target com.scispike.foundation.domain.trait.persistence kind=(package declaration)  hid=(=foundation-domain/src\/main\/java<com.scispike.foundation.domain.trait.persistence*PersistableAspect.aj%com.scispike.foundation.domain.trait.persistence) at  org.aspectj.asm.AsmManager.sameType(AsmManager.java:897)If I do a Project\Clean..., the exception is not reproduced and everything compiles ok.  Next edit repros the exception. Created attachment 229175screen cap of unhandled exception Created attachment 229176screen cap of package error marker Matthew, I think you need to give me some fresh access to the project? (Based on our discussion earlier). Efforting that now...(In reply to comment #3)> Matthew, I think you need to give me some fresh access to the project?> (Based on our discussion earlier). Fixed. Thanks for the project. An declare @type was targeting a parameterized type and those don't have a proper representation in the model, only the generic type is stored. The fix was to work with the generic type instead. All committed, should be in the next e42 AJDT build. 	2013-03-29 00:48:42	1364530000.0	resolved fixed	ff0859d	1364930000.0	weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java
404594	Assertion failed at ResolvedType.java:614	"Created attachment 229171Sample Maven projectStacktrace:java.lang.AssertionError  at org.aspectj.weaver.ResolvedType.lookupResolvedMember(ResolvedType.java:614)  at org.aspectj.weaver.JoinPointSignatureIterator.findSignaturesFromSupertypes(JoinPointSignatureIterator.java:192)  at org.aspectj.weaver.JoinPointSignatureIterator.hasNext(JoinPointSignatureIterator.java:68)  at org.aspectj.weaver.patterns.SignaturePattern.matches(SignaturePattern.java:317)  at org.aspectj.weaver.patterns.KindedPointcut.matchInternal(KindedPointcut.java:202)  at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:137)  at org.aspectj.weaver.patterns.AndPointcut.matchInternal(AndPointcut.java:51)  at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:137)  at org.aspectj.weaver.patterns.OrPointcut.matchInternal(OrPointcut.java:50)  at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:137)  at org.aspectj.weaver.patterns.OrPointcut.matchInternal(OrPointcut.java:50)  at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:137)  at org.aspectj.weaver.patterns.OrPointcut.matchInternal(OrPointcut.java:50)  at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:137)  at org.aspectj.weaver.ShadowMunger.match(ShadowMunger.java:113)  at org.aspectj.weaver.Advice.match(Advice.java:109)  at org.aspectj.weaver.bcel.BcelAdvice.match(BcelAdvice.java:149)  at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:3167)  at org.aspectj.weaver.bcel.BcelClassWeaver.matchInvokeInstruction(BcelClassWeaver.java:3115)  at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2773)  at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2553)  at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:480)  at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:99)  at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1691)  at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1635)  at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1400)  at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1186)  at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.weaveQueuedEntries(AjPipeliningCompilerAdapter.java:514)  at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.queueForWeaving(AjPipeliningCompilerAdapter.java:447)  at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.afterProcessing(AjPipeliningCompilerAdapter.java:432)  at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$after$org_aspectj_ajdt_internal_compiler_CompilerAdapter$5$6b855184(CompilerAdapter.aj:98)  at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:805)  at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:468)  at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:1028)  at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performBuild(AjBuildManager.java:272)  at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:185)  at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)  at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)  at org.aspectj.tools.ajc.Main.run(Main.java:371)  at org.aspectj.tools.ajc.Main.runMain(Main.java:248)  ...Sample Maven project attached. It fails on test-compile phase, and assertions should be enabled: ""MAVEN_OPTS=-ea mvn test-compile"". fixed. thanks so much for the testcase, they are so helpful. "	2013-03-28 16:53:10	1364500000.0	resolved fixed	4e34477	1364860000.0	org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java
318878	Pertarget aspect instantiation is not thread-safe	"The way in which pertarget aspects compiled with ajc check if a given target already has an aspect is not thread safe. When two different threads trigger an advice on a target object for the first time at the same time, sometimes the aspect for that target gets created twice.The following code demonstrates the problem:The following pertarget aspect will add itself to a (synchronized) set in another class in it's constructor.aspect Pertarget pertarget(execution(void foo())) {        public Pertarget() {                Main.aspects.add(this); // Add this instance to the set in Main        }        before(): execution(void foo()) {} // Empty advice to trigger creation}This class creates 10000 target objects and has two separate threads call a method (that causes the aspect to be instantiated) on each object. The aspects add themselves to the ""aspects"" set and this set's size is printed when all threads have finished.import java.util.Collections;import java.util.IdentityHashMap;import java.util.Set;public class Main {    public static Set aspects = Collections.synchronizedSet(        Collections.newSetFromMap(new IdentityHashMap()));    public static void main(String[] args) throws InterruptedException {        for (int i = 0; i < 10000; ++i) {            final Main m = new Main(); // Create a new target for the aspect            Runnable r = new Runnable() {                public void run() { m.foo(); } // This will trigger the advice            };            Thread t1 = new Thread(r);            Thread t2 = new Thread(r);            t1.start();            t2.start();            t1.join();            t2.join();        }        System.out.println(aspects.size()); // Should be 10000    }    private void foo() {}}When compiled with ajc and run, the main method prints values over 10000 (something like 10030-10060 typically), which means that some target objects get multiple aspect instances.In my own application I sometimes also saw some threads accessing partially built aspect instances. This was quite rare however and I wasn't able to make a test case for it.The ajc version (the current stable) used was:AspectJ Compiler 1.6.8 (1.6.8 - Built: Friday Jan 8, 2010 at 21:53:37 GMT) - Eclipse Compiler 0.785_R33x, 3.3The sun vm version was:Java(TM) SE Runtime Environment (build 1.6.0_20-b02)Java HotSpot(TM) 64-Bit Server VM (build 16.3-b01, mixed mode)I investigated the source of this problem: the ajc compiler generates the following (decompiled) method into the aspect class:public static void ajc$perObjectBind(Object obj){    if((obj instanceof ajcMightHaveAspect) && ((ajcMightHaveAspect)obj).perObjectGet() == null)        ((ajcMightHaveAspect)obj).perObjectSet(new Pertarget());}, which obviously is not thread safe. reported on the mailing list too, the same issue with perthis. I modified the bind method to be synchronized (will affect perthis and pertarget) "	2010-07-05 07:23:40	1278330000.0	resolved fixed	be5a530	1361830000.0	org.aspectj.matcher/src/org/aspectj/weaver/AjcMemberMaker.java
391384	WildAnnotationTypePattern.java:231	"OK, I get that this is not supported (and what I *want* here is matching on the existence of the supplied header *among* the headers in the String[]). A feature request might be in order, but a syntax for specifying how you want to match the array would be needed....The bug that I'm reporting is that trying to *save* this program gets an error that pops up a dialog. This should just become another error marker.It might the compiler that has to change what it throws, but in the end it's the Eclipse IDE that ends up breaking from a user standpoint.(RequestMapping.headers() is of type String[]).public aspect Fail {    pointcut testable(): execution(public * @RequestMapping(headers=""x-test=test"") com.example..*(..));}java.lang.RuntimeExceptionat org.aspectj.weaver.patterns.WildAnnotationTypePattern.resolveAnnotationValues(WildAnnotationTypePattern.java:231)at org.aspectj.weaver.patterns.WildAnnotationTypePattern.resolveBindings(WildAnnotationTypePattern.java:325)at org.aspectj.weaver.patterns.WildTypePattern.resolveBindings(WildTypePattern.java:657)at org.aspectj.weaver.patterns.SignaturePattern.resolveBindings(SignaturePattern.java:81)at org.a ... n(Worker.java:53)Compile error: RuntimeException thrown: Compiler limitation: annotation value support not implemented for type java.lang.String[] I've changed it to a regular error from a runtime exception. "	2012-10-09 00:09:54	1349760000.0	resolved fixed	edb41e3	1360090000.0	org.aspectj.matcher/src/org/aspectj/weaver/WeaverMessages.java org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java tests/bugs172/pr391384/Code.java tests/src/org/aspectj/systemtest/ajc172/Ajc172Tests.java
394535	Java throws OutOfMemory in call to Class.getGenericSuperclass() on woven class	"Ran AspectJ compiler on this class:  public class Bug {    @org.springframework.beans.factory.annotation.Configurable    public static class ClassA<T extends Interface1 & Interface2> {    }    public static class ClassB extends ClassA<ClassB> implements Interface1, Interface2 {    }    public interface Interface1 {    }    public interface Interface2 {    }    public static void main(String[] args) throws Exception {        System.out.println(ClassB.class.getGenericSuperclass());    }  }Then tried to execute the class' main() method using Java 1.6.0-37 and got OOM:  Exception in thread ""main"" java.lang.OutOfMemoryError: Java heap space    at java.util.Arrays.copyOf(Arrays.java:2760)    at java.util.Arrays.copyOf(Arrays.java:2734)    at java.util.ArrayList.ensureCapacity(ArrayList.java:167)    at java.util.ArrayList.add(ArrayList.java:351)    at sun.reflect.generics.parser.SignatureParser.parseFormalTypeParameters(SignatureParser.java:190)    at sun.reflect.generics.parser.SignatureParser.parseZeroOrMoreFormalTypeParameters(SignatureParser.java:177)    at sun.reflect.generics.parser.SignatureParser.parseClassSignature(SignatureParser.java:171)    at sun.reflect.generics.parser.SignatureParser.parseClassSig(SignatureParser.java:126)    at sun.reflect.generics.repository.ClassRepository.parse(ClassRepository.java:34)    at sun.reflect.generics.repository.ClassRepository.parse(ClassRepository.java:23)    at sun.reflect.generics.repository.AbstractRepository.<init>(AbstractRepository.java:56)    at sun.reflect.generics.repository.GenericDeclRepository.<init>(GenericDeclRepository.java:30)    at sun.reflect.generics.repository.ClassRepository.<init>(ClassRepository.java:30)    at sun.reflect.generics.repository.ClassRepository.make(ClassRepository.java:47)    at java.lang.Class.getGenericInfo(Class.java:2254)    at java.lang.Class.getTypeParameters(Class.java:621)    at sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl.validateConstructorArguments(ParameterizedTypeImpl.java:39)    at sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl.<init>(ParameterizedTypeImpl.java:35)    at sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl.make(ParameterizedTypeImpl.java:77)    at sun.reflect.generics.factory.CoreReflectionFactory.makeParameterizedType(CoreReflectionFactory.java:86)    at sun.reflect.generics.visitor.Reifier.visitClassTypeSignature(Reifier.java:122)    at sun.reflect.generics.tree.ClassTypeSignature.accept(ClassTypeSignature.java:31)    at sun.reflect.generics.repository.ClassRepository.getSuperclass(ClassRepository.java:66)    at java.lang.Class.getGenericSuperclass(Class.java:677)    at Bug.main(Bug.java:18)Using JDK 1.7 we get a java.lang.reflect.GenericSignatureFormatError instead.Users mailing list discussion thread:  http://dev.eclipse.org/mhonarc/lists/aspectj-users/msg13789.htmlThis bug may be related to Bug #360253.Reproducible test case will be attached. Test case is also available here:  http://people.freebsd.org/~archie/bug.tgz Created attachment 223702Reproducible test case fixed. Thanks for taking the time to create a testcase, it is so helpful.Each field signature in the generated signature should be prefixed with a ':' but we were just prefixing the first one. "	2012-11-18 10:54:17	1353250000.0	resolved fixed	46f9079	1360090000.0	org.aspectj.matcher/src/org/aspectj/weaver/TypeVariable.java tests/bugs172/pr394535/Bug.java tests/bugs172/pr394535/Bug2.java tests/src/org/aspectj/systemtest/ajc172/Ajc172Tests.java
399590	Bad generics signature generated	Please see http://jira.springsource.org/browse/SPR-5949.  The bug ID https://bugs.eclipse.org/bugs/show_bug.cgi?id=284297 was raised for this issue and fixed in version 1.6.6.  We were using AspectJ version 1.7.1 and got hit by this bug today.During investigation we have found that the problem does not occur with AspectJ versions 1.6.6 - 1.6.8 but it resurfaces with version 1.6.9 and can be reproduced all the way up to the current version 1.7.1. Are you sure it is the same signature problem exactly? I took the code from spr5949 and cannot make it fail in the same way.  I don't see the P signatures in the resultant compiled code and I can use the woven classes just fine.Can you let me know your sequence of steps? What version of Spring - is it 2.5.5/2.5.6/3.0M3 as mentioned in the spring jira? What version of Java compliance? (1.5/1.6/1.7?)Per the spring jira i compiled these 3 files:public class DomainObject<E> { }public class DomainLogic<E, D extends DomainObject<E>> { }@org.springframework.beans.factory.annotation.Configurablepublic class FancyDomainLogic<E, D extends DomainObject<E>> extends DomainLogic<E, D> { }using Spring 2.5.6 jars, classpath contained spring-tx.jar/spring-beans.jarI created a zip of the resultant class file, then a binary weave applying the aspects:ajc -aspectpath spring-framework-2.5.6/dist/weaving/spring-aspects.jar -inpath code.zip -outjar code2.zipthen compiled this against the result:public class FancyDomainLogicImpl <E, D extends DomainObject<E>> extends FancyDomainLogic<E, D> { }all worked fine. I'm happy to fix it but I will need to recreate a failing scenario.  I also tried a separate aspect that I knew would really target the type signature and change it, still no problems.If you do have a failing signature message, can you attach it here?thanks Hi AndrewLet me create a sample using the bare minimum classes that will reproduce the problem. Created attachment 226487Sample Maven project to reproduce the problemPlease find a sample Maven project that can be used to reproduce the error. thanks so much for taking the time to create a testcase.  I've fixed it all up and the latest 1.7.2.BUILD-SNAPSHOTs in maven include the fix.  The failing case needed a slightly complex generics signature which your type 'Cage' had, so similar to the problem previously fixed but a different manifestation. Hi AndrewThanks a ton for addressing this so quickly.  Is there any guidance on when 1.7.2 will be released publicly? Also, where is the source code and how can one get access to it?  I checked out the repository link to Eclipse Git but could not understand where release 1.7.2 code is maintained. 1.7.2 is quite imminent, couple of weeks I think. Just a few loose ends to wrap up.If you have the git repo cloned shown on here:http://git.eclipse.org/c/aspectj/org.aspectj.gitThen 'master' is the current active development code. All the previous releases are dealt with as tags, there are no branches for releases. Run 'git tag' and you will see V1_1_0 > V1_7_1. When 1.7.2 is out, it'll get tagged there too. The fix I made for this was in BoundedReferenceType to ensure it overrode getSignatureForAttribute() (IIRC). 	2013-01-31 04:17:35	1359620000.0	resolved fixed	4af4b1e	1360010000.0	org.aspectj.matcher/src/org/aspectj/weaver/BoundedReferenceType.java tests/bugs172/pr399590/Cage.java tests/bugs172/pr399590/Cage2.java tests/bugs172/pr399590/five/Cage.java tests/bugs172/pr399590/five/Cage2.java tests/bugs172/pr399590/four/Cage.java tests/bugs172/pr399590/four/Cage2.java tests/bugs172/pr399590/three/Cage.java tests/bugs172/pr399590/three/Cage2.java tests/bugs172/pr399590/two/Cage.java tests/bugs172/pr399590/two/Cage2.java tests/src/org/aspectj/systemtest/ajc172/Ajc172Tests.java
399408	NPE in ExactAnnotationTypePattern.matches	[ERROR] java.lang.NullPointerException[ERROR] at org.aspectj.weaver.patterns.ExactAnnotationTypePattern.matches(ExactAnnotationTypePattern.java:137)[ERROR] at org.aspectj.weaver.patterns.ExactAnnotationTypePattern.matches(ExactAnnotationTypePattern.java:96)[ERROR] at org.aspectj.weaver.patterns.AnyWithAnnotationTypePattern.matchesExactly(AnyWithAnnotationTypePattern.java:55)[ERROR] at org.aspectj.weaver.patterns.TypePattern.matchesStatically(TypePattern.java:132)[ERROR] at org.aspectj.weaver.patterns.DeclareParents.match(DeclareParents.java:63)[ERROR] at org.aspectj.weaver.patterns.DeclareParents.findMatchingNewParents(DeclareParents.java:358)[ERROR] at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.doDeclareParents(AjLookupEnvironment.java:885)[ERROR] at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:766)[ERROR] at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveIntertypes(AjLookupEnvironment.java:424)[ERROR] at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveIntertypes(AjLookupEnvironment.java:410)[ERROR] at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:261) This is due to not reinitializing the annotation list in EclipseSourceType when a declaration gets a new annotation.  The annotation types list was correctly recomputed but not the pure annotation list.  Fixed. 	2013-01-29 12:01:47	1359480000.0	resolved fixed	d524403	1359480000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java
398588	Using aspect 'requires' clause causes all aspects with 'requires' clauses not be loaded regardless	The usage of the 'requires' clause causes all aspects that have have 'requires' clauses not to be loaded regardless of whether the specified required class exists or not. Here is the scenario and why it happens:   Let's assume we have a bunch of aspects (A1, A2, A3, etc.) - all with 'requires' clauses and all referencing classes that can be satisfied. ClassLoaderWeavingAdaptor#registerAspects goes over the aspects in a Definition one by one. It reaches aspect A1 and detects that it has a 'requires' clause, and so it invokes BcelWorld#addAspectRequires. This causes the aspect A1 and its required class to be registered in an internal 'aspectRequiredTypes' map.   Then the code calls BcelWeaver#addLibraryAspect with A1 as the argument, which in turn calls addOrReplaceAspect which invokes 'hasUnsatisfiedDependency'. The 'hasUnsatisfiedDependency' has been written to run only ONCE - i.e., it checks if it has already run, and if so then it does nothing. Otherwise, it removes from the 'aspectRequiredTypes' map all the types that can be resolved, thus leaving only those that cannot be resolved. In other words, it assumes that after having run (once !!!) any remaining type must be unsatified. Thus, when it is invoked with A1, being the 1st time, it resolves the required type by A1 and leaves the 'aspectRequiredTypes' map empty - but also marks that no further running is required.   When the ClassLoaderWeavingAdaptor#registerAspects loop reaches A2, it call BcelWorld#addAspectRequires since A2 also declares a 'requires' clause. This causes A2 and its referenced class to be mapped in the 'aspectRequiredTypes' map. However, when BcelWeaver#addLibraryAspect is called with A2 and the code reaches 'hasUnsatisfiedDependency' - the code assumes that it has already run (which it has - with A1), so it does not check if indeed A2's referenced class can be satisfied (which we assume it can). In other words, all subsequent aspects (A2, A3, etc.) are declared as having unsatisified dependencies - which they don't.   The (quick) bugfix seems rather simple: every time BcelWorld#addAspectRequires method is called, it should mark 'aspectRequiredTypesProcessed' as FALSE, in order to force a re-evaluation in case 'hasUnsatisfiedDependency' is called. good catch !I just added some testcases for this and changed the implementation. I could just set aspectRequiredTypesProcessed to false but that will produces lots of confusing (and duplicated) error messages about deactivated aspects when you have multiple 'requiring' aspects.  I've restructured it instead, testcases are passing. fixed *** Bug 398590 has been marked as a duplicate of this bug. *** *** Bug 398589 has been marked as a duplicate of this bug. *** *** Bug 398587 has been marked as a duplicate of this bug. *** 	2013-01-20 01:42:35	1358660000.0	resolved fixed	96ebaae	1358790000.0	tests/bugs172/pr398588/Anno.java tests/bugs172/pr398588/Anno2.java tests/bugs172/pr398588/AspectA.java tests/bugs172/pr398588/AspectB.java tests/bugs172/pr398588/AspectC.java tests/bugs172/pr398588/AspectD.java tests/bugs172/pr398588/Blah.java tests/bugs172/pr398588/Code.java tests/bugs172/pr398588/Code2.java tests/src/org/aspectj/systemtest/ajc172/Ajc172Tests.java weaver/src/org/aspectj/weaver/bcel/BcelWorld.java
395221	weird error about unbound formals when mixing generics with annotation style	"From the mailing list:I have following problem with following Aspect:@Aspectpublic class CounterAspect extends AbstractMoskitoAspect {	@Around(value = ""execution(* *(..)) && (@annotation(method))"")    public Object countMethod(ProceedingJoinPoint pjp, Count method) throws Throwable {    	return count(pjp, method.producerId(), method.subsystem(), method.category());    }	@Around(value = ""execution(* *(..)) && (@annotation(method))"")	public Object countByParameter(ProceedingJoinPoint pjp, CountByParameter method) throws Throwable {		return countByParameter(pjp, method.producerId(), method.subsystem(), method.category());	}	@Around(value = ""execution(* *.*(..)) && (@within(clazz))"")    public Object countClass(ProceedingJoinPoint pjp, Count clazz) throws Throwable {    	return count(pjp, clazz.producerId(), clazz.subsystem(), clazz.category());    }	private Object countByParameter(ProceedingJoinPoint pjp, String aProducerId, String aSubsystem, String aCategory) throws Throwable {....It works. However, since I have two similar aspects that differ only in using some internal classes, I made my super class using generics:public class AbstractMoskitoAspect<S extends IStats> {@Aspectpublic class CounterAspect extends AbstractMoskitoAspect<CounterStats> {this breaks the build instantly with the very unhelpful error message:[ERROR] Failed to execute goal org.codehaus.mojo:aspectj-maven-plugin:1.4:compile (default) on project moskito-aop: Compiler errors:[ERROR] error at @Around(value = ""execution(* *(..)) && (@annotation(method))"")[ERROR] ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^[ERROR] /Users/another/projects/moskito/moskito-aop/java/net/anotheria/moskito/aop/aspect/CounterAspect.java:24:0::0 the parameter pjp is not bound in [all branches of] pointcut[ERROR] error at @Around(value = ""execution(* *(..)) && (@annotation(method))"")[ERROR] ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^[ERROR] /Users/another/projects/moskito/moskito-aop/java/net/anotheria/moskito/aop/aspect/CounterAspect.java:29:0::0 the parameter pjp is not bound in [all branches of] pointcut[ERROR] error at @Around(value = ""execution(* *.*(..)) && (@within(clazz))"")[ERROR] ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^[ERROR] /Users/another/projects/moskito/moskito-aop/java/net/anotheria/moskito/aop/aspect/CounterAspect.java:34:0::0 the parameter pjp is not bound in [all branches of] pointcutwhat am i doing wrong here? this is due to the parameterization of the pointcuts in the sub-aspect, which loses the 'fields to ignore' list in the AndPointcut.  Thus pjp is not ignored and is reported as a problem fixed "	2012-11-27 17:34:23	1354060000.0	resolved fixed	3e5af0f	1354060000.0	org.aspectj.matcher/src/org/aspectj/weaver/patterns/AndPointcut.java
394234	Invalid StackMapTable generated in Java 7	"When compiling for Java 7, AspectJ can compute an invalid StackMapTable. The verifier will throw a ClassNotFoundException when the generated class is loaded.Example:class Parent<T> {}class ChildA<T> extends Parent<T> {}class ChildB<T> extends Parent<T> {}public Object methodWithBadStackMapTable(boolean value) {	return value ? new ChildA<String>() : new ChildB<String>();}javap shows the computed StackMapTable to be:StackMapTable: number_of_entries = 2   frame_type = 15 /* same */   frame_type = 71 /* same_locals_1_stack_item */  stack = [ class ""Parent<T>"" ]when it should be:StackMapTable: number_of_entries = 2   frame_type = 15 /* same */   frame_type = 71 /* same_locals_1_stack_item */  stack = [ class Parent ] Created attachment 223544maven project reproducing the issue Created attachment 223545patch to org.aspectj.weaver.bcel.asm.StackMapAdder thanks for the testcase and nice little fix!  Committed locally, it'll be on the public repo when I can finally get a decent connection to git.eclipse.org. all pushed to the public repo. "	2012-11-13 18:48:24	1352850000.0	resolved fixed	fc55431	1352940000.0	weaver/src/org/aspectj/weaver/bcel/asm/StackMapAdder.java
391123	Added support for more cache backing(s)	"Created attachment 221903Asynchronous file cache backing(s) patchAdded support for asynchronouse cache backings - one uses a ""flat"" model similar to the default cache backing only does the updates in the background. The other uses a ZIP file to hold the cached bytes.Attached is a patch file for the fix/feature *** Bug 385836 has been marked as a duplicate of this bug. *** merged by Andy into the master "	2012-10-04 10:14:52	1349360000.0	closed fixed	df1823b	1351540000.0	build/src/org/aspectj/internal/tools/ant/taskdefs/Checklics.java util/src/org/aspectj/util/LangUtil.java weaver/src/org/aspectj/weaver/tools/cache/AbstractIndexedFileCacheBacking.java weaver/src/org/aspectj/weaver/tools/cache/AsynchronousFileCacheBacking.java weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java weaver/src/org/aspectj/weaver/tools/cache/FlatFileCacheBacking.java weaver/src/org/aspectj/weaver/tools/cache/ZippedFileCacheBacking.java weaver/testsrc/org/aspectj/weaver/tools/cache/AbstractCacheBackingTestSupport.java weaver/testsrc/org/aspectj/weaver/tools/cache/AsynchronousFileCacheBackingTestSupport.java weaver/testsrc/org/aspectj/weaver/tools/cache/CacheTests.java weaver/testsrc/org/aspectj/weaver/tools/cache/DefaultCacheKeyResolverTest.java weaver/testsrc/org/aspectj/weaver/tools/cache/DefaultFileCacheBackingTest.java weaver/testsrc/org/aspectj/weaver/tools/cache/FlatFileCacheBackingTest.java weaver/testsrc/org/aspectj/weaver/tools/cache/SimpleClassCacheTest.java weaver/testsrc/org/aspectj/weaver/tools/cache/WeavedClassCacheTest.java weaver/testsrc/org/aspectj/weaver/tools/cache/ZippedFileCacheBackingTest.java
389967	Weaved aspects mechanism does not take into account modified classes	patch committed, with following changes:1. when there are no original bytes, I pass null for that value. In the patch is just passes woven bytes, this doesn't seem right.2. I had to comment out a test that fails: testExistingGeneratedClassesPassedThroughHandler()i'll leave this issue open for now, let me know if I need to apply something else to get that test working. (In reply to comment #3)> patch committed, with following changes:   I just got the latest 'master' and did not see the committed part - I have some reservations about the changes you have made, but I need to see the committed code. Where is it ?> 1. when there are no original bytes, I pass null for that value. In the> patch is just passes woven bytes, this doesn't seem right.   Need to make sure that the code that attempts to generate a CRC for it knows how to handle null(s)> 2. I had to comment out a test that fails:> testExistingGeneratedClassesPassedThroughHandler()> i'll leave this issue open for now, let me know if I need to apply something> else to get that test working.  Need to see the whole code and test it in order to understand why it fails - it might have something to do with the null(s), but I can't say unless I have the whole code. I have reviewed the code some more - the changes you made seem in order. You can safely remove the 'testExistingGeneratedClassesPassedThroughHandler' - I don't know why I did not do that.Please let me know when the changes are in the 'master' so I can continue to the next contriubtion (ZIP, ASYNC, etc. cache backings) for some reason I can't push to GIT from the office - where I was yesterday. Today I am at home and I can push just fine. The changes are in the main repo now.I also merged in the separate cache changes that another team wanted - where they share a cache across all classloaders in the system.  That doesn't disturb your stuff too much I don't think.I thought my change to pass null would be OK in the AspectJ code because non of the existing code cares about the original bytes, but I was pretty sure you'd have to make your extension aware of null. That's fine. Also, I have checked and as far as I can see, passing null(s) should have no effect as the code should handle it correctly (but I will review this once you have pushed the code). i pushed it yesterday, I hope it is all there now... Thanks, I got the changes in the master The current caching mechanism assumes that if the same class is encountered then its cached weaved version can be used. However, the mechanism uses only the (fully qualified) class name to identify the class and does not take into account the fact that the class bytes may have changed (e.g., the user re-compiled and re-deployed some changes to the same class). Created attachment 221281Diff file for the proposed fixA .diff file generated from the git diff command Created attachment 221282Patch file created via git format-patchSame as the .diff only in .patch format 	2012-09-20 02:38:31	1348120000.0	resolved fixed	9a3cc2b	1349120000.0	loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java loadtime/src/org/aspectj/weaver/loadtime/WeavingURLClassLoader.java org.aspectj.matcher/src/org/aspectj/weaver/tools/GeneratedClassHandler.java util/src/org/aspectj/util/LangUtil.java weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java weaver/src/org/aspectj/weaver/tools/cache/CacheBacking.java weaver/src/org/aspectj/weaver/tools/cache/CacheStatistics.java weaver/src/org/aspectj/weaver/tools/cache/CachedClassEntry.java weaver/src/org/aspectj/weaver/tools/cache/CachedClassReference.java weaver/src/org/aspectj/weaver/tools/cache/DefaultCacheFactory.java weaver/src/org/aspectj/weaver/tools/cache/DefaultCacheKeyResolver.java weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java weaver/src/org/aspectj/weaver/tools/cache/GeneratedCachedClassHandler.java weaver/src/org/aspectj/weaver/tools/cache/WeavedClassCache.java weaver/testsrc/org/aspectj/weaver/tools/cache/DefaultFileCacheBackingTest.java weaver/testsrc/org/aspectj/weaver/tools/cache/WeavedClassCacheTest.java
389456	NPE in EclipseTypeMunger.mungeNewMethod()	"<Pyinson Data Over Head> Created attachment 221002ajcore can you share the project with me?  I can put a guard on that line but I'd rather determine the cause of the issue first. I can email you the code. Problem is, the bug is intermittent. Blew up when I filed the bug. Exactly the same code compiles fine now...Let me know where I should email the code. send it over to andrew.clement AT gmail.com, thanks.I'm guessing it is probably on an incremental compile so it may build clean first time but then depending on what gets subsequently incrementally compiled, that may trigger the problem. Figured out that the failure is deterministic. Fails when built from command line using gradle, ""gradle build"". Works great when imported into Spring Tool Suite 3.0.0.RELEASE build 201208091018. thanks for sending that through, it helped me fix it up.The problem was due to the external build doing effectively two separate builds (src then tests) whilst in eclipse just one build is done of everything together.When there are two separate builds, when tests is compiled it loads some of the compiled results from building 'src'. When loading them into AspectJ as binary types we 'fix up' them up to ensure they look right and have the ITDs correctly applied.  In the case here we were pulling in a type that had already had the ITD applied and AspectJ got confused because it was about to apply something that was already there and both the ITD and the thing that was already there was final.  AspectJ was trying to tell us about the problem when it NPE'd because it couldn't record an error against a binary type (it was expecting a source type).  The fix is simply to recognize the ITD is already there and proceed normally.Fix will be in 1.7.2. Any workaround until then. Some way to reorder my code? I haven't tried this... but if you make your ITDs non-final (the failing one was something like 'whyNotValid') then that shouldn't trigger the error path. Awesome, worked great. Thanks! "	2012-09-12 19:05:05	1347490000.0	resolved fixed	b8ebdc3	1348170000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseTypeMunger.java
389752	declare parents & @type not matching on annotation properties of enum types	"NOTE:  real project private git repo demonstrating bug has been shared with Andy Clement privately.  I'm reporting bug as Andy requested with as much info as I feel I can.I have a case where 'declare parents' and 'declare @type' instructions are not being applied because their type patterns, which use annotations whose properties are of enumerated types, are not matching.Below find the relevant artifacts and their shapes.  The lines in the aspect PersistableJpaAspect that are not matching as they should are the 'declare parents' and 'declare @type'.  If I change the annotation properties to be of type String and change the type patterns to use string literals (see ""matches"" comments in annotation:  StoreType.JPA => ""JPA"" and IdType.LONG => ""LONG""), the matching works properly.enums:======public enum StoreType {	MONGO, JDO, JPA;}=====public enum IdType {	LONG, STRING;}annotation:===========public @interface Persistable {	StoreType in() default StoreType.MONGO; // doesn't match	// matches: String in() default ""MONGO"";	IdType id() default IdType.STRING; // doesn't match	// matches: String id() default ""STRING"";}aspect:=======public abstract privileged aspect PersistableAspect {	public interface I extends ....trait.interfaces.persistence.Persistable {		long version();		void version(long version);	}	public interface L extends I {		Long idLong();		void idLong(Long id);	}	public interface S extends I {		String idString();		void idString(String id);	}		declare @type : I+ : @Configurable;	// ...}=====public privileged aspect PersistableJpaAspect extends PersistableAspect {	public interface JL extends L {	}	public interface JS extends S {	}	declare parents :        (@Persistable(id = IdType.LONG, in = StoreType.JPA) *)        implements JL;	declare parents :        (@Persistable(id = IdType.STRING, in = StoreType.JPA) *)        implements JS;	declare @type : @Persistable(in=""JPA"") JL+ : @Entity;	declare @type : @Persistable(in=""JPA"") JS+ : @Entity;	// ...} can you possibly give me a commit hash that shows the problem? I don't really want to go editing too much of the app to recreate.  I can change the decps but surely I then need to change all the targets to be using enum values too? Or do all the targets have double annotations on right now for the enum and string variant values? I think HEAD can be used.  I'll add a quick test and let you know.  Hang tight & I'll advise when committed. Ok, pushed commit e0a11efa3c6adc8d6ccc26b4229e7ae32772fd91 on master.  You should see failing tests. thanks. I have checked that out and have failures but am having a little trouble understanding the setup.I see the PersistableAspect, doing things like:	declare parents :        (@Persistable(idAsEnum = IdType.LONG, in = StoreType.JPA) *)        implements JS;But I don't see anywhere annotated with @Persistable(idAsEnum = IdType.LONG, in = StoreType.JPA) I only see:@Persistable(id = ""LONG"", in = ""JPA"")do I need to change those places myself to idAsEnum=IdType.LONG? Committed change 9f3d93c66884 on master.  Sorry 'bout that! All fixed.  This was due to a couple of things - bad code paths when multiple annotation values specified and an ordering issue too (if the annotated element hadn't yet gone through the compilation pipeline, the eclipse version of the annotation value was not creating the right value that would match the pattern).I still had to change a couple of things in your codebase though.  One of your Mongo test classes still specified it was JPA in the annotation.  Also in your patterns you must be careful because right now this will not give you an error:String in();EnumType inAsEnum();declare parents: (@Persistable(in = StoreType.JPA) *) ...note that a string value will accept anything, it will not give you the error saying can't use enum value there.  This is tricky to fix (but I've created a testcase for the problem).With the fixes and the changes to correct the app, the tests all pass. closing Omg -- sorry again. I was trying to hurry while supporting production for another client.  Copy/paste error.  Thanks for fixing. no problem. It is my fault that the error messages aren't coming out. If they were then you would have known it was broken! I grabbed 1.7.2.BUILD-SNAPSHOT this morning & everything tested ok. "	2012-09-17 14:47:17	1347910000.0	resolved fixed	0d69bd3	1348100000.0	org.aspectj.matcher/src/org/aspectj/weaver/EnumAnnotationValue.java org.aspectj.matcher/src/org/aspectj/weaver/StandardAnnotation.java org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java tests/bugs172/pr389752/Code.java tests/bugs172/pr389752/Code2.java tests/bugs172/pr389752/Code3.java tests/src/org/aspectj/systemtest/ajc172/Ajc172Tests.java
389750	Inconsistent classfile encountered: The undefined type parameter xxx is referenced from within yyy	"With the declare parents pattern below, I'm getting this **runtime** error (compiler completes ok):Inconsistent classfile encountered: The undefined type parameter ID is referenced from within PersistableAspectIf I remove the generics part of the interface declaration, the error goes away.  Here's the pattern:interface:==========package example.trait;// imports...public interface Persistable<ID extends Serializable> {	Object getOid();	ID getId();	String getIdString();	long getVersion();}annotation:===========package example.anno;// imports...@Target(TYPE)@Retention(RUNTIME)@Traitpublic @interface Persistable {	String in() default ""MONGO"";	StoreType inAsEnum() default StoreType.MONGO;	String id() default ""STRING"";	IdType idAsEnum() default IdType.STRING;}aspect:=======package example.aspect;// imports...public privileged aspect PersistableAspect {	public interface I<ID extends Serializable> extends example.trait.Persistable<ID> {	}	public interface L extends I<Long> {	}	public interface S extends I<String> {	}	declare parents :        (@Persistable(id=""LONG"") *)        implements L;	declare parents :        (@Persistable(id=""STRING"") *)        implements S;	// remaining code is ITDs introducing vars & methods...} by the 'app/app-test' I mean I get these errors:[ERROR] Failed to execute goal on project foundation-domain: Could not resolve dependencies for project com.scispike:foundation-domain:jar:0.1.0.BUILD-SNAPSHOT: The following artifacts could not be resolved: org.example:app-support:jar:0.1.0.BUILD-SNAPSHOT, org.example:app-test-support:jar:0.1.0.BUILD-SNAPSHOT: Failure to find org.example:app-support:jar:0.1.0.BUILD-SNAPSHOT in http://maven.springframework.org/release was cached in the local repository, resolution will not be reattempted until the update interval of maven.springframework.org has elapsed or updates are forced -> [Help 1]Until I remove the lines:        <dependency>            <groupId>org.example</groupId>            <artifactId>app-support</artifactId>            <version>${project.parent.version}</version>        </dependency>        <dependency>            <groupId>org.example</groupId>            <artifactId>app-test-support</artifactId>            <version>${project.parent.version}</version>            <scope>test</scope>        </dependency>With those gone, and using the commit you referenced and running mvn clean verify, I now see the error, hurray! For some reason I was under the impression this was a new problem in 1.7.1 that didn't happen with 1.7.0 - but I've tried 1.7.1/1.7.0/1.6.12 and they all have the same problem. I'm glad you can repro.Ah, I know now why those dependencies are there that you had to remove.  That's a copy/paste bug, which I've fixed & committed in the head.  Sorry 'bout that!If you want me to fix it back at the commit that contains the error, then I'll have to do that, too.  Let me know if that's something you want me to do. From debugging Matthews code, distilled the entire problem to this:Code.aj====import java.io.*;interface Persistable<ID extends Serializable> {}public aspect Code {  public interface I<ID extends Serializable> extends Persistable<ID> {  }  public static void foo() {}  public boolean I.equals(Persistable<?> that) {    return false;  }}===Clazz.java===public class Clazz {  public static void main(String[] argv) {    Code.foo();  }}===ajc -1.5 Code.ajajc -1.5 Clazz.javaorg.aspectj.org.eclipse.jdt.internal.compiler.problem.AbortCompilation: Pb(538) Inconsistent classfile encountered: The undefined type parameter ID is referenced from within Code FYI, not that you need it now that you've distilled the problem, but I created a new branch called ""aspectj-bug-389750"" as a branch of commit 368b7dc827ef0237bdb6d460320cf1e7fbedf7da (the one containing the aj error) and fixed the poms there. fix committed. The problem is due to missing type variables in the generic signature for the ITD helper methods that get generated.  They are missing because they are declared on the target type and we need to copy them over to the ITD. I confirmed this fixes it for your failing scenario that I could previously recreate. Great, Andy!  In which release do you expect this to be included? it'll be in 1.7.2. I'll put a 1.7.2 snapshot on the spring maven repo.  It'll be in AJDT shortly too. I grabbed 1.7.2.BUILD-SNAPSHOT & everything tested ok. "	2012-09-17 14:25:23	1347910000.0	resolved fixed	b9c7a19	1348080000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AstUtil.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java tests/bugs172/pr389750/Clazz.java tests/bugs172/pr389750/Clazz2.java tests/bugs172/pr389750/Clazz3.java tests/bugs172/pr389750/Clazz4.java tests/src/org/aspectj/systemtest/AllTests17.java tests/src/org/aspectj/systemtest/ajc172/Ajc172Tests.java tests/src/org/aspectj/systemtest/ajc172/AllTestsAspectJ172.java
388971	Double Synthetic attributes on some around advice members	Some of the support members in aspects were getting Synthetic attributes added twice (once when compiled, once when used as an aspect library).  Some JVMs appear to flag this as a verify error.  The fix is simply to check before adding to make sure the attribute isn't added twice. fixed 	2012-09-06 12:34:52	1346950000.0	resolved fixed	c2ff74f	1346950000.0	weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java
384401	NPE when no pointcut in afterthrowing annotation style advice	"From the mailing list:import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.AfterThrowing;import org.aspectj.lang.annotation.Aspect;@Aspectpublic class X {//	@AfterThrowing(pointcut=""execution(* *(..))"",throwing = ""e"")	@AfterThrowing(throwing = ""e"")    public void bizLoggerWithException(JoinPoint thisJoinPoint,Throwable e) {  //  .....// do some stuff    }}class BizLoggable {} fixed "	2012-07-05 14:04:53	1341510000.0	resolved fixed	55ebaa1	1345750000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java tests/bugs171/pr384401/X.java tests/src/org/aspectj/systemtest/ajc171/Ajc171Tests.java
387444	Softening exception in try-with-resources	"From this post on the Eclipse AJDT forum: http://www.eclipse.org/forums/index.php/t/369503/When softening exceptions, AspectJ doesn't seem to soften the exception thrown by the automatic close() invocation when using the try-with-resources syntax introduced in Java 7 (often an IOException).  eg:---In Java code:try (BufferedReader reader = new BufferedReader(new FileReader(""test.txt""))) {  System.out.println(reader.readLine());}In AspectJ code:declare soft: IOException: within(*)---The above will result in a compilation error, ""Unhandled exception type IOException thrown by automatic close() invocation"".A workaround is to add a catch for the IOException, or to add a throws clause to the method, which kind of makes the exception softening somewhat redundant.If you're using AJDT, doing these workarounds then adds AJDT add markers to the try-with-resources block, one of which looks like it's for the automatic close() - maybe the 'unhandled exception' error is preventing AspectJ from properly softening the exception? fixed.  problem was due to a different path through the compiler that is used for the autoclose case. "	2012-08-16 20:46:55	1345160000.0	resolved fixed	76d695f	1345750000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java tests/bugs171/pr387444/Code.java tests/bugs171/pr387444/Code2.java tests/src/org/aspectj/systemtest/ajc171/Ajc171Tests.java tests/src/org/aspectj/systemtest/ajc171/Ajc171Tests_need17jre.java
387718	RuntimeException when trying to compile broken code	java.lang.RuntimeExceptionat org.aspectj.weaver.NameMangler.makeVisibilityName(NameMangler.java:297)at org.aspectj.weaver.NameMangler.interMethod(NameMangler.java:242)at org.aspectj.weaver.AjcMemberMaker.interMethod(AjcMemberMaker.java:538)at org.aspectj.ajdt.internal.compiler.problem.AjProblemReporter.methodMustOverride(AjProblemReporter.java:385)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(M ... dJob.java:241)at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)Compile error: RuntimeException thrown: protected inter-types not allowed Created attachment 220114Simplified project that reproduces the errorThanks for the sample project.  I was able to reproduce the error.  I simplified it and I'm attaching the simplified project.It looks like the problem is that BasicFilter.getLogMessage() is referenced inside of an advice, but getLogMessage is protected.  If I change from protected to public, the error goes away.To reproduce, import the attached project into your workspace and do a full build. Urrrgh...wrong bug report.  Previous comment should be applied to Bug 386049. not quite sure what the broken code was but I've modified somewhere on that stack trace to avoid it going down into the code that throws an exception in what I think are the problem circumstances. Don't plan on doing more than that right now. 	2012-08-21 13:30:11	1345570000.0	resolved fixed	cbb6f5a	1345670000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java
386049	"Error ""must implement abstract inter-type declaration"" even though build is fine"	"Build Identifier: Version: 4.2.0 Build id: I20120608-1400I have an AspectJ project with Java classes like this (schematically, not the full code):public abstract class BasicFilter {    protected abstract String getLogMessage();}public class PreJTidyFilter extends BasicFilter{    @Override    protected String getLogMessage() {        return ""Fixing HTML so as to enable JTidy to parse it"";    }}public class JTidyFilter extends BasicFilter {    @Override    protected String getLogMessage() {        return ""Converting to clean, pretty-printed XHTML"";    }}public class XOMUnclutterFilter extends BasicFilter {    @Override    protected String getLogMessage() {        return ""Removing clutter (header, footer, navigation, ads) and fixing structure"";    }}###################################I also have this aspect:privileged aspect LoggingAspect {    pointcut runFilter() : execution(* BasicFilter.run());    void around(BasicFilter filter) : runFilter() && this(filter) {        String message = filter.getLogMessage();        SimpleLogger.verbose(message, IndentMode.INDENT_AFTER);        proceed(filter);        SimpleLogger.dedent();    }}###################################The aspects compile and run fine, but the Eclipse error view always shows two errors:must implement abstract inter-type declaration:    java.lang.String de.scrum_master.galileo.filter.BasicFilter.getLogMessage()    (XOMUnclutterFilter.java)must implement abstract inter-type declaration:    java.lang.String de.scrum_master.galileo.filter.BasicFilter.getLogMessage()    (JTidyFilter.java)The errors even re-occur after cleaning and rebuilding the project. But as I said, the code runs just fine.Please note: The funny thing is that in those two classes I just need to add and remove whitespace, then save the file, and the error goes away file by file. As soon as I rebuild though, the errors are there again.Please also note: The errors always are shown for subclasses XOMUnclutterFilter and JTidyFilter, but strangely *not* for subclass PreJTidyFilter, even though it is affected by the same pointcut and advice as the others and also subclassing the same base class.Reproducible: AlwaysSteps to Reproduce:I do not know if there is a way for you to reproduce this behaviour with the little code snippets I provided above, but here it happens all the time.If you would like to clone my project, it is located at https://github.com/kriegaex/Galileo-Openbook-Cleaner.My Eclipse was configured via Yoxos, but AJDT  Version: 2.2.0.e42x-RELEASE-20120703-2200  AspectJ version: 1.7.0.20120703164200was installed by me manually because right after the Juno release AJDT were not available via Yoxos yet (I do not know if they are now). Because this still occurs all the time, I have tested with and without automatic build. The result is the same. Even after a clean and manual build from the IDE, this happens. Only when I pseudo-edit (add + remove a space, then save) the file affected by the error, it goes away until the next build. This looks like an AJDT problem.  My understanding is that you see this error in the editor, but not in problems view?I am trying your code snippets out right now, but I can't see the problem.  Did you leave something out of your code snippet below?  The error message implies that there is something amiss with ITDs, but your snippet does not have any ITDs. No, Andrew, I see it in both the problems view and the editor.Feel free to clone my little playground repository at https://github.com/kriegaex/Galileo-Openbook-Cleaner in order to reproduce the bug. Meanwhile, now that I have your attention, I am trying to reduce the problem, trying to create a minimal test sample without the other classes around the main problem.BTW, the three warnings you will also see when cloning my project are the ones I mentioned in https://bugs.eclipse.org/bugs/show_bug.cgi?id=387568, if you want to take care of that one too. I stand corrected then.  This may not be an AJDT problem, but a compiler problem.  I'll have a look at your repo. Okay, I have reduced the problem to these three entities (2 classes, 1 aspect), just create a project with those entities and do ""Project - Clean"" (with auto-rebuild on) or manually clean + recompile (with auto-build off):package filter;public abstract class BasicFilter implements Runnable {	public void run() {		System.out.println(""running BasicFilter"");	}	protected abstract void filter();	protected abstract String getLogMessage();}// ##############################################################################package filter;public class JsoupFilter extends BasicFilter {	@Override	protected String getLogMessage() {		return ""Cleaning up HTML, removing clutter, fixing structure"";	}	@Override	protected void filter() {		System.out.println(""running JsoupFilter"");	}}// ##############################################################################import filter.BasicFilter;privileged aspect LoggingAspect {	pointcut runFilter() : execution(* BasicFilter.run());	void around(BasicFilter filter) : runFilter() && this(filter) {		System.out.println(filter.getLogMessage());		proceed(filter);	}} Damn, I want to be able to edit a comment...It is crucial that the filter classes be in a sub-package which the aspect needs to import. The problem seems to go away when all three are in the same package. Created attachment 220115Simplified project that reproduces the errorThanks for the sample project.  I was able to reproduce the error.  I simplified it and I'm attaching the simplified project.It looks like the problem is that BasicFilter.getLogMessage() is referenced inside of an advice, but getLogMessage is protected.  If I change from protected to public, the error goes away.To reproduce, import the attached project into your workspace and do a full build. This is an AspectJ bug, so moving it back to that project. (In reply to comment #5)> Okay, I have reduced the problem to these three entities (2 classes, 1> aspect), just create a project with those entities and do ""Project - Clean""> (with auto-rebuild on) or manually clean + recompile (with auto-build off):Oh well, looks like our comments crossed-paths.  We now know why the problem is occurring. all fixed.  Problem was due to the abstract nature of the member that we were granting privileged access to.  The check didn't go far enough and verify what it was looking at was a real ITD (privileged access is handled in an ITD like mechanism).  The solution was just to extend the check and avoid the error if it isn't a 'real' itd. committed changes into AJDT master, should appear in 4.2 dev builds shortly. I tried the build by Andrew Eisenberg of ca. 10 hours ago directly from Bamboo server (one failed test seems to have stopped it from being pushed to the update site), but there it is not fixed yet. The same applies to the other bug you fixed. Maybe the changed were not part of that build, I just wanted to provide some early feedback. I spoke in haste as I had committed locally but when it came to push i couldn't yesterday (for some reason), just pushed all these changes a few mins ago so should appear in a build later today. I just verified this with the latest build https://build.springsource.org/browse/AJDT-E42-37 and can acknowledge that the problem is gone in my project. Thank you very much. "	2012-07-26 10:15:19	1343310000.0	verified fixed	7c6e936	1345660000.0	org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java tests/bugs171/pr386049/de/scrum_master/galileo/filter/BasicFilter.java tests/bugs171/pr386049/de/scrum_master/galileo/filter/JsoupFilter.java tests/bugs171/pr387568/Code.java tests/src/org/aspectj/systemtest/ajc171/Ajc171Tests.java weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java
384398	Type Mismatch error when using inner classes contained in generic types within ITDs	"Please see attached example project. I get the following (strange) compiler error:Type mismatch: cannot convert from A<T>.InnerA<> to A.InnerA	BAspect.aj   /AspectJInnerclassInGenericTypeBug/src/de/example	line 12 Created attachment 218347Example project. Please compile with AspectJ compiler and see error. fixed.  There is a bit of a messy area (EclipseFactory.fromBinding()) and there are a few related issues like this one (where, for example, the outer type is properly parameterized).  I've not addressed those in this fix, I've just addressed the problem raised here. "	2012-07-05 13:42:53	1341510000.0	resolved fixed	bf949d3	1341940000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java tests/bugs171/pr384398/A.java tests/bugs171/pr384398/B.java tests/bugs171/pr384398_2/A.java tests/bugs171/pr384398_2/B.java tests/src/org/aspectj/systemtest/AllTests17.java tests/src/org/aspectj/systemtest/ajc171/Ajc171Tests.java tests/src/org/aspectj/systemtest/ajc171/AllTestsAspectJ171.java
384189	make ajcore file creation optional	Although cores are useful, there may be situations where you are working around whatever they are reporting and are perhaps unable to pick up a later version of AJ that includes the fix.  In these situations it might be helpful to make the creation of cores optional, through a sys prop. actually the org.aspectj.weaver.Dump.exception property should really do this already but it isn't wired up!! last fix in for 1.7.0.  Now respects the setting. 	2012-07-03 14:06:05	1341340000.0	resolved fixed	5d0e186	1341350000.0	org.aspectj.matcher/src/org/aspectj/weaver/Dump.java
382189	NPE in BcelTypeMunger.createBridgeMethod	"Build Identifier: Since I updated to version     AspectJ Development Tools	2.2.0.e37x-20120529-0900I get during compile:java.lang.NullPointerExceptionat org.aspectj.weaver.bcel.BcelTypeMunger.createBridgeMethod(BcelTypeMunger.java:1325)at org.aspectj.weaver.bcel.BcelTypeMunger.createAnyBridgeMethodsForCovariance(BcelTypeMunger.java:1272)at org.aspectj.weaver.bcel.BcelTypeMunger.mungeNewMethod(BcelTypeMunger.java:971)at org.aspectj.weaver.bcel.BcelTypeMunger.munge(BcelTypeMunger.java:108)at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeave ... )Before, I had     AspectJ Development Tools	2.2.0.e37x-20120507-1400 and the same project compiled without that exception.Reproducible: Always Sorry, I could not really verify yet that this did not happen with the 2.2.0.e37x-20120507-1400 version. So please ignore this remark. <Pyinson Data Over Head> Created attachment 217121Sample ProjectThe sample project reproduces the bug. I seems, covariant return types in intertype declarations are somehow causing the problem. If you edit the Aspect and replace this:public B A.getSomeB(SuperB<String> b){		return null;	}with:public SuperB<String> A.getSomeB(SuperB<String> b){		return null;	}the error will go away. thanks for the test projects Stefan, they are invaluable for fixing this kind of thing. fixed. The actual problem was an attempt was being made to create an abstract bridge method.  When in fact no bridge method needed to be created by the weaver because the compiler had already done it.  The reason the weaver couldn't see it is because it was comparing an erased parameter signature with a parameterized signature. "	2012-06-10 10:48:00	1339340000.0	resolved fixed	a748303	1339810000.0	org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java tests/bugs170/pr382189/covbug/A.java tests/bugs170/pr382189/covbug/B.java tests/bugs170/pr382189/covbug/SuperA.java tests/bugs170/pr382189/covbug/SuperB.java tests/bugs170/pr382189/covbug/cc/covbug/A.java tests/bugs170/pr382189/covbug/cc/covbug/B.java tests/bugs170/pr382189/covbug/cc/covbug/SuperA.java tests/bugs170/pr382189/covbug/cc/covbug/SuperB.java tests/bugs170/pr382189/covbug/pj/Foo.java tests/bugs170/pr382189/one/A.java tests/bugs170/pr382189/one/B.java tests/bugs170/pr382189/one/SuperA.java tests/bugs170/pr382189/one/SuperB.java tests/bugs170/pr382189/three/A.java tests/bugs170/pr382189/three/B.java tests/bugs170/pr382189/three/SuperA.java tests/bugs170/pr382189/three/SuperB.java tests/bugs170/pr382189/two/A.java tests/bugs170/pr382189/two/B.java tests/bugs170/pr382189/two/SuperA.java tests/bugs170/pr382189/two/SuperB.java tests/bugs170/pr382435/one/bug/A.java tests/bugs170/pr382435/two/bug/A.java tests/src/org/aspectj/systemtest/ajc170/Ajc170Tests.java weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java
382723	An package-level abstract generic privileged aspect, which extends an abstract generic aspect, gives a IlligalStateException on a method call in around advice	<Pyinson Data Over Head> fixed.  Another occurence of the problem where we fail to shift from a parameterized type to its original (generic) type before doing something.Fix was very minor so will make 1.7.0 final. 	2012-06-15 06:31:34	1339760000.0	resolved fixed	ba9d43c	1339780000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java tests/bugs170/pr382723/Foo.java tests/bugs170/pr382723/FooAspect.java tests/bugs170/pr382723/FooAspect2.java tests/bugs170/pr382723/FooAspect3.java tests/src/org/aspectj/systemtest/ajc170/Ajc170Tests.java
376990	iajc does not support source compliance level 1.7	"Build Identifier: Version: 3.7.2 Build id: M20120208-0800I am using AspectJ 1.7.0.M1. I changed the examples build.xml to use a source compliance level of 1.7 and verbose=true as follows:<iajc destdir=""${classes.dir}"" verbose=""true"" source=""1.7"" argfiles=""${list}""When I run this using 'ant bean' I get the following line:[iajc] ignored: -source 1.7 at E:\aspectj1.7\doc\examples\build.xml:136:I have tried running the compiler 'ajc' directly specifying -source 1.7 and that works.I am trying to use this on a large development project that uses AspectJ and has been migrated over to Java 7. The project uses ant to do builds so it is critical that iajc support 1.7. The project can't be built if any Java 7 features are used in the source files which defeats the whole purpose of moving to Java 7.Reproducible: AlwaysSteps to Reproduce:1.Change the examples build.xml to use a source compliance level of 1.7 and verbose=true as follows:<iajc destdir=""${classes.dir}"" verbose=""true"" source=""1.7"" argfiles=""${list}""2.Run using 'ant bean' I get the following line:[iajc] ignored: -source 1.7 at E:\aspectj1.7\doc\examples\build.xml:136: good catch !I've just fixed it and uploaded a new dev build.  On downloads page, or here:http://www.eclipse.org/downloads/download.php?file=/tools/aspectj/dev/aspectj-DEVELOPMENT-20120417094200.jar (In reply to comment #1)> good catch !> > I've just fixed it and uploaded a new dev build.  On downloads page, or here:> http://www.eclipse.org/downloads/download.php?file=/tools/aspectj/dev/aspectj-DEVELOPMENT-20120417094200.jarThanks for the quick response. I tried that build and I'm now seeing     [copy] Copying 1 file to E:\javadev\indigo\workspace\codeStage9_0\build\classes\META-INF     [java] java.lang.VerifyError: Expecting a stackmap frame at branch target 15 in method xxxxxxxxxx.main([Ljava/lang/String;)V at offset 0     [java]     at java.lang.Class.getDeclaredMethods0(Native Method)     [java]     at java.lang.Class.privateGetDeclaredMethods(Class.java:2442)     [java]     at java.lang.Class.getMethod0(Class.java:2685)     [java]     at java.lang.Class.getMethod(Class.java:1620)     [java]     at sun.launcher.LauncherHelper.getMainMethod(LauncherHelper.java:488)     [java]     at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:480)     [java] Exception in thread ""main""     [java] Java Result: 1The xxxxxxxxxx has been edited in by me due to security concerns.Does this build have 'Bug 353467 - VerifyError: Expecting a stackmap frame' fixed in it? sorry about that.  A change last week to prevent asm damaging the constant pool had a side effect of damaging the creation of stackmap attributes.  Yesterday I just checked compilation succeeded and didn't have a 1.7 vm in order to run the result.I've patched it all up and todays dev build:http://www.eclipse.org/downloads/download.php?file=/tools/aspectj/dev/aspectj-DEVELOPMENT-20120418141500.jardefinetly compiles and runs (with stackmap) "	2012-04-17 11:35:31	1334680000.0	resolved fixed	89c178f	1334680000.0	taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java
376351	attribute problems with Java 7 compilation	"From the mailing list, this goes wrong:***R.java***public class R{   public static void main(String[] args) {System.out.println(new R().getClass().getName());}}***R1.java***public class R1 extends R {}***RAj.aj***public aspect RAj{    private ThreadLocal<Object> inAspect = new ThreadLocal<Object>();        pointcut createR() : execution(R.new());    Object around() : createR()    {        System.out.println(""aspect:"" + inAspect.get() + "":"" + this);        if (inAspect.get() != null)        {            return proceed();        }        else        {            inAspect.set(this);            return new R1();        }    }}compile command:/cygdrive/c/Program\ Files/Java/aspectj-1.6.12/bin/ajc.bat -source 1.7 -outxml -outjar araj.jar -classpath ""aspectjrt.jar;."" RAj.aj run:/cygdrive/c/Program\ Files/Java/aspectj-1.6.12/bin/aj5.bat  -classpath "".;./araj.jar"" Rerrors:Apr 06, 2012 1:37:40 PM org.aspectj.weaver.tools.Jdk14Trace errorSEVERE: register definition failedjava.lang.RuntimeException: Problem processing attributes in RAj    at org.aspectj.weaver.bcel.BcelObjectType.ensureAspectJAttributesUnpacked(BcelObjectType.java:385) this is caused by asm trying to be too clever for its own good and damaging the constant pool when it adds the stack map entries.  This leaves us with attributes that refer to constant pool entries that have 'moved'. There is a way to turn off this asm behaviour by passing the classreader into the classwriter.  I've done this and the exception is fixed. "	2012-04-09 15:13:54	1334000000.0	resolved fixed	be063b8	1334010000.0	tests/bugs170/pr376351/R.java tests/bugs170/pr376351/R1.java tests/bugs170/pr376351/RAj.java tests/src/org/aspectj/systemtest/ajc170/Ajc170Tests.java weaver/src/org/aspectj/weaver/bcel/asm/StackMapAdder.java
376139	AspectJ throws Nullpointer after its IDE plugin update	"fix committed into AspectJ and into AJDT - should be in a dev build in 2 hours. Build Identifier: Version: Indigo Service Release 2 Build id: 20120216-1857java.lang.NullPointerExceptionat org.aspectj.org.eclipse.jdt.internal.compiler.ast.SwitchStatement.analyseCode(SwitchStatement.java:118)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:104)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:730)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseC ... oBuildJob.run(AutoBuildJob.java:241)at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)Compile error: NullPointerException thrown: nullReproducible: AlwaysSteps to Reproduce:1. After updating the eclipse plugin Showstopper for me. There is no way to workaround other than just letting maven do the work. Back to Eclipse 3.6 . I found the issue. Empty Switch statements seems to cause the problem.switch(stuff) {}We had left the switch statement there and had commented some of the code out and forgot to remove the whole switch statement.While it seems to be legally java it seems to break aspectj. thanks for discovering that - that's invaluable info! Great Guys.. So when can we get the update (relief), or is there a way to use older version on Eclipse 3.7 if that is the issue, hopefully in a few hours I'll have something out. (just gotta get through some meetings) I guess there is a little more to it as this simple program doesn't seem to fail for me:===public class CC {	public static void main(String[] args) {		int i=4;		switch (i) {		}	}}=== Got it, the thing being switched on had to be an enum:enum Color { R,G,B; }public class C {        public void foo() {                Color c;                switch (c) {                }        }} "	2012-04-05 00:00:07	1333600000.0	resolved fixed	62fca9a	1333660000.0	tests/bugs170/pr376139/Code.java tests/src/org/aspectj/systemtest/ajc170/Ajc170Tests.java
374964	Performance - improve pointcut expensiveness calculation	"Build Identifier: 1.6.12I'm able to reduce the AspectJ LTW startup overhead on the app I'm working on, from 95 seconds down to 47 seconds, just by switching the ""expensiveness"" of THIS_OR_TARGET and CALL in PointcutEvaluationExpenseComparator.  It seems to make sense to me that THIS_OR_TARGET is more expensive since it requires type matching (under profiler ExactTypePattern.matchesInstanceof() is what shows up as very expensive), whereas CALL can evaluate very quickly in most cases since it just fails to match on method name.  I'm not sure if this is specific to my particular usage, but cutting 50% of the LTW startup is a very nice improvement.  If you think this change doesn't make sense for everyone, I can work on a patch that makes this configurable somehow.  Thanks.Reproducible: Always Created attachment 213018patch Actually in the original version of AspectJ (when pointcut rewriting was introduced), the order was that call was cheaper than this/target.  This was changed under bug 292069 because it was found in some situations (see the reference to that bug in the mailing list archives) call was being evaluated against lots and lots and lots of methods and dismissing them, when the this() it was attached to would have dismissed the type immediately.However, that was before I implemented fast match for call/execution.  But, fastmatch will only work if there is a declaring type in the call pointcut.  I could imagine this pointcut:call(* *(String)) && this(Elephant)would misbehave if you consider call() cheaper than this() because (as mentioned above) it will look through all the methods in every type (which might be many many matches) before dismissing a bunch of types due to the this().  Whereas this will benefit from fastmatch:call(* Elephant+.*(String)) && this(Elephant)The declaring type in the call() can be used to dismiss lots of types before we look through their methods.So.... I guess I am saying it does depend on the scenario.  Perhaps the rewriter needs to be smarter and dynamically alter the ordering.  A call() with declaring type can be cheaper than a this() which can be cheaper than a call without a declaring type.Can you let me know what kinds of pointcuts you are using?  If you have a declaring type in call() then I'm inclined to implement what I just mentioned and dynamically weight it based on the declaring type existing.  This seems preferable to giving the user an option to twiddle. Thanks for the explanation.  Yes, I'm using pointcuts with a declaring type (and mostly even a method name) in call(). committed the change that I proposed.  There are two weights for call now - depending on whether a declaring type is specified.  This will make it cheaper than this() if a declaring type is used, or more expensive if no declaring type is used. "	2012-03-21 14:02:09	1332350000.0	resolved fixed	f85631f	1332550000.0	org.aspectj.matcher/src/org/aspectj/weaver/patterns/PointcutEvaluationExpenseComparator.java tests/src/org/aspectj/systemtest/ajc170/Ajc170Tests.java
374745	Performance regression in 1.6.12	Build Identifier: 1.6.12The application I'm working on takes 152 seconds to start under the 1.6.11 LTW agent, but takes 37 *minutes* to start under the 1.6.12 LTW agent.  Profiling it under the 1.6.12 LTW agent shows the extra time is spent in ReferenceType.addDependentType() (being called from TypeFactory.createParameterizedType()).  Under a debugger, I can see that the ReferenceType.derivativeTypes HashSet is getting very very big (because ResolvedType.equals() falls back to ==, so there are lots of 'duplicates' in the HashSet), which is causing each successive add() to get slower and slower.  It looks like derivativeTypes was changed from ArrayList to HashSet in 1.6.12 (as part of the changeset for bug 344005), which seems to be what caused the performance regression.  Changing derivativeTypes back to ArrayList solves the issue and brings startup times back in line with 1.6.11.  I'm not sure if this is the best fix though, I started thinking about storing parameterized types in World.typeMap to remove duplicate instances globally and/or changing ResolvedType.equals() to remove duplicate instances inside of derivativeTypes, but quickly got in over my head.Reproducible: Always Created attachment 212907Patch to convert ReferenceType.derivativeTypes from HashSet back to ArrayListPatch to convert ReferenceType.derivativeTypes from HashSet back to ArrayList. I converted it back to a list but I made further changes too.  The list is checked for a candidate before building a new type, the list is also now of weak refs so it will not accidentally anchor resolvedtypes.It would be great if you could try it out and see how it behaves.  I did do some equals/hashCode work around type variable references.  All my tests are OK but I don't really have a good LTW app at the moment that can tell me if these lists are growing out of control.The dev build is here:http://www.eclipse.org/downloads/download.php?file=/tools/aspectj/dev/aspectj-DEVELOPMENT-20120323182000.jar(that also contains the change to pointcut expense computation for call/this)thanks for finding and digging into this issue, it is a serious regression! Thanks, start up time is good with this patch.  I do still see a few duplicates in derivativeTypes because ReferenceType.findDerivativeType() ends up comparing the typeParameters using TypeVariableReferenceType.equals() which uses ==.  If you want to try something else I'm happy to re-test, though I'm good with the fix as is also. Yep, that == is deliberate.  I'm basically trying to edge towards a mode where we don't have multiple copies of the same type around.  Two type variable references are considered the same if they point to exactly the same type variable.I saw a couple of remaining dups related to RAW types in my testing, I didn't see any erroneous dups for parameterized types.  If it contains multiple List<E> or similar it may well be because they are being used in slightly different contexts.  Here:<X> void foo(List<X> x)<X> void bar(List<X> x)there are two different List<X>'s - the X's on each line are different type variables. So I'd expect two entries in the derivatives array for List.But if you think performance numbers are back in line with what they used to be, that's good enough for me at the moment.thanks for testing it so quickly. 	2012-03-20 07:19:52	1332240000.0	resolved fixed	549d227	1332550000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java org.aspectj.matcher/src/org/aspectj/weaver/TypeFactory.java org.aspectj.matcher/src/org/aspectj/weaver/TypeVariableReferenceType.java org.aspectj.matcher/src/org/aspectj/weaver/UnresolvedType.java org.aspectj.matcher/src/org/aspectj/weaver/UnresolvedTypeVariableReferenceType.java org.aspectj.matcher/src/org/aspectj/weaver/World.java
373195	Memory leak in CompilationAndWeavingContext leading to PermGen OOME	Build Identifier: 1.6.11The static contextMap in CompilationAndWeavingContext keeps strong references to Thread instances (which in turn strongly reference their contextClassLoader which prevents all kinds of stuff from unloading).In my particular use case I am running unit tests, each in their own WeavingURLClassLoader, but these ClassLoaders are never released, and running several unit tests at once leads to PermGen OutOfMemoryError.Using -XX:+HeapDumpOnOutOfMemory and analyzing the resulting heap dump in Eclipse Memory Analyzer points to CompilationAndWeavingContext.contextMap.I am able to work around this issue by executing the following at the end of each unit test to clear out this contextMap:    CompilationAndWeavingContext.setMultiThreaded(false);    CompilationAndWeavingContext.reset();    CompilationAndWeavingContext.setMultiThreaded(true);I am also able to resolve this issue (more satisfactorily) by patching CompilationAndWeavingContext and changing contextMap into a ThreadLocal.Reproducible: Always Created attachment 212036patch patch committed, thanks for submitting it! 	2012-03-04 01:25:51	1330840000.0	resolved fixed	6defb4e	1331050000.0	bridge/src/org/aspectj/bridge/context/CompilationAndWeavingContext.java
371998	"org.aspectj.weaver.BCException compiling @DeclareParents with value using ""||"""	"Build Identifier: 20110916-0149Using:import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.DeclareParents;@Aspectpublic class AspectTest {        private interface X {}    private static class XImpl {}    @DeclareParents(value=""java.lang.Runnable || java.util.concurrent.Callable"",  defaultImpl=XImpl.class)    private X xImpl;  }Throws:org.aspectj.weaver.BCExceptionat org.aspectj.weaver.patterns.ExactTypePattern.resolveBindings(ExactTypePattern.java:312)at org.aspectj.weaver.patterns.OrTypePattern.resolveBindings(OrTypePattern.java:121)at org.aspectj.weaver.bcel.AtAjAttributes.handleDeclareParentsAnnotation(AtAjAttributes.java:746)at org.aspectj.weaver.bcel.AtAjAttributes.readAj5ClassAttributes(AtAjAttributes.java:384)at org.aspectj.weaver.bcel.BcelObjectType.ens ... \Program Files\Java\jre6\lib\ext\sunjce_provider.jar;C:\Users\xxx\software\eclipse-j2ee\\plugins/org.eclipse.equinox.launcher_1.2.0.v20110502.jar;Current workaround is to use multiple DeclareParents annotations on different variables.Reproducible: AlwaysSteps to Reproduce:1. Create new class given the code in the details.2. Save and compile in Eclipse. fixed.  avoid secondary resolve.  Only happens for non simple patterns where there is a tree structure of patterns (in this case an Or node with two children). "	2012-02-19 15:42:42	1329680000.0	resolved fixed	f37c56e	1330710000.0	tests/bugs170/pr371998/AspectTest.java tests/src/org/aspectj/systemtest/ajc170/Ajc170Tests.java weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java
371684	type construction for signature makes mistakes with wildcards	If you have a type with multiple type params, like this:Foo<?,T>the signature is:LFoo<*TT;>;and the handling of * is not working in TypeFactory.  If that signature is passed in it will actually build:Foo<?>having lost the second type parameter, this breaks code later that has expectations on the number of params.  (e.g. ArrayIndexOutOfBoundsException when building parameterization map) fixed.Handles multiples as well (eg. LFoo<***>;) 	2012-02-15 17:16:16	1329340000.0	resolved fixed	89756cd	1329340000.0	org.aspectj.matcher/src/org/aspectj/weaver/TypeFactory.java tests/src/org/aspectj/systemtest/ajc170/Ajc170Tests.java
362956	neo4j NPE	java.lang.NullPointerException        at org.aspectj.weaver.patterns.ExactAnnotationTypePattern.matches(ExactAnnotationTypePattern.java:128)        at org.aspectj.weaver.patterns.ExactAnnotationTypePattern.matches(ExactAnnotationTypePattern.java:96)        at org.aspectj.weaver.patterns.AndAnnotationTypePattern.matches(AndAnnotationTypePattern.java:42)        at org.aspectj.weaver.patterns.AnyWithAnnotationTypePattern.matchesExactly(AnyWithAnnotationTypePattern.java:55)        at org.aspectj.weaver.patterns.TypePattern.matchesStatically(TypePattern.java:132)        at org.aspectj.weaver.patterns.TypePattern.matches(TypePattern.java:146)        at org.aspectj.weaver.patterns.SignaturePattern.couldEverMatch(SignaturePattern.java:999)        at org.aspectj.weaver.patterns.DeclareAnnotation.couldEverMatch(DeclareAnnotation.java:483)        at org.aspectj.weaver.bcel.BcelClassWeaver.getMatchingSubset(BcelClassWeaver.java:1065)        at org.aspectj.weaver.bcel.BcelClassWeaver.weaveDeclareAtField(BcelClassWeaver.java:1301)        at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:445)        at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:100)        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1687)        at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1631)        at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1394)        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1180)        at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.weaveQueuedEntries(AjPipeliningCompilerAdapter.java:514)        at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.queueForWeaving(AjPipeliningCompilerAdapter.java:447)        at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.afterProcessing(AjPipeliningCompilerAdapter.java:432)        at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$after$org_aspectj_ajdt_internal_compiler_CompilerAdapter$5$6b855184(CompilerAdapter.aj:98)        at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:652)        at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:392)        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:1021)        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performBuild(AjBuildManager.java:268)        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:181)        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)        at org.aspectj.tools.ajc.Main.run(Main.java:371) fixed.  hasAnnotation() doing one thing, getAnnotation() doing another. 	2011-11-04 20:33:16	1320450000.0	resolved fixed	942da06	1320680000.0	org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java
359332	NPE in AjBuildManager.java:528 after non-Java/AJ file was renamed	"Build Identifier: Upon using Eclipse's ""Rename Resource"" dialog to rename my project's ""src/main/resources/META-INF/spring/email.properties"" file to ""scheduler.properties"" in the same directory, Eclipse displayed the ""AspectJ Internal Compiler Error"" dialog with this stack trace: java.io.FileNotFoundExceptionat java.io.FileInputStream.open(Native Method)at java.io.FileInputStream.<init>(FileInputStream.java:120)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.copyResourcesFromFile(AjBuildManager.java:528)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.copyResourcesToDestination(AjBuildManager.java:466)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performBuild(AjBuildManager.java:363) ... e error: FileNotFoundException thrown: /Users/aswan/projects/foo/src/main/resources/META-INF/spring/email.properties (No such file or directory)Reproducible: Couldn't ReproduceSteps to Reproduce:N/A Sorry, forgot to add the build ID, which is I20110613-1736. guard on the FileNotFoundException - lets not choke when this happens "	2011-09-29 00:22:08	1317270000.0	resolved fixed	14a6eac	1317310000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
354947	Nullpointer-Exception while parsing definition file (aop.xml) in DocumentParser	"Build Identifier: 20100617-1415With an activated NullpointerException-Breakpoint i recently stumpled upon a thrown NPE in the DocumentParser.parse()-method (Line 106):	public static Definition parse(final URL url) throws Exception {		InputStream in = null;		try {			if (CACHE && parsedFiles.containsKey(url.toString())) {				return parsedFiles.get(url.toString());			}			Definition def=null;						if(LIGHTPARSER){					def = SimpleAOPParser.parse(url);			}else{				def = saxParsing(url);			}					if (CACHE && def.getAspectClassNames().size() > 0) {				parsedFiles.put(url.toString(), def);			}			return def;		} finally {			try {				in.close();			} catch (Throwable t) {			}		}	}... The parsing of the configuration file works fine, merely the InputStream seems not to be used anymore. Reproducible: Always thanks for taking the time to let me know.  Fixed it. "	2011-08-17 09:28:42	1313590000.0	resolved fixed	e71e287	1313600000.0	weaver/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java
353457	NPE when saving an aspect - Aspectj Internal Compiler Error	Created attachment 200625Two projectsjava.lang.NullPointerExceptionat org.aspectj.weaver.ShadowMunger.getBinaryFile(ShadowMunger.java:201)at org.aspectj.weaver.ShadowMunger.getBinarySourceLocation(ShadowMunger.java:188)at org.aspectj.weaver.model.AsmRelationshipProvider.createAdviceChild(AsmRelationshipProvider.java:699)at org.aspectj.weaver.model.AsmRelationshipProvider.addChildNodes(AsmRelationshipProvider.java:657)at org.aspectj.weaver.model.AsmRelationshipProvider.crea ... bleAspect$edu_uat_cs2011_observerpattern_Observable$observers(java.util.List)end public class edu.uat.csc263.su10045.observermodel.DepartmentManagerI have attached a zip file containing the two projects that in combination caused this problem.  To recreate, load the projects, go into DepartmentManagerObservableAspect, modify the pointcut and save the file. this is now fixed.  It is due to the abstract aspect being only on the classpath.  If you want to workaround it until an AJDT is available containing the change, just add the jar file (containing the abstract aspect) to the aspectpath rather than the classpath. *** Bug 357067 has been marked as a duplicate of this bug. *** 	2011-07-30 17:23:36	1312060000.0	resolved fixed	0f506ab	1313440000.0	org.aspectj.matcher/src/org/aspectj/weaver/ShadowMunger.java
354022	constructor inlining can fail for some groovy built code	The file grails.util.BuildSettings contains bytecode where the constructors are recursive.You can't compile this in JavaA() {  this();}but groovy generates some code where it switches on a value in the ctor and if it is a certain value, the recursive ctor call is made.  I imagine this 'never happens' in practice but because it is in the bytecode it trips up the AspectJ code which inlines this() calls before weaving - since it gets into an infinite loop.For now, just keep track of ctors making the recursive call and so don't get trapped in the infinite loop. fixes in. Seems to behave, perhaps not perfect but we'll limp along. 	2011-08-05 12:17:24	1312560000.0	resolved fixed	6ae463a	1312560000.0	weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java
340806	Race condition in JavaLangTypeToResolvedTypeConverter (potentially exposed through Spring AOP)	"Build Identifier: 1.6.11Spinoff of https://jira.springsource.org/browse/SPR-8070 and Bug 337855There is a race condition in JavaLangTypeToResolvedTypeConverter's use of the'typeVariablesInProgress' Map.  This can lead to fromType() returning NULL (which eventually leads to the NPE in World).        } else if (aType instanceof java.lang.reflect.TypeVariable) {            if (typeVariablesInProgress.get().get(aType) != null) {>>>             // aType can get removed from the Map after this null check!                return typeVariablesInProgress.get().get(aType);            }The error results in the following stack trace:java.lang.NullPointerException: null	at org.aspectj.weaver.World.resolve(World.java:278) ~[aspectjweaver.jar:1.6.11]	at org.aspectj.weaver.World.resolve(World.java:218) ~[aspectjweaver.jar:1.6.11]	at org.aspectj.weaver.World.resolve(World.java:253) ~[aspectjweaver.jar:1.6.11]	at org.aspectj.weaver.TypeFactory.createParameterizedType(TypeFactory.java:42) ~[aspectjweaver.jar:1.6.11]	at org.aspectj.weaver.reflect.JavaLangTypeToResolvedTypeConverter.fromType(JavaLangTypeToResolvedTypeConverter.java:88) ~[aspectjweaver.jar:1.6.11]I have also attached a BTrace script that shows further analysis of the problem:  onFromType_Line91: RETURNING TYPE FROM MAP (typeVariablesInProgress: {T=T})  onFromType_FieldGet: typeVariablesInProgress: {T=T}  onFromType_Return: fromType(T) --> nullWe have tested a patch that wraps the 'typeVariablesInProgress' Map in a ThreadLocal.  In limited testing, this appears to have fixed the problem.  I have attached the patch.Reproducible: SometimesSteps to Reproduce:Perform type resolution on classes with parameterized/generic signatures concurrently with multiple threads.Note: I have been unable to reproduce this issue outside of our server.  We see the issue with Spring and during Server initialization under heavy load. Created attachment 191791Patch to JavaLangTypeToResolvedTypeConverterUse a ThreadLocal to avoid race condition Created attachment 191792BTrace Script for diagnosing race conditionYou will need to supply your own ""logger"" implementation, or just replace with System.out I'd prefer to avoid threadlocals if we can.  Can we simply change it from:if (typeVariablesInProgress.get().get(aType) != null) {  return typeVariablesInProgress.get().get(aType);}toTypeVariableReferenceType tvrt = typeVariablesInProgress.get(aType);if (tvrt!=null) {  return tvrt;}I think I'd prefer to synchronize on it rather than threadlocal, if that doesn't work. I actually did that first and can confirm that using the local var works.  I switched to the ThreadLocal because that seemed more in line with your goal of using that Map to prevent infinite recursion. Andy - I see this didn't make it in to 1.6.12.  Is there anything you are waiting on from me?  We'd appreciate if this could make it into 1.6.13 - seems like a quick fix.  Thanks! probably just slipped through the net.  We haven't released 1.6.12 yet so there is scope to get this in.  We have put out M1 and an M2 will be out shortly, likely a release in a couple of months. committed the local variable variant of the change, hope that is sufficient. At the company I work for, we have run into this issue in the the last spring before we release it to our customers. I was glad to had found out about this bug had been fixed but oh surprise, neither the target version (1.6.12) nor subsequent ones include the aforementioned fix. Is there any update on when this fix will make it into one of the versions?Thanks Given the date of my last comment it should be in 1.7.0 - are you saying it isn't in that version?Possibly the fix doesn't actually address all situations where this can occur.  Let me know what version you are trying it with. I guess I'll have to go in and double check whether the change is really in the code. Yes, I got the latest version 1.7.1 and the code in JavaLangTypeToResolvedTypeConverter has not changed to reflect the fix mentioned in here I think you did add a change but it is not what it is in the Attachments section (""Patch to JavaLangTypeToResolvedTypeConverter""). IMHO the attachment should be removed to avoid confusion on what was really changed. I think as discussed in comment 3 I didn't want to do the threadlocal so went with the local variable variant instead.You are right I should remove the attachment.I just confirmed my local variable variant of the change is in the code. If you are using that changed version the stacktrace is likely to be slightly different - can you attach a new stacktrace for the problem you see? We are testing now using 1.6.12. I will update if we experience it again. Thanks Andrew. "	2011-03-23 16:35:10	1300910000.0	resolved fixed	167b801	1312400000.0	weaver5/java5-src/org/aspectj/weaver/reflect/JavaLangTypeToResolvedTypeConverter.java
353349	NPE in deleteNewAndDup	java.lang.NullPointerException        at org.aspectj.weaver.bcel.BcelShadow.deleteNewAndDup(BcelShadow.java:179)        at org.aspectj.weaver.bcel.BcelShadow.prepareForMungers(BcelShadow.java:303)        at org.aspectj.weaver.Shadow.implement(Shadow.java:543)        at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:3147)        at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:490)        at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:100)        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1687)        at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1631)        at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1394)        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1180)        at org.aspectj.weaver.tools.WeavingAdaptor.getWovenBytes(WeavingAdaptor.java:467)        at org.aspectj.weaver.tools.WeavingAdaptor.weaveClass(WeavingAdaptor.java:318)        at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:96) due to groovy constructors being funky.  Guard now allows for this. 	2011-07-28 13:52:00	1311880000.0	resolved fixed	e8ef5bf	1311890000.0	weaver/src/org/aspectj/weaver/bcel/BcelShadow.java
353100	"Need to demote ""warning ignoring duplicate definition"" from warning to debug"	Build Identifier: 1.6.11This kind of “problem” can occur for complex class loader hierarchies, and since it is not really a problem, we should make it debug level message so as not to write log messages un-necessarily.Reproducible: AlwaysSteps to Reproduce:1. Create an application that has some weaved class loaders hierarchy - recommend some URLClassLoader derived ones2. Add the same(!) JAR with only an aop.xml file to more than one loader along the hierarchy3. Make the loader the default context thread loader and start running some code. warning demoted to debug 	2011-07-26 08:47:48	1311680000.0	resolved fixed	c6fb752	1311700000.0	loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java
352389	overweaving can attribute duplicate attributes, one of which will not deserialize correctly	"When overweaving it is possible that a class will get a second WeaverState attribute.  This second one will not be valid (it hasn't been correctly configured).  This isn't normally a problem because the next thing that happens is that the class is defined to the VM.  But if *another* weave step occurs, the malformed attribute will cause that weave to fail with this kind of message:bad WeaverState.Kind: -115The solution is to avoid adding the duplicate when overweaving. fix committed to avoid adding the dup I'm getting ""key not found in wovenClassFile"" due to the fix because second time weaving doesn't insert the key due to this fix.The problem manifested itself due to the fact BcelWeaver.processReweavableStateIfPresent requires overweaving when second time weaver doesn't have access to aspects already woven to bytecode. Otherwise it will produce REWEAVABLE_ASPECT_NOT_REGISTERED error.I worked around the problem with a patch that replaces the WeaverState attribute instead of ignoring/duplicating it, but I'm not sure if this is the right way or not due to the validity/correctness concern described in previous comment. I can see that both weavings have taken place without any problems that I know of at this point. Created attachment 259215LazyClassGen.patchI see that the problem that I described above still exists with 1.8.8. I guess that this might be related to discussion java.lang.RuntimeException: key not found in wovenClassFile <http://aspectj.2085585.n4.nabble.com/Aspectj-error-Internal-compiler-error-java-lang-RuntimeException-key-not-found-in-wovenClassFile-at--td4650879.html>. I tried the patch and all the existing tests pass - although I recognize we don't have many for overweening. It'd be great to have the changes proposed here covered by some new overweening tests (some that fail without the patch and pass with it).  The use of removeAttribute makes me a little nervous but I haven't been into that code for a few years so my concerns may not be warranted. Comment on attachment 259215LazyClassGen.patchIt seems that patch contains a bit old code from 1.8.6 to 1.8.8. by accident. Mainly the section starting with reference to bug 352389 is relevant. Attribute adders and getter shouldn't be removed an toString should use the equals test. Created attachment 259249LazyClassGen.patch When I tested the patch yesterday I only applied the relevant bit to LazyClassGen (not the getter/setter/equals changes). If you want me to apply it you will need to sign the Eclipse CLA (you can tell if you have signed it because there is a check mark against the CLA button next to your name in each comment on the bug).However, I'd still like to have a test case. If you aren't sure how to create one as a patch, if you can at least give me a snippet of code to compile and a set of command line steps that trigger failure, I can convert that into a test case. Created attachment 259859ajc crash logHello everybody!This error also reproduces on ajc 1.8.8 in my case:— I've been delcared my java output as -inpath to handle weaving sub-java languages, like groovy or kotlin, which cannot be accessed in CTW, but with binary weaver only;— This inpath contains already woven aj classes;— Restricting inpath to concrete directory (package) doesn't allow ajc to weave anything; (below more details about this)The aspects that breaks ajc you can find here in my example project:https://github.com/Archinamon/AspectJExampleAndroid/tree/master/app/src/main/aspectj/com/archinamon/xpointDunno, am I should crete a separate bug report for this one?I'm trying to restrict ajc binary weaving from passing all files in my output dir, so I walk across all sources, marks aspectj folder and exclude it from inpath directories. I'm adding to inpath only not-common directories with non-aspect binary outputs (java, groovy, etc.). But this behaviour doesn't recognisable by ajc — it doesn't weave my .class files at all if inpath not equals to the common build variant output dir.Hard to describe it, so I'll write simple example:My java output path (android project) is: ""/Project/app/build/intermediates/classes/debug/""where 'app' is a sub-module, 'debug' is my build variant.When I'm trying to set inpath to smth different from the path mentioned above, for example: ""/Project/app/build/intermediates/classes/debug/com/archinamon/grooid/"" where I have groovy compiled code, then ajc not pick up this bytecodes at all. No errors or warnings I didn't get :( Just to say under https://bugs.eclipse.org/bugs/show_bug.cgi?id=389678 I just enhanced overweaving support. 1.9.3 will probably not fail in the way you had it fail in comment#8 "	2011-07-18 16:08:47	1311020000.0	resolved fixed	8553b30	1311020000.0	weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java
350855	overweaving misbehaving when subclassing WeavingURLClassLoader	Raised by the Spring Insight team, they observed that in a system where they are using a special classloader (subclassing weaving url classloader) they see it fail to weave an aspect if overweaving is on. The problem here is how the aspect gets registered with the weaver.  If reweaving then when the reweaving code encounters the aspect, it defines it there and then.  If overweaving is running then we don't do that, we only register new aspects (ignoring existing ones), since we are applying the new ones over the top of the old ones.  However, if the aspects on the aspectpath they should still be defined to the weaver even when overweaving.  The fix is in BcelWeaver to ensure we still add aspects from the aspectpath even when overweaving.This fix has been put into 1.6.12 but also into a special 1.6.11.SR1 build that Insight are going to use. 	2011-06-30 11:32:19	1309450000.0	resolved fixed	2302e94	1309450000.0	weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java
349764	Repeated output of ASPECTJ: aspectj.overweaving=true: overweaving switched ON	Build Identifier: 1.6.11The message is repeated every time a new class loader is being use to load weaving configuration (using  -Dorg.aspectj.tracing.factory=default). Since this value is a system (!) property there is no need to display its value more than once (or even check it more than once - it could be lazily initialized and cached...)Reproducible: AlwaysSteps to Reproduce:1. use -Dorg.aspectj.tracing.factory=default -Daspectj.overweaving=true properties2. place some JAR that contains aop.xml with some aspects and weaving options where it can be loaded/visible from several class loaders3. runt the application and check the STDOUT output fixed 	2011-06-19 05:42:40	1308480000.0	resolved fixed	bb2aea4	1308590000.0	org.aspectj.matcher/src/org/aspectj/weaver/World.java
349636	"AspectJ reports ""abort trouble"" while instrumenting a class on startup"	<Pyinson Data Over Head> Looks to be a type that has somehow been resolved without having its 'world' set.Given the context of spring and osgi in the mix on the stack, it could be the reset logic for primitives is being called at an unhelpful time (i.e. the reset logic is called to clear the worlds from the primitive types, to prevent them anchoring that world in memory, then something else runs that tries to use them and expects their world to be set).As a first step I've put in a bit of debug that will fire if this happens again which will tell us the type that was having the problem - if it is a primitive, that would suggest it is a problem due to reset. AspectJ no longer nulls the world for a primitive type representation - it doesn't need to since it no longer shares primitives amongst worlds, they are resolved independently in each world.  This will prevent a NPE like this.  Although I haven't been able to recreate this to confirm the fix, I'm reasonably sure it is addressed.  Lets close for now and re-open if it comes up post 1.6.12. 	2011-06-16 20:13:48	1308270000.0	resolved fixed	f7b1193	1308350000.0	weaver/src/org/aspectj/weaver/bcel/Utility.java
348979	world type map fixed/expendable problems	Discovered whilst working with Steve Ash on a build of a few projects that was consuming more than 2Gigs of heap.To recover memory Steve activated type demotion.  This didn't appear to help much.  This was due to Steve's projects using aspectpath.  The aspectpath scanning to discover aspects was inadvertently making any types discovered on the aspectpath permanent types (not expendable) and they'd never be demoted/evicted.The types were all being made permanent in case they were an aspect but never being demoted if it turns out they were not.  In a Roo petclinic I added spel as a dependency (on the aspectpath) and parsed a simple expression (just to further exaggerate the problem).  This was leaving 213 types in the fixed area of the typemap.  By correctly scanning aspectpath and demoting non-aspects this was reduced to 90. fix is to demote them immediately if they are not an aspect.Also observed is that array types of anything are considered permanent - whether it is String[] or ThisIsGoingToBeWoven[] they are all inserted in the fixed map, we should stop that.  However, we may still want to keep primitive arrays int[]/etc in the map. ok - final changes are in.  primitive arrays are anchored (in addition to primitives), like [[I for example. 	2011-06-09 18:59:37	1307660000.0	resolved fixed	2edb246	1307740000.0	tests/multiIncremental/PR278496_10/base/com/Asp.java tests/multiIncremental/PR278496_10/base/com/Foo.java tests/multiIncremental/PR278496_11/base/com/Foo.java tests/multiIncremental/PR278496_11_a/base/com/Asp.java tests/multiIncremental/PR278496_11_a/base/com/Dibble.java
348488	"""register definition failed"" with NullPointerException"	the problem here is a broken/unusual localvariabletable in one of the classes.  I've put in a guard to cope with this occurring.  Surprising that it isn't easily reproduceable as the same code woven in the same way a second time should cause the same thing to occur.  When this situation occurs it will also print a line of debug info:AspectJ: 348488 debug: unusual local variable table for method XXX.YYYwhich, if it happens again, will allow us to investigate further, but the NPE can't happen anymore. committed <Pyinson Data Over Head> 	2011-06-06 21:12:28	1307410000.0	resolved fixed	95e70d2	1307470000.0	weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java
327134	Cant suppress raw types warning in a pointcut	"Build Identifier: I20100608-0911Generic type used in a pointcut and bound to target() or this() must omit actual type name and thus causes 'raw type must be parametrized' compiler warning. @SuppressAJWarning or @SuppressWarning annotations does not turn it offReproducible: AlwaysSteps to Reproduce:Code snippets:pointcut IVOListUpdate(IVOList list):		&& target(list) && call(void updateList(*));public interface IVOList<T extends IValueObject> extends List<T>, Externalizable, Serializable {		void updateList(List<T> newList);	}public interface IValueObject extends Comparable<IValueObject>, Serializable {} Because AspectJ is based on an older JDT compiler, you needed to use @SuppressWarnings(""unchecked"") - since the old compiler did not distinguish between raw type refs and unchecked conversions, using 'unchecked' to cover both.However, yesterday I backported the recent JDT changes and so @SuppressWarnings(""rawtypes"") will now work with 1.6.12 dev builds. "	2010-10-06 12:12:17	1286380000.0	resolved fixed	199299c	1304000000.0	tests/bugs1612/pr327134/Code.java tests/src/org/aspectj/systemtest/ajc1612/Ajc1612Tests.java
339974	NPE when accessing static class inside of an ITIT	"This code:public class City {    private String name;    private Country country;}And separate file:public aspect TrafficCalculator {		public static class City.TrafficCalculator {		Function<City, Time> EXTREME = createExtremeTraffic(); 		Function<City, Time> BASIC = createBasicTraffic();	}			private static Function<City, Time> createExtremeTraffic() {		return null;	} 	private static Function<City, Time> createBasicTraffic() {		return null;	} 		public static class Time { } }Try full build and the following exception:java.lang.NullPointerException	at org.aspectj.ajdt.internal.compiler.ast.IntertypeMemberClassDeclaration.resolveOnType(IntertypeMemberClassDeclaration.java:238)	at org.aspectj.ajdt.internal.compiler.ast.IntertypeMemberClassDeclaration.build(IntertypeMemberClassDeclaration.java:246)	at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.processIntertypeMemberTypes(AspectDeclaration.java:1039)	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.processInterTypeMemberTypes(AjLookupEnvironment.java:523)	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:197)	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.internalBeginToCompile(Compiler.java:616)	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:357)	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:371)	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:1021)	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performBuild(AjBuildManager.java:305)	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:185)	at org.aspectj.ajde.core.internal.AjdeCoreBuildManager.performBuild(AjdeCoreBuildManager.java:127)	at org.aspectj.ajde.core.AjCompiler.build(AjCompiler.java:91)	at org.eclipse.ajdt.core.builder.AJBuilder.build(AJBuilder.java:257)	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:629)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:172)	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:203)	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:255)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:258)	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:311)	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:343)	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:144)	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:242)	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54) Oops.  I realize what the problem is now. I named the inner type the same as the outer aspect.  This is a user error, but no exception should be thrown. this was addressed by the fix for bug 338175.  You also forgot to include the definitions of Country and Function, so I guessed them and fleshed it out into a testcase which has been committed. "	2011-03-15 00:21:25	1300160000.0	resolved fixed	249f832	1303400000.0	tests/bugs1612/pr339974/City.java tests/bugs1612/pr339974/TrafficCalculator.java tests/bugs1612/pr342605/Code.java tests/src/org/aspectj/systemtest/ajc1612/Ajc1612Tests.java
341446	java.lang.UnsupportedClassVersionError when running Java 1.5	We are using Spring 3.0 and they have a dependency to aspectj. Thus we have the runtime Jars on the classpath.Problem is the aspectjweaver.jar contains 1.6 byte code. When starting our application on JBoss 5.1 with JDK 1.5 we get an exception in the logs:Unexpected error during load of:testdata.SomeAnnotationjava.lang.UnsupportedClassVersionError: Bad version number in .class fileat java.lang.ClassLoader.defineClass1(Native Method)at java.lang.ClassLoader.defineClass(ClassLoader.java:620)at org.jboss.classloader.spi.base.BaseClassLoader.access$200(BaseClassLoader.java:63)at org.jboss.classloader.spi.base.BaseClassLoader$2.run(BaseClassLoader.java:572)at org.jboss.classloader.spi.base.BaseClassLoader$2.run(BaseClassLoader.java:532)at java.security.AccessController.doPrivileged(Native Method)As we are not using aspects from aspectj we don't have a problem ... but others might have. There is a issue for Spring as well:https://issuetracker.springsource.com/browse/EBR-622Also had a look at the current release 1.6.11 and the same situation there.So as other people have no chance of working around this (other than building the jar themself) I set this to major. It is actually some rogue testdata classes that have been packaged into the distribution, 3 of them, in the testdata package.  All the main classes are of the correct level (1.3/1.5).   I've just committed some changes to ensure the testdata code isn't packaged up.  I *might* rebuild the 1.6.11 release to remove them. The latest 1.6.12 snapshots available in our (springsource) maven repo have this fixed.  I am not going to rebuild 1.6.11 right now 	2011-03-31 02:20:53	1301550000.0	resolved fixed	293a075	1301630000.0	org.aspectj.matcher/testdata/AnnotatedClass.java org.aspectj.matcher/testdata/MethodLevelAnnotation.java org.aspectj.matcher/testdata/SomeAnnotation.java org.aspectj.matcher/testsrc/org/aspectj/matcher/tools/CommonAdvancedPointcutExpressionTests.java org.aspectj.matcher/testsrc/testdata/AnnotatedClass.java org.aspectj.matcher/testsrc/testdata/MethodLevelAnnotation.java org.aspectj.matcher/testsrc/testdata/SomeAnnotation.java
340323	NPE when weaving java.lang.Object at org.aspectj.weaver.bcel.BcelTypeMunger.createAnyBridgeMethodsForCovariance(BcelTypeMunger.java:1251)	Created attachment 191423AJ core dumpI'm trying to add a method to Object using a inter-type declaration. When calling ajc, I encounter a NPE. From a cursory glance, it would appear that the code is looking for the parents classes of Object, which presumably is null.I've attached the dump and a simple example that causes it. Created attachment 191424Test class Created attachment 191425Aspect with inter-type declaration causing NPE. Note that this only happens if the compliance level is set to 1.6 or 1.5. The example test case I gave doesn't require this level, but my original code will not compile without it, since it uses generics. I wasn't able to build the sources, but I was able to manually modify the class file, within the jar. I added a null reference check for the createAnyBridgeMethodsForCovariance method, around line 1250 of BcelTypeMunger.java. ajc now compiles the test example correctly. Hi,Sorry I didn't reply sooner.I've put in the null check, I think I've done the same as you have tried out.  I don't have a test harness for checking weaving against JDK classes so haven't added a regression test.  I've never heard anyone weave into Object like that either, but I guess it is working for you :)Fix will be in 1.6.12. 	2011-03-17 10:34:56	1300370000.0	resolved fixed	a8e6797	1301340000.0	weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java
339300	problem weaving anonymous inner (member owned) classes in scala library	Reported by Ramnivas.Due to the use of numerous $ chars in scala classnames, some of the AspectJ handling of inner classes breaks down.  It should be possible to correctly use the available class attributes rather than mess around with attributes.  A while back one use did contribute a change to enable scala weaving which tried to use the InnerClasses attribute before falling back on string chopping.  However we have now hit another case.In the scenario we are dealing with the class scala.Predef$$anon$3 in the scala library (a 2.9.0-SNAPSHOT version).  What we normally do here is in that type we discover the InnerClass attribute and refer to the outerclass index it holds.  Unfortunately, due to it being an anonymous inner inside a method, the index is 0.  So we fail to process the attribute and with string chopping come up with a stupid guessed name for the outer.The solution is to use the EnclosingMethod attribute in these situations.  The EnclosingMethod attribute is an optional attribute. A class must have an EnclosingMethod attribute if and only if it is a local class or an anonymous class. A class may have no more than one EnclosingMethod attribute.The EnclosingMethod attribute includes a pointer to the containing outerclass (that had the method in which encloses this inner type). fix just made it into 1.6.11 *** Bug 337064 has been marked as a duplicate of this bug. *** 	2011-03-08 18:49:10	1299630000.0	resolved fixed	945402f	1299630000.0	weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java
336997	IllegalStateException for generic ITD usage	<Pyinson Data Over Head> caused by changing from this:public  Iterable<? extends NodeBacked> NodeBacked.findAllByTraversal(final Class<? extends NodeBacked> targetType, TraversalDescription traversalDescription) {...    }to this   public  <T extends NodeBacked> Iterable<T> NodeBacked.findAllByTraversal(final Class<T> targetType, TraversalDescription traversalDescription) {...    }changed resolve in World slightly for type variables.fixed. 	2011-02-11 14:01:27	1297450000.0	resolved fixed	80785bf	1297450000.0	org.aspectj.matcher/src/org/aspectj/weaver/TypeVariable.java org.aspectj.matcher/src/org/aspectj/weaver/TypeVariableReferenceType.java org.aspectj.matcher/src/org/aspectj/weaver/World.java
282379	[plan] spaces in file names causes AspectJ weaver to fail	"The WeavingAdaptor requires the aspect path to be composed by URLs. The URL of a file is encoded, for example if it contains spaces they will be represented with %20.It then converts these file:// urls to simple string paths, and then tries to access files pointed by those paths.This is done inside the FileUtil.makeClasspath(URL[]) . This method uses URL.getPath() to obtain the path. But this method does not decode the string, it returns it as it is in the URL. When later this string is used to create a new File instance, that file contains an invalid path, and the weaver fails as follows :Caused by: org.aspectj.bridge.AbortException: bad aspect library: '/home/sym/path%20with%20space/aspect-library.jar'        at org.aspectj.weaver.tools.WeavingAdaptor$WeavingAdaptorMessageHolder.handleMessage(WeavingAdaptor.java:624)        at org.aspectj.bridge.MessageUtil.error(MessageUtil.java:80)        at org.aspectj.weaver.tools.WeavingAdaptor.error(WeavingAdaptor.java:504)        at org.aspectj.weaver.tools.WeavingAdaptor.addAspectLibrary(WeavingAdaptor.java:472)        at org.aspectj.weaver.tools.WeavingAdaptor.registerAspectLibraries(WeavingAdaptor.java:447)        at org.aspectj.weaver.tools.WeavingAdaptor.init(WeavingAdaptor.java:177)        at org.aspectj.weaver.tools.WeavingAdaptor.<init>(WeavingAdaptor.java:112)This issue is quite important, because on older windows ""Documents and Settings"" is an unfortunately common path, for example Maven stores there its repository.Multiple solutions are possible for this simple bug, in order of impact :- Decode the string obtained by URL.getPath() using URLEncoder.decode() - Use Files instead of Strings and let Java handle the URL, using the File(URI) constructor- Don't assume that aspect libraries are files, and hence that urls are file url, and use URLConnection to fetch aspect library contents. A simple workaround for this bug, from the user code, is to add the following snippet in the getAspectURLs of the WeavingClassloader passed to the WeavingAdaptor :for (int i = 0; i < aspects.length; i++) {  try {    aspects[i] = new URL(URLDecoder.decode(aspects[i].toExternalForm(), ""UTF-8""));  } catch (Exception e) {    throw new RuntimeException(""Error sanitizing the aspect URL"", e);  }}Surprisingly, new URL(String) does not encode it. I've tested this under Linux, with a path with spaces. Will test it under windows XP soon. i'm surprised this hasn't been reported before now, hmmm It would be easier if you gave me a patch as I don't understand where you want that code snippet to be put.  It mentions a field called aspects that I don't see in getAspectsURLs() - and surely putting it in there will cause the decode to happen on every call to getAspectsURLs() when it should only be done once. Hi Andy,yes, that code was merely a workaround, forget about it.The simplest patch would be to use URLEncoder.decode() in FileUtil.java line 1422.In fact the problem is that the file url may be ""file:///path%20with%20space/something.jar"", calling URL.getPath() (as it happens in line 1422 of FileUtil.java) returns ""/path%20with%20space/something.jar"", and trying to build a new File() with that string will search for that path literaly, without reconverting %20 to "" "". I changed FileUtil to use 	try {	ret.add(URLDecoder.decode(urls[i].toExternalForm(), ""UTF-8""));} catch (UnsupportedEncodingException e) {	// TODO Auto-generated catch block	e.printStackTrace();}and got lots of test failures. Seen by Martin Lippert with tc server and insight running on the mac under STS. Created attachment 188381patchI am attaching a patch. I confirmed that it fixes the problem in Tc Server.I am currently rerunning all the tests and seem to have no additional test failures (I did have two tests failures initially without making any changes).After applying this patch, there's actually only one test failure now.Since you said you prefer a 'minimal' change. This change impacts only the place where it matters for the TcServer problem. Also I've included a 'fallback' for when the 'correct' method of converting a URL to a path string might fail because the input contains bad stuff (such as unescaped spaces, which would not occur in correctly formatted URLs). In that case we will assume that some other ill-behaved code has passed us a URL created while not properly escaping stuff.It runs fine on Unix, but you may have some problems with tests in Windows because of '\' characters in the paths.I might try and run this on my Windows view later. With some luck the 'fallback' for broken URLs should work.KrisPS: I still don't like that there seem to be many more places that incorrectly use the URL.getPath method.PS2: I will try and create a regression test somehow later. I tried on Windows last night. I did have one test failure *before* applying my patch. I think it was the same test that failed on Linux, a test called 'testIncompletAspectPath' or something like that.Also on Windows it seems that applying the patch makes that test pass.I did have my workspace under 'Documents and Settings' somewhere so there werespaces in the path.After applying the patch, all tests ran clean for me on Windows. This the test failed before patch appied:org.aspectj.weaver.loadtime.WeavingURLClassLoaderTest.testIncompletePath() patch is in, thanks Kris "	2009-07-03 10:12:55	1246630000.0	resolved fixed	5648105	1296940000.0	util/src/org/aspectj/util/FileUtil.java
324804	NullPointerException at AspectJElementHierarchy.java:677	"Build Identifier: 20100617-1415After removing a ""throws"" clause from the constructor of a class and then saving I got the following error:java.lang.NullPointerExceptionat org.aspectj.asm.internal.AspectJElementHierarchy.getCanonicalFilePath(AspectJElementHierarchy.java:677)at org.aspectj.asm.internal.AspectJElementHierarchy.updateHandleMap(AspectJElementHierarchy.java:641)at org.aspectj.asm.AsmManager.removeStructureModelForFiles(AsmManager.java:572)at org.aspectj.asm.AsmManager.processDelta(AsmManager.java:604)at org.aspectj.ajdt.internal.core.builder.AjBuildManager ... oBuildJob.run(AutoBuildJob.java:242)at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)Compile error: NullPointerException thrown: nullReproducible: Didn't try Created attachment 178463JVM Error LogI was able to reproduce this error when adding or removing the throws clause from the constructor...until Eclipse eventually crashed. Attaching the JVM hs_err log. The JVM identified the following: # Problematic frame:# J  org.aspectj.asm.internal.AspectJElementHierarchy.updateHandleMap(Ljava/util/Set;)V Possibly a threading issue with an AJDT thread affecting the handleMap which the compiler is in the middle of processing.  A guard would seem to suffice here as null effectively means the same as the check the code was going to perform.Not sure why a simple NPE would lead to a vm crash.I've committed a guard on null to stop this occurring. "	2010-09-08 18:30:31	1283990000.0	resolved fixed	6249672	1284050000.0	asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java
324190	NullPointerException in AjBuildManager.findOutputDirsForAspects when compiling AspectJ project generated with Maven	Build Identifier: 20100617-1415When I compile my AspectJ project, I get an AspectJ Internal Compiler Error. The stack trace is : java.lang.NullPointerExceptionat org.aspectj.ajdt.internal.core.builder.AjBuildManager.findOutputDirsForAspects(AjBuildManager.java:725)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.writeOutxmlFile(AjBuildManager.java:652)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performBuild(AjBuildManager.java:367)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:181)at org.aspectj.a ... on$1.run(GlobalBuildAction.java:179)at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)I digged a bit and looked into the classes. It would seem that AjState.getAspectNamesToFileNameMap() can return null in AjBuildManager.findOutputDirsForAspects. It is taken in account when AjBuildConfig.getCompilationResultDestinationManager() returns null or a list with one element, but not when it returns a list with several elements.Reproducible: AlwaysSteps to Reproduce:Always happen in my configuration, but I didn't try to make it happen again in another workspace. Here are the steps I followed.1. Generate a AspectJ project with Maven using the pom.xml I'll join2. Create an aspect with a few pointcuts and a few advices3. Compile (not with maven, the Eclipse compilation) Created attachment 177948pom.xml used to generate the project Created attachment 177949.project Created attachment 177950.classpath null guard added. *** Bug 331981 has been marked as a duplicate of this bug. *** 	2010-09-01 09:15:48	1283350000.0	resolved fixed	03c43f5	1283350000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
318899	NPE with @args matching Argument by Type	"Build Identifier: This bug is related to Bug 257833. I'm wondering why nobody has faced and reported that bug before?!?!This is the top of the stacktrace i get:java.lang.NullPointerException	at org.aspectj.weaver.reflect.ShadowMatchImpl$RuntimeTestEvaluator.visit(ShadowMatchImpl.java:140)	at org.aspectj.weaver.ast.Instanceof.accept(Instanceof.java:29)	at org.aspectj.weaver.reflect.ShadowMatchImpl$RuntimeTestEvaluator.matches(ShadowMatchImpl.java:121)	at org.aspectj.weaver.reflect.ShadowMatchImpl.matchesJoinPoint(ShadowMatchImpl.java:78)This bug occurs in aspectJ 1.6.1 and 1.6.8 so i think all versions in between are affected as well. I'm using aspectJ together with Spring 2.5.6 but i think that does not matter.Expected behavior:When using @Before(""args(myId,..)"") to match all methods that have an argument of type MyInterface as first argument (see steps to reproduce), the methods declared argument types should be used to determine if the method matches when null is passed as first argument.Actual Behavior:NullPointerException is thrown from org.aspectj.weaver.reflect.ShadowMatchImpl$RuntimeTestEvaluator.visit(ShadowMatchImpl.java:140).Note: Everything works fine if null is not used as first argument. That means if your first argument is never null you'll get no exception and everything works as expected. But if there is one method you don't want to match/intercept that gets null as it's first argument the runtime exception occurs.Reproducible: AlwaysSteps to Reproduce:1. define an interface MyInterface2. define a pointcut / empty advice using ""@args(myId)"", e.g.@Before(""args(myId,..)"")public void startsMyIdArgument(final JoinPoint jp, final MyInterface myId) { };3. call a method of an intercepted class with the first argument being null and you'll get a NullPointerException I tried to build a scenario from your instructions, but it just works fine for me.  My code is below - is that the kind of thing you mean?  I haven't used spring in this case, I was hoping to recreate it without needing to do so.---- B.java ----import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;public class B {	public static void main(String[] args) {		new D().foo(null);	}}class D {	public void foo(MyInterface mi) {	}}@Aspectclass X {	@Before(""args(myId)"")	public void startsMyIdArgument(final JoinPoint jp, final MyInterface myId) {	}}interface MyInterface {}---- created the NPE with a unit test (couldn't create it with a compiler test).  Fixed it up. "	2010-07-05 10:24:03	1278340000.0	resolved fixed	2a8d684	1283310000.0	org.aspectj.matcher/src/org/aspectj/weaver/reflect/ShadowMatchImpl.java org.aspectj.matcher/testsrc/org/aspectj/weaver/patterns/ThisOrTargetTestCase.java
324135	ArrayIndexOutOfBoundsException at AjState.java:1767	Build Identifier: 20100617-1415Using AspectJ version: 1.6.10.20100817163700I hit the blow exception after saving a edited java file.java.lang.ArrayIndexOutOfBoundsExceptionat org.aspectj.ajdt.internal.core.builder.AjState.hasStructuralChanges(AjState.java:1767)at org.aspectj.ajdt.internal.core.builder.AjState.recordClassFile(AjState.java:1510)at org.aspectj.ajdt.internal.core.builder.AjState.noteResult(AjState.java:1322)at org.aspectj.ajdt.internal.core.builder.AjBuildManager$3.acceptResult(AjBuildManager.java:1049)at org.aspectj.ajdt.internal.compiler.AjPipeli ... b.run(AutoBuildJob.java:242)at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)Compile error: ArrayIndexOutOfBoundsException thrown: 14Reproducible: Didn't try Fix committed. Can happen on an incremental build when determining whether the set of inner types for a file has changed from one build to the next (adding a new inner class is likely the trigger).AJDT will pick up the fix next time I drop an AJ build into it. 	2010-08-31 16:50:55	1283290000.0	resolved fixed	88fab6a	1283300000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java
320468	ModifiersPattern.getModifierFlag() is not thread safe	<Pyinson Data Over Head> I moved initialization of the map to a static initializer block, preventing later threading issues.  thanks for the detailed bug report. 	2010-07-21 04:22:43	1279700000.0	resolved fixed	e0e1330	1282840000.0	org.aspectj.matcher/src/org/aspectj/weaver/patterns/ModifiersPattern.java
323634	NPE parameterizing perclause	java.lang.NullPointerExceptionat org.aspectj.weaver.ReferenceType.getPerClause(ReferenceType.java:823)at org.aspectj.weaver.patterns.PerFromSuper.lookupConcretePerClause(PerFromSuper.java:82)at org.aspectj.weaver.patterns.PerFromSuper.concretize(PerFromSuper.java:61)at org.aspectj.weaver.CrosscuttingMembers.setPerClause(CrosscuttingMembers.java:512)at org.aspectj.weaver.ResolvedType.collectCrosscuttingMembers(ResolvedType.java:748) ... oBuildJob.run(AutoBuildJob.java:242)at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54) We shouldn't attempt parameterization completion if the perclause is null, just guard for that. 	2010-08-25 12:40:52	1282750000.0	resolved fixed	ce16a06	1282750000.0	org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java
323417	Sometimes StackOverflow is got while weaving	"Build Identifier: 1.6.10While weaving LifeRay 6.0.5 over tomcat 6.0.26 sometimes the next exceptions appear:java.lang.StackOverflowError        at java.lang.String.indexOf(String.java:1521)        at org.aspectj.weaver.TypeFactory.createTypeFromSignature(TypeFactory.java:199)        at org.aspectj.weaver.UnresolvedType.forSignature(UnresolvedType.java:375)        at org.aspectj.weaver.UnresolvedType.getRawType(UnresolvedType.java:533)        at org.aspectj.weaver.ResolvedType.getRawType(ResolvedType.java:2400)        at org.aspectj.weaver.ReferenceType.isAssignableFrom(ReferenceType.java:430)        at org.aspectj.weaver.ReferenceType.isAssignableFrom(ReferenceType.java:399)        at org.aspectj.weaver.ReferenceType.isAssignableFrom(ReferenceType.java:430)        at org.aspectj.weaver.ReferenceType.isAssignableFrom(ReferenceType.java:399)        at org.aspectj.weaver.ReferenceType.isAssignableFrom(ReferenceType.java:430)        at org.aspectj.weaver.ReferenceType.isAssignableFrom(ReferenceType.java:399)        at org.aspectj.weaver.ReferenceType.isAssignableFrom(ReferenceType.java:430)        at org.aspectj.weaver.ReferenceType.isAssignableFrom(ReferenceType.java:399)        at org.aspectj.weaver.ReferenceType.isAssignableFrom(ReferenceType.java:430)        at org.aspectj.weaver.ReferenceType.isAssignableFrom(ReferenceType.java:399)        at org.aspectj.weaver.ReferenceType.isAssignableFrom(ReferenceType.java:430)        at org.aspectj.weaver.ReferenceType.isAssignableFrom(ReferenceType.java:399)        at org.aspectj.weaver.ReferenceType.isAssignableFrom(ReferenceType.java:430)        at org.aspectj.weaver.ReferenceType.isAssignableFrom(ReferenceType.java:399)        at org.aspectj.weaver.ReferenceType.isAssignableFrom(ReferenceType.java:430)        at org.aspectj.weaver.ReferenceType.isAssignableFrom(ReferenceType.java:399)...Reproducible: Sometimes HeyAre you absolutely 100% certain it is 1.6.10.  This was a known serious problem for AspectJ 1.6.7 (and less likely, but possible on earlier versions).Andy Now, not 100 % I have realized Liferay includes some aspectj libraries at the  ROOT  web application, taking into account the Tomcat class Loader Hierarchy, which prevents overriding all the classes from the bootclasspath I am not sure. However the stacktrace matches the source code line from aspectj 1.6.10.... The setup is using LTW  and the LTW aspectjweaver is 1.6.10 (100%). it could be picking some classes from the local webapp repo (it has aspectjweaver.jar + aspectj-rt.jar)  (thus using and old version of aspect) and the others from the boottclasspath?I was trying to create some patch for debug and testing purposes and I will forward to you as soon all the tests are passed as per my email to you just now, we need to ensure the world isn't populated with wrong data, rather than just try to cope with bad data later. just for ref: bug 298908 discusses this situation. I have removed, literally all aspect* that is not from aspect-1.6.10 from the liferay installation so now it should be using only 1.6.10.We still get the same error. I am including the ajcores. Although we compiled the aspectj version with the assertion uncommented, the assertion does not seem to appear in the logs neither in the cores.... Created attachment 177255Cores with assertion enabled I believe I know who to blame, have a look at this debug stack trace:ATCHUNG: introducing GenericType. The QUID is:java.lang.Exception: This is the quid        at org.aspectj.weaver.World$TypeMap.insertInExpendableMap(World.java:1168)        at org.aspectj.weaver.World$TypeMap.demote(World.java:1090)        at org.aspectj.weaver.World$TypeMap.demote(World.java:1059)        at org.aspectj.weaver.World.demote(World.java:1800)        at org.aspectj.weaver.loadtime.ClassLoaderWeavingAdaptor.accept(ClassLoaderWeavingAdaptor.java:852)        at org.aspectj.weaver.tools.WeavingAdaptor.weaveClass(WeavingAdaptor.java:309)        at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:96)        at org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter.transform(ClassPreProcessorAgentAdapter.java:54)        at sun.instrument.TransformerManager.transform(TransformerManager.java:169)        at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:365)        at java.lang.ClassLoader.defineClass1(Native Method)        at java.lang.ClassLoader.defineClassCond(ClassLoader.java:632)^_^ In fact what is going on (I need to test before being sure) is that when demoting is achieved, the object is demoted to generic type:		if (type.isParameterizedOrGenericType()()) {							type = type.getGenericType();						}						List<ConcreteTypeMunger> typeMungers = type.getInterTypeMungers();						if (typeMungers == null || typeMungers.size() == 0) {							tMap.remove(key);							insertInExpendableMap(key, type);							demotionCounter++;						}.... Created attachment 177357Experimental PatchThis patch fixed the issue properly. However all the test has not been performed yet. Keep updated as soon as passed. Comment 8 includes the patched source code, the original one is:      if (type.type.isParameterizedOrRawType()) {                            type = type.getGenericType();                        }                        List<ConcreteTypeMunger> typeMungers =type.getInterTypeMungers();                        if (typeMungers == null || typeMungers.size() == 0) {                            tMap.remove(key);                            insertInExpendableMap(key, type);                            demotionCounter++;                        }The point is avoiding the inclusion of  GenericTypes into TypeMap, including its explodeableMap, where before the patch all RawTypes could be demoted to GenericType, thus being the root cause of the problem... To do so just replace type.type.isParameterizedOrRawType with:  isParameterizedOrGenericType() should avoid RAW demoting conversion to GenericType.... interesting find.I propose a slight variant of the fix.  If the original code wasif (type.isParameterizedOrRawType()) {  type = type.getGenericType();}this incorrectly reduced parameterized or raw to generic (as you discovered).Your change was to make it.if (type.isParameterized()) {  type = type.getGenericType();}which addresses the raw case.  However, given that parameterized types can't go into the map at all (the put() method forbids it), we can actually remove that code entirely, because demotion will never be processing any.So delete all 3 lines.I'd also propose the same change to the compile time weaving demotion code that is a few lines further down and does a similar thing.  Do you think my change will also address your case?  I'm running the tests against that change now.It is hard to test demotion reliably as behaviour of type demotion can rely on GC behaviour, but at least we can check nothing obvious breaks. Thanks.I was a little bit scared to change more about demotion as far as I am not familiarized enough yet with the functional requirements... Thats the reason why I just removed Generic change only for raw types...Andy, I tested this, and as you know in our env we were always able to reproduce the issue, however after testing with this we are not able anymore. thanks for confirming the fix.  Good bit of detective work to track it down, thanks. Thanks to all of you because of AspectJ ;) Sorry to report that, but after having this bug with 1.6.7 and 1.6.9, I have just experienced this bug with AspectJ 1.6.10, while performing a Maven build under Linux.java.lang.StackOverflowError       at org.aspectj.weaver.UnresolvedType.forSignature(UnresolvedType.java:427)       at org.aspectj.weaver.UnresolvedType.getRawType(UnresolvedType.java:585)       at org.aspectj.weaver.ResolvedType.getRawType(ResolvedType.java:2331)       at org.aspectj.weaver.ReferenceType.isAssignableFrom(ReferenceType.java:427)       at org.aspectj.weaver.ReferenceType.isAssignableFrom(ReferenceType.java:393)       at org.aspectj.weaver.ReferenceType.isAssignableFrom(ReferenceType.java:427)       at org.aspectj.weaver.ReferenceType.isAssignableFrom(ReferenceType.java:393)       at org.aspectj.weaver.ReferenceType.isAssignableFrom(ReferenceType.java:427)       at org.aspectj.weaver.ReferenceType.isAssignableFrom(ReferenceType.java:393) As for my previous report, I am unable to reproduce the bug. Although this is an automated build on a server, that starts everytime from clean SVN checkout and there has been no activity in the repository, I only got the bug once. On the bright side, it means it is not such a big trouble. Created attachment 188415Output from AspectJ compiler when the bug occurredI managed to reproduce the bug on our Linux build server. I attach log output from AspectJ 1.6.10 Martin - were there any ajcore files about when the problem occurred? I'd like to have a look at them if there were. thanks. (In reply to comment #18)> Martin - were there any ajcore files about when the problem occurred? I'd like> to have a look at them if there were. thanks.I am sorry, I tried to rebuild the project with new revision and the problem is no longer reproducible, even though I tried reverting to the old revision of the project. The ajcore files (if there were any) were deleted with the rebuild. *** Bug 336463 has been marked as a duplicate of this bug. *** "	2010-08-23 13:44:19	1282590000.0	resolved fixed	f631ad6	1282700000.0	org.aspectj.matcher/src/org/aspectj/weaver/World.java
322039	Fully qualified ITD has incorrect handle identifier	"In the following aspect:public aspect Aspect {	public void q2.ThisClass.something2() {}}In aspectJ, the ITD has the following handle identifier (notice that the ITD name is not fully qualified):=AspectJ Project/src2<p*Aspect.aj'Aspect)ThisClass.something2However, it should be (with fully qualified name):=AspectJ Project/src2<p*Aspect.aj'Aspect)q2.ThisClass.something2This means that fully qualified ITDs cannot be navigated to or searched.  I'm a little surprised that this doesn't work because I thought I had tests for it... This is becoming more important since searching for ITDs has become a required feature for 2.1.1 i changed some element name processing to make this work.  If the new element names are too annoying (outline view?) then I will come up with another way to persist the data so it can be included in the handle. let me know This appears to be working now.  Thanks for the fix.A couple of things:1. Yes, the fully qualified name appears in the outline view.  There may be a way to control the name without having to fuss too much with the internal representation.  For example, ProgramElement.toLinkLabel() returns the ITD with the simple name of the type.2. The source location of the element appears to be off.  Or at least when you navigate from the target type, the wrong location is highlighted.  I have to track this down.  It might be an AJDT problem. #1 looks quite difficult to fix.  The name in the outline view is generated from IJavaElement.getElementName().  This method is also called to generate the handle identifier.  So, we can't fix one without breaking the other.Although, I'd prefer the name in the outline view to be nicer, I'm not too fussed about it.  I'd rather all the other bits and pieces work. #2 is now fixed.  It was an AJDT issue. please resynchronize.  I changed it to do it another way, now the names remain short but the handle will include the fqname. believed fixed "	2010-08-06 19:47:15	1281140000.0	resolved fixed	6b35ea4	1282150000.0	tests/multiIncremental/pr322039/base/src/p/Azpect.java tests/multiIncremental/pr322039/base/src/q2/Code.java tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java
322832	early field resolution leading to problems for ITDs when declare parents in use	I have a type that is being used where a generic is being expected.  That generic specifies an upper bound.  The type only obeys the upper bound once a declare parents has applied to it.I have an intertype declaration (a field).  When the ITD is applied we do some work to see if it clashes with existing fields.  This causes existing fields to be resolved.  If this resolution triggers a bounds check for the declare parents affected type before the declare parents has applied, a problem will be raised.Basically if the target of the declare is processed before the intertype then we are ok, but that is luck based.We should do the declare parents first (and declare annotation) and then do intertype declarations (since they may trigger this extra resolution). fix committed. 	2010-08-16 15:33:00	1281990000.0	resolved fixed	16adee6	1281990000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java
321641	No way to exclude Proxool classes although excluded from AOP. Causing Veryfy error.	"I believe the issue is related to new modifications regarding fast exclusion patterns.While before patterns such us ""*..*CGLIB*"" where matching for classes like com/mycompany/framework/service/MessageService$$EnhancerByCGLIB$$6dd4e683Now the *..*CGLIB* patterns are stored in the list excludeStarDotDotStar and the next piece of code is executed:		if (!excludeStarDotDotStar.isEmpty()) {			for (String namePiece : excludeStarDotDotStar) {				int index = fastClassName.lastIndexOf('.');				if (fastClassName.indexOf(namePiece, index + 1) != -1) {					return false;				}			}		}where fastClassName = com.mycompany.framework.service.MessageService..EnhancerByCGLIB..6dd4e683as init previously in the line:String fastClassName = className.replace('/', '.').replace('$', '.');Which in turns makes the excludeStarDotDotStar method not to work as expected for this kind of patterns because GCGLIB is searched at string 6dd4e683, where never is, so it always return true. In order to avoid this, I suggest just changing the fastClassName at the very beginning avoiding '$' substituion and just after the excludeStarDotDotStar fast pattern check is performed, substitute the '$' character by '.' to allow the rest of code work smoothly.I have created a diff patch with this suggestion already coded.Feedback is welcome.Thank you. a shame the patch is not against my repo, it does make it messier to apply.  I also like to have a test with each patch to stop any future regressions.I've created a tiny test and applied the change. thanks!! Build Identifier: 20100218-1602For aspectJ 1.6.7 the setup works, however exactly the same setup but changing the aspectJ version to 1.6.8 or 1.6.9 derive to the same error: a piece of code excluded from the aop.xml is woven causing a Verify Error.We are using Proxool, proxy setup which in fact uses CGLIB to create a EnhancerProxy class. In order to avoid VerifyError exceptions the Proxool classes are excluded from aop.xml exactly in the same way the CGLIB workarround is commented in the aspectJ FAQ:		<exclude within=""*..*Proxool*""/>This is the error we got when we upgrade our 1.6.7 aspejctweaver.jar to 1.6.8. The same is got when using 1.6.9:jvm 3    | 2010/08/03 16:42:53 | java.lang.VerifyError: (class: oracle/jdbc/internal/OracleConnection$$EnhancerByProxool$$7f6320a8, method: getTdoCState signature: (Ljava/lang/String;Ljava/lang/String;)J) Inconsistent stack height 1 != 0jvm 3    | 2010/08/03 16:42:53 | 	at java.lang.Class.getDeclaredMethods0(Native Method)jvm 3    | 2010/08/03 16:42:53 | 	at java.lang.Class.privateGetDeclaredMethods(Class.java:2427)jvm 3    | 2010/08/03 16:42:53 | 	at java.lang.Class.getDeclaredMethod(Class.java:1935)jvm 3    | 2010/08/03 16:42:53 | 	at org.logicalcobwebs.cglib.proxy.Enhancer.getCallbacksSetter(Enhancer.java:627)jvm 3    | 2010/08/03 16:42:53 | 	at org.logicalcobwebs.cglib.proxy.Enhancer.setCallbacksHelper(Enhancer.java:615)jvm 3    | 2010/08/03 16:42:53 | 	at org.logicalcobwebs.cglib.proxy.Enhancer.setThreadCallbacks(Enhancer.java:609)jvm 3    | 2010/08/03 16:42:53 | 	at org.logicalcobwebs.cglib.proxy.Enhancer.createUsingReflection(Enhancer.java:631)jvm 3    | 2010/08/03 16:42:53 | 	at org.logicalcobwebs.cglib.proxy.Enhancer.firstInstance(Enhancer.java:538)jvm 3    | 2010/08/03 16:42:53 | 	at org.logicalcobwebs.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:225)jvm 3    | 2010/08/03 16:42:53 | 	at org.logicalcobwebs.cglib.proxy.Enhancer.createHelper(Enhancer.java:377)jvm 3    | 2010/08/03 16:42:53 | 	at org.logicalcobwebs.cglib.proxy.Enhancer.create(Enhancer.java:285)....As far as the Verify Error is got while deploying one of the applications that run on the serve we are no able to use the new versions of aspectJ because the application is not properly started up.Thank you very much in advance,Best regards.Reproducible: AlwaysSteps to Reproduce:1.Exclude Proxool classes from aop.xml using aspectj 1.6.7. It works2.Upgrade to 1.6.8: it does not work.3.Upgrade to 1.6.9: it does not work. Created attachment 175805This is the unique aop.xml we are using Created attachment 176202Proposed Patch "	2010-08-03 14:05:08	1280860000.0	resolved fixed	85fd25d	1281450000.0	loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java loadtime/testsrc/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptorTest.java loadtime/testsrc/testdata/MessageService$$EnhancerByCGLIB$$6dd4e683.java
318397	Caching in EclipseSourceType is too aggressive	In fixing a recent Roo related issue (where annotations are resolved too early, before declare parents are done) a cache was introduced into EclipseSourceType (see ensureAnnotationTypesResolved()).  The cache needs to be cleared if the set of annotation declarations changes - this can occur even after parsing because declare annotation can change them. was fixed in 1.6.9 	2010-06-29 20:15:57	1277860000.0	resolved fixed	fe049ea	1277860000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java
317743	import handling and type lookup issues	"Raised by Peter Melnikov on the mailing list.Two problems: 1) the binding scope being used for annotation style aspects accumulates lots of duplicate import prefixes in the SimpleScope object.2) SimpleScope.lookupType tries the prefixes even if the type is already fully qualified. The combination of these issues causes a terrible mess.  Lots of class lookup failures.  Since the type cannot be 'partially qualified' it is silly to use the prefixes if the type is fully qualified. Created attachment 172545Classfiles patching this issueThis jar includes two classes that replace those in an AspectJ 1.6.9 weaver.to apply it, save it alongside aspectjweaver.jar thenjar -xvf pr317743.jarjar -uvf aspectjweaver.jar orgthis will patch BindingScope and SimpleScope in the jar. I have applied the path and it works for me. Log file is now 2.5MB vs 22 MB before, and overall weaving speed has increased a lot. No more ClassNotFoundException error messages.Before, I got your patch, I changed slightly the SimpleScope.java:public UnresolvedType lookupType(String name, IHasPosition location) {ResolvedType resolvedType = world.resolve(UnresolvedType.forName(name), true);        if(resolvedType.isMissing()) {            for (int i = 0; i < importedNames.length; i++) {                String importedName = importedNames[i];                // // make sure we're matching against the                // // type name rather than part of it                // if (importedName.endsWith(""."" + name)) {                if (importedName.endsWith(name)) {                    return world.resolve(importedName);                }            }            for (int i = 0; i < importedPrefixes.length; i++) {                String importedPrefix = importedPrefixes[i];                ResolvedType tryType = world.resolve(UnresolvedType.forName(importedPrefix + name), true);                if (!tryType.isMissing()) {                    return tryType;                }            }        }        return resolvedType;  }This worked for me too. But it was just a quick fix. Just found single exception:SEVERE: Unable to find class 'java.lang.void' in repositoryjava.lang.ClassNotFoundException: java.lang.void not found - unable to determine URL	at org.aspectj.apache.bcel.util.ClassLoaderRepository.loadClass(ClassLoaderRepository.java:292)	at org.aspectj.weaver.bcel.BcelWorld.lookupJavaClass(BcelWorld.java:390)	at org.aspectj.weaver.bcel.BcelWorld.resolveDelegate(BcelWorld.java:373)	at org.aspectj.weaver.ltw.LTWWorld.resolveDelegate(LTWWorld.java:111)	at org.aspectj.weaver.World.resolveToReferenceType(World.java:452)	at org.aspectj.weaver.World.resolve(World.java:298)	at org.aspectj.weaver.patterns.SimpleScope.lookupType(SimpleScope.java:64)	at org.aspectj.weaver.BindingScope.lookupType(BindingScope.java:69)I'am pretty sure it is because I have following pointcut declaration (and it is the only which has void as return type parameter):"" || execution(public void net.mansion.redirect.impl.engine.web.RedirectProcessorServlet.doGet(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse))"" thanks for testing that so quickly.I'll probably refine it a bit and see if I can squeeze it into 1.6.9 final release.  I just have to think through any cases that might be adversely affected.oh and i'll fix the void case too. change should make it into 1.6.9.RC2, available this week 1.6.9.RC2 is now available for download if you want to try it out. <Pyinson Data Over Head> <Pyinson Data Over Head> "	2010-06-23 15:28:27	1277320000.0	resolved fixed	767bb85	1277770000.0	org.aspectj.matcher/src/org/aspectj/weaver/BindingScope.java org.aspectj.matcher/src/org/aspectj/weaver/patterns/IScope.java org.aspectj.matcher/src/org/aspectj/weaver/patterns/SimpleScope.java org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildTypePattern.java org.aspectj.matcher/testsrc/org/aspectj/weaver/patterns/PatternsTests.java org.aspectj.matcher/testsrc/org/aspectj/weaver/patterns/SimpleScopeTests.java org.aspectj.matcher/testsrc/org/aspectj/weaver/patterns/TypePatternTestCase.java
317139	NullPointerException during weaving	Created attachment 172090AspectJ compile logUsing the Maven plugin to compile aspects into my code I get the following exception:…---- Exception Information ---java.lang.NullPointerException        at org.aspectj.weaver.bcel.BcelObjectType.ensureGenericSignatureUnpacked(BcelObjectType.java:823)        at org.aspectj.weaver.bcel.BcelObjectType.getSuperclass(BcelObjectType.java:228)        at org.aspectj.weaver.ReferenceType.getSuperclass(ReferenceType.java:905)        at org.aspectj.weaver.bcel.AtAjAttributes.handleAspectAnnotation(AtAjAttributes.java:490)        at org.aspectj.weaver.bcel.AtAjAttributes.readAj5ClassAttributes(AtAjAttributes.java:234)…I have attached the complete log as attachment. Is there any way you could share with me the project that causes this?I'm nervous about just putting in a guard for the NPE and would rather understand what is leading to the failure.  It appears a raw/parameterized type has forgotten its generic type somehow. Created attachment 172413Project causing the issueIt's perfectly possible that I am messing things up here :). But even in this case I think a more expressive exception would be useful.Attached the project. Running mvn clean test-compile should produce the error log files. thanks for the project.The NPE is occurring (I assert) because the generic type is being used before it has been set.  A particular path is being taken into the generic signature unpacker and it is too early to assume the generic type has been set.  If we guard on null, it looks like the caller will subsequently set the generic type correctly, so that is what I'll do. After building an AspectJ with the proposed change in, I see that the NPE was hiding a real error in the project:[ERROR] BUILD ERROR[INFO] ------------------------------------------------------------------------[INFO] Compiler errors :error at <Unknown>::0 The generic aspect 'org.synyx.hades.domain.auditing.AuditingAdvice' must be declared abstractI'll publish this build today as AspectJ 1.6.9.RC2 	2010-06-17 01:50:24	1276750000.0	resolved fixed	92a52a2	1277770000.0	weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java
314766	NPE when using aop.xml for compile time config	Reported on the list:java.lang.NullPointerExceptionat org.aspectj.weaver.bcel.BcelWorld.isAspectIncluded(BcelWorld.java:942)at org.aspectj.weaver.ShadowMunger.match(ShadowMunger.java:80)at org.aspectj.weaver.Advice.match(Advice.java:106)at org.aspectj.weaver.bcel.BcelAdvice.match(BcelAdvice.java:149)at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:3108)at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2562) Created attachment 170256project exhibiting npe just another case of an advice that wasn't having the declaring type set.  It never used to matter, but it does now if using xml configuration as we use the declaring type to see if the aspect has been included in any aop.xml.In this case the advice was the entry point to cflow: AdviceKind.CflowEntryfix in Advice.makeCflowEntry to set the declaring type. 	2010-05-27 15:47:56	1274990000.0	resolved fixed	0e5ecd3	1274990000.0	org.aspectj.matcher/src/org/aspectj/weaver/Advice.java
314130	[plan] [ltw] [hcr] LTW, Reweaving and Hot Code Replace changes reflected every two saves of files	"For the record:Finally I tested this with the 1.6.9.RC1 version and I can confirm that now works fine in every save. Also now works too with -Xset:overWeaving=trueGreat work!Thanks Andy Build Identifier: AspectJ 1.6.9.M2 (Eclipse 3.5.1 Build ID: 20090920-1017)A full description of the bug is in the AspectJ-Users mail list:http://dev.eclipse.org/mhonarc/lists/aspectj-users/msg12114.htmlWhile debugging if I change the content of a method (ex. the text of a System.out) and save the file, it wouldn't reflected. But if I save the save file again, this time the changes are reflected. And it repeats on cycles of two saves.The rare is that when I save and the changes are not reflected, in log appears the next two lines and when I save the file and changes are reflected this lines are not showed:[AppClassLoader@2bbd86] info processing reweavable type test.weaved.Test: test\weaved\Test.java[AppClassLoader@2bbd86] info successfully verified type test.aspects.TestAspect exists.  Originates from test\aspects\TestAspect.javaThis lines comes from the method processReweavableStateIfPresent(String, BcelObjectType) on the class org.aspectj.weaver.bcel.BcelWeaverSetting -Xset:overWeaving=true was worst because every time that I save the file that is aspected I get this message from Eclipse in a popup: ""Hot code replace failed - Scheme change not implemented"" and the changes are never reflected, neither in the first save nor in the second save.My environment is:Windows XP SP3 32 bitsSun Java 1.6.0 Update 19 JDKEclipse 3.5.1 Build ID: 20090920-1017AspectJ 1.6.9 M2 (the same occurs with 1.6.8)Project: A clean new basis java project that only has this test and AspectJWeaver options: -Xreweavable -verbose -showWeaveInfo -debug (and also -Xset:overWeaving=true in some tests)Using: -javaagent:aspectjweaver-1.6.9.M2.jarI will attach the test project that I used to isolate and reproduce this bug.Reproducible: AlwaysSteps to Reproduce:1. Import the attached project into Eclipse2. Run the project with the Main.launch that is in the project root.3. Modify the method print() in the class test.weaved.Test (ex. uncomment a line)4. See the console log. The changes are not reflected in the behavior.5. Modify again the method print() in the class test.weaved.Test (ex. uncomment another line)6. See the console log. Now the changes are reflected in the behavior.7. The same occurs whatever you change (obviously with the limits of the Hot Code Replace imposed by the JDK) Created attachment 169687The Eclipse test project that shows the bug I'll try out the test project tomorrow.hotswap with ltw is still not 100% supported - up until recently it was completely banned but a couple of releases ago I removed the restrictions as people had been trying out a patch and with it 'enabled' they seemed to find it was OK (not sure what kinds of change they were making to the file though) - we have no testcases in AspectJ for it, so regressions are certainly possible.overweaving certainly shouldn't cause a class schema change - so that is interesting. as suspected, it was just showing that we are limping along with our hotswap support.  The weaver is not designed to see something for a second time.  I've patched it up to address this case but I'd imagine other scenarios will be lurking.I don't have a test harness to build a test for a hotswap type case but I've just tried out the fix and it does address the problem you describe. "	2010-05-24 11:53:33	1274720000.0	resolved fixed	cf0ee0c	1274910000.0	weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java weaver/src/org/aspectj/weaver/bcel/BcelWorld.java weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java
314365	pointcut rewriter can have issues for large hashcode values	AJDT uses a pointcut like this:(persingleton(org.eclipse.ajdt.internal.ui.ras.UIFFDC) && ((handler(java.lang.Throwable+) && args(arg1)) && ((within(org.eclipse.ajdt..*) && (!within(org.eclipse.ajdt.internal.ui.lazystart..*) && (!within(org.eclipse.ajdt.internal.ui.dialogs.OpenTypeSelectionDialog2) && !(within(org.eclipse.ajdt.internal.ui.editor.AspectJBreakpointRulerAction) && handler(org.eclipse.jface.text.BadLocationException))))) && (!(within(org.eclipse.ajdt.core.ras.FFDC+) || handler(org.eclipse.core.runtime.OperationCanceledException)) && !this(java.lang.Object)))))After the pointcut rewriter has chewed on it, it is reduced to a normal form.  This is meant to be a stable form such that further rewrites of it would not change it.  This turned out not to be the case.  The hashcodes for some of the components were quite large and manifested as negative integers.  The arithmetic in the comparator for the elements would have a problem and give unhelpful responses.  For example, if the elements were C,B,A it might rewrite them to A,B,C but on a subsequent rewrite it would realise that C was less than A, giving B,C,A.  Whether it went wrong was dependent on the order in which the elements were collected by the rewriter.This is now fixed.  It impacts incremental compilation sometimes as two pointcuts that should be identical look different because one has been through the rewritter more times than the other... tests and fix committed 	2010-05-25 17:32:47	1274820000.0	resolved fixed	1e28b92	1274830000.0	org.aspectj.matcher/src/org/aspectj/weaver/patterns/PointcutEvaluationExpenseComparator.java org.aspectj.matcher/testsrc/org/aspectj/weaver/patterns/PointcutRewriterTest.java
311910	AspectJ internal Compiler Error	Stack Trace:java.lang.NullPointerExceptionat org.aspectj.weaver.model.AsmRelationshipProvider.createSourceLocation(AsmRelationshipProvider.java:303)at org.aspectj.weaver.model.AsmRelationshipProvider.addPointcuts(AsmRelationshipProvider.java:580)at org.aspectj.weaver.model.AsmRelationshipProvider.createHierarchyForBinaryAspect(AsmRelationshipProvider.java:562)at org.aspectj.weaver.model.AsmRelationshipProvider.addAdvisedRelationship(AsmRelations ...       ARETURN  end public Object run(Object[])end public class com.cerner.isis.biz.services.asclepius.patient.PatientManagerImplTest$AjcClosure3Happening when weaving a jar with a aspect jar. i'd need more to go on to do a proper fix (and work out why the aspect is running a null location).  I'd need the jar and the aspect.  For now I've just committed a guard. 	2010-05-06 11:22:11	1273160000.0	resolved fixed	3be69a2	1273160000.0	weaver/src/org/aspectj/weaver/model/AsmRelationshipProvider.java
310144	java.lang.RuntimeException at AsmManager.java:1143	Build Identifier: Eclipse AspectJ Development Tools  Version: 2.0.3.e35x-20100419-1200 AspectJ version: 1.6.9.20100416110000java.lang.RuntimeExceptionat org.aspectj.asm.AsmManager.removeSingleNode(AsmManager.java:1143)at org.aspectj.asm.AsmManager.removeRelationshipsTargettingThisType(AsmManager.java:798)at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1173)at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.weaveQueuedEntries(AjPipeliningCompilerAdapter.java:455)at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter. ...  for handle =xstm/stm<com.argilsoft.xstm.core{TKeyed.java[TKeyed[Visitor?field-set(java.util.ArrayList com.argilsoft.xstm.core.Visitor._continueStack)Reproducible: SometimesSteps to Reproduce:Random exception popup in Eclipse it is a problem with attempting to remove a node from the structuremodel on an incremental build.  wonder why it can't be found... hmmm as being unable to delete something isn't the end of the world (it must already have been removed), I'm demoting this from an exception to a message (the message will just go to the console).  This means compilation won't be interrupted.  If there turn out to be downstream issues due to deletion failing, we can revisit this problem. 	2010-04-22 12:18:39	1271950000.0	resolved fixed	728ecb8	1272570000.0	asm/src/org/aspectj/asm/AsmManager.java
310704	Bug in ProgramElement.getCorrespondingType()	"Here is the code for the method:	public String getCorrespondingType(boolean getFullyQualifiedType) {		String returnType = (String) kvpairs.get(""returnType"");		if (returnType == null)			returnType = """";		if (getFullyQualifiedType) {			return returnType;		}		int index = returnType.lastIndexOf(""."");		if (index != -1) {			return returnType.substring(index);		}		return returnType;	}the line:return returnType.substring(index);should be using 'index+1' done.  that model could really do with ripping out and replacing, I think i'll add a work item to the list. "	2010-04-27 15:59:36	1272400000.0	resolved fixed	a502da8	1272420000.0	asm/src/org/aspectj/asm/internal/ProgramElement.java
309402	Changes to Main.java	In order to get the AJDT ant integration working, we need a small change to Main.java.We need to be able to pass in a custom org.aspectj.bridge.ICommand object.  Currently, the ICommand object is created via reflection.Here is my suggestion:1. augment the ICommand local variable to being a field2. add a setter for this field3. change this:ICommand command = ReflectionFactory.makeCommand(commandName, holder);to this:if (command != null)  command = ReflectionFactory.makeCommand(commandName, holder); done Yep.  These changes are working for me as expected.  Thanks. 	2010-04-15 19:09:23	1271370000.0	verified fixed	b21eb05	1271430000.0	org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java
308386	NPE when hasfield evaluating with annotations and there is an unresolved import	hasfield/hasmethod can cause early matching - before the weaving process kicks in properly.  For a 'normal' compile error, like an unresolvable import, the error is put out before the weaving process kicks off.  However hasfield/hasmethod happening early causes an NPE to occur before the error is put out.A guard for the NPE (which occurs in EclipseResolvedMember.getAnnotationTypes()) addresses this problem and allows the real error to come out. guard committed 	2010-04-07 15:15:51	1270670000.0	resolved fixed	94d0a4e	1270670000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseResolvedMember.java
291206	Allow declare error & declare warning to support type expressions	User-Agent:       Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.9.1.3) Gecko/20090824 Firefox/3.5.3 (.NET CLR 3.5.30729)Build Identifier: declare error & declare warning currently only support pointcut expressions; it would be nice if they also supported type expressions.See http://www.nabble.com/declare-error---type-pattern--ts25619498.html#a25619498 for mailing list discussion.Reproducible: Always needs some thought if I'm going to do anything on this, now would be the time as 1.6.9 changes the serialized form (due to the non mangling private itd field change) - and it is likely work for this feature would also need a serialized form change. done under bug 292264 	2009-10-02 11:01:11	1254500000.0	resolved fixed	9241e2e	1270510000.0	tests/bugs169/pr291206/One.java tests/bugs169/pr291206/Three.java tests/bugs169/pr291206/Two.java
308093	incremental build problem when mixing up ITDs and declare parents	reported by Rod Johnson.  He had a sophisticated aspect doing a mix of ITDs and declare parents.  On doing an incremental build he was receiving errors that looked like the declare parents hadn't applied on the secondary build.What was actually happening is that when a class file was brought in as a BinaryTypeBinding, the existing World representation wasn't being cleaned up properly.  Without the cleanup the declare parents thought it was still in effect, but it was not.  With proper cleanup the declare parents applies on the secondary build and all is well. Change is in AjLookupEnviroment.weaveInterTypeDeclarations where the onType.clearInterTypeMungers() must be paired with an onType.ensureConsistent() call. fix committed 	2010-04-05 14:16:02	1270490000.0	resolved fixed	4b43dc6	1270490000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java
305788	Exception was thrown when I saved a file in Eclipse	"Build Identifier: SpringSource STS 2.3.1java.util.ConcurrentModificationExceptionat java.util.HashMap$HashIterator.nextEntry(HashMap.java:793)at java.util.HashMap$KeyIterator.next(HashMap.java:828)at org.aspectj.asm.internal.AspectJElementHierarchy.updateHandleMap(AspectJElementHierarchy.java:594)at org.aspectj.asm.AsmManager.removeStructureModelForFiles(AsmManager.java:564)at org.aspectj.asm.AsmManager.processDelta(AsmManager.java:639)at org.aspectj.ajdt.internal.core ... un(AutoBuildJob.java:238)at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)Compile error: ConcurrentModificationException thrown: nullReproducible: AlwaysSteps to Reproduce:1.Generate an abstract class using Spring roo2. Edit that file within Eclipse/STS to add JPA annotations3.Click on the save icon to save the file - Exceptions box pops up Created attachment 161971The source file I had been editiing and then saved it. Created attachment 161972This is the one of several .aj files that most likely was in conflict.Note that I never attempted to change any of the .aj files, but did view them (without changing them.) I am getting the same exception in STS 2.3.1 and on Eclipse+AJDT (see link below). Never happened using STS 2.2.1. Tried to use jps + jstack as suggested by Andy Clement on this but with no ""success"" as of now.Right now, I am working with no problems for two hours, but then again, Roo did not have to change anything during that time. As described in the post linked to below, shortly after this exception is thrown the IDE gets stuck building the workspace while saving a file. I will try to catch that with jstack and post anything helpful as to where the problem lies.http://forum.springsource.org/showthread.php?t=84262 Created attachment 162037jstack Thread Dump on STS/Eclipse lock-upThis is the jstack thread dump while STS is locked ""Building workspace"" / ""Invoking 'AspectJ Builder'"". I have to kill it to get out of it.Sorry if I got things mixed up. My post in the SpringSource forum wasn't actually about a ConcurrentModificationException but a NullPointerException. However, the behaviour is the same and I am getting the ConcurrentModificationException now plus the lock-up when Roo is changing stuff and the workspace is rebuilt.Hope this helps. I think this is a call in from AJDT to findElementForHandleOrCreate() that occurs at the same time as the updateHandleMap() code is running.  Outside of the IDE AspectJ is purely single threaded and nothing can damage the collection whilst it is being iterated over.  But in Eclipse some jobs against a project run asynchronously alongside the build and if any happen to call that findElementForHandleOrCreate() then the collection will be modified whilst already in use. I think we can address it with a bit of synchronization that will stop the AJDT UI job interfering with the compiler.  I think I'll synchronize on the AspectJElementHierarchy instance. Created attachment 162097Modification for ajde.jarThis attachment replaces a class in the ajde.jar - which is in the org.aspectj.ajde plugin.  This will add synchronization around the typeMap and handleMap collections to prevent UI interference.Apply by going into the eclipse\plugs\org.aspectj.ajde_XXXX plugin (where XXXX is the most recent one you have installed).  Then backup the ajde.jar in there and then (whilst is eclipse is not running) apply this patch:jar -xvf patch.zipjar -uvf ajde.jar orgthis will replace one class in ajde.jar.  Then restart eclipse.If anyone experiencing the exception here could try that out and let me know the outcome, that would be great. Great, applied the patch and will be back with feedback. Hi Andy, up to now I did not come across any more Exceptions or Freezes, so it seems that your patch solved the underlying problem. This helped me a lot, thanks. thanks for getting back to me.  The patch is now committed into HEAD. I encountered the same problem in a project with Roo-created ITDs. Roo was not running at the time. I'll try the patch provided in comment 7. "	2010-03-13 20:52:59	1268530000.0	resolved fixed	749078d	1269350000.0	asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java
298786	suspected problem with handling of multiple aop.xml files	"On my blog, William Louth reported:---I should also point out that this AND'ing only appears across aop.xml files within them the normal logic evaluation seem to still apply. For exampleIf one aop.xml file has an include clause as within=""java.sql.Connection+""within=""java.sql.Statement+""and another aop.xml file has an include clause aswithin=""*""Then the complete class set visibility is narrowed towithin=""java.sql.Connection+""within=""java.sql.Statement+""Any class presented to the weaver must be included in all aop.xml files.--- However, I am having no success trying to recreate the issue.I've two aop.xml files, one like this:<aspectj>  <aspects>   <aspect name=""com.one.Aspect""/>  </aspects>  <weaver>    <include within=""com.one.A+""/>  </weaver></aspectj>and one like this:<aspectj>  <aspects>   <aspect name=""com.two.Aspect""/>  </aspects>  <weaver>    <include within=""*""/>  </weaver></aspectj>and my type com.two.A is woven just fine (which would only be woven if the include='*"" is being used).I will ask William what is different between what I've done and what he is doing. Ok, I now have a test harness in which I can test the merging.  XML files are represented as Definition objects.  Here is my case so far:Definition aopOne = new Definition();aopOne.getIncludePatterns().add(""*"");Definition aopTwo = new Definition();aopTwo.getIncludePatterns().add(""java.sql.Connection+"");aopTwo.getIncludePatterns().add(""java.sql.Statement+"");TestClassLoaderWeavingAdaptor adaptor = getAdaptor(aopOne, aopTwo);checkAccept(adaptor, ""testdata.Apples"");checkAccept(adaptor, ""testdata.MySqlStatement"");// test the other orderadaptor = getAdaptor(aopTwo, aopOne);checkAccept(adaptor, ""testdata.Apples"");checkAccept(adaptor, ""testdata.MySqlStatement"");I'm trying to configure the patterns as similar to Williams' as I can, and that is passing OK. <Pyinson Data Over Head> Thanks for getting back to me.  You didn't mention which parts of that output you were or were not expecting.  Is it the lines like this?debug not weaving '$java.sql.PreparedStatement$ProbeAspect' Oh i see a ""debug not weaving 'aspectj167.HelloWorld'""I guess you weren't expecting that either. <Pyinson Data Over Head> <Pyinson Data Over Head> Actually there was one other aop.xml file on the path which is missing from the test case. <aspectj>  <weaver>    <exclude within=""com.jinspired..*""/>    <exclude within=""$com.jinspired..*""/>    <exclude within=""com.jinspired.jxinsight.server..*+""/>  </weaver></aspectj>If I remove this then everything works fine but of course I do not want to. very interesting, thanks for continuing to dig for me!  I didn't realise youwere using annotation style aspects and that may make a difference.In that recent comment (comment 8) you took the two files and ran them (at the top of the comment) - where you say ""Running this we get:"" - what was your original single aop.xml file? Before you added the other one. Now that you've given me the exclusions, I do have a testcase that is unexpectedly failing.  Looking at the cause now. (In reply to comment #11)> Now that you've given me the exclusions, I do have a testcase that is> unexpectedly failing.  Looking at the cause now.I have now narrowed it down to the expression that causes the problem. Thefollowing aop.xml works with the last exclude commented out.<aspectj>  <weaver>    <exclude within=""com.jinspired..*""/>    <exclude within=""$com.jinspired..*""/>    <!--<exclude within=""com.jinspired.jxinsight.server..*+""/>-->  </weaver></aspectj>Why is this exclude that has always been present in our files now causing somuch grief.<exclude within=""com.jinspired.jxinsight.server..*+""/> It appears my first hunch was correct.  From the blog: ""on just a quick look at the code I suspect it may be the lack of consideration for include of '*' in all cases. If the exclude clauses don't match all the optimized patterns, the include of '*' may be ignored.""This is what is happening.  Your third exclude pattern ""com.jinspired.jxinsight.server..*+"" does not match an optimization pattern  whilst the other two do match an optimization pattern.Here 'optimization pattern' can be read as whether something can be determined to be a match purely by string comparison.  For your first two excludes we just have to look at the name, for the third we have to open up the type and look at the hierarchy.When one of the exclude clauses cannot be optimized, a different codepath is taken in the new acceptance logic.  Unfortunately all the AspectJ tests happen to have been using patterns that got optimized or where acceptance was not dependent on one of these types of include: (star) ""*"", (startswith) ""com.foo..*"" or (exact) ""com.foo.Bar"".  You don't need two aop.xml files to cause this situation, you just need an non-optimizable exclude and two includes, one of which can be optimized and one which can't.. phew.  Here is an aop.xml file that fits that description:<aspectj>  <aspects>   <aspect name=""com.one.Aspect""/>  </aspects>  <weaver options=""-debug"">    <include within=""*""/>    <include within=""*wibble*""/>    <exclude within=""*Funk*y*""/>  </weaver></aspectj>The include=""*"" can be optimized.  The include=""*wibble*"" is not currently optimized (it could be, but it isn't right now).  The exclude=""*Funk*y*"" is not optimized.With that configuration any types that the include=""*"" would have accepted are not accepted. William - if I get a new build out, can you try it for me in your scenario? (In reply to comment #14)> William - if I get a new build out, can you try it for me in your scenario?YES. Please. Created attachment 155294patch for aspectjweaver.jarAs a build will take a few hours, if you want to try it sooner I've attached replacement .class files for two entries in aspectjweaver.jar.  To apply this, go to where your weaver jar is and:jar -xvf clwapatch.zipjar -uvf aspectjweaver.jar orgthat will overwrite the two classes in the existing weaver.This addresses this particular include/exclude problem, but due to your use of annotation style aspects and concrete-aspects in the aop.xml, something else may be lurking... hopefully your tests will confirm either way. Thanks Andy. Our test applications are now running within comparable levels of instrumentation & measurement compared with the 1.6.6 build. This fixes things for us. Will you publish an official update to 1.6.7 this week? I would love to get it distributed with our next software update scheduled for next week.Thanks again and I really appreciate the fast and efficient handling of this issue. Hi William - thanks for testing that so quickly and helping me resolve the issue.  Yes, I think there will be a 1.6.7a imminently.  I've some tests in place now to prevent a regression like this again.If you have any feedback on whether you notice performance improvements/degradation in moving to 1.6.7 (now that it actually works!), I'd be very interested.cheersAndy fix committed - will build 1.6.7a if nothing else comes up overnight tonight. Hi, I am experiencing an issue certainly related to #298786, if not #298786 itself. I have just upgraded from 1.6.2 to 1.6.8 to take advantage of the @annotation performance improvements in LTW via Spring 2.5.4, and have found that as of 1.6.7 my <weaver/> configuration has ceased to work.I'm guessing the reason this bug was left open post-1.6.8 is that there is a suspicion it is still lurking out there.My setup is as follows:* ATracer is an @Aspect on A* BTracer is an @Aspect on B* CTracer1, CTracer2, and CTracer3 are @Aspects on C* DTracer is an @Aspect on DMy @Aspects typically use @annotation and method-execution pointcuts.My aop.xml in META-INF is as follows:<aspectj>    <weaver options=""-debug -verbose -showWeaveInfo -XmessageHandlerClass:org.springframework.aop.aspectj.AspectJWeaverMessageHandler"">          <include within=""com.lmax.A""/>          <include within=""com.lmax.B""/>          <include within=""com.lmax.C""/>          <include within=""com.lmax.D""/>    </weaver>           <aspects>             <aspect name=""com.lmax.ATracer""/>        <aspect name=""com.lmax.BTracer""/>         <aspect name=""com.lmax.CTracer1""/>        <aspect name=""com.lmax.CTracer2""/>        <aspect name=""com.lmax.CTracer3""/>        <aspect name=""com.lmax.DTracer3""/>    </aspects></aspectj>I've defined my aop.xml to be as tight as possible and minimise classloader scanning. However, the above is broken as of 1.6.7. The workaround for me is to replace my <include/> entries with <include within=""*""/>, which is obviously not ideal. Is my <include/> pattern badly defined as of 1.6.7 or have I triggered the bug? I presume the patch aspectjweaver.jar is by default included in 1.6.8. I should also say that the only other aop.xml in my classpath is the aop.xml in spring-agent.jar for @Configurable, etc. actually this bug should be closed now.Don't use 1.6.7 - that was a dud release for load time weaving.  1.6.7 was the point where all aop.xml handling was rewritten, and 1.6.8 addressed the serious regressions that appeared in 1.6.7.You don't say how it doesn't work for you, just that it doesn't work - how is it failing?Can you perhaps try including your aspects in the weaver include section?<aspectj>    <weaver options=""-debug -verbose -showWeaveInfo-XmessageHandlerClass:org.springframework.aop.aspectj.AspectJWeaverMessageHandler"">          <include within=""com.lmax.A""/>          <include within=""com.lmax.B""/>          <include within=""com.lmax.C""/>          <include within=""com.lmax.D""/>          <include within=""com.lmax.ATracer""/>          <include within=""com.lmax.BTracer""/>          <include within=""com.lmax.CTracer1""/>          <include within=""com.lmax.CTracer2""/>          <include within=""com.lmax.CTracer3""/>          <include within=""com.lmax.DTracer3""/>    </weaver>    <aspects>             <aspect name=""com.lmax.ATracer""/>        <aspect name=""com.lmax.BTracer""/>         <aspect name=""com.lmax.CTracer1""/>        <aspect name=""com.lmax.CTracer2""/>        <aspect name=""com.lmax.CTracer3""/>        <aspect name=""com.lmax.DTracer3""/>    </aspects></aspectj> (In reply to comment #22)> actually this bug should be closed now.> > Don't use 1.6.7 - that was a dud release for load time weaving.  1.6.7 was the> point where all aop.xml handling was rewritten, and 1.6.8 addressed the serious> regressions that appeared in 1.6.7.> > You don't say how it doesn't work for you, just that it doesn't work - how is> it failing?> > Can you perhaps try including your aspects in the weaver include section?> > <aspectj>>     <weaver options=""-debug -verbose -showWeaveInfo> -XmessageHandlerClass:org.springframework.aop.aspectj.AspectJWeaverMessageHandler"">>           <include within=""com.lmax.A""/>>           <include within=""com.lmax.B""/>>           <include within=""com.lmax.C""/>>           <include within=""com.lmax.D""/>> >           <include within=""com.lmax.ATracer""/>>           <include within=""com.lmax.BTracer""/>>           <include within=""com.lmax.CTracer1""/>>           <include within=""com.lmax.CTracer2""/>>           <include within=""com.lmax.CTracer3""/>>           <include within=""com.lmax.DTracer3""/>>     </weaver>> >     <aspects>     >         <aspect name=""com.lmax.ATracer""/>>         <aspect name=""com.lmax.BTracer""/>>          <aspect name=""com.lmax.CTracer1""/>>         <aspect name=""com.lmax.CTracer2""/>>         <aspect name=""com.lmax.CTracer3""/>>         <aspect name=""com.lmax.DTracer3""/>>     </aspects>> </aspectj>Hi, that's worked. I'm happy for the bug to be closed, that's what led me down the path of thinking there was still an issue. Thanks very much. you were hit by a side effect of an improvement in the aop handling.It used to be that in addition to including everything you specified, it would automatically include annotation style aspects.  Unfortunately to find these things was not cheap as we'd have to crack open ALL the .class files and look for the @Aspect annotation.  With 1.6.7 I made it more explicit and they had to be listed.Code style aspects don't need to be listed, it is only annotation style because they may not have been 'finished' if they haven't seen a weaver before (if they were just compiled with javac).  We could improve things and when digging through your aspects section, look for annotation style ones and automatically include them...Regardless, I should have made this more clear in the README.glad it worked for you, I hope you see some benefits with 1.6.8 original issue was addressed in 1.6.8 "	2010-01-04 13:27:42	1262630000.0	resolved fixed	a968890	1262650000.0	loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java
297013	Unclosed stream in AjAttribute	Created attachment 153879Patch to close the stream at the end of the method.The getAllBytes() method of org.aspectj.weaver.AjAttribute uses aDataOutputStream to write into a ByteArrayOutputStream. However, the stream isneither closed nor flushed at the end of the method, so that its not sure thatall bytes are actually written (it depends on the implemention ofDataOutputStream). To fix it, one should add a call to close() or flush(). A patch is attached. Created attachment 153880Patch to close the streams at the end of the methods.The same problem exists in getBytes(). I attach a patch that closes both streams. patch committed, thanks! 	2009-12-06 04:06:10	1260090000.0	resolved fixed	28fb861	1260990000.0	org.aspectj.matcher/src/org/aspectj/weaver/AjAttribute.java
120375	Support Load-Time Weaving and HotSwap	"LTW can be used in a development environment when the JVM is run under the debugger. If a class is modified it may be recompiled, submitted to the JVM being debugged and ""HotSwapped"" (see bug 117854). The AspectJ 5 javaagent used for LTW is made aware of this through the JVMTI (http://java.sun.com/j2se/1.5.0/docs/api/java/lang/instrument/ClassFileTransformer.html) but current implementation throws an exception. There may be a limited number of transformations we could safely perfrom especially if the aspects involved only implement dynamic cross-cutting. Hi guys!I saw that the AspectJ5 release is out ... Congratulations and Thanks! :)Now, can you please give this issue a priority? It's really important to us.Thanks!Misha. Some thoughts on how we go about implementing this. Firstly this can't be ""run-time weaving by the back door"". There are several restrictions current production JVMs place on what you can do to class at runtime (see http://dev.eclipse.org/mhonarc/lists/aspectj-users/msg05170.html). This enhancement should be considered an improvement to the support for LTW in a debug environment. Secondly we may need to limit support (at least initially) to include only just classes. Swapping an aspect would require enumerating and reweaving all previously loaded classes unless we can borrow some logic from an improved incremental compilation mechanism. This is because for LTW classes and aspects will typically be built separately and hence not automatically submitted by the debugging JVM. Finally the key problem that I see is to ensure a class is resolved using the new unwoven bytes rather than from disk (or anywhere else) using ClassLoader.getResource() as usual. This may need a new route into the weaving or “forcing” the new bytes into the World.Writing testcases is going to be fun! ""... Secondly we may need to limit support (at least initially)to include only just classes. Swapping an aspect would require enumerating andreweaving all previously loaded classes unless we can borrow some logic from animproved incremental compilation mechanism ... "" 1. I totally agree. This feature looks like ""for debugging only"". It'll make A LOT of programmers happy, because honestly, iajc has terrible performance and a huge memory footprint. It makes windows desktops go crazy, and programmers to make themselves a cup of coffee ;-) 2. ""... from an improved incremental compilation mechanism ..."" - What do you mean? Daemon that monitors and rebuilds only affected classes/aspects? We've tried to work with it, it looked totally unstable ... This is why this feature is so important to us. If you need any help testing stuff on a BIG development project, feel free to use us.Thanks!Misha. Given the amount of investigation required and problems with test this won't make 1.5.3. I want this feature too! :)And if you need some help testing on a large project, please use me too.And btw which version of aspectj may include this feature? Might it be possible as an interim fix to just not throw an exception, but log a warning instead?  This would of course leave it up to the developer to keep track of invalidating their runtime, but in certain scenarios I believe that would be totally possible.As an example case I just started using LTW for Spring transaction advice of Struts Actions. (I can't use their proxy based AOP because Struts MappingDispatchAction.execute(...) does a this.x(...), which bypasses the proxy.) Now during development any class I touch, whether it's advised or not, causes HotSwap to fail.  The requisite server restarts drain enough time that I'm considering punting on LTW.  If I only had to restart when modifying one of my known declared transaction points that would certainly be manageable. Created attachment 98340patch class to change ltw of redefined classesDo you mean this exception? AspectJ5 does not weave hotswapped classI presume you aren't really asking for this to be downgraded to a warning, because it isn't actually thrown, it is just printed out.  From this code: if (classBeingRedefined == null) {   return s_preProcessor.preProcess(className, bytes, loader); } else {   new Exception(""AspectJ5 does not weave hotswapped class ("" + className + "")"").printStackTrace();   return bytes; }I guess you really want is us to have-a-go at weaving rather than returning the unwoven bytes.  The attached patch will attempt to reweave the class when it is redefined - you will see an exception entry printed out about this happening, but it will be woven.  Try it out, you need to patch your aspectjweaver.jar with the class in here:jar -xvf patch.zipjar -uvf aspectjweaver.jar orgdepending on your success, I might commit something. (In reply to comment #7)> I presume you aren't really asking for this to be downgraded to a warning,> because it isn't actually thrown, it is just printed out.  From this code:So it does.  Forgive me for being out of my element here.  I couldn't find a source download for AspectJ, so I just presumed Eclipse's HotSwap failure dialog and the preceding stack trace in the log were closely related.After some digging I've checked out version 1.5.4 of the weaver, weaver5, loader, and loader5 modules, built and attached a source jar for aspectjweaver-1.5.4.jar, and now see exactly where you are referring too.The issue might lie with Spring then.  I'm starting JBoss with:-javaagent:path/to/spring-agent-2.5.3.jarAnd have the following in my Spring config:<context:load-time-weaver aspectj-weaving=""on"" />If I remove that config entry I no longer get the hot swap failures.I figured it was a long shot, but I applied your patch class...[snip]21934 Thu Dec 20 13:44:18 PST 2007 org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.class   241 Tue Apr 29 13:52:18 PDT 2008 org/aspectj/weaver/loadtime/ClassPreProcessor.class 12697 Thu Dec 20 13:44:18 PST 2007 org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.class[/snip]No change, so unfortunately until I can get hot swap working at all with Spring's load time weaver turned on I can't provide feedback on your patch.  My thanks for such a quick reply however! ok - I'll ask some spring guys, watch this space :) Ian,What happens if you try -javaagent::path/to/aspectjweaver.jar (and remove <context:load-time-weaver aspectj-weaving=""on"" /> as it is no longer needed)? They both use basically the same underlying machinery, so any change in hotswap behavior should tell us something.-Ramnivas Created attachment 100035Patch for 1.6 level weaver jarnew version of patch, that last one was rubbish :) I migrated from the Spring 2.5.3 and spring-agent with AspectJ 1.5.4 to the Spring 2.5.4 with the spring-tomcat-weaver(In reply to comment #10)> Ian,> > What happens if you try -javaagent::path/to/aspectjweaver.jar (and remove> <context:load-time-weaver aspectj-weaving=""on"" /> as it is no longer needed)?> They both use basically the same underlying machinery, so any change in hotswap> behavior should tell us something.> > -RamnivasHaven't had a chance to try this yet.  I switched to Spring's TomcatInstrumentableClassLoader.  Hot swap is working now for the usual non-API related changes.  Not getting the warning message from ClassPreProcessorAgentAdapter, and that makes sense as a quick scan of Spring's source suggests it's not used.  What's not clear is whether classes swapped by TomcatInstrumentableClassLoader are being rewoven, but that seems a question for the Spring folks.So my highly uninformed guess is that the outright failure of HotSwap is unrelated to ""AspectJ5 does not weave..."", and is a higher up problem with the Spring Agent.  If I can get a chance to build an environment with the AspectJ weaver agent and the ClassPreProcessorAgentAdapter patch I'll follow up. (In reply to comment #12)> I migrated from the Spring 2.5.3 and spring-agent with AspectJ 1.5.4 to the> Spring 2.5.4 with the spring-tomcat-weaver(In reply to comment #10)Ignore that half-sentence at the top of my last comment.  It's a fragment from a previous comment on another bug.  Weird.  Hello,I installed the patch, but I still sometimes get the message ""Hot code replacement failed. Timeout occured while waiting for packet XXXX"". The message appears randomly, from time to time. I used the ""showWeaveInfo"" option in the aop.xml file and the join points displayed are the same when the error occurs and when it doesn't. Also, I turned dump on and watched the classes which were swapped. In both cases, they are the same. Finally, I tried to see if the new classes were really loaded (by choosing to continue and not restart Tomcat in the message)...and they were, as the functionality was changed.So is this just a harmless message? And when does it appear? And why?Thank you!Marius Well the timeout message is not from AspectJ.  I can imagine there are JVMTI timeouts for waiting on code to be transformed, but I can't find much information on that message or how to increase the timeout.  Maybe we would need to include a native agent rather than a java one to specify a timeout value but I don't want to go down that route until I know that it would make a difference to this problem. Created attachment 116501ajcore dumpBy applying the patch to AspectJ5 development build from 2008-10-29 I can hotswap weaved class.But if I want to hotswap the aspect itself, I am getting exception which is in the attached file.With this patch being not officially included in AspectJ5 I can't unfortunately use it for development and so I must revert back to Spring AOP proxying for now. downloaded the patch, and it seems to work just fine, please advise when patch is in regular build get this into 1.6.7 I just committed the patch into HEAD for this.  AspectJ 1.6.7 builds after today will attempt reweaving.When it occurs, AspectJ will (currently) produce an INFO message:""INFO: (Enh120375):  AspectJ attempting reweave of '""+className+""'""this is purely informational but if things subsequently go pear shaped, it will be a clue as to why.  After a while, if we are confident in reweaving, I will remove the message. patch is in and not aware of any further issues here right now. no more to do here. "	2005-12-12 10:43:11	1134400000.0	resolved fixed	19355dd	1258660000.0	loadtime5/java5-src/org/aspectj/weaver/loadtime/ClassPreProcessorAgentAdapter.java
293457	NPE on multiple declare @methods	"raised on the list:> java.lang.NullPointerException> at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.visit(AsmHierarchyBuilder.java:548)> at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:214)> at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1246)> at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(Compilatio ... oBuildJob.run(AutoBuildJob.java:238)> at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)>> Compile error: NullPointerException thrown: null>>> Here's the aspect I'm using:>> package com.citi.gdos.smart.applib.service.cache;>> import org.springmodules.cache.annotations.Cacheable;>> public aspect CachingIntroduction {>>        declare @method: public * *..I*Dao+.set*(..): @Setter; >        declare @method: !@Setter public * *..I*Dao+.*(..):>                @Cacheable(modelId=""fooModel"");>> } test and fix committed *** Bug 296054 has been marked as a duplicate of this bug. *** "	2009-10-27 11:24:31	1256660000.0	resolved fixed	dc53b77	1258650000.0	tests/bugs167/pr293457/org/springmodules/cache/annotations/Cacheable.java tests/src/org/aspectj/systemtest/ajc167/Ajc167Tests.java tests/src/org/aspectj/systemtest/ajc167/IntertypeTests.java
293351	RuntimeException weaving roo app with advice based on execution pointcut	java.lang.RuntimeExceptionat org.aspectj.weaver.ResolvedType.getAnnotations(ResolvedType.java:718)at org.aspectj.weaver.AbstractAnnotationAJ.retrieveAnnotationOnAnnotation(AbstractAnnotationAJ.java:123)at org.aspectj.weaver.AbstractAnnotationAJ.ensureAtTargetInitialized(AbstractAnnotationAJ.java:85)at org.aspectj.weaver.AbstractAnnotationAJ.specifiesTarget(AbstractAnnotationAJ.java:115)at org.aspectj.weaver.bcel.BcelWeaver.verifyTa ... .eclipse.core.internal.jobs.Worker.run(Worker.java:55)Compile error: RuntimeException thrown: ResolvedType.getAnnotations() should never be called this is how a type not found exception manifests - the type which is being asked for the annotation is actually a MissingTypeWithKnownSignature - it should raise a typenotfound problem, like the other methods in that MissingXXX type. fixed - now raise a cant find type *** Bug 293461 has been marked as a duplicate of this bug. *** 	2009-10-26 14:19:20	1256580000.0	resolved fixed	a23c7e4	1256650000.0	org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java
279298	AspectJ LTW with Cobertura	"We are using AspectJ LTW along with Cobertura for code coverage. Class files areweaved just fine if they are not instrumented with Cobertura, but whenAspectJ attempts to weave the same aspects into Cobertura-instrumentedcopies of the same class files, weaving fails with the following error:>> error at com\mycompany\MyAspect.java::0 Cannot read debug info for@Aspect to handle formal binding in pointcuts (please compile with 'javac-g' or '<javac debug='true'.../>' in Ant)The attached project demonstrates the problem. It contains one simple aspect, a target class, and a unit test for the aspect. To see the problem, run the ""unittest"" target in the included Ant build file. This will run the single unit test twice. In the first pass, the test is run with javac-generated (i.e. uninstrumented) class files. The aspect is correctly woven and the test passes. In the second pass, the test is run with Cobertura-instrumented class files. There is an error during LTW, and the test fails. The example project zip file is too big for bugzilla, I will make it available elsewhere and provide a link. The example project is available here: http://github.com/scottfrederick/aspectj-cobertura-example. the problem here is that Cobertura has moved the start positions of all the local variable table entries.  Instead of starting at 0 they now start at 6.  AspectJ uses the rule that variables defined from position 0 are the names of the parameters.    LocalVariableTable:    Start  Length  Slot  Name   Signature   6      40      0    this       Lcom/example/ExampleAspect;   6      40      1    pjp       Lorg/aspectj/lang/ProceedingJoinPoint;   6      40      2    __cobertura__line__number__       I   6      40      3    __cobertura__branch__number__       ICobertura has inserted extra bytecode ahead of the main code, but that doesn't mean that 'this' and 'pjp' should be moved, since they are defined from the very start of the method because they are method arguments.I'm not sure what I want to do about this right now.However, the workaround is to define the argument names in the advice annotation - that works.@Around(value = ""monitorDoSomething()"",argNames=""pjp"")public Object aroundMonitorDoSomething(ProceedingJoinPoint pjp) throws Throwable { let me know what you think of that workaround.  It doesn't seem unreasonable for that to be required if the code is going to be modified by a third party.I can make AspectJ just take the first parameters in the method that make sense for it (skipping 'this' for static contexts) but that does seem a bit fragile since I may just be grabbing local variable names and not parameter names. I will also take a look at the Cobertura code and see if I can figure out why they modify the code in the way they do, and if it is possible to change Cobertura. I will let you know what I find out.Thanks for researching this.  FWIW, this bug has also bitten us - using AspectJ 1.6.4 and Cobertura 1.9.3.Interestingly enough, we were previously using LTW from Aspectwerkz 2.0 with Cobertura, and did not suffer these problems.  We have been stuck on Aspectwerkz for over a year because the LTW in AspectJ did not work properly when previously evaluated.  I know Aspectwerkz project has folded into AspectJ now.  Does looking at how Aspectwerkz does its LTW (which works with Cobertura) offer any solution that can be used to get AspectJ LTW to also work with Cobertura? anything I do is a workaround for what cobertura is doing to the bytecode (see comment 3).  I don't need to see what Aspectwerkz did to understand what to do, AspectJ is being more strict and expecting particular (as produced by compilers) input - the fix would be to cope with unusual input like this, if cobertura isn't going to adjust the output it produces. I should add - with this only being hit now and again and not having any votes, I haven't put any time into it.  thanks for letting me know you are also hitting it, I will raise the priority because of that. Andy, I took Scott Frederick's code, replaced the TestNG test case with a Cactus test, performed the changes you suggested and ran it from within the Tomcat container. It failed for the same reason ( [cactus] [WebappClassLoader@165b7e] error at com\example\ExampleAspect.java::O Cannot read debug info for @Aspect to handle formal binding in pointcuts).Here's the Byte Code   Local variable table:        [pc: 6, pc: 21] local: this index: 0 type: com.example.ExampleAspect        [pc: 6, pc: 21] local: __cobertura__line__number__ index: 1 type: int        [pc: 6, pc: 21] local: __cobertura__branch__number__ index: 2 type: int  @org.aspectj.lang.annotation.Around(value=""monitorDoSomething()"",    argNames=""pjp"")  public java.lang.Object aroundMonitorDoSomething(org.aspectj.lang.ProceedingJoinPoint pjp) throws java.lang.Throwable;Thoughts??? I recall that error about missing debug information coming out for the wrong reasons sometimes.  On a quick look I could only find bug 202088 which has been fixed for a while.  I will try and find some time to work around what cobertura is doing, but it is likely to take me a couple of weeks to get to it. I've committed the fix for enabling AspectJ to cope with the quirky bytecode that cobertura creates.  There is no flag to turn on as the function that goes searching for the argument names only kicks in if they aren't found where they are supposed to be.The fix is in the currently available dev build. Works like charm! Thanks a lot for doing this Andy.Just a side note for others working on projects involving Cactus, Cobertura and Aspectj - Cobertura serialized file thats used to store the coverage information is getting locked  and I will have to investigate why thats happening (multiple JVMs perhaps). There is one other thing Cobertura is doing in some cases that's causing AspectJ to mishandle the byte code. Developers might find it useful.Aspect J expects the Byte code's local variable table data to be in thefollowing order (example code)Local variable table:[pc: 6, pc: 21] local: this index: 0 type: com.example.ExampleAspect[pc: 6, pc: 21] local: __cobertura__line__number__ index: 1 type:int[pc: 6, pc: 21] local: __cobertura__branch__number__ index: 2 type:int[pc: 10, pc:121] local: key: 3 type: StringCobertura changes the byte code (instruments) and sometimes the order of the above variables get mixed.Local variable table:[pc: 10, pc:121] local: key: 3 type: String[pc: 6, pc: 21] local: this index: 0 type:com.example.ExampleAspect[pc: 6, pc: 21] local: __cobertura__line__number__ index: 1 type:int[pc: 6, pc: 21] local: __cobertura__branch__number__ index: 2 type:intThis is causing AspectJ to not behave properly resulting in ""error at com.example.ExampleAspectjava::0 Cannot read debug info for@Aspect to handle formal binding in pointcuts (please compile with 'javac-g' or '<javac debug='true'.../>' in Ant)....""Recommendation 1:Cobertura folks need to fix the way instrumentation is performed sothat the local variable table data order is retainedRecommendation 2:AspectJ LTW would have to look at the index field values of the local variables rather than assuming that the local variable entries are always added (to the byte code) in the increasing order of the index field valuesRecommendation 3: Work around:Instead of coding the logic within the Aspect method, re-factor the logicinto a new method.@Around(XXXXXX)public Object aspectAround(ProceedingJoinPoint pjp,.....){return logic();}public Object logic(){String key = ""XYZ"";// some more logicreturn key;} "	2009-06-05 14:02:54	1244230000.0	resolved fixed	35a9649	1256250000.0	weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java
289818	Unclosed stream in org.aspectj.weaver.bcel.ExtensibleURLClassLoader	Created attachment 147527Eclipse workspace patch that closes the streamThe method getBytes() gets a fresh stream from ClassFile and should close itafter using it. Right now, the stream is left open.A patch is attached that closes the stream. patch committed - thanks!  resolving 	2009-09-18 04:31:21	1253260000.0	resolved fixed	4d200d1	1253320000.0	weaver/src/org/aspectj/weaver/bcel/ExtensibleURLClassLoader.java
289816	Potentially unclosed stream in org.aspectj.weaver.bcel.BcelWorld	Created attachment 147526Eclipse workspace patch that closes the stream correctlyIn method lookupJavaClass(), one has to close a stream used by ClassParser.This should be done in a finally block, since parse() may fail and throw anIOException. Right now, the stream is left open in that case.A path to correctly close the stream is attached. patch committed- thanks! resolving 	2009-09-18 04:23:05	1253260000.0	resolved fixed	67ffda8	1253320000.0	weaver/src/org/aspectj/weaver/bcel/BcelWorld.java
288198	LangUtils JVM version detection cannot handle Java 7	User-Agent:       Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-GB; rv:1.9.1.2) Gecko/20090729 Firefox/3.5.2Build Identifier: 1.6.4The JVM detection in LangUtils is currently unable to handle Java7, whilst this is naturally an unreleased version of the JVM, the fix is trivial.Reproducible: AlwaysSteps to Reproduce:Attempt to use the LangUtils java version support on java7 Created attachment 146131Change the JVM version handling in LangUtils to be future proof against new JVM versionsChanges that allow the LangUtils JVM version handling to be more future proof against new JVM versions, for example 1.7 > 1.6 > 1.5. But the current version of LangUtils will not recognise 1.7 just to note that any 1.7 compilation that results in invokedynamic instructions in the bytecode is likely to crash the weaver. For sure, I was not fixing all of the extra changes in java7 that will influence the weaver, just the immediate happy case that causes the weaver to fail.I would certainly not suggest that anyone actually uses java7 at the moment, I just like playing :S unfortunately your patch wont apply as it is, because it refers to missing elements like 'weaver2'. I think its actually not applying because I cut the patch against the released source for 1.6.4I will rebuild the patch against trunk Created attachment 146470Patch recut against CVS trunk Remade the patch against aspectj cvs rather than random source jars from maven thanks for the patch, committed.  Slight rework to avoid reliance on autoboxing.If you do discover anything interesting using AspectJ on Java 1.7, let me know ! 	2009-08-31 21:09:33	1251770000.0	resolved fixed	b29f839	1252080000.0	util/src/org/aspectj/util/LangUtil.java
288505	failure to close inputstream	org.aspectj.weaver.Lint.loadDefaultProperties fix committed 	2009-09-03 12:17:03	1251990000.0	resolved fixed	3d3d03b	1251990000.0	org.aspectj.matcher/src/org/aspectj/weaver/Lint.java
287315	NPE using declare @type	reported by Ramnivas:java.lang.NullPointerException        at org.aspectj.weaver.bcel.BcelObjectType.hasAnnotation(BcelObjectType.java:558)        at org.aspectj.weaver.ReferenceType.hasAnnotation(ReferenceType.java:161)        at org.aspectj.weaver.patterns.ExactAnnotationTypePattern.matches(ExactAnnotationTypePattern.java:101)        at org.aspectj.weaver.patterns.ExactAnnotationTypePattern.matches(ExactAnnotationTypePattern.java:94)        at org.aspectj.weaver.patterns.AnyWithAnnotationTypePattern.matchesExactly(TypePattern.java:513)        at org.aspectj.weaver.patterns.TypePattern.matchesStatically(TypePattern.java:129)        at org.aspectj.weaver.patterns.DeclareAnnotation.matches(DeclareAnnotation.java:269)        at org.aspectj.weaver.bcel.BcelWeaver.applyDeclareAtType(BcelWeaver.java:1590) The problem here is that the weaver is being treated as re-entrant.  On re-entering the weaver we attempt to access the list of annotations on a type which was in the process of being built before we re-entered.  The NPE is due to an array which has yet to have all its elements initialized.In this case I will fix it by allowing for re-entrancy and performing the check in another way.  This sub-optimal way will only be used whilst in a re-entrant state and once we 'unwind' it will go back to an optimal mechanism. fix committed 	2009-08-21 11:30:34	1250870000.0	resolved fixed	b664969	1251140000.0	weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java
285172	Sometimes when load-time weaving there will be two ReferenceType objects for the same type	Seen by Ramnivas.A pointcut uses an exact type name for an annotationexecution(* (@Controller *..*).*(..))Resolving this pointcut causes us to construct a ReferenceType for 'Controller'.  Then we attempt to populate it by loading the class implementation.  This recurses back into the weaver as Controller is loaded and an attempt is made to weave it.  This takes a second route through the weaver to build a referencetype again and this second referencetype is cached in the world.  When we unwind, we continue building the original referencetype and are left with one in the cache and the one resolved for the pointcut.  Due to the use of == for comparison, we fail to match on join points later because they will use the ReferenceType from the cache. the solution in this case is to use the cached version after we 'unwind', rather than continue building the one we were originally constructing. 	2009-07-30 11:00:41	1248970000.0	resolved fixed	dd7d879	1248970000.0	org.aspectj.matcher/src/org/aspectj/weaver/World.java
280783	JavaDocRunner fails on System.setSecurityManager in Netbeans	<Pyinson Data Over Head> Created attachment 139548Patch removing the anonymous SecurityManager and calls to System.setSecurityManager(). I don't know why that code is in that runner, there are no comments.  I've done basically what the patch does and commented out all that code.  All my tests still pass just fine.so i'll commit the change to remove that code for now. 	2009-06-18 10:48:34	1245340000.0	resolved fixed	59d5c3b	1245350000.0	ajdoc/src/org/aspectj/tools/ajdoc/JavadocRunner.java
279120	NPE determining annotation target kind during weaving	"reported on the list:Hi, I am using aspectj LTW (aspectjweaver-1.6.1) for weaving an aspect available in another jar within my web application code. While building the jar which contains the aspect, using maven, I have JUnits which run without any problems using LTW. My aspect code looks as below      @Around(""execution (@com.arisglobal.aglite.annotations.OperationTrail public * *(..)) && this(executor)"")      public Object auditOperation(ProceedingJoinPoint thisJoinPoint,                  Object executor) {            …… aspect code…            } However when I deploy the application in tomcat (with javaagent:aspectjweaver-1.6.1.jar option), I get a NPE which I have pasted below. Jun 4, 2009 12:06:18 PM org.aspectj.weaver.tools.Jdk14Trace errorSEVERE: com/arisglobal/aglite/services/actiontrail/ActionTrailAspectjava.lang.NullPointerException        at org.aspectj.weaver.bcel.BcelObjectType.getAnnotationTargetKinds(BcelObjectType.java:612)        at org.aspectj.weaver.ReferenceType.getAnnotationTargetKinds(ReferenceType.java:265)        at org.aspectj.weaver.patterns.SignaturePattern.checkForIncorrectTargetKind(SignaturePattern.java:112)        at org.aspectj.weaver.patterns.SignaturePattern.checkForIncorrectTargetKind(SignaturePattern.java:94)        at org.aspectj.weaver.patterns.SignaturePattern.resolveBindings(SignaturePattern.java:87)        at org.aspectj.weaver.patterns.KindedPointcut.resolveBindings(KindedPointcut.java:262)        at org.aspectj.weaver.patterns.AndPointcut.resolveBindings(AndPointcut.java:75)        at org.aspectj.weaver.patterns.Pointcut.resolve(Pointcut.java:196)        at org.aspectj.weaver.bcel.AtAjAttributes.handleAroundAnnotation(AtAjAttributes.java:1308)        at org.aspectj.weaver.bcel.AtAjAttributes.readAj5MethodAttributes(AtAjAttributes.java:403)        at org.aspectj.weaver.bcel.BcelMethod.unpackAjAttributes(BcelMethod.java:189)        at org.aspectj.weaver.bcel.BcelMethod.<init>(BcelMethod.java:96)        at org.aspectj.weaver.bcel.BcelObjectType.getDeclaredMethods(BcelObjectType.java:264)        at org.aspectj.weaver.bcel.LazyClassGen.<init>(LazyClassGen.java:303)        at org.aspectj.weaver.bcel.BcelObjectType.getLazyClassGen(BcelObjectType.java:524)        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1728)        at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1696)        at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1458)        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1244)        at org.aspectj.weaver.tools.WeavingAdaptor.getWovenBytes(WeavingAdaptor.java:423)        at org.aspectj.weaver.tools.WeavingAdaptor.weaveClass(WeavingAdaptor.java:286)        at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:95)        at org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter.transform(ClassPreProcessorAgentAdapter.java:52)        at sun.instrument.TransformerManager.transform(TransformerManager.java:122)        at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:155)        at java.lang.ClassLoader.defineClass1(Native Method)        at java.lang.ClassLoader.defineClass(ClassLoader.java:620) I also tried using aspectjweaver-1.6.4 version however got the same error. proposed fix committed.  Don't attempt to use the javaClass directly to retrieve annotations, use the local copy of them that will have been taken earlier. fix available "	2009-06-04 11:10:13	1244130000.0	resolved fixed	3417cbe	1244130000.0	weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java
274986	DocumentParser incorrectly caches DTD InputStream	Build ID: 1.6.3Steps To Reproduce:Attempt to parse two aop.xml files using two DocumentParsers that are loaded by the same class loader. If the DTD is loaded from a JAR file you'll get an NPE at  java.util.zip.Inflater.inflateBytes(Native Method).More information:DocumentParser caches the DTD InputStream in a static final field. Many InputStreams are unusable after being closed so the same instance should not be used here. For InflaterInputStreams there seems to be a bug in the JRE that prevents the stream from reporting itself as closed when you use it again. haven't setup a testcase yet, but have changed the code so it is no longer a static field.will leave open until I find time to at least manually test it got half a test program together, then realised it was found on a Mac (I'm on Windoze).  That may explain why it just won't fail for me.  Let me resurrect the mac and try it. right, I recreated a failure on the mac - not quite the one reported though.I got a 'premature end of file' problem in:org.apache.xerces.util.ErrorHandlerWrapper.createSAXParserException()With the proposed fix the problem went away so I'm presuming this is now fixed. 	2009-05-05 09:50:07	1241530000.0	resolved fixed	66235e8	1241570000.0	weaver/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java
274559	Compile exception when not using debug info	"The following project throws a compiler exception when the project property ""Add variable attributes to generated class files"" is turned off. Created attachment 133986throws compiler exception when compiledThis project has the particular setting turned off.  So, you should be able to just import and attempt to compile. how about including the exception? ;) Yes, that would help, wouldn't it?java.lang.NullPointerExceptionat org.aspectj.ajdt.internal.compiler.ast.InterTypeMethodDeclaration.generateDispatchMethod(InterTypeMethodDeclaration.java:306)at org.aspectj.ajdt.internal.compiler.ast.InterTypeMethodDeclaration.generateCode(InterTypeMethodDeclaration.java:233)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:535)at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.generateCode(AspectDeclaration.java:271)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:604)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.generateCode(CompilationUnitDeclaration.java:215)at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:642)at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:392)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:1003)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performBuild(AjBuildManager.java:267)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:181)at org.aspectj.ajde.core.internal.AjdeCoreBuildManager.performBuild(AjdeCoreBuildManager.java:105)at org.aspectj.ajde.core.AjCompiler.buildFresh(AjCompiler.java:97)at org.eclipse.ajdt.core.builder.AJBuilder.build(AJBuilder.java:243)at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:633)at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:37)at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:170)at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:201)at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:253)at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:37)at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:256)at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:218)at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:360)at org.eclipse.core.internal.resources.Project.internalBuild(Project.java:516)at org.eclipse.core.internal.resources.Project.build(Project.java:94)at org.eclipse.jdt.internal.ui.util.CoreUtility$BuildJob.run(CoreUtility.java:160)at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55) fixed not sure why this is still open... "	2009-04-30 14:06:37	1241110000.0	resolved fixed	f9578da	1241130000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java
272591	[WARNING] couldn't find aspectjrt.jar on classpath	I am using the aspectj runtime jar that is in the spring source bundle repository.  The have renamed their jar to match their naming conventions and it is causing the warning to occur.  Their bundle is named com.springsource.org.aspectj.runtime-1.6.3.RELEASE.jar.  It would be nice if this warning was not printed out in this case. i agree - will change that checking for 1.6.5 fixed - will allow for org.aspectj.runtime renamed jar. 	2009-04-16 18:32:15	1239920000.0	resolved fixed	1b663a9	1241120000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
269522	[handles] Cross reference view and markers mix up joinpoints assigned to advice	"Build ID: M20090211-1700Steps To Reproduce:I have two pieces of after advice in my aspect.  In the cross reference view I see all of the joinpoints for both after advice selecting one of the after advice statements.  When I select the other after advice statement I see no joinpoints.When I select the marker for either piece of after advice, I see all the joinpoints for both pieces of advice.1. open and perform a clean compile on the attached project2. open the xref view3. select line 22 an note that you see 5 joinpoints (should only be 3)4. select line 68 and note that you see zero joinpoints (should be 2 here)5. right click the marker at line 68 and choose ""advises"" - note you see all 5 joinpoints6. right click the marker at line 22 and choose ""advises"" - note you see all 5 joinpointsMore information: Do you have a test case for this?  Or at least the pointcuts and advice you are using? Created attachment 129472sample projectsorry... I thought I had attached the project with the initial report.  I guess it didn't take. This is a handles problem.  Both aspect advice have the same handle:=EnforceProcess/src<com.kronos.aspects*ProcessAspect.aj}ProcessAspect&after&QMyProcessor;However, the second advice should have the handle:=EnforceProcess/src<com.kronos.aspects*ProcessAspect.aj}ProcessAspect&after&QMyProcessor;!2However, interesting thing is that when I trim the aspect down to this the problem goes away and all handles are generated correctly:public aspect ProcessAspect perthis(initMyProcessor(MyProcessor)) {	HashMap<String, Field> fieldList = new HashMap<String, Field>();		pointcut initMyProcessor(MyProcessor myProcessor) : initialization(MyProcessor+.new(..)) && this(myProcessor);		pointcut executesProcess(MyProcessor myProcessor) : execution(* MyProcessor+.process()) && this(myProcessor);		// find all of the public fields or fields with public accessors	after(MyProcessor myProcessor): initMyProcessor(myProcessor) {  	}			after(MyProcessor myProcessor): executesProcess(myProcessor) && !cflowbelow(executesProcess(MyProcessor)){	}} Moving this over to AspectJ because it is a handles problem. the problem here is that the after method signatures are in fact different.  One advice uses thisJoinPointStaticPart and the other does not - this introduces an extra parameter to the advice signature and thus they are considered different.  I have to build in tolerance for this extra parameter and disregard it in advice signature counter calculations. In fact I have to build in tolerance for up to 3 parameters - thisJoinPoint, thisJoinPointStaticPart, thisEnclosingJoinPointStaticPart.  The advice knows how many extra params were added, but in creation of the program element that information is lost so for now we will just strip them based on well known names (a better future fix would be to pass that data across to the programelement).  The current fix could break if someone actively wrote an advice signature that specified a join point type... but who on earth would do that.I wonder how many users have been hitting this problem?  Seems relatively serious so important to get this fix out fast. proposed fix is committed into AspectJ and AJDT - should be in an AJDT build later today tested the scenario described at the top of the bug report and this works fine on the latest AJDT dev build. "	2009-03-20 10:24:07	1237560000.0	resolved fixed	6dbb5f3	1238090000.0	asm/src/org/aspectj/asm/internal/JDTLikeHandleProvider.java
270033	[incremental] Incremental compilation with aspects on an incoming classpath/aspectpath	"This is something it might now be time to address.  I encountered it in bug 267794 and it was rather annoying.  With all the improvements to incremental it is annoying to just throw our hands in the air and do a full build if we hit an aspect on the defined classpath/aspectpath for a project.  I'm not looking into inpath here, if that benefits from some of these changes - that's great - but it is not something I'm trying to fix here. I have a minimal project configurationA - defines abstract base tracing aspect (abstract pointcut)B - depends upon A (via classpath) and supplies:1) a concrete aspect extending the tracing aspect2) a type affected by that tracing aspectC - this project depends upon BHere is a typical problematic scenario:In project B the affected class is changed (a STRUCTURAL change is made, a new method to be affected by the trace aspect).  It is recompiled - due to the type dependencies stored in the state, we see that the concrete subaspect is related to it and so rebuild that too - this is OK.Project C then rebuilds because it depends on project B.  It sees that the affected class has been recompiled, but decides it doesn't care as it has nothing in it that depends upon it.  Then it sees the rebuilt aspect class file - and goes OH NO, MUST REBUILD FROM SCRATCH.  Rebuilding this project from scratch then causes nightmare builds for everything else downstream.The problematic code is the statement in the path analysis logic:if (state.isAspect(classFile)) {					  return CLASS_FILE_CHANGED_THAT_NEEDS_FULL_BUILD;}Two questions need answering before I change it (kind of related to each other).- Can I just remove the check and depend on the regular type dependency information maintained to know what to do?  Or do we need special logic to handle aspects?- Is it true that anything that changes within an aspect will cause the .class file for the aspect to exhibit a structural change? > - Is it true that anything that changes within an aspect will cause the .class> file for the aspect to exhibit a structural change?In a simple case, if a pointcut changes, the hashcode from the pointcut text changes and the hashcode is used to create the advice name.  However in the case of an abstract aspect and concrete subaspect, the advice names will be basically 'fixed' in the super-aspect based on the pointcut specified in the aspect.  Right now (I've tried it) - changing the expression in the subaspect pointcut does NOT manifest as a structural change to the .class file for the subaspect.  So an aspect can be changed in such away that its affect should affect more or less places and just seeing if we need to do something based on structural changes of .class files will not identify what has happened.So the timestamp of the .class file will change but not the structure.  What does that mean for downstream projects?  If a downstream project, like my project C, had only a classpath dependency (and not aspectpath) upon that aspect and that aspect was concrete, then we are fine to avoid a full build.  The effect that aspect had on other types in project B will cause us to rebuild the appropriate parts of project C.If A defined an abstract aspect, then B extended it via another abstract aspect, and then C concretized the aspect... then regardless of whether it has a structural change on we need to do the isTypeWeReferTo check - and if that is true, we know we have a local concrete aspect.So it sounds like I'm morphing this test from:if (state.isAspect(classFile)) {                                          return CLASS_FILE_CHANGED_THAT_NEEDS_FULL_BUILD;}toif (state.isAspect(classFile)) {               if (state.hasStructuralChangedSince(classFile, lastSuccessfulBuildTime) ||      isTypeWeReferTo(classFile)) {         // further improvements possible                          return CLASS_FILE_CHANGED_THAT_NEEDS_FULL_BUILD;  } else {    // it is an aspect but we don't refer to it:     // - for CLASSPATH I think this is OK, we can continue and try an    //   incremental build    // - for ASPECTPATH we don't know what else might be touched in this project    //   and must rebuild  }}is that right...? The test appears ok but glitches galore are falling out now:- in incremental building it checks all types from projects upon which it references to see which it has a direct dependency on.  Once one of them triggered it to say YES, I depend directly on that type, then it considered that it directly depended upon everything checked after that.  This would lead to incremental builds that build more than they need to.- now I have the problem that in multiple projects I named the sub-aspect the same thing (Tracer).  This means when we observe the aspect Tracer on the classpath for our project, we think we depend upon it because we have a type called Tracer - I think that match needs to be ignored because ours would override what was on the classpath anyway.Fixed the first one, working on the second one. I'm deferring the second problem I listed in the previous comment - it is unlikely in a real world setup I *think* and I want to chew on it some more.But here are the numbers so far.For my large scale configuration where all the aspectj modules are aspectj projects and 3 of them extend an abstract aspect defined in another project - the build time (for adding a new method to util/FileUtil.java) is reduced.Without the change in the test: 3 runs of an incremental structural change: 51352ms, 46705ms, 50881msWith the change:3 runs of an incremental structural change: 7843ms, 11112ms, 7680mserr, bit of a saving...  the big benefit here will be to anyone downstream of a project using aspectpath where they themselves are not using aspectpath. spun off that seconday problem as bug 270046.  Running the AJ tests against the changes I've just made for aspectpath projects. fixes in - now going back to 267794 "	2009-03-25 17:20:22	1238020000.0	resolved fixed	b23cc1a	1238040000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java
269902	NPE in AsmRelationshipProvider.addRelationship	When doing a clean build of my project, seeing dozens, upwards of 100 of NPEs similar to the following:java.lang.NullPointerExceptionat org.aspectj.weaver.model.AsmRelationshipProvider.addRelationship(AsmRelationshipProvider.java:168)at org.aspectj.weaver.bcel.BcelTypeMunger.munge(BcelTypeMunger.java:124)at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:441)at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:103)at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1732)at org.aspectj.weaver.b ...  FWIW, this is seen for Spring-managed auto-injection of beans with the @Configurable annotation.Official AJDT version is: 1.6.4.20090304172355Version: 3.4.2Build id: M20090211-17 By some coincidence, I fixed something like this earlier on today - it manifested for me because I had some aspects on my aspectpath that used the same package name as source in my project, but I believe it could also happen if using split packages where source code in two different source folders shares the same package name.  Do you have that situation?The fix was to AspectJElementHierarchy - to make it continue searching even after finding a match in case there are others. The proposed fix has not made it into an AJDT dev build yet but it should do shortly.  (bug I raised to cover it was bug 269840) > By some coincidence, I fixed something like this earlier on today - it> manifested for me because I had some aspects on my aspectpath that used the> same package name as source in my project, but I believe it could also happen> if using split packages where source code in two different source folders> shares the same package name.  Do you have that situation?>I do indeed. > The fix was to AspectJElementHierarchy - to make it continue searching even> after finding a match in case there are others. The proposed fix has not made> it into an AJDT dev build yet but it should do shortly.  (bug I raised to cover> it was bug 269840)> Is there a development plugin build produced automatically somewhere? Or maybe some documentation on how to c/o and compile? Happy to test the fix to see if it applied to my case before I go too deep into the source. the ajdt builds are currently failing some tests (my fault).  But let me work out how to give you a patch for this. Created attachment 129779Replacement class fileThis replaces the version in the org.aspectj.weaver plugin.Shutdown eclipse, go to your eclipse installation folder, then the plugins directory.  Within their go to org.aspectj.weaver_XXX - go into the latest version you have.backup the weaver jar: cp aspectjweaver.jar aspectjweaver.jar.originalapply the patch: jar -xvf patch266902.zipjar -uvf aspectjweaver.jar orgThis will replace the .class file in that jar with a build of the latest version from HEAD.  Let me know what happens... Thanks for that, unfortunately same NPEs still coming up. Happy to test further or debug if you have a guide on how to debug the compiler. i'll look at it next after what I'm working on.  If you have a minimal project that exhibits the problem, that would be great. you could try the latest AJDT 1.6.5 dev build that has just been made available. (In reply to comment #7)> you could try the latest AJDT 1.6.5 dev build that has just been made> available.> Similar error with the dev build, one line difference in the location of the NPE:java.lang.NullPointerExceptionat org.aspectj.weaver.model.AsmRelationshipProvider.addRelationship(AsmRelationshipProvider.java:167)at org.aspectj.weaver.bcel.BcelTypeMunger.munge(BcelTypeMunger.java:124)at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:441)at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:103)at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1735)at org.aspectj.weaver.b ...  ah, it is similar to the npe i fixed but not on exactly the same line, I should have checked.  I suspect it has a similar root cause though, hopefully now I have an up to date stack trace I'll be able to recreate - thanks! i've recreated it, yey. hmm, well i only managed a recreate by using a broken aspect (that had syntax errors in it).  But anyway - I've put guards in place to prevent the NPE, this change is in todays AJDT dev build that includes AspectJ 1.6.4.20090326115100 (In reply to comment #11)> hmm, well i only managed a recreate by using a broken aspect (that had syntax> errors in it).  But anyway - I've put guards in place to prevent the NPE, this> change is in todays AJDT dev build that includes AspectJ 1.6.4.20090326115100> That seems to have remove the NPE, thanks. FWIW, all of my advice is applied using annotations and they compile and weave fine with a stand-alone ant task. Entirely possible that something is wrong with them, but it doesn't surface when outside the AJDT context.I seem to now be encountering 267794 so its hard for me to know if I'm entirely out of the woods yet, but appreciate the help. Running with Ant outside of eclipse you aren't building a structure model (which drives the markers/etc in eclipse) - so you don't trigger the codepath that leads to the NPE.Are you really hitting an OutOfMemory problem?  Please can you comment on that bug with any details if you are... 	2009-03-24 18:39:30	1237930000.0	resolved fixed	d5e900d	1238030000.0	weaver/src/org/aspectj/weaver/model/AsmRelationshipProvider.java
269912	wasted time building message context when it is only used for command line builds	The context for a message is created even when AspectJ is used inside AJDT - but the context only ever gets used when printing messages to System.out.  Under AJDT we ought to be able to 'switch it off' When all the AspectJ modules (about 20 or so) are converted to AspectJ projects, the totals for 'time spent in AJDE' (from the event trace view) are as follows.  These are all full builds, but the initial one is a bit higher, presumably just because eclipse hasn't warmed up at all.33525ms27399ms28595ms26926msI then removed the context creation code (hacked it out), these are the new full build times:24075ms (saved 29%)22718ms (saved 18%)22593ms (saved 21%)My yourkit measurement showed it was about 20% of the time for context building, and the numbers agree.  So now I'll look for the proper way to avoid building the context in the IDE.I think a 20% improvement in build times for a full build in the IDE is rather nice!Although, the saving here is because there are a lot of messages coming out - if there are no messages (no warnings, no TODOs, no errors, nothing at all) then the context building code will not be costing anything.  All the AspectJ code produces around 8000 warnings - these are mostly the ones about using types like List without specifying the generic parameters. fixed - my build times down by 20% now in the IDE. 	2009-03-24 19:25:29	1237940000.0	resolved fixed	c732808	1238000000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseAdapterUtils.java
269867	Non synchronized access to WeakHashMap causes infinite loop	"The non synchronized access from AjTypeSystem.getAjType(clazz) to a static instance of WeakHashMap may cause an infinite loop at start up in a multi threaded system. The thread dump shows that 32 of 33 threads of the application stuck in WeakHashMap.get(Object) line 355:""BundleStarterThreadQcCtrl24"" prio=3 tid=0x00957c00 nid=0x39 runnable [0xd42fb000..0xd42ffa70]   java.lang.Thread.State: RUNNABLE	at java.util.WeakHashMap.get(WeakHashMap.java:355)	at org.aspectj.lang.reflect.AjTypeSystem.getAjType(AjTypeSystem.java:37)	at org.aspectj.weaver.reflect.Java15ReflectionBasedReferenceTypeDelegate.initialize(Java15ReflectionBasedReferenceTypeDelegate.java:66)	at org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegateFactory.create15Delegate(ReflectionBasedReferenceTypeDelegateFactory.java:56)	at org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegateFactory.createDelegate(ReflectionBasedReferenceTypeDelegateFactory.java:42)	at org.aspectj.weaver.reflect.ReflectionWorld.resolveDelegate(ReflectionWorld.java:111)	at org.aspectj.weaver.World.resolveToReferenceType(World.java:388)	at org.aspectj.weaver.World.resolve(World.java:279)	at org.aspectj.weaver.World.resolve(World.java:199)	at org.aspectj.weaver.World.resolve(World.java:348)	at org.aspectj.weaver.reflect.ReflectionWorld.resolve(ReflectionWorld.java:103)	at org.aspectj.weaver.reflect.ReflectionWorld.resolve(ReflectionWorld.java:93)	at org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegateFactory.toResolvedTypeArray(ReflectionBasedReferenceTypeDelegateFactory.java:214)	at org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegateFactory.createResolvedMethod(ReflectionBasedReferenceTypeDelegateFactory.java:107)	at org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegateFactory.createResolvedMember(ReflectionBasedReferenceTypeDelegateFactory.java:98)	at org.aspectj.weaver.reflect.ReflectionShadow.makeExecutionShadow(ReflectionShadow.java:53)	at org.aspectj.weaver.internal.tools.PointcutExpressionImpl.matchesExecution(PointcutExpressionImpl.java:100)	at org.aspectj.weaver.internal.tools.PointcutExpressionImpl.matchesMethodExecution(PointcutExpressionImpl.java:92)	at org.springframework.aop.aspectj.AspectJExpressionPointcut.getShadowMatch(AspectJExpressionPointcut.java:370) Created attachment 129726Thread Dump Created attachment 129734TestCaseThe attached reproduces the Bug, if you set 'syncGetter=false'. wrapped the map with Collections.synchronizedMap() available in latest dev builds. "	2009-03-24 14:16:04	1237920000.0	resolved fixed	752f895	1237930000.0	aspectj5rt/java5-src/org/aspectj/lang/reflect/AjTypeSystem.java
269840	[model] package search fails in binary aspect in same package as a source type	If type a.b.c.C is advised by an aspect a.b.c.X from the aspectpath the model search logic breaks for finding 'X' because it hits the package node for a.b.c and stops looking fixed 	2009-03-24 12:07:29	1237910000.0	resolved fixed	7a7d6f0	1237910000.0	asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java
269578	Resource deletion in source folder on full build when source and output folders are the same.	On the clean before a full aspectj build resources are removed from the output folder.  This is true even when the output and the source folder are the same.  In this case, the resources are deleted from the source folder!When the source and output folders are the same, resources should never be deleted. at least triage for 1.6.4 fixed.  that resource code was really ropey.  For any resource it went through all output folders and tried to delete it.  It didn't care where it originated from - in fact it had forgotten and thats why it tried everywhere!  	2009-03-20 17:01:10	1237580000.0	resolved fixed	5c49c0b	1237600000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java
266996	AspectJElementHierarchy.java:427 NullPointerException	"Since an recent update to eclipse I get errors when using ajdt compile time weaving. Single used aspect is @Configurable from spring 2.5.6. I call this critical because my application wont run without that aspect compiled in.When doing a build two popups ""AspectJ Internal Compiler Error"" are showing up with instructions to look for and post bugreports.1st popup:--------------------------------java.lang.NullPointerExceptionat org.aspectj.asm.internal.AspectJElementHierarchy.findCloserMatchForLineNumber(AspectJElementHierarchy.java:427)at org.aspectj.weaver.model.AsmRelationshipProvider.addRelationship(AsmRelationshipProvider.java:130)at org.aspectj.weaver.bcel.BcelTypeMunger.munge(BcelTypeMunger.java:124)at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:441)at org.aspectj.weaver.bcel.BcelClassWeaver.weave( ... end abstract interface org.springframework.beans.factory.aspectj.AbstractInterfaceDrivenDependencyInjectionAspect$ConfigurableDeserializationSupport--------------------------------2nd popup--------------------------------java.lang.NullPointerExceptionat org.aspectj.asm.internal.AspectJElementHierarchy.findCloserMatchForLineNumber(AspectJElementHierarchy.java:427)at org.aspectj.weaver.model.AsmRelationshipProvider.addRelationship(AsmRelationshipProvider.java:130)at org.aspectj.weaver.bcel.BcelTypeMunger.munge(BcelTypeMunger.java:124)at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:441)at org.aspectj.weaver.bcel.BcelClassWeaver.weave( ... ibatis/domain/Banf;)I                    IRETURN  end public volatile int compareTo(Object)end public class de.synaix.k070_Banf.ibatis.domain.Banf--------------------------------Output of AJDT Event trace window:--------------------------------11:21:34 Removed problems and tasks for project SOME_webapp11:21:34 Builder: Tidied output folder(s), removed class files and derived resources11:21:35 Timer event: 1ms: Delete markers: SOME_webapp (Finished deleting markers for SOME_webapp11:21:38 Compiler configuration for project SOME_webapp doesn't know previous state, so assuming EVERYTHING has changed.11:21:38 ===========================================================================================11:21:38 Build kind = FULLBUILD11:21:38 Project=SOME_webapp, kind of build requested=Full AspectJ compilation11:21:38 Builder: Tidied output folder(s), removed class files and derived resources11:21:38 Timer event: 442ms: Pre compile11:21:38 Compiler configuration for project SOME_webapp has been read by compiler.  Resetting.11:21:38      Configuration was [PROJECTSOURCEFILES_CHANGED, JAVAOPTIONS_CHANGED, ASPECTPATH_CHANGED, CLASSPATH_CHANGED, INPATH_CHANGED, NONSTANDARDOPTIONS_CHANGED, OUTJAR_CHANGED, PROJECTSOURCERESOURCES_CHANGED, OUTPUTDESTINATIONS_CHANGED, INJARS_CHANGED]11:21:38 Resetting list of modified source files.  Was null11:21:38 Preparing for build: not going to be incremental because no successful previous full build11:21:40 Timer event: 1252ms: Time to first compiled message11:21:40 Timer event: 1276ms: Time to first woven message11:21:45 AspectJ reports build successful, build was: FULL11:21:45 AJDE Callback: finish. Was full build: true11:21:45 Timer event: 6456ms: Total time spent in AJDE11:21:45 Timer event: 157ms: Refresh after build11:21:45 Types affected during build = 30811:21:45 Crosscutting model sanity checked with no problems11:21:45 Timer event: 0ms: Post compile11:21:45 Timer event: 7248ms: Total time spent in AJBuilder.build()11:21:45 Timer event: 2ms: Delete markers: SOME_webapp (Finished deleting markers for SOME_webapp)11:21:45 Timer event: 179ms: Create markers: SOME_webapp (Finished creating markers for SOME_webapp)-------------------------------- Created attachment 127505patch for aspectjweaver.jar in org.aspectj.weaver pluginThis is a replacement .class for the one in org.aspectj.weaver_XXXXX/aspectjweaver.jar that should address the NPE. Sorry about this problem Thorsten, I will try and get a new AJDT out today with the fix in.  it is due to some 'improvements' to the relationships support.  If you get a chance to try the patch I attached, great - otherwise just pick it up in when it is in AJDT.  To apply the patch, go to your eclipse plugins folder, then the most recent org.aspectj.weaver folder:1) backup: copy aspectjweaver.jar aspectjweaver.jar.original2) jar -xvf weaverpatch.zip3) jar -uvf aspectjweaver.jar org wait! Dont apply the patch.  I thought you would be on the AspectJ I released yesterday into AJDT, but seems like you can't be as there hasn't been a release of that AJDT yet.  So the patch is unlikely to be compatible with what you have.  I'll try and get a decent fix out today through ajdt. proposed fix is in todays AJDT 1.6.4 RC  I did the update and think thats fixed. No more errors shown, aspect is woven in as expected. Thank you big times, Andy! great, thanks for testing it. "	2009-03-04 05:49:51	1236160000.0	resolved fixed	2309f7b	1236190000.0	asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java
266602	Problem with incremental itd compilation	"<Pyinson Data Over Head> Quite complicated - and I'm having trouble recreating it purely in AspectJ so something in the AJDT setup is interfering but I'm not quite sure what it is yet.I have also recreated the mungeNewMethod problem.It appears to be that on an incremental compile:1) the change to the Visit class is made and it is saved2) incremental compile of that file runs, determines that it needs to recompile associated files:  ""Visit_Roo_Jpa_Itd.aj"", ""Visit_Roo_Entity_Itd.aj"", ""Visit_Roo_Finder_Itd.aj"", ""VisitIntegrationTest_Roo_Integration_Test_Itd.aj"", ""VisitDataOnDemand_Roo_Dod_Itd.aj""3) When weaving Visit we go looking for the annotations from the ITD member, but it is still in EclipseSourceType form having just been compiled, and its getDeclaredMethods() is deliberately not including ITD methods.I'm imagining two solutions right now:- the pipeline needs to 're-stall' because the aspects are being compiled, it should be stalled until all aspects are through and then Visit will be fine as the aspect containing the ITD will be a bcel entity.- return the full set of declared methods, including itds, from the EclipseSourceType object.The first solution may get us into trouble if an ITD is ever made from one aspect to another - we can hit this same situation, it is just less likely (who does an ITD from one aspect to another...)The seconds solution makes sense but:- there is a damn good reason why I didn't return ITDs from getDeclaredMethods(), but I cant remember why- the annotations may or may not be easily accessible, even if I did return the ITD.thinking required... ok, i have recreated it myself outside of AJDT.Commenting out the 'vet' field in Visit - in order to create the BCException in fact leaves us with broken code.  There are compiler errors recorded against the Entity class during compilation that cause it not to go through the weaver before we recompile Visit.  Not going through the weaver means it does not transition from an Eclipse object to a Bcel object. ok - the only scenarios i can make this occur are when the project already has errors in it.  So I've downgraded the BCException - it can't happen any more.fix committed. "	2009-02-28 16:09:42	1235860000.0	resolved fixed	2f36e7f	1235970000.0	weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java
264869	AspectJ depends on Class files having a dot in their source file name attribute	"The following code in ShadowMunger$getBinaryFile() (line 169 ff) fails if a class file does not contain a proper source file name:		if (binaryFile == null) {			String s = getDeclaringType().getBinaryPath();			File f = getDeclaringType().getSourceLocation().getSourceFile();			int i = f.getPath().lastIndexOf('.');			String path = f.getPath().substring(0, i) + "".class"";			binaryFile = new File(s + ""!"" + path);		}(there is no '.' in the file name, thus this gives a string index out of bounds error). fixed forgot to close it The bug is maybe a bit badly phrased. Did you remove the dependency on the source file attribute completely, or just fix the problem with the dot? i put in a guard for dot.  If you want to give me a concrete example of when the attribute is incorrect then that might help me decide whether there is a more appropriate fix? To be honest, I don't quite understand what that code is doing there.But as a basic example, if you obfuscate or shrink code using many popular tools, there either won't be a source file attribute at all, or it will be something like ""foo"" for all class files on the classpath. So whatever AspectJ is doing there to sort files, it's not going to work. As a follow up: it may not be the goal of AspectJ to support obfuscated code, but I think the source file attribute is not mandatory, and it is indeed not included if you pass the right switches to javac, if I'm not mistaken.So depending on it is probably not a good idea. Why don't you just use the classes canonical name? if there is no source name then I don't believe it will fail.  Here the bug appears to be someone supplied something as that attribute value but it was nonsense and the expectation of the code (that it contained a dot) was not met.  The goal then is just to cope with that.please give me a failing scenario that I can then fix it to do the right thing.  Are you deliberately supplying class files with bogus name attributes? class files with no name attributes?This code is (as far as I know) only used to produce nice error messages, nothing super super critical.  We are using the information the supplied to us in the class file, this doesn't seem unreasonable, and whether it is there or not will likely only impact info/warning/error messages.  if they supply obfuscated code in, they are likely to get very unhelpful message anyway.We don't go out of our way not to support obfuscated code, but if it is obfuscated to the degree that some of the common javac/jdt compiler patterns are broken in the bytecode, we might well fail to weave it - but we have no open bugs for this scenario at the moment. The scenario is simply as I said that the source file attribute of all files is ""foo"". If this is non-critical and only for error reporting, then everything is probably fine if you fix the issue with the dot. "	2009-02-13 11:54:48	1234540000.0	resolved fixed	9f80317	1234890000.0	org.aspectj.matcher/src/org/aspectj/weaver/ShadowMunger.java
264563	[handles] Remove trailing '/' from source path handles	"In bug 262953, we noticed that when the .classpath has an entry like:  	<classpathentry kind=""src"" path=""src/""/>Instead of something like:		<classpathentry kind=""src"" path=""src""/>AspectJ handles will include the extra '/', but JDT handles will not.  On the AJDT side, I fixed things in Bug 262953 so that this kind of classpath entry will not be created by AJDT.  However, for consistency, it is probably a good idea for AspectJ to handle these kinds of paths the same as JDT.For example, the AspectJ handle for the source folder in Spacewar when the .classpath entry contains and extra '/' looks like:=Spacewar Example/src\/but the JDT handle looks like:=Spacewar Example/src fixed. "	2009-02-11 13:19:52	1234380000.0	resolved fixed	0af658e	1234460000.0	asm/src/org/aspectj/asm/internal/JDTLikeHandleProvider.java
263837	Error during Delete AJ Markers	Error sent through the AJDT mailing list.  I believe this is an LTW weaving error, so not raising it against AJDT. Created attachment 124849error message reportedToo long to attach directly. This looks to be a re-entrancy problem.  Where two threads are using the same weaver instance at the same time.  This is not supported - the weaver is only threadsafe, it is not reentrant.Under AspectJ loadtime weaving, entry to the weaver is gated on having a lock on the classloader associated with the weaver:  synchronized (loader) {    WeavingAdaptor weavingAdaptor = WeaverContainer.getWeaver(loader, context);    byte[] newBytes = weavingAdaptor.weaveClass(className, bytes, false);    return newBytes;  }Going in from equinox aspects we don't use this code but go straight for the weaver, we need to check on a similar lock.  Looking at a section of the stack: at org.aspectj.weaver.tools.WeavingAdaptor.getWovenBytes(WeavingAdaptor.java:423) at org.aspectj.weaver.tools.WeavingAdaptor.weaveClass(WeavingAdaptor.java:286) at org.eclipse.equinox.weaving.aspectj.loadtime.OSGiWeavingAdaptor.weaveClass(OSGiWeavingAdaptor.java:97) at org.eclipse.equinox.weaving.aspectj.WeavingService.preProcess(WeavingService.java:156) at org.eclipse.equinox.weaving.adaptors.AspectJAdaptor.weaveClass(AspectJAdaptor.java:235) at org.eclipse.equinox.weaving.hooks.AspectJHook.processClass(AspectJHook.java:126)I'd expect some kind of lock possibly in the OSGIWeavingAdaptor or maybe in WeavingService.preProcess() Ah no.... it isn't that - although I am intrigued about the lack of synchronized entry to the weaver from Equinox Aspects - does some higher level mechanism prevent the issue?This appears to be a problem with the reweavable setting.  Currently (I honestly couldn't say why) the reweavable mode is a shared field across all weavers.  So all weaver instances share the setting which might be true or it might be false.  For compile time weaving it defaults to true and for load time weaving it defaults to false.  This used to be fine, because all weavers in Eclipse were for AJDT projects and typically all defaulted to true.  But now we are using weavers for JDT weaving and weavers for projects within the same VM.This means the LTW kicks in first, creates a few weavers and everything is fine - if, however, the LTW of JDT is in the middle of this method:org.aspectj.weaver.bcel.BcelClassWeaver.weave()at the same point as a new AJDT project (and builder and thus weaver) is setup then we have a problem.AJDT will switch ON reweaving for all weavers.  The thread doing JDT weaving will then crash with this NPE because the check on line 421 will have returned false whilst the check on line 533 will return true.Why on earth is that flag static?Note:This will also damage the performance of JDT Weaving - since if it is incomplete (some codepath may not have been exercised yet) and an AJDT project comes along and switches the flag to TRUE, then all JDT weaving after that will suffer the cost of reweavable. fix committed. hopefully it addresses this. *** Bug 262779 has been marked as a duplicate of this bug. *** 	2009-02-05 13:25:34	1233860000.0	resolved fixed	1b54b4b	1233880000.0	weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java
261808	"iajc-Ant-Task fails ""type already defined"""	"Created attachment 123223Eclipse-project-export that demonstrates the errorAs attachment you find a simple Eclipse-Project, which reproduces the error. The project-structure consists of two packages ""anttest"" and ""anttest.test"". The second package should not be included in the build, so I was trying to exclude it using a dirset. This does not work, because with this configuration iajc always fails with an ""already defined""-error for every type (class or aspect).As comment I included a simple workaround for this problem in the iajc-task. This workaround does its job, but I want to reuse the source-path-definition, which is not possible this way. i encountered this the other day too - take a look for 1.6.4 Thanks for the complete project.Running ant -verbose we can see why the duplication message is coming out:compile:     [iajc] ajc [-d, c:\temp\antTest\build, -source, 1.5, -classpath, F:\aspectj164-dev\lib\aspectjrt.jar;C:\temp\at\AntTest\build\${JRE_LIB}, C:\temp\at\AntTest\src\de\tobiasdemuth\anttest\AntTest.java, C:\temp\at\AntTest\src\de\tobiasdemuth\anttest\HelloWorldAspect.aj,  C:\temp\at\AntTest\src\de\tobiasdemuth\anttest\test\TestClass.java, C:\temp\at\AntTest\src\de\tobiasdemuth\anttest\AntTest.java, C:\temp\at\AntTest\src\de\tobiasdemuth\anttest\HelloWorldAspect.aj, C:\temp\at\AntTest\src\de\tobiasdemuth\anttest\test\TestClass.java, C:\temp\at\AntTest\src\de\tobiasdemuth\anttest\AntTest.java, C:\temp\at\AntTest\src\de\tobiasdemuth\anttest\HelloWorldAspect.aj, C:\temp\at\AntTest\src\de\tobiasdemuth\anttest\test\TestClass.java, C:\temp\at\AntTest\src\de\tobiasdemuth\anttest\AntTest.java, C:\temp\at\AntTest\src\de\tobiasdemuth\anttest\HelloWorldAspect.aj, C:\temp\at\AntTest\src\de\tobiasdemuth\anttest\test\TestClass.java]Each of the files is passed 4 times to the ajc command.  That is because the source.path is defining a dirset and all the directories are included multiple times as it recurses down:srcsrc/desrc/de/tobiasdemuthsrc/de/tobiasdemuth/anttest(note src/de/tobiasdemuth/anttest/test is excluded, as specified in the dirset exclude).Under each of these 4 all the source files are found and passed to the compiler.  So you get 4 copies of each source file.  An interesting thread relating to paths/etc for the javac task:http://marc.info/?l=ant-user&m=118847696407900&w=2Now, javac doesn't mind this behaviours and would dismiss the duplicates, but iajc does not - I think that might be a bug we should fix. fixed in HEAD - will be in next dev build "	2009-01-21 07:43:15	1232540000.0	resolved fixed	1da1f7c	1233380000.0	taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java
260751	java.lang.StringIndexOutOfBoundsException	"ava.lang.StringIndexOutOfBoundsExceptionat java.lang.String.substring(String.java:1938)at org.aspectj.ajdt.ajc.ConfigParser.stripWhitespaceAndComments(ConfigParser.java:103)at org.aspectj.ajdt.ajc.ConfigParser.parseConfigFileHelper(ConfigParser.java:69)at org.aspectj.ajdt.ajc.ConfigParser.parseImportedConfigFile(ConfigParser.java:224)at org.aspectj.ajdt.ajc.ConfigParser.parseOneArg(ConfigParser.java:213)at org.aspectj.ajdt.ajc.ConfigP ... 82)at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55) Would have been nice to see the config file that led to this problem, but I'm guessing that you have a line with a single "" on it.  Fixed. "	2009-01-12 12:43:06	1231780000.0	resolved fixed	d9bd46d	1231800000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/ConfigParser.java
259528	[incremental] [build] Class with ITD declared on it causes too many full builds	As expected, this same behavior holds for declare @annotation and delare parents.What this means is that any class with any form of ITD on it will be perofmring way too many full builds. are you sure this is just an AJDT bug?? It is an AspectJ bug, not an AJDT one.  On the first compile loop we build the advised type (targeted by the ITD), we then look at what may need recompiling based on what we just compiled.  The aspect has a hard coded reference to the advised type so we do another compile, this time building the aspect too.  Now due to attempting an incremental build involving an aspect, we compare the possible crosscutting behaviours defined in the aspect with what it said previously (ie. whether ITDs have changed, whether declares have changed). In this problem case we report YES, something has changed.  Clearly it hasn't, but pipelining is making us think it has.  This is because early on in the pipeline we use eclipse structures to hold crosscutting information, later on these have become bcel entities.  an eclipse entity is considered to be different to a bcel entity for the purposes of the crosscutting comparison.  The code to consider these equivalent is already written in CrossCuttingMembers.replaceWith(), but it is commented out because other tests fail when it is activated.  A description of why it was initially written, with some discussion of a scenario rather similar to the one reported here is in bug 133532, comment 5.So, we need to fix this properly now. Fixed because of fixes coming in from AspectJ Move to the 2.0.2 release. When there is a structural change to a class that has an ITD on it there is a full build.  This should be an incremental build, but the compiler always drops to a full build. Created attachment 121092project that exhibits this behaviorSteps to reproduce: 1. import project2. full build3. open ajdt console4. add a method to IsAdvised class (full build)5. change a method body (no full build)6. remove ITD declared in Adivses aspect7. add a method to IsAdvised (no full build)step 4 should not cause a full build. 	2008-12-22 16:42:04	1229980000.0	resolved fixed	2b43e63	1230080000.0	tests/multiIncremental/pr259528/base/src/b/IsAdvised.java tests/multiIncremental/pr259528/inc1/src/b/IsAdvised.java
251326	Anonymous inner classes declare inside an ITD method will cause IllegalAccessError	"If i declare an aspect in pkgB, having an ITD method for a class in pkgA using an inner anonymous class, is created in the pkgA package, package protected, but then instantiated from pkgB causeing the error.Test case is attached. Created attachment 115519Patch containing testcase If the inner anonymous classes are made public (by the compiler) then this code all works fine.  It does seem unusual, but it works.  It is not dissimilar to other visibility changes that AspectJ makes during compilation (for features like privileged aspects).  Given that it is an anonymous class it won't be found by other people and so affecting the visibility doesn't seem too much of an issue.  So far I've had to make the type itself public and the generated ctor public too.  With the following changes to SuperFixerVisitor:	public boolean visit(TypeDeclaration localTypeDeclaration, BlockScope scope) {		depthCounter++;		localTypeDeclaration.modifiers = AstUtil.makePublic(localTypeDeclaration.modifiers);		localTypeDeclaration.binding.modifiers = AstUtil.makePublic(localTypeDeclaration.binding.modifiers);		localTypeDeclaration.binding.methods[0].modifiers = AstUtil.makePublic(localTypeDeclaration.binding.methods[0].modifiers);		return super.visit(localTypeDeclaration, scope);	}this was just to test things out (as I knew SuperFixerVisitor ran over the code within an ITD).  It probably needs this visitor to be generalized such that it is defined to also fix type visibility as well as super calls. testcase committed *** Bug 270339 has been marked as a duplicate of this bug. *** better variant of the fix was actually done for bug 343051fixed "	2008-10-19 15:53:28	1224450000.0	resolved fixed	f1a83b5	1228850000.0	tests/bugs163/pr251326/pkgA/Listener.java tests/bugs163/pr251326/pkgA/Target.java tests/src/org/aspectj/systemtest/ajc163/Ajc163Tests.java
185447	[plan] [ataspectj] Abstract @Aspect causing problems	"Trying to use an abstract @Aspect from a library jar file is causing problems.In the (soon to be) attached zip of eclipse projects:* logging-library: defines two abstract trivial logging aspects, one in code-style and one in @AspectJ style.* sample-system: uses the code-style abstract aspect successfully* sample-system2: uses the @AspectJ style abstract aspect and won't compile in EclipseException:java.lang.NullPointerExceptionat org.aspectj.weaver.bcel.AtAjAttributes$LazyResolvedPointcutDefinition.getPointcut(AtAjAttributes.java:1632)at org.aspectj.weaver.ShadowMunger.addChildNodes(ShadowMunger.java:258)at org.aspectj.weaver.ShadowMunger.createHierarchy(ShadowMunger.java:247)at org.aspectj.weaver.AsmRelationshipProvider.adviceMunger(AsmRelationshipProvider.java:180)at org.aspectj.weaver.Shadow.implementMungers(Shadow.java:717)a ... int;)Ljava/lang/String;                    ARETURN  end public Object run(Object[]) Created attachment 65849Eclipse projects to demonstrate problem recreated on latest dev build with this command line:ajc -emacssym -1.5 -sourceroots src -aspectpath ..\logging-library\logging-library.jarwhilst in the sample-system2 folder.  Stack trace has moved:java.lang.NullPointerException	at org.aspectj.weaver.bcel.AtAjAttributes$LazyResolvedPointcutDefinition.getPointcut(AtAjAttributes.java:1527)	at org.aspectj.weaver.model.AsmRelationshipProvider.addChildNodes(AsmRelationshipProvider.java:285)	at org.aspectj.weaver.model.AsmRelationshipProvider.createHierarchy(AsmRelationshipProvider.java:274)Problem here is the lazy resolution mechanism that is used for annotation style pointcuts does not cope well with abstract pointcuts (which have components represented by nulls).  I've fixed the code to allow for this.  Making the annotation style pointcut non-abstract also stops this happening, but isn't really a helpful workaround.  I suspect this only happens in the IDE since AsmRelationhshipProvider (present in the stack trace) wouldn't be used if everything was being built on the command line. "	2007-05-03 17:18:07	1178230000.0	resolved fixed	120b47f	1228170000.0	weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java weaver/src/org/aspectj/weaver/model/AsmRelationshipProvider.java
256400	"An internal error occurred during: ""Delete and update AspectJ markers for CoreSource""."	"this occured during a clean and build of the project i'm working on. The following was inthe details.An internal error occurred during: ""Delete and update AspectJ markers for CoreSource"".java.lang.NullPointerException I did another clean and build (without changing anything) and no more errors were encountered. Do you have a stack trace or anything? (In reply to comment #2)> Do you have a stack trace or anything?> Only what was in the details of the error dialog as stated above.""An internal error occurred during: ""Delete and update AspectJ markers forCoreSource"".java.lang.NullPointerException"" This is actually an AspectJ problem.  The problem lies here:JDTLikeHandleProvider.java : line 163the line is:if (sig1 == null && ipeSig == null || sig1.equals(ipeSig)) {but this can throw a null pointer exception.should be this instead:if ((sig1 == null && ipeSig == null) || (sig1 != null && sig1.equals(ipeSig))) {MOving this over to AspectJ. Bumping priority becuase this is an easy fix that whose consequences are large. would have liked a testcase, but I've committed the change anyway. "	2008-11-25 04:51:17	1227610000.0	resolved fixed	155a888	1227810000.0	asm/src/org/aspectj/asm/internal/JDTLikeHandleProvider.java
249710	[compiling] Problem with -XterminateAfterCompilation	I just committed a fix under another bug for a null delegate (which is the situation here too).  The problem was that the delegate was null for a type generated during the compilation process (eg. a marker interface for a perclause).  If the problems here with -XterminateAfterCompilation and -outxml also involved aspects with perclauses (or some other construct that would lead to generation of a class at compile time) then it may be the same issue here and so also resolved.Here is a program that crashes:public aspect Foo perthis(execution(* *(..))) {}ajc -1.5 -XterminateAfterCompilation -outxml Foo.javajava.lang.NullPointerException        at org.aspectj.weaver.ReferenceType.isAspect(ReferenceType.java:165)        at org.aspectj.ajdt.internal.core.builder.AjBuildManager$4.addAspectName(AjBuildManager.java:1095)        at org.aspectj.ajdt.internal.core.builder.AjBuildManager$4.acceptResult(AjBuildManager.java:1040)I've confirmed this is now fixed in AspectJ.  No dev build for a while due to test failures on the build machine (classpath related) - fix will be in next successful dev build. Reported on the mailing list by Simone:I tried disabling pipelining as described in bug 146781, that is using-Xset:pipelineCompilation=false, but unfortunately I get this errorwhile compiling with -XterminateAfterCompilation :java.lang.NullPointerException       at org.aspectj.weaver.ReferenceType.isAspect(ReferenceType.java:160)       atorg.aspectj.ajdt.internal.core.builder.AjBuildManager$4.addAspectName(AjBuildManager.java:1108)       atorg.aspectj.ajdt.internal.core.builder.AjBuildManager$4.acceptResult(AjBuildManager.java:1047)       at I've been trying to recreate this, but I can't so can't make a fix.The stack trace is from the logic driven due to -outxml being specified.  However, I have no clue why the delegate is null when isAspect() is being called against the reference type.  I have a few bugs where the delegate is unexpectedly null, I don't yet know if they all have the same root cause.I've tried combining -XterminateAfterCompilation and -Xset:pipelineCompilation=false but it doesn't fail.  Can you tell me if the code you are processing with the command that fails has already been woven in an earlier compile? Hi Andy,now that I have better knowledge of the testing system, I'll try to setup a test case.Anyway, most probably it is already pre-woven with other aspects. It is inside a maven build of multiple modules, all having aspects.Removing -outxml works like a charm. 	2008-10-05 18:24:39	1223250000.0	resolved fixed	cffe291	1225310000.0	tests/bugs163/pr249710/Foo.java tests/src/org/aspectj/systemtest/ajc163/Ajc163Tests.java
186884	Unhandled Kind of New Exception when have advice for Pointcut call(Throwable+.new(..))	<Pyinson Data Over Head> Created attachment 67138Reproducible bug test caseTest case to reproduce the bug thanks for that clear way to reproduce it.  Looks like an unusual bytecode sequence AspectJ had not encountered before so I've allowed it through by making changes to AJ. 	2007-05-14 17:02:02	1179180000.0	resolved fixed	7a398a2	1222820000.0	weaver/src/org/aspectj/weaver/bcel/BcelShadow.java
192877	[ataspectj] @AspectJ style inter-type declaration causes false compiler error during incremental build	"Build ID: M20070212-1330Steps To Reproduce:Use @DeclareParents to introduce a default interface implementation to an existing type.  A full build compiles cleanly and works as expected.  An incremental build causes the following type of compile error: ""The type FooImpl must implement the inherited abstract method Test.methodA()"".  In this example FooImpl is the class we are introducing a default implementation of the Test interface which defines the method ""methodA"".More information:See attached zip for a complete set of files to reproduce.I can repoduce this bug with AJDT 1.4.2.200705221209 for Eclipse 3.2.2 as well as AJDT 1.5RC1 for Eclipse 3.3RC1 Created attachment 71457Contains source files to reproduce the bug Passing over to the compiler check in 1.5.4 timeframe fixed by other changes - have added attached testcase to test suite. "	2007-06-15 09:57:08	1181920000.0	resolved fixed	9b68a31	1222810000.0	tests/multiIncremental/PR192877/base/src/DefaultTestImpl.java tests/multiIncremental/PR192877/base/src/Foo.java tests/multiIncremental/PR192877/base/src/FooImpl.java tests/multiIncremental/PR192877/base/src/Test.java tests/multiIncremental/PR192877/base/src/TestAspect.java tests/multiIncremental/PR192877/inc1/src/Test.java tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java
245734	AJDT throws a RuntimeException from EclipseResolvedMember.getAnnotations	Build ID: N/ASteps To Reproduce:This exception is happening for us in both Eclipse 3.4 and 3.3 when we run an incremental build on one of our projects.We are using an aspect to declare an annotation on a class in the project, and we only started seeing this exception after we added it.  A clean build on the project never throws the exception, only an incremental build.More information:The Exception Stack Trace:java.lang.RuntimeExceptionat org.aspectj.ajdt.internal.compiler.lookup.EclipseResolvedMember.getAnnotations(EclipseResolvedMember.java:78)at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.doDeclareAnnotations(AjLookupEnvironment.java:794)at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:592)at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironmen ... at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)Compile error: RuntimeException thrown: not yet implemented - please raise an AJ bugI was going to include the AJDT Event log for the build but it is very long, and mostly unremarkable, so I have included only the section for the project where the exception was thrown.11:9:50 Build kind = INCREMENTALBUILD11:9:50 Project=ICODES, kind of build requested=Incremental AspectJ compilation11:9:50 build: Examined delta - source file changes in required project ICODES11:9:51 Found state instance managing output location : C:\jnaylor\Java_Dev\workspace\ICDM11:9:51 Failed to find a state instance managing output location : C:\jnaylor\Java_dev\workspace\Dependencies\MARVEL\resources11:9:51 Failed to find a state instance managing output location : C:\jnaylor\Java_Dev\workspace\GSG11:9:52 Failed to find a state instance managing output location : C:\jnaylor\Java_dev\.build\Launch4J11:9:52 Preparing for build: planning to be an incremental build11:9:52 Starting incremental compilation loop 1 of possibly 511:9:52 AJDE Callback: finish. Was full build: false11:9:52 Timer event: 2172ms: Total time spent in AJDE11:9:54 Timer event: 47ms: Create element map (0 rels in project: ICODES)11:9:54 Types affected during build = 011:9:54 Timer event: 0ms: Add markers (0 markers)11:9:54 Timer event: 3735ms: Total time spent in AJBuilder.build()11:9:54 ===========================================================================================This is occurring frequently, but not every time so we haven't been able to narrow down a reasonable sized test case. An AspectJ problem Can you give me a definition of your annotation (fields and their types and any default values) - and the declare @type statement?you may be able to work around it by turning off pipeline compilation. (In reply to comment #2)> Can you give me a definition of your annotation (fields and their types and any> default values) - and the declare @type statement?>Annotation Def:@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface Subscribable { }Declare statement:declare @type: Cargo : @Subscribable; > you may be able to work around it by turning off pipeline compilation.No dice.  This is causing us considerable delays now.  I'm going to try and produce a small scale test for this. let me know how you get on, I cannot recreate it.  I have an annotation, a class and an aspect doing declare @type of the anno onto the class.  I've tried incremental builds where I just change each of the 3, and it always works.  I've no doubt there is an issue, but can't see what is triggering it. Created attachment 113182Small testcase that can reproduce the bug.The project zipped up in this file can reproduce the bug:Steps to reproduce:Get the project into eclipse.1. Turn off automatic build.2. Clean the project ( or make sure it is clean )3. change the import in class generated.C to fakepackage.B4. build the project.5. change the import back to realpackage.B6. build the project. (In reply to comment #6)Note: I have only tested these steps in Eclipse 3.3.2, not 3.4 I just tried with that sample as a testcase (it didnt fail...) so I imported it into my eclipse (3.4) and it didnt fail, so I fired up my eclipse 3.3 build that has the latest dev build of AJDT installed (1.5.4.200809111249 it seems) and it didnt fail in there either.On changing it to 'fakepackage' and forcing the build, I get 9 errors, but when I change it back to realpackage, they disappear and it builds OK.  I've decided to change the AspectJ code to plug in the necessary annotation transform code rather than just throwing the exception for which this bug was originally raised.  The annotation transform code does not handle all cases (the intent is to cover them as they crop up since there are so many to deal with) - but it already handles many straightforward cases.  This change passes all my tests so I have committed it.  I wish I could recreate this scenario to know it would help you though.But... I am currently only committing changes into Eclipse 3.4 AJDT - commits into Eclipse 3.3 aren't happening frequently right now and the interface between ajdt/aspectj has changed in the 3.4 stream so some AJDT changes will need backporting to AJDT on Eclipse 3.3 in order to allow me to drop in a new AspectJ.  I'd planned on doing that once 1.6.2 went out (a weeks time).However, if you could confirm it fails for you in the Eclipse 3.4 right now, then that might be a way to confirm my proposed fix addresses it, and then I'll know it is definetly worthwhile putting a new AspectJ into Eclipse 3.3 AJDT sooner rather than later. Sorry for all the trouble here. I hadn't updated to the latest dev build for eclipse 3.3.  The latest one no longer reproduces this problem.  Eclipse 3.4 threw a different exception for us (a NPE with almost the same stack trace) with the release version, but the dev build no longer reproduced.  And here I was so happy I finally got a small test case for it. I guess this bug can be closed at least until I see it crop up again. ;)  (In reply to comment #8) I wonder what my fix does then ;)closing for now. 	2008-08-29 14:27:06	1220030000.0	resolved fixed	f376a21	1222130000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseResolvedMember.java
246021	FindBugs reporting another optimization	"Ben Hale reported that FindBugs was producing a warning about a dead store to a local variable (a variable that is never then read within the method).  This bug is to investigate and hopefully remove the dead store. Whenever a join point shadow is advised by some advice, we look at the advice and see if it uses any of the available arguments exposed by the join point.  In a simple case, for example, the arguments for the method-execution join point are those being passed to the method.  If any arguments are used by the advice, then we copy all of them to other local variables and use those copies as arguments to the advice call.  We copy them because we do not want any changes made by another piece of advice at the same join point to affect what our advice sees. Here is an example:aspect X {  before(Object o): execution(* foo(*,*)) && args(*,o) {  }  public void foo(String s, StringBuffer t) { }}So the second parameter at the execution join point is exposed and passed to the advice.  The bytecode for foo() looks like this:  Code:   Stack=2, Locals=5, Args_size=3   0:   aload_1   1:   astore_3   2:   aload_2   3:   astore  4   5:   invokestatic    #58; //Method aspectOf:()LX;   8:   aload   4   10:  invokevirtual   #60; //Method ajc$before$X$1$fb064c60:(LObject;)V   13:  returnThe pairs of calls ""aload_1/astore 3"" and ""aload_2/astore 4"" copy the method parameter values into local variables 3 and 4.  Then variable 4 is used as the advice parameter (see instruction 8, 'aload 4').Currently all the arguments are initialized and copied in this way regardless of whether they are used by the advice.  A tool being picky over the above valid code would say that the 'astore_3' is a waste since it is never used - and so consequently the 'aload_1' is a waste as well.  That is what FindBugs is reporting.AspectJ has done this since the beginning of time.  However, there is clearly scope for some optimization to copy only the arguments that the advice needs.  This is not entirely trivial as the argument setup code is a little divorced from the advice invocation code.However, I've now implemented it.  Using the new code, if I compile the program above I get a new version of the foo() method:  Code:   Stack=2, Locals=4, Args_size=3   0:   aload_2   1:   astore_3   2:   invokestatic    #58; //Method aspectOf:()LX;   5:   aload_3   6:   invokevirtual   #60; //Method ajc$before$X$1$fb064c60:(LObject;)V   9:   returnwhere only the argument used is copied. fix committed. should generate much neater code in quite a few situations. "	2008-09-02 18:22:57	1220390000.0	resolved fixed	78a483d	1220400000.0	weaver/src/org/aspectj/weaver/bcel/BcelShadow.java
244321	I cannot aspect code written in SJPP-based encoding	"Created attachment 110112sjpp.jar to parse encodingI cannot aspect code written in SJPP-based encodingHowever, I *can* compile the code fine:-  if I remove Aspect nature from my project, or-  using command line ajc (of slightly newer version of AspectJ). i.e.,      ajc.bat -J-Dpp.charset=%USERPROFILE%\pp.charset.properties -encoding MY_ENCODING -d out ...Adding ""-encoding MY_ENCODING"" to AspectJ non-standard compiler options did *not* help.source code: ------------public class Foo {   public static void main(String [] args) {#ifdef A_MACRO      System.out.println(""ok!"");#endif   }}errors reported by ""Problems"" view:-----------------------------------	Severity and Description	Path	Resource	Location	Creation Time	Id	A_MACRO cannot be resolved to a type	encoded/src	Foo.java	line 3	1218821924326	474099	out cannot be resolved	encoded/src	Foo.java	line 4	1218821924326	474101	Syntax error on token ""."", ; expected	encoded/src	Foo.java	line 4	1218821924326	474100	Syntax error on token ""Invalid Character"", @ expected	encoded/src	Foo.java	line 3	1218821924326	474098	Syntax error, insert "";"" to complete Statement	encoded/src	Foo.java	line 4	1218821924326	474102project encoding:-----------------	Set to: MY_ENCODING%USERPROFILE%/pp.charset.properties:------------------------------------	charset = MY_ENCODING	MY_ENCODING.defines = A_MACROMy Eclipse environment is:--------------------------*	Eclipse AspectJ Development Tools	Version: 1.5.2.200804241330	AspectJ version [for Eclipse]: 1.6.0.20080423100000*	AspectJ version [for ajc]: AspectJ Compiler 1.6.1 (1.6.1 - Built: Thursday Jul 3, 2008 at 18:35:41 GMT) - Eclipse Compiler 0.785_R33x, 3.3*	Eclipse v3.3.2 M20080221-1800*	C:\jdk1.5\jre\lib\ext\sjpp.jar (see attached) Thanks for the clear report.  I've modified the compiler to allow the '-encoding MY_ENCODING' setting to get through from the non-standard compiler options for a project to the AspectJ compiler.  This fixes it.I could respect the project property setting for encoding but that would be more work and with this change you are going to be able to work OK. "	2008-08-15 13:54:43	1218820000.0	resolved fixed	d5c2ead	1220040000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
216067	Typo in point example	"Build ID: 3.3.1.1Steps To Reproduce:1. Install AspectJ2. Navigate to the examples/introduction directory3. Method in Point.javaMore information:protected void makeRectangular(){      if (!rectangular) {	 x = rho * Math.sin(theta);	 y = rho * Math.cos(theta);	 rectangular = true;      }   }x and y should be interchanged in the method above, mathetimatical definition. For reference: http://en.wikipedia.org/wiki/Trigonometric_function .. please look at Right Triangle Definitions. fixed in AspectJ HEAD - will be in next build "	2008-01-21 21:05:25	1200970000.0	resolved fixed	6d906dc	1219260000.0	docs/dist/doc/examples/introduction/Point.java
238666	Allow the ltw configuration to be directly specified rather than discovered on the classpath	Currently the property:org.aspectj.weaver.loadtime.configurationcan be set to name the ltw configuration file that the loadtime weaver searches for.  The default value is:META-INF/aop.xml;META-INF/aop-ajc.xml;org/aspectj/aop.xmland the weaver searches the classpath for .xml files matching any of those three possibilities.A typical override might therefore be:-Dorg.aspectj.weaver.loadtime.configuration=META-INF/overhere.xmlhowever the weaver will still only look for it on the classpath.In some environments the ltw user may just want to name the aop config file to use, and not be forced to include it on the classpath.We have had the suggestion to make it protocol based, which i like, but for now I would just allow support for 'file:'.  If file: is the prefix, it will be treated as direct reference to the file to use, otherwise it will be searched for.This change would mean all existing uses of the override will be fine, but new users will be all to exploit the flexibility of naming their configuration directly. Created attachment 105948Patch for loadtime moduleThis patch to loadtime introduces the behaviour discussed.  The configuration option now supports 'file:' prefixed references directly to files that do not have to be on the classpath.  The configuration parameter is still a semi-colon separate list however. So all these work:aj5 -Dorg.aspectj.weaver.loadtime.configuration=file:c:\aspectj161-dev\doc\examples\someotherplace\foo.xml HelloWorldaj5 -Dorg.aspectj.weaver.loadtime.configuration=file:../someotherplace/foo.xml HelloWorldaj5 -Dorg.aspectj.weaver.loadtime.configuration=file:c:\aspectj161-dev\doc\examples\someotherplace\foo.xml;aop.xml HelloWorldIn the final case the foo.xml will be loaded directly and then aop.xml will be searched for on the classpath. enhancement committed - will be in 1.6.2 	2008-06-26 15:05:26	1214510000.0	resolved fixed	df49b5c	1218050000.0	loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java
229829	SourceTypeBinding.sourceStart() NPE	java.lang.NullPointerExceptionat org.aspectj.org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.sourceStart(SourceTypeBinding.java:1514)at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.MethodBinding.sourceStart(MethodBinding.java:988)at org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.fillDeclaredMembers(EclipseSourceType.java:243)at org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.getDeclaredFiel ...                     IRETURN  end public boolean isTracingModifications()end public class com.centricsoftware.pi.core.data.reflection.Attribute When change some jave file that had some syntax error, the exception happend. I get this intermittently, after I save a Java file, slightly different stack trace but it looks similar to mejava.lang.NullPointerExceptionat org.aspectj.org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.sourceStart(SourceTypeBinding.java:1514)at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.MethodBinding.sourceStart(MethodBinding.java:992)at org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.fillDeclaredMembers(EclipseSourceType.java:255)at org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.getDeclaredMeth ...  access$0(com.racediary.gui.preferences.GoogleCalendarPreferencePage)Is this the same as bug 242200?I'm on Version: 3.4.0, Build id: I20080617-2000 with AJDT Version: 1.6.0.200807041530 and AspectJ version: 1.6.1.20080703120000.Cheers Created attachment 108534More detailed Eclipse error log More details eclipse error log *** Bug 242200 has been marked as a duplicate of this bug. *** Fix for this is now in AspectJ.  Fix will be in AJDT for Eclipse 3.3 shortly (AJDT 1.5.4 dev builds).  It should also be in the next AJDT for Eclipse 3.4 build, but that may not happen for a few days. fix available *** Bug 248446 has been marked as a duplicate of this bug. *** Is the fix available for Eclipse 3.3? Where can I donwload it? The last version a see on eclipse.org is 1.5.3. I can't find version 1.5.4 for Eclipse 3.3(In reply to comment #6)> fix available>  The latest dev builds of ajdt for eclipse 3.3 are at the update site: http://download.eclipse.org/tools/ajdt/33/dev/updateLinked under the 'Development builds for Eclipse 3.3' section of the ajdt download page. 	2008-05-01 14:00:27	1209660000.0	resolved fixed	e9823aa	1217350000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java
237962	[migration] Unexpected problem loading an aspect built with 1.5.4	"We always support processing of old aspects.  It doesn't matter what level of AspectJ was used to build an aspect, as long as you use that version or a later version of the weaver, we can unpack it and don't require it to be rebuilt from source.  However, I've just encountered a .class apparently built with 1.5.4 that 1.6.1 cannot load.  It crashes deserializing a PointcutDeclaration.In the data stream we have just read the numbers 1 and 3 indicating 'kinded pointcut' and then 'method-execution' and the next digit is a 0 when it should be 1-9.  We crash with a:org.aspectj.weaver.BCException: weird kind 0when batch building BuildConfig[null] #Files=43	at org.aspectj.weaver.MemberKind.read(MemberKind.java:35)	at org.aspectj.weaver.patterns.SignaturePattern.read(SignaturePattern.java:682)The memberkind is a typesafeenum and so can never be other than 1-9.  It is the first part of a signaturepattern so hard to see how it got written out 'wrong' right now.I've been told 1.5.4 can load this, so about to try that. Wow....1.5.4 did load it back in, how the hell.I suspect we aren't consuming enough in 1.6.1 which then leaves us some extra that we interpret as a rogue pointcut.Ok, in a comparison we consume one extra byte from the stream when reading it with 1.6.1 that we do not consume with 1.6.0 - at position 260.As I got closer to it, I knew what it would be - especially when I knew it was just one byte difference.  The version check for whether the byte for 'annotation pattern relates to a parameter match' was wrong (urgh). fixes committed. "	2008-06-20 13:07:32	1213980000.0	resolved fixed	be03167	1213980000.0	weaver/src/org/aspectj/weaver/patterns/AndAnnotationTypePattern.java weaver/src/org/aspectj/weaver/patterns/NotAnnotationTypePattern.java weaver/src/org/aspectj/weaver/patterns/OrAnnotationTypePattern.java weaver/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java
203367	ITD of interface on generic type; can't match calls to methods on interface+	"Build ID: I20070621-1340Steps To Reproduce:package bug;  // I used a ""bug"" package under the ""src"" source folder.public aspect CantMatchOnInterfaceIntroducedToGenericClass {	public static interface Marker {}	public static class NonGenericClass {		public void doit(String msg) {			System.out.println(""doit(): msg = ""+msg);		}	}	public static class GenericClass<T> {		public void doit(T t) {			System.out.println(""doit<T>(): t = ""+t);		}	}		declare parents: NonGenericClass implements Marker;	declare parents: GenericClass    implements Marker;		pointcut nonGenericCall(): call (void NonGenericClass.doit(..));	pointcut genericCall():    call (void GenericClass.doit(..));	pointcut markerCall():     call (void Marker+.doit(..));		before(): nonGenericCall() {		System.out.println(""nonGenericCall: ""+thisJoinPointStaticPart);	}	before(): genericCall() {		System.out.println(""genericCall: ""+thisJoinPointStaticPart);	}	before(): markerCall() {		System.out.println(""markerCall: ""+thisJoinPointStaticPart);	}		public static void main(String args[]) {		new NonGenericClass().doit(""message1"");		new GenericClass<Integer>().doit(new Integer(2));	}}More information:The code pasted in the ""steps"" demonstrates the bug. Compiled and executed this agains AspectJ 1.5.4. Havent seen any bugs.(On Windows + Eclipse 3.3) thanks for the info Michael Added as testcase to 1.6.1.  I changed it slightly to throw an exception if the advice attached to Marker+ does not execute twice in the main() method.  Otherwise it never actually 'fails' but you just have to know that it should print marker advice is reached twice.Without that change, this does compile and run on 1.5.4, it just doesn't do the right thing.  All fixed now in 1.6.1 "	2007-09-13 17:23:51	1189720000.0	resolved fixed	11ebdd8	1213680000.0	tests/bugs161/pr203367/CantMatchOnInterfaceIntroducedToGenericClass.java tests/src/org/aspectj/systemtest/ajc161/Ajc161Tests.java
155347	NPE during compilation of class file with pointcuts	I commented out a static nested aspect inside a class to let me do a rename refactoring in Eclipse. This results in the following exception, which even a full rebuild won't fix. The class does have pointcut definitions inside of it. Commenting those out avoids the problem (though it caused other syntax errors...)java.lang.ArrayIndexOutOfBoundsExceptionat org.aspectj.weaver.patterns.IfPointcut.findResidueInternal(IfPointcut.java:186)at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:269)at org.aspectj.weaver.patterns.AndPointcut.findResidueInternal(AndPointcut.java:93)at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:269)at org.aspectj.weaver.patterns.AndPointcut.findResidueInternal(AndPointcut.java:93)at or ... ses when weaving when batch building BuildConfig[C:\devel\glassbox\.metadata\.plugins\org.eclipse.ajdt.core\glassboxAgent.generated.lst] #Files=210 The file does have an .aj extension Could you post the testcase. I'll work on narrowing it down, but probably won't have time until next week. quick look for 1.5.4 added guard to fire if we ever see this again and include a bit more context in the error message. 	2006-08-27 18:46:07	1156720000.0	resolved fixed	248962b	1213130000.0	weaver/src/org/aspectj/weaver/patterns/IfPointcut.java
227295	AJC error, somehow connected with generics	"Build ID: 1.5.0.20070607Steps To Reproduce:I cannot find a way to reproduce it, it's somehow ""randomic"", for example it happened to me now while creating a new class in an aspectj project, but when i then saved the .java it compiled properly. That's why I'm filing it in AJDT and not in AspectJ directly.Based on the exception, IIUC, there is a narrowing in a generic (UnresolvedType should be something like Converter<?>, while BoundedReferenceType should be somethinf like Converter<? extends Number>), and the weaver is not handling it properly, but simply casting from one to the other .. but this are just silly assumptions.More information:java.lang.ClassCastExceptionat org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding1(EclipseFactory.java:656)at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding(EclipseFactory.java:579)at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding1(EclipseFactory.java:640)at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeTypeBinding(EclipseFactory.java:579)at org.asp ... Worker.java:55)Compile error: ClassCastException thrown: org.aspectj.weaver.UnresolvedType cannot be cast to org.aspectj.weaver.BoundedReferenceType This is connected to partial builds:- it happened always after saving a modified file (even if that file is a class,not an aspect, even if that class is not weaved by any aspect)- it always happens on an aspect- a full clean and rebuild of the project always fixes itI get this error about three times per hour, would say once every 4 modifications to the code base. <Pyinson Data Over Head> transferring to compiler Hard to address without a testcase.  I have been working on the wildcard generics support and introduced a brand new type that represents unresolved wildcarded types (rather than mixing it all up in UnresolvedType) - this may help in this situation.  So I have reworked the code that fails with classcast to do the right thing depending on the incoming type or report an error about what it has encountered if it is something unexpected (rather than failing with a CCE).  So this exception cant happen any more - and we should get more diagnostics if something goes wierd in the future.Fix will be in next dev build. "	2008-04-16 06:24:42	1208340000.0	resolved fixed	3b2109a	1212780000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java
233497	StringIndexOutOfBoundsException thrown in BcelWeaver	"I do agree that it is a bit odd that the package specification of an aspect does not need to be mirrored in its directory structure. For some time, this has caused some significant confusion when moving aspects by hand rather than using Eclipse's refactoring support (which happened in this case). We ended up moving aspects but not altering their package declarations appropriately. As a practice, we try to mirror the package and directory structures but somehow this fell through the gap. Is there any particular reason why the AJDT support for refactoring seems to be so poor?On the issue of using a package prefix in the aspectPath. Here is the reason why I have done that. In Eclipse, suppose project A depends on project B and also wants to add project B's classes to its aspectPath. Also, assume that the project source and output folders are the same. I would go to the aspectPath and try to add a class folder for Project B in the properties of project A. However, since this would automatically add a Java library entry to project A it conflicts with the project dependency between them. In short, I don't want to use that prefix, but have found that I need to do it in order to add the project to the aspectPath.As far as pipelining compilation, it doesn't seem to directly have any issues, but from time to time we get exception during AJDT's build, like the following (which I have yet investigate or report):java.lang.NullPointerExceptionat org.aspectj.org.eclipse.jdt.internal.compiler.lookup.SyntheticMethodBinding.<init>(SyntheticMethodBinding.java:422)at org.aspectj.ajdt.internal.compiler.lookup.SimpleSyntheticAccessMethodBinding.<init>(SimpleSyntheticAccessMethodBinding.java:30)at org.aspectj.ajdt.internal.compiler.lookup.InterTypeFieldBinding.<init>(InterTypeFieldBinding.java:47)at org.aspectj.ajdt.internal.compiler.lookup.EclipseTyp ... oBuildJob.run(AutoBuildJob.java:235)at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)Compile error: NullPointerException thrown: nullWe just have not taken it out of our builds yet because it appears more consistent and consistency overrides build time/memory. BTW, thanks for fixing that generics bug with the BCEL and pipelining a while back.As a final note. I want to sincerely thank you and the AspectJ team for your help. If it weren't for your timely help in fixing bugs and providing clarification to our dev members (like myself and Jason Naylor), we would have had to give up on using AspectJ in our product long ago. But we really find AOP a solution to many of the problems we have encountered in the past 10-15 years of development. We really appreciate your hard work. > Is there any particular reason why the AJDT support> for refactoring seems to be so poor?Really it is because we try and play in the JDT world in areas where they don't have extension points in place and some of the tricks we have to play on JDT aren't reliable.  However, I have some new resource working on AJDT now which should see if we can finally crack some of these problems properly.On the aspectpath thing, I am certainly not saying that using that package prefix in the aspectpath is wrong, it is just unusual and I hadn't seen it done before.The benefits of pipelining do come with a cost, it is certainly a much more complicated compilation process and still has a few errors in it. Like the one you mentioned. org.aspectj.org.eclipse.jdt.internal.compiler.lookup.SyntheticMethodBinding.<init>(SyntheticMethodBinding.java:422)atif you do get round to reporting that properly i will take a look.  It looks like the use of ITD fields and annotations could lead to it.> We really appreciate your hard work.thanks, your kind words are appreciated :)  I just happen to have done a build of AJDT today to pick up another fix and so that AJDT will also include the fix for the exception this bug was raised for. <Pyinson Data Over Head> As you say, the problem is when the path name to an aspect does not include the typename in it.  Do you happen to know what this might be in your case?Are you using softlinks or anything?  What is the name of your aspect - anything unusual?  Presumably it is something within the directory:C:\mhuffman\Java_Dev\Trunk\workspace\ICODES\comis com part of the package declaration for the types within it?Actually I have just recreated your crash, but in an unusual way.I have two files, A.java (an aspect in package a.b.c) and a C.java (a class in no package).I compiled A.java in some locationajc A.javathis produced A.class but not in the sub-directory a/b/c because ajc won't do that unless -d <directory> is specified.I then compiled C.java with an aspectpath pointing to where A.class was.  Of course, when the class file was opened, the typename was discovered to be 'a.b.c.A' and the attempt to find that in the path to A.class failed.How do you compile the aspects that go into your aspectpath? I am not exactly sure why this is the case. We recently had a configuration that used inpaths but want the behavior of the aspectPath instead. None of the names of the aspects have changed. The names of the aspects are simple names, meaning they don't have special symbols. These are the names of the aspects in ICODES\com:AccessAspect.ajItemAspect.ajAgentManagerAspect.ajConveyanceAspect.ajStowableItemAspect.ajAccessAspect.ajAmmoAspect.ajAssociationAspect.ajBreakbulkAspect.ajCargoAspect.ajContainerAspect.ajVehicleAspect.ajViolatorAspect.ajYes, com is part of the package declaration for each of these aspects. I do this because there is a project dependency between the projects and thus cannot select the project root (source folder) as the class folder of the aspectPath.I compile the aspects in the aspectPath without a directory (i.e. ""destDir""). Here is an excerpt from my build files:      <iajc source=""1.5"" Xlint=""ignore"" X=""set:pipelineCompilation=false"">         <sourceroots>            <pathelement location=""${workspace.dir}\ICODES""/>         </sourceroots>         <classpath>            <path refid=""GSG.classpath""/>            <path refid=""ICDM.classpath""/>            <path refid=""ICODES.classpath""/>            <path refid=""ISF.classpath""/>         </classpath>                    </iajc>I assume that without destDir specified, the class files will be placed directly next to their sources (as destDir is optional). Am I mistaken? How is the argument ""-d <directory>"" specified? I assume that this is something abstracted by paths constructed in AJDT, so I don't know if I am missing something when compiling/weaving from iajc.I tried explicitly specifying a destDir and it appears to have avoided the exception. Is this a misuse of the iajc task? Perhaps I don't understand the destDir adequately when used in conjunction with the aspectPath. If I want to compile multiple sourceRoots using the aspects compiled in the previous task, like below, how would I go about specifying a destDir? Do I need to compile each source root independently?      <iajc source=""1.5"" <!-- DEST DIR??? --> Xlint=""ignore"" X=""set:pipelineCompilation=false"">         <sourceroots>            <pathelement location=""${workspace.dir}\Air_Domain""/>            <pathelement location=""${workspace.dir}\Personnel_Domain""/>            <pathelement location=""${workspace.dir}\Rail_Domain""/>            <pathelement location=""${workspace.dir}\Ship_Domain""/>            <pathelement location=""${workspace.dir}\Yard_Domain""/>         </sourceroots>         <!-- Use an aspect path so that all domains have the ICODES aspects applied/woven into them -->         <aspectPath>            <pathelement location=""${workspace.dir}\ICODES\com""/>         </aspectPath>         <classpath>            <path refid=""GSG.classpath""/>            <path refid=""ICDM.classpath""/>            <path refid=""ISF.classpath""/>            <path refid=""ICODES.classpath""/>            <!-- Domains -->            <path refid=""Air_Domain.classpath""/>            <path refid=""Personnel_Domain.classpath""/>            <path refid=""Rail_Domain.classpath""/>            <path refid=""Ship_Domain.classpath""/>            <path refid=""Yard_Domain.classpath""/>         </classpath>                    </iajc> > I assume that without destDir specified, the class files will be placed> directly next to their sources (as destDir is optional). Am I mistaken? How is> the argument ""-d <directory>"" specified? I assume that this is something> abstracted by paths constructed in AJDT, so I don't know if I am missing> something when compiling/weaving from iajc.You aren't mistaken, at least in terms of command line compiler behaviour.  No -d means javac and ajc will put the class file alongside the .java fileBut I think it is a bit of a quirk that AspectJ allows class files in directories to be loaded and usable but does not require the path to them includes their package prefix.  For a java class a.b.c.A you cannot run it just by being in the directory where A.class is and typing java a.b.c.A or java A.  I would probably recommend that the package structure is respected and so the builds place the .class files in the tree structure that mirrors the package structure (so using a destination directory).So in your case use destdir when building the aspects code into ICODES.<iajc destDir = ""${workspace.dir}\ICODES"" ...It is unusual to see the first part of the package prefix in an aspectpath entry, but it will work.  I'd rather build the aspects into a new folder and consume them from there.You *could* change it so destdir was ICODES/aspectbinand then use ICODES/aspectbin as your aspectpath entry for the last stage.I also note you turn off pipelineCompilation - do you still need to do that?  It is unrelated to this bug but will consume a ton more memory if you turn it off. I've put in the change to cope with not finding the typename in the file path.In tolerating this situation, the only problem I can think will occur later isthat weave messages may include the prefix in the filename embedded in them i believe this fix is now in the latest AJDT. "	2008-05-22 13:12:59	1211480000.0	resolved fixed	93b7bed	1211480000.0	weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java
232712	ClassFormatError during LTW using annotation approach	"The following exception is obtained when using the annotation approach and load-time weaving:[AppClassLoader@1f12c4e] info AspectJ Weaver Version 1.5.4 built on Thursday Dec 20, 2007 at 13:44:10 GMT[AppClassLoader@1f12c4e] info register classloader sun.misc.Launcher$AppClassLoader@1f12c4e[AppClassLoader@1f12c4e] info using configuration /H:/temp/aspectj_bug/scratch/classes/scratch/aop/annotationbug/aspect/aop-bug.xml[AppClassLoader@1f12c4e] info register aspect scratch.aop.annotationbug.aspect.BugAspectdoSomething()Exception in thread ""main"" java.lang.ClassFormatError: Code attribute in native or abstract methods in class file scratch/aop/annotationbug/extra/SubClass	at java.lang.ClassLoader.defineClass1(Native Method)	at java.lang.ClassLoader.defineClass(ClassLoader.java:620)	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:124)	at java.net.URLClassLoader.defineClass(URLClassLoader.java:260)	at java.net.URLClassLoader.access$000(URLClassLoader.java:56)	at java.net.URLClassLoader$1.run(URLClassLoader.java:195)	at java.security.AccessController.doPrivileged(Native Method)	at java.net.URLClassLoader.findClass(URLClassLoader.java:188)	at java.lang.ClassLoader.loadClass(ClassLoader.java:306)	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:276)	at java.lang.ClassLoader.loadClass(ClassLoader.java:251)	at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:319)	at scratch.aop.annotationbug.extra.BugOther.getSubClass(BugOther.java:22)	at scratch.aop.annotationbug.main.BugMain.somethingElse(BugMain.java:36)	at scratch.aop.annotationbug.main.BugMain.doSomething(BugMain.java:30)	at scratch.aop.annotationbug.main.BugMain.execute(BugMain.java:24)	at scratch.aop.annotationbug.main.BugDriver.doExecute(BugDriver.java:27)	at scratch.aop.annotationbug.main.BugDriver.main(BugDriver.java:21)The same advice logic does not result in a ClassFormatError when using the Aspect approach, it only appears using the annotation approach.Unfortunately we have not been able to track down exactly why the above Error occurs but have attached a test case that manifests it.To run simply use the runtime configuration on the BugDriver main():-Dorg.aspectj.weaver.loadtime.configuration=""scratch/aop/annotationbug/aspect/aop-bug.xml""Along with the AspectJ Load-Time Weaver Agent.The above occurs with both AspectJ 1.5.4 and AspectJ 1.6.0. Interestingly when using the aspectj 1.6.0 weaver, the AppClassLoader log still indicates ""1.5.4"". Created attachment 100841Sample eclipse project that illustrates the bug Problem is related to usage of clone() in SubClass - the bridge method for clone that returns Object rather than SubClass has the native modifier on (and a method body) - hence the error.  When creating bridge methods we should remove the native modifier.However - there are two interesting future investigations I will put in another bug:1. Why does the class file get opened for sticking a bridge method in for the annotation style case and not code style.2. Why does the method need adding by the weaver when the compiler will have already done it, since the aspect does not do anything that would require new bridge methods.I've raised the new issues in bug 233032.  The change that causes a ClassFormatError in this case has been committed, should be in a dev build later today.thanks for the testcase! *** Bug 216754 has been marked as a duplicate of this bug. *** "	2008-05-18 17:23:43	1211150000.0	resolved fixed	f014275	1211310000.0	weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java
231467	Cant Compile new Statement for the Generic Class	<Pyinson Data Over Head> Any chance of providing a sample of the kind of code that leads to this exception? Created attachment 996512 Eclipse Project with reproHello,There are 2 Main Classes with the same code in 2 Eclipse projects:   com.centricsoftware.pi.core.test.Main (compiles fine)   com.centricsoftware.pi.module.test.Main (compiler Exception) There are no aspects in both sample projects, but there are in real one. So project settings and dependency are essential. As I played around with the code, I find that the problem is caused by Matrix class that is using 'int[]' as a generic parameter for his super class. If the generic parameter is simple Object(like Integer, String, etc.) then compiler works fine. thanks for the testcode, that really helped!Fix committed into AspectJ (in TypeFactory.createTypeParams()) - will be in AJDT later today.You are correct that it happens when a primitive array is used as a type parameter - but a few other conditions had to be met too before it would trigger the problem, and I managed to work those out from your test code.  	2008-05-11 12:48:06	1210520000.0	resolved fixed	a8739e3	1210710000.0	weaver/src/org/aspectj/weaver/TypeFactory.java
209372	Compile error: IllegalArgumentException thrown: negative line: -1	If line numbers have not been added to the generated class files the following exception is thrown:java.lang.IllegalArgumentExceptionat org.aspectj.bridge.SourceLocation.validLine(SourceLocation.java:41)at org.aspectj.bridge.SourceLocation.<init>(SourceLocation.java:96)at org.aspectj.bridge.SourceLocation.<init>(SourceLocation.java:85)at org.aspectj.bridge.SourceLocation.<init>(SourceLocation.java:70)at org.aspectj.ajdt.internal.core.builder.EclipseSourceContext.makeSourceLocation(EclipseSourceContext.java:57)at org.aspectj.we ... reUtility.java:155)at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)Compile error: IllegalArgumentException thrown: negative line: -1An easy way to reproduce the problem is to uncheck the corresponding checkbox in the Classfile Generation section of the Java Compiler options in Eclipse.  A full build is performed during which an AspectJ Internal Compiler Error is thrown.My Eclipse feature version is org.eclipse.ajdt_1.5.0.200706070619. I have also run into the same exception. After cleaning the project eclipse would proceed to rebuild. Once the rebuild was complete it wouldn't throw the exception right away but, if you waited a good 30 seconds or so the window would pop up with this exception. I also noticed if I modified an aspect and rebuilt either automatically or by hand it would throw the exception while it was building, so it appears it is some sort of an issue not with the initial build but with any following builds. Has this issue been explored since the original bug was posted?java.lang.IllegalArgumentExceptionat org.aspectj.bridge.SourceLocation.validLine(SourceLocation.java:41)at org.aspectj.bridge.SourceLocation.<init>(SourceLocation.java:96)at org.aspectj.bridge.SourceLocation.<init>(SourceLocation.java:85)at org.aspectj.bridge.SourceLocation.<init>(SourceLocation.java:70)at org.aspectj.ajdt.internal.core.builder.EclipseAdapterUtils.makeMessage(EclipseAdapterUtils.java:136)at org.aspectj.ajdt.inter ... oBuildJob.java:235)at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)Compile error: IllegalArgumentException thrown: negative line: -1Version: 1.5.2.200804241330AspectJ version: 1.6.0.20080423100000Eclipse PlatformVersion: 3.3.0Build id: I20070621-1340 Doesn't happen for me - I tried turning off 'include line numbers' in the compiler options page and I have about 20 projects (some AspectJ/some Java) in my workspace, they all build just fine.I believe it is failing for a special kind of message that it wants to put out (a message which includes multiple related source locations).  So I'll stick in a guard for now to cope with it and the likely effect is that when a message has supplementary source locations that it wants to tell you about, you won't see them because it can't find them, you'll just see the primary message. guard is in now (latest builds of AJ and AJDT) - please reopen if still a problem as I never was able to recreate. 	2007-11-09 14:27:51	1194640000.0	resolved fixed	d3c3e32	1210200000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseAdapterUtils.java
230817	LazyMethodGen.remap() NullPointerException	<Pyinson Data Over Head> The general solution is to recognize when the exception handler is occurring against something we don't expect to see (we expect to see a STORE). And when that happens, we introduce a NOP, and move the exception handler to point at the NOP.  So, we morph the code above.First we introduce the NOP:    | catch java.lang.Exception (1806389629) -> E0    |               ARETURN    |               NOP       | method-call(ProjectData getGlobalProjectData())    | |         E0: INVOKESTATIC ProjectData.getGlobalProjectData()    | method-call(ProjectData ProjectData.getGlobalProjectData())Then we move all targeters from the invoke to the NOP    | catch java.lang.Exception (1806389629) -> E0    |               ARETURN    |           E0: NOP       | method-call(ProjectData getGlobalProjectData())    | |             INVOKESTATIC ProjectData.getGlobalProjectData()    | method-call(ProjectData ProjectData.getGlobalProjectData())Now the two join points are not overlapping and when the method call is extracted into a new method, the handler stays where it is and the remap() call succeeds.I've tested this and it works.  Changes are in: BcelClassWeaver.match(LazyMethodGen mg,InstructionHandle ih,BcelShadow enclosingShadow,List shadowAccumulator) I had to reorder that match code so it looked at exception handlers first rather than last, this enables us to deal with the handler, modify the instructions if necessary and then go on to deal with matching on the invokestatic as a method-call join point.As the change is to deal with catch blocks that start with anything other than store or nop, this solution will likely enable us to cope better with other unusual (but valid) bytecode sequences too. Changed committed. 	2008-05-06 22:43:15	1210130000.0	resolved fixed	5f97d46	1210170000.0	weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java
228633	AST Support for PointcutDesignators	"I would like an enhancement to be able to match two PointcutDesignators (called 'pointcut definitions' in the AJ5 quick reference). Currently, the following test fails:---------------AjASTMatcherTest.java---------------public void testMatchDefaultPointcut() {  AjAST ast = AjAST.newAjAST(AST.JLS3);  DefaultPointcut dp1 = ast.newDefaultPointcut();  DefaultPointcut dp2 = ast.newDefaultPointcut();  dp1.setDetail(""call(* *.foo(..)"");  dp2.setDetail(""call(* *.bar(..)"");  assertFalse(dp1.subtreeMatch(new AjASTMatcher(), dp2));}---------------------------------------------------The reason is that there are no implementations for the many different kinds of pointcut definitions of AspectJ. Instead, DefaultPointcut simply contains the pointcut definition in a String-field ""detail"" as shown in the test case. The same is true for DefaultTypePattern and SignaturePattern. Additionally, in the current implementation a DefaultPointcut, DefaultTypePattern, and SignaturePattern node will always match another AST node if that node is of the same type (instanceof).From what I see, it is necessary to 1) add types for every possible pointcut definition,2) extend the current implementation of type name patterns and 3) signature patterns,4) extend the parser (internal and external?) to create nodes for the pointcut definitions,5) extend the converter to convert the new node types, and finally6) extend the matcher to be able to match two pointcut definitions.Implementation is already done for combinations of poincuts using and (&&), or (||), not (!), cflow, and reference pointcuts (without parameters).Please comment on the task list as it is just an initial overview resulting from my limited knowledge on this field. Here are some more comments and a workaround:Implementation is already done for combinations of poincuts using and (&&), or (||), not (!), cflow, and reference pointcuts (without parameters).To points 2) and 3): Maybe the current string representation is sufficient for those two. I don't see another characteristic of a pattern than its string. If this is true, than DefaultTypePattern and SignaturePattern should no longer be regarded as stubs.Right now, I'm using simple textual comparison of the detail strings as a workaround. This may return false for two semantically equal pointcuts, but it will never return true for two unequal pointcuts. Therefore I suggest it as a temporary fix until the full implementation is done.-------------AjASTMatcher.java--------------------[...]public boolean match(DefaultTypePattern node, Object other) {  if (!(other instanceof DefaultTypePattern)) {    return false;  }  return node.getDetail().equals(((DefaultTypePattern) other).getDetail());}public boolean match(SignaturePattern node, Object other) {  if (!(other instanceof SignaturePattern)) {    return false;  }  return node.getDetail().equals(((SignaturePattern) other).getDetail());}public boolean match(DefaultPointcut node, Object other) {  if (!(other instanceof DefaultPointcut)) {    return false;  }  return node.getDetail().equals(((DefaultPointcut) other).getDetail());}---------------------------------------------------- Well your changes still allow all our tests to pass, so I'll put them in. Here is another little addition for the AjNaiveASTFlattener:-----------------AjNaiveASTFlattener.java----------------public boolean visit(SignaturePattern node) {  this.buffer.append(node.getDetail());  return false;}---------------------------------------------------------If it's fine with you, I'll put related additions like this in this bug report from time to time. If you see them fit, I'd appreciate your committing them. "	2008-04-24 05:32:45	1209030000.0	resolved fixed	bed3f4e	1209060000.0	org.aspectj.ajdt.core/src/org/aspectj/org/eclipse/jdt/core/dom/AjASTMatcher.java
224962	AjcTask doesn't work with Java6	"Although support for Java6 has been added in the last milestone, you can't use it from ant because AjcTask doesn't recognize the ""source=1.6"" and ""target=1.6"" parameters.It's easy to fix by modifying AjcTask.java and adding the missing constants:     static final String[] TARGET_INPUTS = new String []     { ""1.1"", ""1.2"", ""1.3"", ""1.4"", ""1.5"", ""1.6"" };    static final String[] SOURCE_INPUTS = new String []     { ""1.3"", ""1.4"", ""1.5"", ""1.6"" };    static final String[] COMPLIANCE_INPUTS = new String []     { ""-1.3"", ""-1.4"", ""-1.5"", ""-1.6"" };Thanks. fixed - thanks for spotting that! "	2008-03-31 14:11:02	1206990000.0	resolved fixed	6bdb87d	1207030000.0	taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java
184447	AjLookupEnvironment.java:519	Build ID: Eclipse SDKVersion: 3.2.2M20070212-1330Steps To Reproduce:This occured repeatedly when I saved a .aj file or a .java file that was boing advised.  A restart of eclipse made it go away and it has not happen again so I don't know how reproduce it. Sorry.AJDT version 1.4.2.200703020612More information:java.lang.NullPointerExceptionat org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.doDeclareAnnotations(AjLookupEnvironment.java:803)at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:592)at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:519)at org.aspectj.ajdt.internal.compiler.lookup.AjLookupE ... AutoBuildJob.run(AutoBuildJob.java:217)at org.eclipse.core.internal.jobs.Worker.run(Worker.java:58)Compile error: NullPointerException thrown: null Passing over to compiler i've committed a guard similar to that put in for bug 148536 	2007-04-27 11:00:01	1177690000.0	resolved fixed	8ce9dcf	1206120000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java
163802	Compilation error	<Pyinson Data Over Head> Is it easy to recreate the failure?  Are you able to attach (or send me) the failing class that causes this problem? Changing OS from Mac OS to Mac OS X as per bug 185991 same as 169600 i think - quick fix for 1.5.4? no further info reported - put in a guard for the NPE that will produce more comprehensive diagnostics should this happen again. 	2006-11-08 08:48:52	1162990000.0	resolved fixed	fe99e6b	1206060000.0	weaver/src/org/aspectj/weaver/ResolvedType.java
222987	More NPEs in Java15AnnotationFinder	"Created attachment 92723patch class file for weaverThis class replaces the one in aspectjweaver.jar, to applyjar -xvf patch.zipjar -uvf aspectjweaver.jar orgThe new version will output DEBUG info to System.err indicating the method it is having problems with - it will also attempt to continue rather than crash with an NPE.This patch is for aspectjweaver.jar from AspectJ1.5.4 - it will not work if applied to later versions of AspectJ. Thanks for the quick response, Andy.I tried the aspectjweaver.jar found in the following bug.  The jar outputted the same or similar information, but unfortunately  I did not find relevant output in Eclipse's or plugin's log.  I'll give your attachment a go.http://jira.springframework.org/browse/SPR-4390Note: I also tried aspectj*.jar from the latest 1.6 download.-Chris I have now committed a guard into the codebase for the NPE - but I still think it will error when this situation happens.  But at least it may give out a sensible error rather than NPE. Thank you.  I'll add the jars and give it a spin and report back.  Sorry I haven't tried the patch yet - been pulled away.Again, thanks for your speedy response. unfortunately the build machine is complaining so it wont be in a dev build yet - i will post again when it is available for download. ok, build machine resurrected.  The latest dev build from the download page includes the changes. missing 1.6.0 - once diagnostics are collected, a fix can go into 1.6.1 still seeing this problem Chris? NPE can't happen with the guard that is now in the dev builds of AspectJ - however that may have simply been hiding some underlying problem.  Please reopen if you get a chance to try this again and it still fails for you.I would also say there were some issues with multi-threaded problems in the ReflectionBasedReferenceTypeDelegate types - and they have also been addressed in this timeframe (bug 227029) - that may have been a factor here. Reported on the list by Chris Wall and on spring bug http://jira.springframework.org/browse/SPR-4390---When my plugin is initiated and during Spring context beans loading,we're getting the following:Caused by: java.lang.NullPointerException       at org.aspectj.weaver.reflect.Java15AnnotationFinder.getParameterNamesFromLVT(Java15AnnotationFinder.java:196)       at org.aspectj.weaver.reflect.Java15AnnotationFinder.getParameterNames(Java15AnnotationFinder.java:187)       at org.aspectj.weaver.reflect.Java15ReflectionBasedReferenceTypeDelegate.tryToDiscoverParameterNames(Java15ReflectionBasedReferenceTypeDelegate.java:297)       at org.aspectj.weaver.reflect.Java15ReflectionBasedReferenceTypeDelegate.getDeclaredPointcuts(Java15ReflectionBasedReferenceTypeDelegate.java:270)       at org.aspectj.weaver.ReferenceType.getDeclaredPointcuts(ReferenceType.java:535)       at org.aspectj.weaver.ResolvedType$7.get(ResolvedType.java:477)       at org.aspectj.weaver.Iterators$3$1.hasNext(Iterators.java:118)       at org.aspectj.weaver.Iterators$3.hasNext(Iterators.java:128)       at org.aspectj.weaver.ResolvedType.findPointcut(ResolvedType.java:488)       at org.aspectj.weaver.patterns.ReferencePointcut.resolveBindings(ReferencePointcut.java:152)       at org.aspectj.weaver.patterns.Pointcut.resolve(Pointcut.java:196)       at org.aspectj.weaver.tools.PointcutParser.resolvePointcutExpression(PointcutParser.java:330)       at org.aspectj.weaver.tools.PointcutParser.parsePointcutExpression(PointcutParser.java:308)       at org.springframework.aop.aspectj.AspectJExpressionPointcut.buildPointcutExpression(AspectJExpressionPointcut.java:197)       at org.springframework.aop.aspectj.AspectJExpressionPointcut.checkReadyToMatch(AspectJExpressionPointcut.java:184)       at org.springframework.aop.aspectj.AspectJExpressionPointcut.getClassFilter(AspectJExpressionPointcut.java:165)       at org.springframework.aop.support.AopUtils.canApply(AopUtils.java:198)       at org.springframework.aop.support.AopUtils.canApply(AopUtils.java:253)       at org.springframework.aop.support.AopUtils.findAdvisorsThatCanApply(AopUtils.java:287)       at org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator.findAdvisorsThatCanApply(AbstractAdvisorAutoProxyCreator.java:113)       at org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator.findEligibleAdvisors(AbstractAdvisorAutoProxyCreator.java:85)       at org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator.getAdvicesAndAdvisorsForBean(AbstractAdvisorAutoProxyCreator.java:66)       at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.wrapIfNecessary(AbstractAutoProxyCreator.java:345)       at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.postProcessAfterInitialization(AbstractAutoProxyCreator.java:309)       at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsAfterInitialization(AbstractAutowireCapableBeanFactory.java:360)       at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1343)       at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:470)I've tried with with Spring 2.5.2 and 2.5.3 with JDK 1.5. We're using""@AspectJ"" so <aop:aspectj-autoproxy/> is set, and aspectjweaver.jarand aspectjrt.jar are included. The Spring IDE shows that AOP adviseis applied to expected pointcuts. When compiled and run outside of theSpring IDE, the application encounters the NPE.Ideas? "	2008-03-17 13:57:36	1205780000.0	resolved fixed	6c54db9	1206030000.0	weaver5/java5-src/org/aspectj/weaver/reflect/Java15AnnotationFinder.java
222437	MANIFEST.MF copying is not always reliable	Sometimes an AJDT project gets into a state where it has a meta-inf/manifest.mf - and this file fails to make it out to the destination folder. Looking at the resource handling in AJDT, it is not quite as I expected.  A project clean does not mean 'delete everything in the bin directory and rebuild from scratch' - it means 'delete all the .class files in the bin directory, assume the resources are OK and leave them alone, then do a full build'.  It relies on a change delta from eclipse to indicate that something has changed in the resources (non source files) on the source paths and then copies them to the output location.So, what I think is being observed as 'AJDT fails to copy the manifest.mf to the output folder' is actually 'something deleted META-INF/MANIFEST.MF without letting Eclipse know' and now eclipse/ajdt think it is up to date and refuse (even on a clean) to recopy. /sighFound the problem - not quite what I thought it was but knowing how AJDT wasn't doing what I imagined to be a clean helped me track it down. (and when Rob indicated touching the file on the filesystem caused it to be fixed)There is special code in AspectJ itself to avoid a problem of duplicate resource writing when creating a zip file (ie. using -outjar option).  This code explicitly looks for MANIFEST.MF and completely ignores it.  Unfortunately it doesn't check whether -outjar was being used, it just always ignores it... (DOH!)  Fix for bug 57666 introduced this behaviour.What made it confusing to diagnose is that AJDT also does resource copying, but only sometimes, when resources change (and not on a project clean).  Hence touching the file on the filesystem and doing a refresh causing Eclipse to recognize a change to MANIFEST.MF and the AJDT resource copying puts the file in the output folder.Fixed in AspectJ, fixed in AJDT - builds will be available shortly containing the fix (for Eclipse 3.3) 	2008-03-12 12:45:11	1205340000.0	resolved fixed	906c849	1205340000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
193348	NPE on attempt to compile	I can't really pinpoint any code that trigger this. It happens on for an incremental, and only some of the time. If I do a full build of the project then I do not get the error and all seems to work.----java.lang.NullPointerExceptionat org.aspectj.weaver.bcel.BcelWeaver.raiseUnboundFormalError(BcelWeaver.java:833)at org.aspectj.weaver.bcel.BcelWeaver.validateSingleBranch(BcelWeaver.java:688)at org.aspectj.weaver.bcel.BcelWeaver.validateBindings(BcelWeaver.java:627)at org.aspectj.weaver.bcel.BcelWeaver.rewritePointcuts(BcelWeaver.java:556)at org.aspectj.weaver.bcel.BcelWeaver.prepareForWeave(BcelWeaver.java:484)at org.aspectj.ajd ... oBuildJob.run(AutoBuildJob.java:235)at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)Compile error: NullPointerException thrown: null I hit the bug and it happens consistently to where AJDT is unusable. Every time I make an edit on a class, I get this exception (didn't use to happen during the first few day or so I was using AJDT). I have to do a Project > Clean... to get rid of the error and be able to compile the project. Yes we have the exact same problem - a real pain in the ass! Not sure if it has something to do with our aspects or whether its a problem with some other plugins.Would be great if someone fixed this as its really annoying to have to do a build clean even when you just change a comment! Are you using annotation style aspects and thisJoinPoint - you may be interested in bug 203408. I changed the code here to hopefully avoid the NPE and report what the actual problem is that the code was having.  Should be in the next AJDT refresh.  I can't recreate it but at least if we can see which pointcut it is having trouble with then I might be able to get closer to finding out what the root cause is. Done all i plan to do on this for 1.6.0 - if the extra diagnostics trigger in the future, feel free to reopen. 	2007-06-19 12:01:51	1182270000.0	resolved fixed	a31b3de	1205170000.0	weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java
220686	unsynchronized access to WeakHashMap	Created attachment 90955patch to World.javaBuild ID: M20071023-1652Steps To Reproduce:1. org.aspectj.weaver.World.expendableMap is defined as a java.util.WeakHashMap2. java.util.WeakHashMap is not thread safe3. we have observed that expendableMap can be updated concurrently by multiple threads under load which will corrupt the internal hashmap structure resulting in infinite loops when get() is calledMore information: committed 	2008-02-27 21:16:31	1204160000.0	resolved fixed	caf8960	1204230000.0	weaver/src/org/aspectj/weaver/World.java
219830	java.lang.NullPointerException in Java15AnnotationFinder when using SWT	"<Pyinson Data Over Head> An Eclipse sample project generating the error is available athttp://www.cnwr.com/~mfork/aspectj/AspectJBug.zip I'm currently trying to recreate.  I've imported the project (I am on mac) and defined a run configuration.  On running it I see:Feb 21, 2008 11:12:49 AM org.springframework.context.support.AbstractApplicationContext prepareRefreshINFO: Refreshing org.springframework.context.support.FileSystemXmlApplicationContext@ebd75b: display name [org.springframework.context.support.FileSystemXmlApplicationContext@ebd75b]; startup date [Thu Feb 21 11:12:49 PST 2008]; root of context hierarchyFeb 21, 2008 11:12:49 AM org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitionsINFO: Loading XML bean definitions from file [/Users/aclement/workspaces/aspectj160_parameterAnnotations/AspectJBug/conf/applicationContext.xml]Feb 21, 2008 11:12:49 AM org.springframework.context.support.AbstractApplicationContext obtainFreshBeanFactoryINFO: Bean factory for application context [org.springframework.context.support.FileSystemXmlApplicationContext@ebd75b]: org.springframework.beans.factory.support.DefaultListableBeanFactory@82674bFeb 21, 2008 11:12:49 AM org.springframework.context.weaving.DefaultContextLoadTimeWeaver setBeanClassLoaderINFO: Found Spring's JVM agent for instrumentation[AppClassLoader@33056f] info AspectJ Weaver Version 1.5.4 built on Thursday Dec 20, 2007 at 13:44:10 GMT[AppClassLoader@33056f] info register classloader sun.misc.Launcher$AppClassLoader@33056f[AppClassLoader@33056f] info using configuration /Users/aclement/workspaces/aspectj160_parameterAnnotations/AspectJBug/bin/META-INF/aop.xml[AppClassLoader@33056f] info using configuration file:/Users/aclement/workspaces/aspectj160_parameterAnnotations/AspectJBug/lib/spring-aspects.jar!/META-INF/aop.xml[AppClassLoader@33056f] info register aspect LoggingAspect[AppClassLoader@33056f] info register aspect org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect[AppClassLoader@33056f] info register aspect org.springframework.transaction.aspectj.AnnotationTransactionAspectFeb 21, 2008 11:12:50 AM org.springframework.beans.factory.support.DefaultListableBeanFactory preInstantiateSingletonsINFO: Pre-instantiating singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@82674b: defining beans [org.springframework.context.config.internalBeanConfigurerAspect,org.springframework.context.weaving.AspectJWeavingEnabler#0,loadTimeWeaver]; root of factory hierarchyI turned on weaver verbose output in the aop.xml.  I don't see any weaving and the application just terminates OK.  Any idea what I might be doing differently to you? Here is my entire command line: ""C:\Program Files\Java\jre1.5.0_12\bin\javaw.exe"" -javaagent:C:\AspectJBug\lib\spring-agent.jar -classpath C:\AspectJBug\bin;C:\AspectJBug\lib\swt-debug.jar;C:\AspectJBug\lib\aspectjrt.jar;C:\AspectJBug\lib\aspectjweaver.jar;C:\AspectJBug\lib\commons-logging.jar;C:\AspectJBug\lib\spring-agent.jar;C:\AspectJBug\lib\spring-aspects.jar;C:\AspectJBug\lib\spring.jar BugReportand the info around the exception below:Feb 21, 2008 2:47:05 PM org.springframework.context.support.AbstractApplicationContext prepareRefreshINFO: Refreshing org.springframework.context.support.FileSystemXmlApplicationContext@c5c3ac: display name [org.springframework.context.support.FileSystemXmlApplicationContext@c5c3ac]; startup date [Thu Feb 21 14:47:05 EST 2008]; root of context hierarchyFeb 21, 2008 2:47:05 PM org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitionsINFO: Loading XML bean definitions from file [C:\workspaces\RAD7\AMIS\AspectJBug\conf\applicationContext.xml]Feb 21, 2008 2:47:05 PM org.springframework.context.support.AbstractApplicationContext obtainFreshBeanFactoryINFO: Bean factory for application context [org.springframework.context.support.FileSystemXmlApplicationContext@c5c3ac]: org.springframework.beans.factory.support.DefaultListableBeanFactory@949f69Feb 21, 2008 2:47:05 PM org.springframework.context.weaving.DefaultContextLoadTimeWeaver setBeanClassLoaderINFO: Found Spring's JVM agent for instrumentationFeb 21, 2008 2:47:06 PM org.springframework.beans.factory.support.DefaultListableBeanFactory preInstantiateSingletonsINFO: Pre-instantiating singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@949f69: defining beans [org.springframework.context.config.internalBeanConfigurerAspect,org.springframework.context.weaving.AspectJWeavingEnabler#0,loadTimeWeaver]; root of factory hierarchy--------- EXCEPTION REMOVED ----------------INFO: Dumping to C:\AspectJBug\.\ajcore.20080221.144709.421.txt Michael has tested a patch I sent him, it is now committed and will be in dev builds shortly.The problem was that there are multiple routes to creating an annotationfinder and one did not set the world. "	2008-02-21 12:47:46	1203620000.0	resolved fixed	1bbe6f9	1204070000.0	weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java
220430	mixup in retrieving the right class in Java15AnnotationFinder	See http://jira.springframework.org/browse/SPR-4390The problem is:The method getAnnotations is called in the Java15AnnotationFinder - and the member that is passed is a method that is defined on some class C.  The bcelRepository is then used to load that class.  In the buggy situation there are two versions of the class around - one on the regular classpath and one in the core JVM classes (in this case JAXBContext on Java6).  The member passed in is from the variant defined as a standard extension or core class.  For some reason the bcelRepository loads the Java5 version and then cannot find the member.  This is worse than a ClassNotFoundException which would case the AnnotationFinder to fall back on reflection.  I think the right thing to do now is recognize this situation and fall back on reflection - which will recover the annotations a different way. fixed as described. 	2008-02-26 13:41:45	1204050000.0	resolved fixed	9bbdb41	1204060000.0	weaver5/java5-src/org/aspectj/weaver/reflect/Java15AnnotationFinder.java
220172	[compiler] NullpointerException during compile	Created attachment 90626example code producing the errorThe attached code produces a NullpointerException when compiling it with aspectj.I checked it with the following compiler versions: (using sun java 1.6.0.04)ajc 1.5.3AJDT 1.5.2.200802061816 (ajc 1.6.0.20080206212408)Exception:java.lang.NullPointerException        at org.aspectj.weaver.Shadow.toResolvedString(Shadow.java:735)        at org.aspectj.weaver.patterns.ArgsPointcut.findResidueNoEllipsis(ArgsPointcut.java:237)        at org.aspectj.weaver.patterns.ArgsPointcut.findResidueInternal(ArgsPointcut.java:273)        at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:269)        at org.aspectj.weaver.patterns.AndPointcut.findResidueInternal(AndPointcut.java:94)        at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:269)        at org.aspectj.weaver.patterns.AndPointcut.findResidueInternal(AndPointcut.java:94)        at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:269)        at org.aspectj.weaver.bcel.BcelAdvice.specializeOn(BcelAdvice.java:146)        at org.aspectj.weaver.bcel.BcelShadow.prepareForMungers(BcelShadow.java:327)        at org.aspectj.weaver.Shadow.implement(Shadow.java:470)        at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:2832)        at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:506)        at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:119)        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1612)        at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1563)        at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1341)        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1135)        at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.weaveQueuedEntries(AjPipeliningCompilerAdapter.java:455)        at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.queueForWeaving(AjPipeliningCompilerAdapter.java:392)        at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.afterProcessing(AjPipeliningCompilerAdapter.java:380)        at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$after$org_aspectj_ajdt_internal_compiler_CompilerAdapter$5$6b855184(CompilerAdapter.aj:98)        at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:533)        at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:906)        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:260)        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:176)        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)        at org.aspectj.tools.ajc.Main.run(Main.java:378)        at org.aspectj.tools.ajc.Main.runMain(Main.java:253)        at org.aspectj.tools.ajc.Main.main(Main.java:88) Created attachment 90629ajc output (1.5.3) There is a guard in the toResolvedString() code now (it is in the M2 driver) - it was failing whilst reporting an error.  With the guards in now, it should report whatever the real problem is.  If the real problem is something you don't think is correct, please reopen.Andy. 	2008-02-25 06:34:35	1203940000.0	resolved fixed	5beab0e	1203980000.0	weaver/src/org/aspectj/weaver/Shadow.java
210848	Fix javadoc for ProceedingJoinPoint.proceed(Object[])	Currently, javadoc for ProceedingJoinPoint.proceed(Object[]) incorrectly mentions that arguments must be the same as the advice context (except for the join point object).However, http://www.eclipse.org/aspectj/doc/released/adk15notebook/ataspectj-pcadvice.html mentions a different expectation. It looks like copying the same text as in the  aj5notebook into javadoc should do well. fixed as per the suggestion. 	2007-11-24 17:49:30	1195940000.0	resolved fixed	b4715bc	1203560000.0	runtime/src/org/aspectj/lang/ProceedingJoinPoint.java
203384	AST: Type information not exposed on itmd, itfd...	The Types:org/aspectj/org/eclipse/jdt/core/dom/InterTypeFieldDeclaration.javaorg/aspectj/org/eclipse/jdt/core/dom/InterTypeMethodDeclaration.javaWhich can be returned by visiting the AjAST tree do not expose the name of the type on which the method or field is added. I require this information in the project I'm currently working on, and would appreciate if it was added. The following modifications achieve what I want. I suggest them to be added to the codebase:Index: org.aspectj.ajdt.core/src/org/aspectj/org/eclipse/jdt/core/dom/AjASTConverter.java===================================================================RCS file: /cvsroot/tools/org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/org/eclipse/jdt/core/dom/AjASTConverter.java,vretrieving revision 1.8diff -r1.8 AjASTConverter.java227a228>                       ((org.aspectj.org.eclipse.jdt.core.dom.InterTypeMethodDeclaration) methodDecl).setOnType(((InterTypeMethodDeclaration) methodDeclaration).getOnType().toString());229a231>                       ((org.aspectj.org.eclipse.jdt.core.dom.InterTypeMethodDeclaration) methodDecl).setOnType(((InterTypeMethodDeclaration) methodDeclaration).getOnType().toString());508a511>               fieldDeclaration.setOnType(fieldDecl.getOnType().toString());Index: org.aspectj.ajdt.core/src/org/aspectj/org/eclipse/jdt/core/dom/InterTypeFieldDeclaration.java===================================================================RCS file: /cvsroot/tools/org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/org/eclipse/jdt/core/dom/InterTypeFieldDeclaration.java,vretrieving revision 1.2diff -r1.2 InterTypeFieldDeclaration.java29a30,31>       private String onType;> 65a68,75> >       public String getOnType() {>               return onType;>       }> >       public void setOnType(String onType) {>               this.onType = onType;>       }Index: org.aspectj.ajdt.core/src/org/aspectj/org/eclipse/jdt/core/dom/InterTypeMethodDeclaration.java===================================================================RCS file: /cvsroot/tools/org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/org/eclipse/jdt/core/dom/InterTypeMethodDeclaration.java,vretrieving revision 1.3diff -r1.3 InterTypeMethodDeclaration.java30a31,32>       private String onType;> 94a97,104> >       public String getOnType() {>               return onType;>       }> >       public void setOnType(String onType) {>               this.onType = onType;>       } changes are in - sorry it took so long.  they will be in a dev build later today. 	2007-09-13 19:22:16	1189730000.0	resolved fixed	114db35	1201030000.0	org.aspectj.ajdt.core/src/org/aspectj/org/eclipse/jdt/core/dom/AjASTConverter.java org.aspectj.ajdt.core/src/org/aspectj/org/eclipse/jdt/core/dom/InterTypeFieldDeclaration.java org.aspectj.ajdt.core/src/org/aspectj/org/eclipse/jdt/core/dom/InterTypeMethodDeclaration.java
211674	[ataspectj] after throwing annotation style is too sensitive to parameter positions	"Reported on the list by Ashley Williams:Having converted my aspects to use the @AspectJ style, I'm now getting a strange error message when a compile my tracing aspect,.First here is the section of code:        @Pointcut(""execution(@Tracing * *(..)) && @annotation(tracing)"")        void annotatedMethods(Tracing tracing) {        }               @AfterThrowing(pointcut = ""annotatedMethods(tracing)"", throwing = ""t"")        public void logException(JoinPoint thisJoinPoint, Tracing tracing,                        Throwable t) {                Level level = Level.toLevel(tracing.level());                if (logger.isEnabledFor(level)) {                        logger.log(level, formatter.formatSignatureThrowing(thisJoinPoint),                                        t);                }        }So I am matching on all methods annotated with @Tracing and logging the subclass of Throwable that may have been thrown.However when I run my test case i get the following error:java.lang.VerifyError: (class: com/db/abfo/tracing/PojoOne, method: calculate signature: ()V) catch_type not a subclass of ThrowableThis used to work when I used the aspectj after throwing language extention form:        pointcut annotatedMethods(Tracing tracing) : execution(@Tracing * *(..)) && @annotation(tracing);        after(Tracing tracing) throwing(Throwable t) : annotatedMethods(tracing) {                Level level = tracing.level().getLevel();                if (logger.isEnabledFor(level)) {                        logger.log(level, formatter.formatSignatureThrowing(thisJoinPoint),                                        t);                }        } This seems similar to thishttps://bugs.eclipse.org/bugs/show_bug.cgi?id=219419The workaround for the above is to change the argument order in the advice; it was looking for the Exception argument in a different place. The error about catch_type not being a Throwable is most likely because it's trying to use either a JoinPoint or a Tracing as a Throwable. If you can get your case to work by putting the Exception argument elsewhere in the argument list, then it's very likely that they are related. fixed by addressing 219419.  Fix was in 1.6.3. "	2007-12-01 13:15:13	1196530000.0	resolved fixed	9de03b7	1196590000.0	tests/bugs154/pr211674/Test.java tests/bugs154/pr211674/Test2.java tests/src/org/aspectj/systemtest/ajc154/Ajc154Tests.java
206732	[itds] Problem with ITDs appearing to be applied twice (and clashing) for binary types	"As reported by Josh on the mailing list:I have the following 2 files: Advised.aj: package bugs; public class Advised {}aspect ITD {          public void Advised.f() {}} Ref.aj: package notbugs; import bugs.Advised; public class Ref {          public void g() {                   new Advised().f();          }} I am attempting to build Advised.aj into a jar, and refer to it from Ref.aj, using the following ant build.xml: <?xml version=""1.0""?> <project name=""Bugs"" basedir=""C:\workplace\imds\Bugs""          xmlns:aj=""antlib:org.aspectj"">          <taskdef uri=""antlib:org.aspectj"" resource=""org/aspectj/antlib.xml"" classpath=""./aspectjtools.jar""/>          <target name=""clean"">                   <delete dir=""bugs"" includes=""**/*.class""/>                   <delete dir=""notbugs"" includes=""**/*.class""/>          </target>          <target name=""task1"">                   <aj:iajc srcdir=""."" destdir=""."" source=""1.5"" target=""1.5"">                             <classpath location="".\aspectjrt.jar""/>                             <include name=""bugs/Advised.aj""/>                   </aj:iajc>          </target>          <target name=""task2"">                   <aj:iajc source=""1.5"" target=""1.5"" srcdir=""."">                             <classpath location="".\aspectjrt.jar""/>                             <aspectpath location="".""/>                             <include name=""notbugs/Ref.aj""/>                   </aj:iajc>          </target></project> From within Eclipse, there are no build errors because this is all one project.  On the command line, however, once I execute “ant task2”, I get the following marvelous error message which suggests that ajc is trying to ITD f into a class it already ITDd f into before:   [aj:iajc] error at C:\workplace\imds\Bugs\bugs\Advised.aj:5::77 inter-type declaration from bugs.ITD conflicts with existing member: void bugs.Advised.f()  [aj:iajc] MessageHolder:  (8 info)  (1 error)  [aj:iajc] [error   0]: error at C:\workplace\imds\Bugs\bugs\Advised.aj:5::77 inter-type declaration from bugs.ITD conflicts with existing member: void bugs.Advised.f() Let me also say that in my real use-case, the jar produced by task1 will contain aspects that should apply to clients thereof, and as such, that jar should indeed be in the aspectpath (not the classpath) for task2 (unless I am seriously misunderstanding something). How to stop this duplicate attempt to ITD? Josh---Josh is correct that using aspectpath will pull in the aspects for application to other types, the problem is that when pulling in type Advised, we reapply known ITDs and it clashes with the one added in the original build of the type.Two possible fixes that I am looking at:- don't reapply the ITDs (they are added to ensure type system is consistent) to binary types pulled in from the aspectpath- recognize the ITD is clashing with a member previously applied through the same ITDI am not sure we can determine it came from the aspectpath at the point the clash is detected.  I have option (2) already implemented, but I'll try a little more with option 1 before giving up ;) I think option 2 makes more sense anyway.It seems to me that the end result of building 1 jar or n jars should be the same as long as I use aspectpath instead of classpath.  I'm thinking in particular of the case where A.jar contains ITDs that would apply to B.jar, and C.aj uses classes from B.jar as if they were woven with A.jar.  Now it appears that option 1 would preclude a build like          <target name=""C"">                   <aj:iajc source=""1.5"" target=""1.5"" srcdir=""."">                             <classpath location="".\aspectjrt.jar""/>                             <aspectpath path=""A.jar:B.jar""/>                             <include name=""C.aj""/>                   </aj:iajc>          </target>whereas option 2 would just work. Option 2 is fixed in the codebase now, just having trouble releasing it as cruisecontrol is playing up.Option 2 would just work for your scenario - but I worry that if you forget to weave B.jar, then C will crash at runtime.  When we could have put out an error when compiling C that reminded you that you should have woven B.jar.  Is there some circular dependency scenario you are thinking of that meant the jars could not be woven in a logical order? the latest download on the dev page includes the fix! hurray. going to mark as fixed now - gotta get it off my list of things to do for 1.5.4 "	2007-10-18 05:54:26	1192700000.0	resolved fixed	797ec4d	1192710000.0	weaver/src/org/aspectj/weaver/ResolvedType.java
175039	ArrayIndexOutOfBoundException Bug with Nested Type in TypeParameters	"I debugged this stack trace from load-time weaving (ajcore files are also available). I found that the signature argument to TypeFactory.createTypeFromSignature(String) is Pjava/lang/Enum<Ljavax/jws/soap/SOAPBinding$ParameterStyle;>; but the method is erroneously using an empty array of parameters, because it thinks the $ relates to the generic type, not the parameter. It should be fairly easy to reproduce with a test case and to fix with a patch - I'll look at it some more tonight or this week.java.lang.ArrayIndexOutOfBoundsException	at org.aspectj.weaver.ResolvedType.getMemberParameterizationMap(ResolvedType.java:698)	at org.aspectj.weaver.ReferenceType.getDeclaredInterfaces(ReferenceType.java:406)	at org.aspectj.weaver.ResolvedType.getDirectSupertypes(ResolvedType.java:65)	at org.aspectj.weaver.patterns.TypePattern.matchesSubtypes(TypePattern.java:182)	at org.aspectj.weaver.patterns.TypePattern.matchesSubtypes(TypePattern.java:169)	at org.aspectj.weaver.patterns.TypePattern.matchesStatically(TypePattern.java:119)	at org.aspectj.weaver.loadtime.ClassLoaderWeavingAdaptor.accept(ClassLoaderWeavingAdaptor.java:621)	at org.aspectj.weaver.tools.WeavingAdaptor.weaveClass(WeavingAdaptor.java:253)	at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:78)	at org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter.transform(ClassPreProcessorAgentAdapter.java:52)	at sun.instrument.TransformerManager.transform(TransformerManager.java:122)	at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:155)	at java.lang.ClassLoader.defineClass(Ljava.lang.String;[BIILjava.security.ProtectionDomain;)Ljava.lang.Class;(Unknown Source)	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:124)	at java.net.URLClassLoader.defineClass(URLClassLoader.java:260)	at java.net.URLClassLoader.access$100(URLClassLoader.java:56)	at java.net.URLClassLoader$1.run(URLClassLoader.java:195)	at java.net.URLClassLoader.findClass(URLClassLoader.java:188)	at java.lang.ClassLoader.loadClass(Ljava.lang.String;Z)Ljava.lang.Class;(Unknown Source)	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:268)	at java.lang.ClassLoader.loadClass(Ljava.lang.String;)Ljava.lang.Class;(Unknown Source)	at java.lang.ClassLoader.loadClassFromNative(Ljava.lang.String;)Ljava.lang.Class;(Unknown Source)	at java.lang.Class.forName(Ljava.lang.String;ZLjava.lang.ClassLoader;)Ljava.lang.Class;(Unknown Source)	at jrockit.reflect.MemberAccess.getClassFromFieldDesc(Ljava.lang.String;ILjava.lang.ClassLoader;)Ljava.lang.Class;(Unknown Source)	at jrockit.reflect.MemberAccess.getReturnClassFromMethodDesc(Ljava.lang.String;Ljava.lang.ClassLoader;)Ljava.lang.Class;(Unknown Source) Created attachment 59664First stab at fixing thisThe tests show that the new code works better, fixing the case I encountered in a real system. But isn't PMyInterface<Ljava/lang/String;Ljava/lang/String;>$MyOtherType<Ljava/lang/Object;>; also a valid signature? I'd like to rewrite these tests to get signatures from real types, but if someone could just verify the signatures I used to see if there's an actual problem beyond the one I fixe. patch is in, thanks Ron. that second signature looks a possible sig but I haven't time to explore with some real testcases. anything left to do here? check for 1.5.4 *** Bug 169605 has been marked as a duplicate of this bug. *** *** Bug 178379 has been marked as a duplicate of this bug. *** *** Bug 180132 has been marked as a duplicate of this bug. *** *** Bug 202938 has been marked as a duplicate of this bug. *** The same stack trace is reported in many other bugs.  Looking across all of those I don't see anyone who was using an AspectJ level after 6-Mar-2007, when the patch went in at comment 2.  So I suspect this is now fixed for everyone in the development builds. *** Bug 210032 has been marked as a duplicate of this bug. *** no other reports of this recently - assuming fixed! This bug is not fixed.I can reproduce every time using some code from my companies trunk.Tried version 1.5.4, 1.6.0, and both still had this problem.May 2, 2008 6:28:48 PM org.aspectj.weaver.tools.Jdk14Trace errorSEVERE: com/palantir/util/LRUWeakSoftCache$1java.lang.ArrayIndexOutOfBoundsException: 0	at org.aspectj.weaver.ResolvedType.getMemberParameterizationMap(ResolvedType.java:695)	at org.aspectj.weaver.ReferenceType.getDeclaredInterfaces(ReferenceType.java:406)	at org.aspectj.weaver.ResolvedType.getDirectSupertypes(ResolvedType.java:65)	at org.aspectj.weaver.ResolvedType.collectInterTypeMungers(ResolvedType.java:1156)	at org.aspectj.weaver.ResolvedType.collectInterTypeMungers(ResolvedType.java:1158)	at org.aspectj.weaver.ResolvedType.getInterTypeMungersIncludingSupers(ResolvedType.java:1135)	at org.aspectj.weaver.ResolvedType.checkInterTypeMungers(ResolvedType.java:1202)	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1588)	at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1563)	at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1341)	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1161)	at org.aspectj.weaver.tools.WeavingAdaptor.getWovenBytes(WeavingAdaptor.java:353)	at org.aspectj.weaver.tools.WeavingAdaptor.weaveClass(WeavingAdaptor.java:260)	at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:78)	at org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter.transform(ClassPreProcessorAgentAdapter.java:55)	at sun.instrument.TransformerManager.transform(TransformerManager.java:169)	at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:365)	at java.lang.ClassLoader.defineClass1(Native Method)	at java.lang.ClassLoader.defineClass(ClassLoader.java:620)	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:124)	at java.net.URLClassLoader.defineClass(URLClassLoader.java:260)	at java.net.URLClassLoader.access$000(URLClassLoader.java:56)	at java.net.URLClassLoader$1.run(URLClassLoader.java:195)	at java.security.AccessController.doPrivileged(Native Method)	at java.net.URLClassLoader.findClass(URLClassLoader.java:188)	at java.lang.ClassLoader.loadClass(ClassLoader.java:306)	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:276)	at java.lang.ClassLoader.loadClass(ClassLoader.java:251)	at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:319) Can I ask which version you used to collect that stack trace?from the top line:org.aspectj.weaver.ResolvedType.getMemberParameterizationMap(ResolvedType.java:695)695 isnt a line that can throw that exception in 1.5.4 or 1.6.0.  But line 695 in AspectJ1.5.3 can throw that exception and 1.5.3 had the bug in it.  Are you absolutely sure you aren't picking up a 1.5.3 aspectj weaver from somewhere?  Are you using AJDT in eclipse, if so what version? "	2007-02-21 16:02:15	1172090000.0	resolved fixed	579ec14	1173180000.0	weaver/src/org/aspectj/weaver/TypeFactory.java weaver/testsrc/org/aspectj/weaver/TypeXTestCase.java
171667	When ordering a Clean with Build Automatico I receive the error below.	"When executing an Clean Project in Eclipse with Automatic Building I receive the error below.line from the top stack, e.g. ""SomeFile.jara:243""java.lang.NullPointerExceptionat org.aspectj.ajdt.internal.compiler.problem.AjProblemReporter.methodMustOverride(AjProblemReporter.java:380)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:153)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:400)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDe ... pter.java:107)at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)NullPointerException thrown: null Ideally I need a small example program that demonstrates the failure so i can fix it.  You seem to have ITDs that are being used to ensure a method is being overridden and that's what is causing the failure - if that helps you narrow it down to a test program?Or, you can try deactivating pipeline compilation to see if that makes a difference, by setting ""-Xset:pipelineCompilation=false"" in the advanced compiler options in AJDT (in the pure text field) - but if that works it is only a workaround, switching off pipelining will greatly increase memory consumption. I've put in guards that should stop this happening - i suspect it is us looking at a type munger to see if it provides a method in the supertype when it is not an ITD method munger and so should be ignored. guards are in latest AJ dev build. "	2007-01-25 09:24:17	1169740000.0	resolved fixed	4177bed	1171620000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java
170102	iajc Ant task doesn't support all warn options	The iajc Ant task currently supports only a few of the options provided by the ajc compiler.It would be nice if it could support them all so that builds done using the Ant task generate the same errors/warnings as the ones done within the Eclipse IDE. I have added all the warnings that the 'ajc' command line usage text allows - I've done very basic testing of it but it appears to work for the ones I tried.  the fix will be in a dev build shortly. fixes available in latest dev build 	2007-01-10 12:16:53	1168450000.0	resolved fixed	5336603	1168500000.0	taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java
165148	[ltw] Unnecessary exceptions during concretization of aspects in aop.xml	Due to the mechanism used in ConcreteAspectCodeGen I see a lot of unnecessary exceptions created.  The problem is rather than looking up a type to confirm it doesn't exist before defining it, the code uses a resolve() to check if it exists and resolve attempts to build it if it isnt there.  Because the classloader will never find an aop.xml defined type (the class doesn't exist anywhere on the classpath), a spurious exception is created and sometimes traced (if collecting a trace).  I'm going to change the code to do a lookup, that is all that is really necessary. fix committed. 	2006-11-20 08:26:11	1164030000.0	resolved fixed	e8d2556	1164030000.0	loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.java
164288	Can no longer compile JDK 1.5 projects with apsectj for JDeveloper	"I am working with AspectJ 1.5.2 in JDeveloper and have found that it is not possible to convince the compiler to use JDK 5 constructs. It appears that there is a method on AjcBuildOptions called getJavaOptionsMap() which is currently implemented to return null in all cases. In CompilerAdapter.configureBuildOptions areound line 358 the code tried to access this object to access whether to use JDK 5 constructs or not. Since the return value is always null the project is never properly configured.  I notice that the only other implementation of the root interface is CoreBuildOption which appears to directly return a structure from the eclipse class JavaProject. It would appear that this interface is breaking the rules on abstraction, is this the correct read on the situation? If so the solution would either be to implement a CoreBuildOption class to correctly work with the ADJE project adapter class or alter the code inCompiler adapter to correct use the properties in project adapter. I thinkthat the latter is probably the best as BuildOption assumes a depedency onEclipse which shouldn't be there.We do currently have customer, one in nato, who are currently having to work around this issue so it would be good to get it resolve for 1.5.3 if possibleBut I know I am a bit late for that now do to a lost email. Yes, it seems that the default compliance level is 1.4 if this is set by the implementation of BuildOptionsAdapter.getComplianceLevel(). It's not completely ignored if the BuildOptionsAdapter.getSourceLevel() returns 1.5, however, I believe this also doesn't set up the environment correctly.The fix is to update the implementation within CompilerAdapter to cope with 1.5.Regarding your interface comments...as you are probably aware the interface tools are expected to use to invoke the compiler has evolved over time which has meant that it is not as ""clean"" as it perhaps should be. There is currently an enhancement (bug 148190) to look into this. Please add any comments etc. to that bug. Created attachment 53745patch containing proposed fix and testcasesApply this patch to the ajde project.As mentioned, the fix is to update CompilerAdapter.configureBuildOptions() to manage setting the compliance and source level to be 1.5 directly rather than via the javaOptionsMap. The implementation assumes that if compliance level is set to be 1.5 and source level is set to be 1.4 then everything is 1.5 (effectively, the 1.4 is ignored). It may be that we want to police this and provide an error/warning rather than just going ahead and doing the changes. However, this is the way it worked with 1.4/1.3 levels. Moreover, given that we have bug 148190 I don't think it's worth changing this now. Tested, and verified that fix resolves my bug. I have uncovered another problem with the -1.5 not working for LTW using the class loader on a JDK 6; but I try to will raise another bug for this. Gerard, thanks for testing out the proposed fix :-) patches in. iplog! fix in latest dev builds "	2006-11-13 04:04:24	1163410000.0	resolved fixed	c54fa62	1163770000.0	ajde/src/org/aspectj/ajde/BuildOptionsAdapter.java ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java ajde/testsrc/org/aspectj/ajde/BuildConfigurationTests.java
161502	UnsupportedOperationException thrown: unable to parameterize unresolved type: Pjava/util/List<+Ljava/lang/Object; >;	"Generic parameters (like List<? extends T>) in pointcuts throw UnsupportedOperationException.java.lang.UnsupportedOperationExceptionat org.aspectj.weaver.UnresolvedType.parameterize(UnresolvedType.java: 220)at org.aspectj.weaver.patterns.ExactTypePattern.parameterizeWith (ExactTypePattern.java:244)at org.aspectj.weaver.patterns.SignaturePattern.parameterizeWith (SignaturePattern.java:265)at org.aspectj.weaver.patterns.KindedPointcut.parameterizeWith (KindedPointcut.java:381)at org.aspectj.weaver.bcel.BcelAdvice.parameterizeWith (BcelAdvice.java:93)at org.aspectj.weaver.ResolvedType.getDeclaredAdvice (ResolvedType.java:710)at org.aspectj.weaver.ResolvedType.getDeclaredShadowMungers (ResolvedType.java:739)at org.aspectj.weaver.ResolvedType.collectShadowMungers (ResolvedType.java:575)at org.aspectj.weaver.ResolvedType.collectCrosscuttingMembers (ResolvedType.java:504)at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect (CrosscuttingMembersSet.java:68)at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect (CrosscuttingMembersSet.java:57)at org.aspectj.weaver.bcel.BcelWeaver.prepareForWeave(BcelWeaver.java: 450)at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave (AjCompilerAdapter.java:299)at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling (AjCompilerAdapter.java:192)at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc $afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2 $f9cc9ca0(CompilerAdapter.aj:70)at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile (Compiler.java:367)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation (AjBuildManager.java:887)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild (AjBuildManager.java:244)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild (AjBuildManager.java:163)at org.aspectj.ajde.internal.CompilerAdapter.compile (CompilerAdapter.java:122)at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run (AspectJBuildManager.java:191)UnsupportedOperationException thrown: unable to parameterize unresolved type: Pjava/util/List<+Ljava/lang/Object;>;To reproduce this exception compile the following code snippet.import java.util.ArrayList;import java.util.List;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;public class Main {  public List<? extends Element> getElements() {    return new ArrayList<Element>();  }  class Element {};  @Aspect  static abstract class Base<T> {    @Around(""call(List<? extends T> *.*(..))"")    public List<? extends T> elementList(ProceedingJoinPoint thisJoinPoint) {      try {        return (List<? extends T>)thisJoinPoint.proceed();      } catch (Throwable e) {        throw new RuntimeException(e);      }    }  }  @Aspect  static class Concrete extends Base<Element> {}  public static void main(String[] args) {    new Main().getElements();  }	} thanks for the simple testcase.  Fix committed into AspectJ - will be in a dev build shortly. fix is in latest dev builds. Changing OS from Mac OS to Mac OS X as per bug 185991 "	2006-10-18 22:23:58	1161220000.0	resolved fixed	7b40e7e	1161690000.0	tests/bugs153/pr161502/Main.java tests/bugs153/pr161502/Main2.java tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java weaver/src/org/aspectj/weaver/BoundedReferenceType.java weaver/src/org/aspectj/weaver/Checker.java weaver/src/org/aspectj/weaver/ReferenceType.java weaver/src/org/aspectj/weaver/ResolvedPointcutDefinition.java weaver/src/org/aspectj/weaver/ResolvedType.java weaver/src/org/aspectj/weaver/TypeVariable.java weaver/src/org/aspectj/weaver/TypeVariableReferenceType.java weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java weaver/src/org/aspectj/weaver/internal/tools/PointcutDesignatorHandlerBasedPointcut.java weaver/src/org/aspectj/weaver/patterns/AndAnnotationTypePattern.java weaver/src/org/aspectj/weaver/patterns/AndPointcut.java weaver/src/org/aspectj/weaver/patterns/AndTypePattern.java weaver/src/org/aspectj/weaver/patterns/AnnotationPatternList.java weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java weaver/src/org/aspectj/weaver/patterns/AnnotationTypePattern.java weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.java weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java weaver/src/org/aspectj/weaver/patterns/BindingAnnotationTypePattern.java weaver/src/org/aspectj/weaver/patterns/BindingTypePattern.java weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java weaver/src/org/aspectj/weaver/patterns/ConcreteCflowPointcut.java weaver/src/org/aspectj/weaver/patterns/Declare.java weaver/src/org/aspectj/weaver/patterns/DeclareAnnotation.java weaver/src/org/aspectj/weaver/patterns/DeclareErrorOrWarning.java weaver/src/org/aspectj/weaver/patterns/DeclareParents.java weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java weaver/src/org/aspectj/weaver/patterns/DeclareSoft.java weaver/src/org/aspectj/weaver/patterns/ExactAnnotationTypePattern.java weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java weaver/src/org/aspectj/weaver/patterns/HandlerPointcut.java weaver/src/org/aspectj/weaver/patterns/HasMemberTypePattern.java weaver/src/org/aspectj/weaver/patterns/IfPointcut.java weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java weaver/src/org/aspectj/weaver/patterns/NotAnnotationTypePattern.java weaver/src/org/aspectj/weaver/patterns/NotPointcut.java weaver/src/org/aspectj/weaver/patterns/NotTypePattern.java weaver/src/org/aspectj/weaver/patterns/OrAnnotationTypePattern.java weaver/src/org/aspectj/weaver/patterns/OrPointcut.java weaver/src/org/aspectj/weaver/patterns/OrTypePattern.java weaver/src/org/aspectj/weaver/patterns/PerCflow.java weaver/src/org/aspectj/weaver/patterns/PerFromSuper.java weaver/src/org/aspectj/weaver/patterns/PerObject.java weaver/src/org/aspectj/weaver/patterns/PerSingleton.java weaver/src/org/aspectj/weaver/patterns/PerTypeWithin.java weaver/src/org/aspectj/weaver/patterns/Pointcut.java weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java weaver/src/org/aspectj/weaver/patterns/ThisOrTargetAnnotationPointcut.java weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java weaver/src/org/aspectj/weaver/patterns/ThrowsPattern.java weaver/src/org/aspectj/weaver/patterns/TypePattern.java weaver/src/org/aspectj/weaver/patterns/TypePatternList.java weaver/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java weaver/src/org/aspectj/weaver/patterns/WithinAnnotationPointcut.java weaver/src/org/aspectj/weaver/patterns/WithinCodeAnnotationPointcut.java weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java
149908	NPE in org.aspectj.weaver.MemberImpl.getModifiers(MemberImpl.java:526)	"""cannot resolve this member:<member name>"" would be better than an NPE.  To me, that still means that I need to know more about AspectJ than I'm likely to in order to understand the message.  I'm a new user, so I need more hand holding than most.I really like this Ant message (see below) that not only tells me what the problem is, but what might be causing it and what might fix it.  It is much too verbose for an exception message, but such a message could be logged.  The message itself could contain the core info and suggest consulting the log for further details.  While there is still room for improvement, this criticism is much too harsh:http://cafe.elharo.com/java/errormsg/I think the goals should be:1) the developer should be able to fix the problem from the message and stack trace2) failing that, someone on the AspectJ team should be able to understand the problem from the message and stack traceThanks,CurtAnt message in question:BUILD FAILED/blah.../build.xml:51:Could not create task or type of type: junit.Ant could not find the task or a class this task relies upon.This is common and has a number of causes; the usualsolutions are to read the manual pages then download andinstall needed JAR files, or fix the build file:- You have misspelt 'junit'.Fix: check your spelling.- The task needs an external JAR file to executeand this is not found at the right place in the classpath.Fix: check the documentation for dependencies.Fix: declare the task.- The task is an Ant optional task and the JAR file and/or librariesimplementing the functionality were not found at the time youyourself built your installation of Ant from the Ant sources.Fix: Look in the ANT_HOME/lib for the 'ant-' JAR corresponding to thetask and make sure it contains more than merely a META-INF/MANIFEST.MF.If all it contains is the manifest, then rebuild Ant with the neededlibraries present in ${ant.home}/lib/optional/ , or alternatively,download a pre-built release version from apache.org- The build file was written for a later version of AntFix: upgrade to at least the latest release version of Ant- The task is not an Ant core or optional taskand needs to be declared using <taskdef>.- You are attempting to use a task defined using<presetdef> or <macrodef> but have spelt wrong or notdefined it at the point of useRemember that for JAR files to be visible to Ant tasks implementedin ANT_HOME/lib, the files must be in the same directory or on theclasspathPlease neither file bug reports on this problem, nor email theAnt mailing lists, until all of these causes have been explored,as this is not an Ant bug.  Reopening this bug as we shouldn't NPE. At the very least the ""unresolved member"" warning should be thrown. Looking into this more closely, the same NPE occurs under the following conditions:1. Type T1 is available when type T2 is compiled into a jar file. Type T2 has a reference to T1. When compiling/weaving the contents of a project which has the jar file on it's inpath but doesn't have access to T1 we get the NPE2. Type T1 contains a member m when type T2 is compiled. Type T2 calls this member. When compiling/weaving the contents of a project which has the jar file on it's inpath and a version of T1 which doesn't contain m we get the NPE.In both these cases the NPE only happens when an aspect advises an aspect which advises the use of the type contained in the jar file. There should be two different solutions to these situations. In the first case we should report a cantFindType whereas in the second we should report an unresolvableMember. Created attachment 51417zip file containing proposed fix and testcasesThe attached zip file contains the following:1. pr149908-weaver.txt: Apply to the weaver project. This patch contains the fix proposed in comment #92. pr149908-tests.txt: Apply to the tests project. This patch contains test programs for the two scenarios described in comment #93. simple.jar: Place in the tests\bugs153\pr149908 directory. This is used in the test for scenario 1 in comment #9.4. stringBuilder.jar: Place in the tests\bugs153\pr149908 directory. This is used in the test for scenario 2 in comment #9. patches committed.  slightly nervous about adding 2 more booleans to every member in the system. fix is available in latest aj dev build, therefore closing as fixed.iplog java.lang.NullPointerException	at org.aspectj.weaver.MemberImpl.getModifiers(MemberImpl.java:526)	at org.aspectj.weaver.MemberImpl.getMethodSignatureString(MemberImpl.java:824)	at org.aspectj.weaver.MemberImpl.getSignatureString(MemberImpl.java:753)	at org.aspectj.weaver.bcel.LazyClassGen.initializeTjp(LazyClassGen.java:1039)	at org.aspectj.weaver.bcel.LazyClassGen.initializeAllTjps(LazyClassGen.java:1016)	at org.aspectj.weaver.bcel.LazyClassGen.addAjcInitializers(LazyClassGen.java:964)	at org.aspectj.weaver.bcel.LazyClassGen.writeBack(LazyClassGen.java:502)	at org.aspectj.weaver.bcel.LazyClassGen.getJavaClassBytesIncludingReweavable(LazyClassGen.java:652)	at org.aspectj.weaver.bcel.BcelWeaver.getClassFilesFor(BcelWeaver.java:1337)	at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1309)	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1127)	at org.aspectj.weaver.tools.WeavingAdaptor.getWovenBytes(WeavingAdaptor.java:284)	at org.aspectj.weaver.tools.WeavingAdaptor.weaveClass(WeavingAdaptor.java:212)	at org.aspectj.weaver.loadtime.WeavingURLClassLoader.defineClass(WeavingURLClassLoader.java:125)	at org.aspectj.weaver.ExtensibleURLClassLoader.defineClass(ExtensibleURLClassLoader.java:80)	at org.aspectj.weaver.ExtensibleURLClassLoader.findClass(ExtensibleURLClassLoader.java:46)	at java.lang.ClassLoader.loadClass(ClassLoader.java:306)	at java.lang.ClassLoader.loadClass(ClassLoader.java:251)	at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:319)Exception in thread ""main"" public aspect JoinPointTraceAspect {		private int _callDepth = -1;		pointcut tracePoints() : !within(JoinPointTraceAspect);		before() : tracePoints() {		_callDepth++; print(""Before"", thisJoinPoint);	}		after() : tracePoints() {		print(""After"", thisJoinPoint);		_callDepth--;	}		private void print(String prefix, Object message) {		for(int i = 0, spaces = _callDepth * 2; i < spaces; i++) {			System.out.print("" "");		}				System.out.println(prefix + "": "" + message);	}}aspect EdtRuleChecker {    private boolean isStressChecking = true;        public pointcut anySwingMethods(JComponent c):         target(c) && call(* *(..));    public pointcut threadSafeMethods():                  call(* repaint(..)) ||          call(* revalidate()) ||         call(* invalidate()) ||         call(* getListeners(..)) ||         call(* add*Listener(..)) ||         call(* remove*Listener(..));    //calls of any JComponent method, including subclasses    before(JComponent c): anySwingMethods(c) &&                           !threadSafeMethods() &&                          !within(EdtRuleChecker) {     if(!SwingUtilities.isEventDispatchThread() &&         (isStressChecking || c.isShowing()))      {             System.err.println(thisJoinPoint.getSourceLocation());             System.err.println(thisJoinPoint.getSignature());             System.err.println();      }    }    //calls of any JComponent constructor, including subclasses    before(): call(JComponent+.new(..)) {      if (isStressChecking && !SwingUtilities.isEventDispatchThread()) {          System.err.println(thisJoinPoint.getSourceLocation());          System.err.println(thisJoinPoint.getSignature() +                                "" *constructor*"");          System.err.println();      }    }}Running with SwingSet2. Passing over to compiler I've used your two aspects and am weaving them into SwingSet2.jar but have unfortunately been unable to reproduce your problem. Could you provide more details about your setup? Which versions of AJDT and SwingSet2 are you using?Thanks, Helen Through code inspection and a simple testcase (which doesn't recreate the problem, just allows me to work out the steps taken) it looks like the NPE is caused because we're trying to resolve a Member whose declaring type doesn't have (or we believe doesn't have) a resolved type with the same name or signature. I've managed to recreate this NPE if the SwingSet2.jar which I have on my inpath is from a 1.5 sdk and the project which contains the provided aspects is being built with a 1.3 sdk. I therefore believe this bug is caused by a mis-match in versions and am closing this bug as ""invalid"". Please reopen if you're still seeing the NPE and do not have a mis-match of versions. Helen,I'm sorry I didn't provide more details and you had to do so much investigation.  Thanks for looking into this.  Are you sure throwing an NPE is the best that can be done?  If the null is from probable tool misuse, wouldn't it be better to check for null and throw a more descriptive exception instead?The bug report almost certainly comes from pilot error on my part.  When confronted with the stack trace, that wasn't at all obvious to me.Thanks,Curt Yes, I see your point :-) We do have an XLint option ""Unresolvable Member"" which we could use in this case (since the problem is that we're looking at a member and are unable to resolve it). If this was implemented then in your case you would have got a warning message of the form ""cannot resolve this member: <member name>"" rather than an NPE. Would this have been helpful to you? (note that this xlint option is set to warning by default) "	2006-07-06 17:24:00	1152220000.0	resolved fixed	757004c	1161600000.0	tests/bugs153/pr149908/C.java tests/bugs153/pr149908/C1.java tests/bugs153/pr149908/MyStringBuilder.java tests/bugs153/pr149908/withoutMethod/MyStringBuilder.java tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java weaver/src/org/aspectj/weaver/MemberImpl.java
160496	ajdoc Main class needs refactoring for ease of use	Whilst looking at other ajdoc bugs it was slightly confusing to read the main ajdoc method. I didn't want to include the refactoring of this within patches for the other bugs as this is mearly for ease of use. Therefore, raising this enhancement to cover it. Created attachment 51760patch containing refactoringApply this patch to the ajdoc project This patch has been applied and is in the latest aj dev build. Therefore closing this as fixed.iplog 	2006-10-11 11:41:29	1160580000.0	resolved fixed	efe6cc7	1161600000.0	ajdoc/src/org/aspectj/tools/ajdoc/Main.java
161217	NPE in BcelAdvice	"I've been playing with some aspect deployment models and got into this error during project rebuild from AJDT:java.lang.NullPointerExceptionat org.aspectj.weaver.bcel.BcelAdvice.implementOn(BcelAdvice.java:199)at org.aspectj.weaver.Shadow.implementMungers(Shadow.java:699)at org.aspectj.weaver.Shadow.implement(Shadow.java:471)at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:2832)at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:506)at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeave ... lasses when weaving when batch building BuildConfig[...] #Files=6Here is the aspect and classes it is applied to:-----@Aspect(""percflow(execution(* InstrumentedBean.getProperty2()))"")public class GetFieldAtAspect {  @Around(""execution(* ConfigurableBean.getProperty2())"")  public Object onGet(ProceedingJoinPoint jp) throws Throwable {    return jp.proceed();  }}------import org.springframework.beans.factory.InitializingBean;public class InstrumentedBean implements InitializingBean, IInstrumentedBean {  private ConfigurableBean configurableBean;  private String value;  private transient String transientValue = ""aaa"";    public void afterPropertiesSet() throws Exception {    this.configurableBean = new ConfigurableBean();  }    public String getProperty1() {    synchronized(this) {      return this.configurableBean.getProperty1();    }  }  public String getProperty2() {    synchronized(this) {      return this.configurableBean.getProperty2();    }  }    public void setValue(String value) {    synchronized(this) {      this.value = value;    }  }  public Object getValue() {    synchronized(this) {      return value;    }  }  public Object getTransientValue() {    return transientValue;  }    public void setTransientValue(String transientValue) {    this.transientValue = transientValue;  }}------import java.io.Serializable;import org.springframework.beans.factory.annotation.Configurable;@Configurablepublic class ConfigurableBean implements Serializable {  private static final long serialVersionUID = 1L;    private String property1;  private String property2;    public ConfigurableBean() {  }    public String getProperty1() {    return this.property1;  }    public String getProperty2() {    return this.property2;  }    public void setProperty1(String property1) {    this.property1 = property1;  }    public void setProperty2(String property2) {    this.property2 = property2;  }  } What version of AJDT are you using? Does it work fine if it is a code style aspect?I created a project with your 3 files in and it compiled fine for me (I had to remove the references to Configurable, InitializingBean, IInstrumentedBean as I dont have them) I am running Eclipse 3.2 with latest AJDT from the dev update site. AJ aspect is seem compiles fine.Strange that if with ""perthis"" in @Aspect, error appear on InstrumentedBean, but if I change it to @Aspect(), then error appear on GetFieldAtAspect.Configurable and InitializingBean are from Spring framework, but it looks like error appear even if I remove them as well as IInstrumentedBean.-----------public aspect GetFieldAspect {  pointcut onGetValue() : execution(* InstrumentedBean.getValue(..));  pointcut onGetValueField() : get(* InstrumentedBean.value);  Object around() : onGetValue() {    System.err.println(""Around getValue()"");    return ""{""+proceed()+""}"";  }    String around() : onGetValueField() {    String value = proceed();    System.err.println(""Around get field value: ""+ value);    return ""[""+value+""]"";  }}-----------Here is the more complete stack trace from the Problems view:Internal compiler errorjava.lang.NullPointerException	at org.aspectj.weaver.bcel.BcelAdvice.implementOn(BcelAdvice.java:199)	at org.aspectj.weaver.Shadow.implementMungers(Shadow.java:699)	at org.aspectj.weaver.Shadow.implement(Shadow.java:471)	at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:2832)	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:506)	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:119)	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1611)	at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1562)	at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1340)	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1160)	at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.weaveQueuedEntries(AjPipeliningCompilerAdapter.java:455)	at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.queueForWeaving(AjPipeliningCompilerAdapter.java:392)	at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.afterProcessing(AjPipeliningCompilerAdapter.java:380)	at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$after$org_aspectj_ajdt_internal_compiler_CompilerAdapter$5$6b855184(CompilerAdapter.aj:98)	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:533)	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:906)	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:260)	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:176)	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:298)	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:183)	at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:102)	at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191) Ok - you must be doing something else too - because I've downloaded spring 2.0 - put the spring.jar on the project classpath, then created the 3 files in that project which you mention in the first comment.  I removed the reference to IInstrumentedBean and it all compiles fine.Do you have any compiler options set to something other than default?Do you just have spring.jar on the classpath in the same way I do?Maybe attach your .classpath/.project/(.settings if you have one) for the project so I can see what you are doing differently to me? Created attachment 52245project .settingsI can't attach original .classpath, but it has the following artifacts:<classpath>	<classpathentry excluding=""**/SCCS/**"" kind=""src"" output=""build.eclipse/tests.system.classes"" path=""tests.system""/>	<classpathentry excluding=""**/SCCS/**"" kind=""src"" output=""build.eclipse/tests.system.classes"" path=""tests.system.resources""/>	<classpathentry kind=""con"" path=""org.eclipse.jdt.launching.JRE_CONTAINER""/>	<classpathentry combineaccessrules=""false"" kind=""src"" path=""/spring""/>	<classpathentry kind=""lib"" path=""lib/aspectjrt.jar""/>	<classpathentry kind=""output"" path=""build.eclipse/classes""/></classpath>So, Spring jars are exported from /spring project, that is in the same Eclipse Workspace.Anyways, can you say, what kind of thing is null there? Maybe we can deduct from that? Otherwise I can try to run this stuff under debugger, though not sure how to setup dev environment for AJDT. test and fix are committed in AspectJ cvs head. (In reply to comment #5)> test and fix are committed in AspectJ cvs head.Cool! What was that after all? Annotation style has far less test coverage than code style - some code for removing warnings on the code introduced by the compiler (that were determined to be incorrect at weaving time) never expected a collection to be null and all the tests to check this were written in code style.  It could actually be null for annotation style. Thanks Andy. Any idea when dev AJDT build with this this change will be cut? The latest AJDT 1.4/1.5 dev builds contain this fix. (In reply to comment #9)> The latest AJDT 1.4/1.5 dev builds contain this fix.Just tried that. It works fine in AJDT. I guess I can take aspectjtools.jar from this AJDT build to mak it work from the commend line? I am sorry to bug you again with this, but can you please point me to AspectJ build, which has aspectjtools.jar with iajc Ant task. Last dev build on AJ download page is dated Oct 16. check the download page this morning fix available (in AJ and AJDT) iplog "	2006-10-17 08:19:24	1161090000.0	resolved fixed	044542c	1161270000.0	tests/bugs153/pr161217/AtAspectJAspect.java tests/bugs153/pr161217/C.java tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java
149293	declare annotation problem: AIOOBE at ProblemReporter.java:2992	"This has been happening a lot, but I'm having trouble figuring out why it's happening.  It's always ""5"".  It happens both in Eclipse and from the command line.java.lang.ArrayIndexOutOfBoundsExceptionat org.aspectj.org.eclipse.jdt.internal.compiler.problem.ProblemReporter.invalidType(ProblemReporter.java:2992)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeReference.reportInvalidType(TypeReference.java:170)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:136)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:123)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.Annotation.resolveType(Annotation.java:214)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(ASTNode.java:436)at org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.getAnnotationTypes(EclipseSourceType.java:443)at org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.isAnnotationStyleAspect(EclipseSourceType.java:123)at org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.isAspect(EclipseSourceType.java:108)at org.aspectj.weaver.ReferenceType.isAspect(ReferenceType.java:159)at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.verifyAnyTypeParametersMeetBounds(AjLookupEnvironment.java:269)at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:228)at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301)at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:887)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:244)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:163)at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)ArrayIndexOutOfBoundsException thrown: 5 It is happening because of a problem with one of the annotations you have put on a type - we crash trying to report the error concerning the annotation.  Although the stack trace mentions aspects, it is breaking in the code that is trying to find out if you have the @Aspect annotation on the type it is processing, so it may be any type in the system.Depending on how large your program is, you could try removing the annotations from some of the types and checking what makes it go away - clearly this is a bug but I'd like to come up with a test program before working to fix it if I can. like your other bug ... this could be mismatched versions of compiler/weaver.  Is this AJDT1.4 or AJDT 1.3.1 ? I did a clean install of Eclipse 3.2RC7 and an install of the latest AJDT 1.4 using ""Find and Install"" within Eclipse.  I haven't seen the other bug since doing that, but this bug was present before and also still now. How big is your project? Does it have many dependencies? are you able to send it to me?  I don't mind trying to compile and debug this locally.  Basically I'd remove annotations from types until it went away to find the culprit... It's a multiple project workspace with lots of classes and aspect advice.  Pretty much huge.  And it's a closed source project, too, so I can't just send it to you.  I'm working on deleting it piece by piece and checking that the compiler error still happens.  I'll figure out the minimal code needed to reproduce it. great, thanks!  Created attachment 45633Eclipse projects to reproduce the bugThis assumes you have already installed Eclipse 3.2 release and installed the AJDT 1.4 release plugin into it.Steps to reproduce:1. Extract bug.zip into an empty folder.2. Start Eclipse and choose that folder as your workspace.3. Click the icon to ""Go to the workbench.""4. Right-click in the Package Explorer and choose Import.5. Select ""General:Existing Projects into Workspace"" and click Next.6. Browse for ""Select root directory"" and choose the folder into which you extracted the zip.7. Deselect project2.  ONLY project1 should be checked at this time.8. Click Finish.9. Workspace builds. Verify that nothing is displayed in the ""Problems"" pane.10. Repeat steps 4 through 6.11. ONLY project2 should be available for importing now.  Be sure it is checked.12. Click Finish.13. AspectJ Internal Compiler Error:java.lang.ArrayIndexOutOfBoundsExceptionat org.aspectj.org.eclipse.jdt.internal.compiler.problem.ProblemReporter.invalidType(ProblemReporter.java:2992)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeReference.reportInvalidType(TypeReference.java:170)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:136)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:123)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.Annotation.resolveType(Annotation.java:214)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(ASTNode.java:436)at org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.getAnnotationTypes(EclipseSourceType.java:443)at org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.isAnnotationStyleAspect(EclipseSourceType.java:123)at org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.isAspect(EclipseSourceType.java:108)at org.aspectj.weaver.ReferenceType.isAspect(ReferenceType.java:159)at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.verifyAnyTypeParametersMeetBounds(AjLookupEnvironment.java:269)at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:228)at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301)at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:887)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:244)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:199)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:170)at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)ArrayIndexOutOfBoundsException thrown: 1 This bug still exists in the 1.5.2 release. couple of problems lurking here - caused by the combination of a project dependency ,an inner annotation type and the code being in packages.  thanks for the test program!In AjLookupEnvironment.createAnnotationFromBcelAnnotation() we didn't correctly build the positions array - we made it too short, and hence the arrayindexoutofboundsexception.  Because the annotation type was a nested type we mistakenly referred to it via its binary name (so a $ delimiter for the inner type).  We had to undo that and use its 'source name'.With those two things fixed we now get an error about the visibility of the annotation type.  But ... we only get this error when building Project2 - so I am still investigating...I've reset the version of this bug to 1.5.1 as that is the version it was found on. So good to hear that you're working on this!  This bug has me pulling my hair out because it basically means I can't use the AspectJ builder to build this workspace at the moment.The nested annotation type is declared private, but the privileged aspect should have permission to use it because it's privileged. fix for the AIOOBE is in.  Fix for priliveged aspect being able to see the private inner annotation will take longer. It should be possible for the privileged aspect to see and use the private inner annotation type.  However, I don't think we should be attaching the private annotation to types targeted with declare @type.  If we do that we are creating something that effectively breaks the type checking rules - and if any tool checks it (the visibility of the annotation) then it will see that the target type shouldn't actually be able to see the annotation.  And that is what is happening here on the incremental compile.Normally in AspectJ, for this kind of construct we would add a public 'thing' to the target type with a mangled name - such that AspectJ understood it represented the private type, but no other tool would.  If we did this then the type system would be nice and correct.  So, in this situation:class A {  private @interface M {}}privileged aspect X {  declare @type: C: @A.M;}class C {}class C would get a mangled public annotation, perhaps 'public @interface ajc$A$M'.  The compiler would correctly be able to recognize this as a reference to the private annotation for the purposes of matching advice:'before(): call(* (@A.M *).*(..)) {}'and any tool that checks the visibility of the annotation wouldn't find the visibility rules violated.I imagine implementing this to be a couple of weeks work - and at the moment we only have this one example use case.  If we had another one or two then that would make it more of a priority - so I'm moving this out to 1.6.0A testcase is committed in MultiProjectIncrementalTests called: testDeclareAtType_pr149293() that shows the incremental compilation failure.Right now I'm trying to decide whether to police it for now and produce a compiler limitation error if this is attempted. Mangling may produce problems.  Consider this use case:public abstract class Base {  private @interface AspectApplied { }  protected Base() {    if (!getClass().isAnnotationPresent(AspectApplied.class)) {      throw new RuntimeException(""aspect not woven into class"");    }  }}public class Derived extends Base {  public Derived() {    // implicit call to super()  }}public privileged aspect Aspect {  declare @type : Base+ : @Base.AspectApplied;}The intent is that authors of subclasses of Base will be unable to annotate those subclasses with the private @AspectApplied, and they cannot escape the runtime check that their subclass does indeed have the annotation.  This is a way to check at runtime that subclasses of Base have been woven with Aspect, which is important when third parties would be extending Base but might not be using the AspectJ compiler: they will receive a nasty surprise at runtime and be forced to compile their subclasses with AspectJ and weave with Aspect. You cannot write this code:class A {  private @interface M {}}@A.Mclass B {}C:\>javac A.javaA.java:5: A.M has private access in A@A.M  ^1 errorAnd I don't think AspectJ should be providing a back door to make it possible.To do what you are suggesting, you would use the AspectJ reflection support - and that would understand/hide any mangling.  In your example, this code:if (!getClass().isAnnotationPresent(AspectApplied.class)) {is relying on how AspectJ chooses to implement declare @type at the moment.  What you would be better writing is something like (this is not yet implemented in AjType):if (!AjTypeSytem.getAjType(getClass()).isAnnotationPresent(AspectApplied.class)) {and the AjTypeSystem can hide everything related to the mangling. done all i plan to do here. "	2006-06-30 08:20:01	1151670000.0	resolved fixed	bc2f36f	1161070000.0	tests/multiIncremental/PR149293_1/base/src/mypackage/MyAbstractClass.java tests/multiIncremental/PR149293_1/base/src/mypackage/MyAspect.java tests/multiIncremental/PR149293_1/base/src/mypackage/MyBaseClass.java tests/multiIncremental/PR149293_1/base/src/mypackage/MyInterface.java tests/multiIncremental/PR149293_1/inc1/src/mypackage/MySubclass.java tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java
160167	NPE when using crossrefs option for iajc ant task	<Pyinson Data Over Head> There is a bug here - it shouldn't crash. But crossrefs is a very old option - are you sure it is what you want to use?If you want an information on what was woven where, use '-showWeaveInfo'.  The crossrefs option produces an emacs compatible ajsym file that is never used by anything other than emacs... -crossrefs is similar to -emacssym in that they are both a way to cause the compiler to generate a structure model and relationships map outside of AJDT (command line or through Ant).  I can make the command line compiler fail with something as easy as:ajc -crossrefs -inpath x.jarthe problem is that we don't initialize the output location correctly for the crossrefs option (and so NPE).  The workaround is to supply an output directory, so this works:ajc -crossrefs -inpath x.jar -d outputIn the example Ant script here, the output location is a jar and nothing in the -crossrefs processing understands jar locations as the output destination.Are you planning to use the AspectJ classes to parse this serialized object yourself? the fix is in - we will no longer NPE.  However, if outjar is used, we won't put the .ajsym file into the output jar - that would be a new enhancement request I think.  As I mentioned previously, to see the result of weaving it is best to use showWeaveInfo - or if you want to post-process the weaving messages then supply your own message handler and you can do whatever you like with the messages as they come out. The -showWeaveInfo option shows me what I need, so I can use that.  Thanks for your help. Ron Bodkin pointed me at this report.  It made me wonder if we should be putting the .ajsym file, or something equivalent, into the META-INF directory of JARs that should expose crosscutting structure.  But as you point out Andy, that would be a separate enhancement request. nothing further to do for this bug - the final comments refer to what would be a future enhancement that has yet to be requested... 	2006-10-08 18:51:11	1160350000.0	resolved fixed	f7508cf	1160400000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
159896	advice from injars do not have unique handles with the JDTLikeHandleProvider	Advice of the same kind contained in the same aspect currently do not have unique handles if the aspect is on the aspectpath. *** Bug 159895 has been marked as a duplicate of this bug. *** Created attachment 51520zip containing testcases and proposed patchThe attached zip file contains the following:1. pr159896-tests.txt - apply to the tests project2. pr159896-weaver.txt - apply to the weaver project3. declare.jar - place in tests\features153\jdtlikehandleprovider4. advice.jar - place in tests\features153\jdtlikehandleprovider5. jarForAspectPath.jar -  - place in tests\features153\jdtlikehandleproviderTogether these contain the tests and proposed fix for this bug. patches in.  iplog fixes available. 	2006-10-05 11:44:57	1160060000.0	resolved fixed	d532892	1160150000.0	tests/features153/jdtlikehandleprovider/ClassForAspectpath.java tests/src/org/aspectj/systemtest/ajc153/JDTLikeHandleProviderTests.java weaver/src/org/aspectj/weaver/ShadowMunger.java weaver/src/org/aspectj/weaver/patterns/DeclareErrorOrWarning.java
159143	subtype pattern not working for declare annotation on method	"Hmmmm - that test program works fine for me.  So I tried creating a minimal test program:@interface MethodAnnotation {}aspect X {  declare @method : void Foo+.foo() : @MethodAnnotation;}interface Foo {}class Blah implements Foo {  public void foo() {}}If I comment out 'foo()' then I get the same error Wes describes.  If I have that method in, then it works (and I can see the annotation in the class using javap).  Are you doing anything else that I'm not Wes?  I am on the command line, not in AJDT - and I'm using HEAD rather than 20060927. I get the same results as Andy in head with both test and comment program.  Fixed or ? assumed fixed - no progress for a year. see previous comment, silly bugzilla Using AspectJ 1.5.3.200609271036, when declaring an annotation on a method, get unexpected error when using subtype wildcard for the declaring type.  E.g.,  declare @method : void Foo+.foo() : @MethodAnnotation;Error text: ""The method 'void Foo+.foo()' does not exist"" Created attachment 51100test case, includes test specification "	2006-09-28 12:47:33	1159460000.0	resolved fixed	513564a	1159950000.0	tests/bugs153/pr159143/DeclareMethodAnnotation.java tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java
156904	Incorrect warning when advising a private method of a private inner class	"The Eclipse AJDT give an incorrect warning when you want to advise a private method of a private inner class.When I want to advise a private method in a private inner class, like thispublic class Outer{   private class Inner   {      private void myMethod()   }}Using the following poincut:poincut innerpointcut():execution( * Outer.Inner.myMethod() );and advice:before():innerpointcut(){   System.out.println( ""executing!"" );}I get a warning ""invalidAbsoluteTypeName"" next to my pointcut, but next to the advice, there is a marker that points to the private method. take a look for 1.5.3 This problem is occurring because Outer is in a package. Changing the pointcut expression to include the package ie. pkg.Outer.Inner.myMethod() or moving Outer to the default package does not produce the invalidAbsoluteTypeName warning. Also, note that the test programs for bug 67591 and bug 65925 which have previously been fixed also produce the invalidAbsoluteTypeName warning if the classes are in packages.The reason we're producing the warning is that at this time we're looking at Outer.Inner which we can't find, whereas when we come to match this has become pkg.Outer.Inner which we can find (and is why the marker is there indicating its been advised). The reason we're getting the invalidAbsoluteTypeName is the same as we were getting the warning in bug 67591. That is, due to the visibility checking in org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.canBeSeenBy(). We find Outer.Inner, however, since this is a private class we check for the privileged modififier on the aspect. This isn't there so we return a ProblemReferenceBinding which ultimately results in the warning being reported. The fix for bug 67591 was to check if the type can be found in the world if there's a problem finding it from the current scope. This currently doesn't work in the case of this bug because, as previously mentioned, the class is in a package. When we come to see if the type Outer$Inner is in the world we ask the world's typemap for LOuter$Inner. However, the typemap contains Lpkg/Outer$Inner which doesn't match so we return that we can't find it in the world. A MissingResolvedTypeWithKnownSignature is created and the invalidAbsoluteTypeName warning is the result. The problem is though that when we're resolving the pointcut, the pointcut expression contains ""Outer.Inner.myMethod()"" which makes no reference to the package... The reason we know about the package when we come to match is that after reporting the warning we record scope.getImportedPrefixes(). In the case of the supplied testcase this includes pkg$A, pkg., java.lang.Object$ and java.lang. The fix is to update lookupTypeInWorld to include a search for the typename prepended with these prefixes. Created attachment 51328failing testcasesApply this patch to the tests project.This patch contains four scenarios:1. There is one file containing public aspect and a class. The class contains a private inner class which contains a private method. There should be no warning from the pointcut about not being able to find the type corresponding to the inner class.2. The class and aspect are in different packages. The class has default visibility and contains a private method. The aspect imports the package containing the class. There should be no warning from the pointcut about not being able to find the class type.2. The class and aspect are in different packages. The class has default visibility and contains a private method. The aspect does not import the package containing the class. There should be a warning from the pointcut about not being able to find the class type.4. The class and aspect are are in the same package but different files. The class has default visibility and contains a private method. There should be no warnings saying cant find the class type. Created attachment 51329proposed fixApply this patch to the weaver project.This patch contains the proposed fix as described in comment #5. patches iniplog fixed in latest aj dev builds. "	2006-09-11 13:39:27	1158000000.0	resolved fixed	782ade2	1159890000.0	tests/bugs153/pr156904/inDiffPkgAndImport/Outer.java tests/bugs153/pr156904/inDiffPkgWithoutImport/Outer.java tests/bugs153/pr156904/inSamePkg/Outer.java tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java
152366	LTW Within Patterns Should Accept AND For Consistency	The load-time weaving definition system accepts AND in addition to &amp;&amp; for pointcuts, but it silently accepts and then fails to work with type patterns that use AND. Such type patterns are important when creating exceptions (e.g., excluding weblogic..* &amp;&amp; !weblogic.jdbc..*) and using AND is also helpful here.I've attached a patch to support this and tests to show it's working. Created attachment 47087Patch to loadtime module Created attachment 47088Patch to tests module patches in.iplog fixed in latest aj dev builds. Created attachment 51521tests patch to ensure they work on linuxApply this patch to the tests project.Currently the three tests for this bug fail on linux. The attached patch fixes this. doh!  ron and his patches... 	2006-07-31 14:44:20	1154370000.0	resolved fixed	7b831ff	1159890000.0	loadtime/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java tests/src/org/aspectj/systemtest/ajc150/ltw/LTWTests.java
158573	changing value of variable in aspect results in adviceDidNotMatch warning	"Given the following:public aspect A {	public static int i = 0;	before() : execution(* *.*(..)) {}}public class C {	public void m() {}}Changing the value of i to be something else and then saving results in an incremental build and an ""adviceDidNotMatch"" warning. A full build clears the warning.This is since the JDTLikeHandleProvider (bug 141730) was made the default in AJDT and is down to the call on line 90 of CrosscuttingMembersSet which is the fix for bug 134541). The reason we now hit this is that the JDTLikeHandleProvider doesn't depend on location. Created attachment 50831failing testcaseApply this patch to the tests project. The problem is that the new shadowMunger has the field ""hasMatchedAtLeastOnce"" set to false, as it would do since it was created on this incremental compile. The shadowmunger it's replacing has ""hasMatchedAtLeastOnce"" set to true because on the full compile we went through BcelAdvice.implementOn(). Currently in CrosscuttingMembersSet.replaceWith() we do a blanket replace of the shadowmungers to ensure we've picked up the latest changes. I guess we could be more specific here and ensure that we don't loose this type of information......  it's ugly but we could do that ... i've put in similarly ugly fixes before ;) Created attachment 50839patch containing proposed fixApply this patch to the weaver project.This patch contains the fix proposed in the above comment. test and 'fix' in ;)iplog fix available in aj dev builds. "	2006-09-25 11:09:03	1159200000.0	resolved fixed	cd9fd11	1159540000.0	tests/multiIncremental/PR158573/base/C.java tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java weaver/src/org/aspectj/weaver/CrosscuttingMembers.java weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java
158624	Compiler Error: generics and arrays	"<Pyinson Data Over Head> this problem is to do with generics and arrays.But I can't see any array signatures in the junit testcase stuff.  Can you tell me if any methods in SyncValueGroup involve arrays as a return value or parameters? would like to fix for 1.5.3 Created attachment 51080The SyncValueGroup class that the unit test is testing. Comment on attachment 51080The SyncValueGroup class that the unit test is testing.The method link supports varargs. I thought you might be on to something with that link() method but I still can't get it to fail.  I see SyncValueGroup extends ValueChange - could you possibly attach that?  (I hope that is the top of the hierarchy...)May I ask what kinds of pointcut you are using?  I'm trying within() so that I advise everything, but I just can't trigger this failure :( Created attachment 51087The ValueChange class required by SyncValueGroup.Here's the other file you requested.As for pointcuts, I have an abstract Aspect that pretty much cuts everything  (except for its own package) and some concrete sub-Aspects that narrow the focus.  It's basically some tracing code.  I could add those aspects as well.Also, I am only using the Eclipse AJDT to compile this.  Perhaps this is an AJDT issue?Thanks for the fast response. Created attachment 51088The abstract tracing class.Here's the abstract tracing class that defines my pointcuts. <Pyinson Data Over Head> <Pyinson Data Over Head> It seems to me that we are now both generally receiving the same error message. thanks for responding to me so quickly on this problem.  Here is a minimal test program that I'm using, which fails in the same way:abstract class ValueChange<Q> {    public ValueChange(Q initValue) { }}abstract class SyncValueGroup<T> extends ValueChange<T> {	public SyncValueGroup(T initValue) {        super(initValue);    }    public final synchronized void link(SyncValueGroup<T> ... list) {    }}class SyncValueTest {    class SyncInteger extends SyncValueGroup<Integer> {        public SyncInteger(int val) {            super(new Integer(val));        }    }    private SyncInteger a = new SyncInteger(1);    public void testSyncValueGroup() {        a.link(a);    }}aspect X {  before(): call(* *(..)) {}}As I first suspected, it is an array signature, and it was the link() method as you thought: ""link(SyncValueGroup<T> ... list)"" - after picking the array signature apart we fail to resolved the resulting parameterized type correctly (SyncValueGroup being paramterized by the type variable T).  I've now testing the fix. test and fix committed - will be in a dev build shortly. fix is in latest AJ dev build - will probably make it into AJDT in a few days. (In reply to comment #13)> fix is in latest AJ dev build - will probably make it into AJDT in a few days.Submitter confirming fix.I downloaded the AJDT:Eclipse AspectJ Development ToolsVersion: 1.4.1.200610100440AspectJ version: 1.5.3.200610091525Everything is working.  Thank you. thanks for confirming its fixed. "	2006-09-25 14:18:53	1159210000.0	resolved fixed	ea4ff8a	1159530000.0	tests/bugs153/pr158624/ValueChange.java tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java
148908	incorrect source signature for field ipe with qualified allocation expression	"Ajdoc chokes on interfaces with initializers for final fields (it doesn't preserve the initializer value). See attached AJDT project that fails when you run ajdoc with the default options on it:> Calling ajc...> Building signature files...> Calling javadoc...Loading source file C:\eclipse\3.2\ajdocworkingdir\BadInterface.java...1 error> Decorating html files...> Removing generated tags (this may take a while)...> Finished.C:\eclipse\3.2\ajdocworkingdir\BadInterface.java:9: = expectedstatic final Comparator MY_COMPARATOR;                                     ^ Created attachment 45419Exported jar with AJDT project and source code that chokes ajdoc After some initial investigation.....the actual error is coming from the step where we get hold of the javadoc main class, find the execute method and then call invoke on this method. It's not coming from the ""ajdoc"" side of things, but from the javadoc classes (com.sun.tools.javadoc.Main). The problem is that given the following source file:-------------------------------------public interface BadInterface {		static I MY_I = new I() {};}-------------------------------------the copy we make in ajdocworkingdir is:-------------------------------------/**__AJDECLID:2:__ *  */public interface BadInterface {/**__AJDECLID:3:__ *  */static I MY_I;}-------------------------------------Consequently we pass javadoc the wrong thing and it correctly throws an error. This is not an ajdoc bug. Ajdoc is calling IProgramElement.getSourceSignature() on the ipe with name MY_I and this is returning ""static I MY_I;"". Therefore, this is a bug within the model.Further investigation shows that this is working as designed. The sourceSignature for an IPE is set during AsmHierarchyBuilder.visit(FieldDeclaration,MethodScope) and is generated via the genSourceSignature(FieldDeclaration) method. In particular, this method has the comment ""Doesn't print qualified allocation expressions"". A ""QualifiedAllocationExpression"" has the following javadoc:/** * Variation on allocation, where can optionally be specified any of: * - leading enclosing instance * - trailing anonymous type * - generic type arguments for generic constructor invocation */In the failing case, the initialization is a QualifiedAllocationExpression and consequently it doesn't get included and the sourcesignature is set to be ""static I MY_I;"".The question is why we dont print qualified allocation expressions......... Created attachment 45525failing testcaseApply this patch to the tests project. A possible reason for not printing the qualified allocation expressions is that some extra manipulation needs to go in. Just treating them like other expressions and using the printExpression method results in the following being set as the source signature:static I MY_I = new I() {  x() {    super();  }}; Created attachment 45710failing testcaseApply to the tests project.This test replaces the previously attached one as it adds itself to the 153 tests rather than 152. Also it uses Ron's original BadInterface.java which tests more than the simple case. Created attachment 45712possible fixAttached is a possible fix for this bug........However, I'm not sure about it because it assumes that given something of the formstatic I MY_I = new I() {};in the code, that this becomes something of the formstatic I MY_I = new I() {  x() {    super();  }};In other words, that "" x() {super();}"" is added. Unfortunately, I can't think of a testcase where this assumption could be false (that the first thing after the first ""{"" isn't x(){super();}""). One thing to note is that all this is to do with setting the source signature of the iprogramelement. Currently the source signature is only used within ajdoc to add its extra tags to the code and copy this to the ajdocworkingdir.....this isn't a reason for having the wrong signature though :-)Apply the patch to the org.aspectj.ajdt.core project. decide what to do about this for 1.5.3 patches in - seems reasonable. fix avaiable. iplog "	2006-06-27 18:41:34	1151450000.0	resolved fixed	fc39df1	1159260000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java tests/bugs153/pr148908/BadInterface.java tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java
158412	@Pointcut in declare error results in NPE	"I am trying to use an @AspectJ @Pointcut in a ""normal"" AspectJ declare error expression. That  results in the following exception.java.lang.NullPointerExceptionat org.aspectj.weaver.patterns.ReferencePointcut.concretize1(ReferencePointcut.java:361)at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:233)at org.aspectj.weaver.patterns.NotPointcut.concretize1(NotPointcut.java:100)at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:233)at org.aspectj.weaver.patterns.AndPointcut.concretize1(AndPointcut.java:97)at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:233)at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:220)at org.aspectj.weaver.Checker.concretize(Checker.java:45)at org.aspectj.weaver.CrosscuttingMembers.addShadowMunger(CrosscuttingMembers.java:91)at org.aspectj.weaver.CrosscuttingMembers.addDeclare(CrosscuttingMembers.java:122)at org.aspectj.weaver.CrosscuttingMembers.addDeclares(CrosscuttingMembers.java:113)at org.aspectj.weaver.CrosscuttingMembersSet.addAdviceLikeDeclares(CrosscuttingMembersSet.java:117)at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.addAdviceLikeDeclares(AjLookupEnvironment.java:382)at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:245)at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301)at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:887)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:244)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:199)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:170)at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)NullPointerException thrown: null Created attachment 50755Project that shows the error incorrect resolution for a reference pointcut when using @AJ syntax. working on fix. test and fix committed. fix available in latest dev build. Changing OS from Mac OS to Mac OS X as per bug 185991 "	2006-09-23 05:11:13	1159000000.0	resolved fixed	e56a69a	1159190000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java tests/bugs153/pr158412/dao/Foo.java tests/bugs153/pr158412/layering/SystemArchitektur.java tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java
153845	[generics] Problem with signature for generic type	"public aspect OuterAspect {  private pointcut isSetter() : execution(void set*(..));  public static aspect InnerAspect pertarget(isSetter()) {  }}java.lang.IllegalStateExceptionat org.aspectj.apache.bcel.classfile.GenericSignatureParser.parseFieldTypeSignature(GenericSignatureParser.java:163)at org.aspectj.apache.bcel.classfile.GenericSignatureParser.parseTypeArgument(GenericSignatureParser.java:253)at org.aspectj.apache.bcel.classfile.GenericSignatureParser.maybeParseTypeArguments(GenericSignatureParser.java:261)at org.aspectj.apache.bcel.classfile.GenericSignatureParser.parseClassTypeSignature(GenericSignatureParser.java:208)at org.aspectj.apache.bcel.classfile.GenericSignatureParser.parseAsClassSignature(GenericSignatureParser.java:56)at org.aspectj.apache.bcel.classfile.Signature.asClassSignature(Signature.java:315)at org.aspectj.apache.bcel.classfile.JavaClass.getGenericClassTypeSignature(JavaClass.java:973)at org.aspectj.weaver.bcel.BcelObjectType.initializeFromJavaclass(BcelObjectType.java:164)at org.aspectj.weaver.bcel.BcelObjectType.<init>(BcelObjectType.java:131)at org.aspectj.weaver.bcel.BcelWorld.buildBcelDelegate(BcelWorld.java:337)at org.aspectj.weaver.bcel.BcelWorld.addSourceObjectType(BcelWorld.java:395)at org.aspectj.weaver.bcel.BcelWeaver.addIfAspect(BcelWeaver.java:263)at org.aspectj.weaver.bcel.BcelWeaver.addAspectsFromDirectory(BcelWeaver.java:255)at org.aspectj.weaver.bcel.BcelWeaver.addLibraryJarFile(BcelWeaver.java:205)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.initBcelWorld(AjBuildManager.java:698)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:223)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:199)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:170)at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)IllegalStateException thrown: Expecting [,L, or T, but found Pjava while unpacking Ljava/util/AbstractSet<Pjava/util/Map$Entry<TK;TV;>;>; Are you on 1.5.2 or a dev build of 1.5.3?I tried just compiling the aspect you included, worked fine.  Given that the signature it has trouble with is ""Ljava/util/AbstractSet<Pjava/util/Map$Entry<TK;TV;>;>;""something else must be involved - since your aspect doesn't use collection classes.  How are you compiling that aspect? Are you weaving rt.jar? I can't reproduce it anymore.  I'm using AspectJ 1.5.2 with AJDT 1.4 on Eclipse 3.2.  I was not trying to weave into rt.jar.  I'll reopen this bug if I come across it again and can make a reproducible test case for you. Created attachment 49854Testcase: Ant drivenThis small project demonstrate the BCEL exception for this bug. The project assumes a lib directory with the AspectJ jars (I used aspectj-DEVELOPMENT-20060907092616.jar for this). I've added a test case that demonstrates this bug. thanks for the testcase - I've been able to work out how the rogue signature is getting into the class output during the first compilation. I stripped down the testcase to the bare minimum.Basically you need to have some type that implements/extends a generic type, eg.Foo extends List<Set<String>>(and the generic reference has to be nested, can't be List<String> - needs to be more complex).That type must be affected by a declare parents to cause the signature to change, this will result in a broken signature on disk (so assume declare parents: Foo implements Serializable):Ljava/util/List<Pjava/util/Set<Ljava/lang/String;>;>;(see the rogue P)then that has to be used in a subsequent weave and the weaver will blow up when unpacking it.  The fix is trivial ;)Test and fix checked in - the fix is likely to address any/all related bugs that  suffer this same illegal state exception. fix available in AJ dev builds. Still getting this problem, but only from AJDT - it seems to work perfectly well in Ant/AspectJ.I'll attach a Team Project Set file with two projects that generate this failure. Sorry for the moderate download size. (Depends on Subclipse for Subversion access).The stack trace is a little different from Eclipse as well, here is a copy:java.lang.IllegalStateExceptionat org.aspectj.apache.bcel.classfile.GenericSignatureParser.parseFieldTypeSignature(GenericSignatureParser.java:163)at org.aspectj.apache.bcel.classfile.GenericSignatureParser.parseTypeArgument(GenericSignatureParser.java:253)at org.aspectj.apache.bcel.classfile.GenericSignatureParser.maybeParseTypeArguments(GenericSignatureParser.java:261)at org.aspectj.apache.bcel.classfile.GenericSignatureParser.pars ... teException thrown: Expecting [,L, or T, but found Pjava while unpacking Ljava/lang/ThreadLocal<Pjava/util/Set<Ldash/obtain/provider/ObtainLookup;>;>; Created attachment 50611Team Project Set file for failing caseThis Team Project Set file points to two Eclipse projects that demonstrate the failure in AJDT. i dont believe AJDT has been upgraded with the most recent AspectJ build... hence it is still failing... The latest 1.4 and 1.5 AJDT dev builds now contain this fix. "	2006-08-14 21:28:08	1155610000.0	resolved fixed	70ae0f8	1158230000.0	tests/bugs153/pr153845/Aspect.java tests/bugs153/pr153845/Aspect2.java tests/bugs153/pr153845/GenericType.java tests/bugs153/pr153845/Interface.java tests/bugs153/pr153845/Nothing.java tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java weaver/src/org/aspectj/weaver/ReferenceType.java
155972	NullPointerException in ConstructorSignature.getConstructor()	"AspectJ version: 1.5.3.200608290814When advising a constructor, we can do the following to obtain the constructor as a java.lang.reflect.Member:		Member cons = ((ConstructorSignature) thisJoinPointStaticPart				.getSignature()).getConstructor();however that sometimes fails, and returns null. Created attachment 49252Run MyClass.java and get:mainmember: nulldoneNote that the project has a 1.4 Java compliance setting (bug doesn't occur with 5.0)Also, if you uncomment this line in the aspect:   thisJoinPointStaticPart.getSignature().getDeclaringType();it starts working as expected:mainmember: public bar.MyClass()done Created attachment 49253testcaseoops, previous attachment was the full testcase, this one is the cut down version Created attachment 49254fixThe NPE comes from this line in ConstructorSignatureImpl.getConstructor():constructor = declaringType.getDeclaredConstructor(getParameterTypes());because declaringType hasn't been initialised yet.A fix is to use getDeclaringType() instead. There may be other cases of this to consider. I ran into a similar bug #94167 a long time ago ... it would be good to test that none of the join point methods are implicitly relying on some other method to initialize internal variables. In an instructive, although not scientific, experiment I wrote the following aspect to first find fields in the Signature hierarchy that are initialized lazily then individual declare error statements to find if thy were ever accessed directly where they shouldn't.public aspect LazyInitialization {	/* Find fields that are initialized lazily */	declare warning : set(* org.aspectj.lang.Signature+.*) && withincode(* *.get*(..)) && within(org.aspectj..*) :		""initialize"";		/* Find direct access to those fields */	declare error : get(* org.aspectj.lang.Signature+.*Type) && !(withincode(* *.create*(..)) || withincode(* *.get*Type(..)) || withincode(*.new(..))) && within(org.aspectj..*) :		""reference"";	declare error : get(* org.aspectj.lang.Signature+.*Types) && !(withincode(* *.create*(..)) || withincode(* *.get*Types(..)) || withincode(*.new(..))) && within(org.aspectj..*) :		""reference"";	declare error : get(* org.aspectj.lang.Signature+.*TypeName) && !(withincode(* *.create*(..)) || withincode(* *.get*TypeName(..)) || withincode(*.new(..))) && within(org.aspectj..*) :		""reference"";	declare error : get(* org.aspectj.lang.Signature+.*ClassLoader) && !(withincode(* *.create*(..)) || withincode(* *.get*ClassLoader(..)) || withincode(*.new(..))) && within(org.aspectj..*) :		""reference"";}It found two addition cases in FieldSignatureIMpl.getField() and InitializerSignatureImpl.getInitializer(). However a better solution might be to declare fields private that are initialized lazily. Fix applied and tests added along with those for FieldSignatureImpl and InitializerSignatureImpl. Fix available in aspectj-DEVELOPMENT-20060904170118.jar "	2006-09-01 08:45:05	1157110000.0	resolved fixed	090de7e	1157380000.0	runtime/src/org/aspectj/runtime/reflect/ConstructorSignatureImpl.java runtime/src/org/aspectj/runtime/reflect/FieldSignatureImpl.java runtime/src/org/aspectj/runtime/reflect/InitializerSignatureImpl.java tests/bugs153/pr155972/ConstructorTest.java tests/bugs153/pr155972/FieldTest.java tests/bugs153/pr155972/InitializerTest.java tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java
155238	Trace should use System.identityHashCode, not hashCode	The tracing module uses obj.hashCode() to identify untrusted objects when formatting. I think it would be a little safer and more accurate to useSystem.identityHashCode(obj). This way the tracing code wouldn't call any application-defined code, and would give a value that can't change if the loader state changes. Good idea. I have changed DefaultWeavingContext too. Changes committed. aspectj-DEVELOPMENT-20060904170118.jar 	2006-08-25 11:46:46	1156520000.0	resolved fixed	14e8b7d	1156930000.0	loadtime/src/org/aspectj/weaver/loadtime/DefaultWeavingContext.java weaver/src/org/aspectj/weaver/tools/AbstractTrace.java
155148	jdk14 trace deadlock in oc4j	<Pyinson Data Over Head> <Pyinson Data Over Head> Created attachment 48664This patch to loadtime isn't a complete solution to the problem, but it fixed it in my case.In general, I think the weaver tracing shouldn't call methods like toString that might trigger class loading and result in deadlock. >In general, I think the weaver tracing shouldn't call methods like toString>that might trigger class loading and result in deadlock.If you look carefully at the stack trace you will see that it doesn't. This is _actually_ a problem with the JUL formatter which is using toString(). If you used a different formatter or logging implementation this wouldn't happen. The internal weaver DefaultTrace implementation always uses object identity unless it's a well know simple type.I am inclined to view this as a JDK problem but see the merit of your patch. However I think I will change the implementation of Jdk14Trace to pre-format classes like ClassLoader. *** Bug 155146 has been marked as a duplicate of this bug. *** I have decided not to trust anyone! All arguments, apart from a few JDK classes like Integer, will be pre-formatted as String before being passed to a logging implementation. In the case of this bug it means you will _always_ get oracle.classloader.PolicyClassLoader@12345678.We will continue to expand the set of AspectJ classes that implement Traceable, will add trusted JDK classes on request and may offer a TraceFormatter interface to be used at the user's own risk! That sounds like an excellent strategy. Fix available in aspectj-DEVELOPMENT-20060825175312.jar. 	2006-08-24 20:59:00	1156470000.0	resolved fixed	6be7097	1156520000.0	loadtime/src/org/aspectj/weaver/loadtime/DefaultWeavingContext.java weaver/src/org/aspectj/weaver/tools/AbstractTrace.java weaver/testsrc/org/aspectj/weaver/AbstractTraceTest.java weaver5/java5-src/org/aspectj/weaver/tools/Jdk14Trace.java
155213	[ltw] can get into a state with the Version static initializer	The static initializer in Version that parses the time_text string and turns it into a long field seems to sometimes get loadtime weaving into a state - touching DateFormatters early on is always a pain, so I'm moving it to be processed on first reference.  I could take it a step further ... if WeaverStateInfo didn't write out the time (it doesnt read it back in!!) it would never be used at all in normal processing - potentially saving us from loading a bunch of underpinning junk to do the formatting... fixes committed as he says, fixes committed. 	2006-08-25 08:34:30	1156510000.0	resolved fixed	40cf610	1156510000.0	ajde/src/org/aspectj/ajde/ui/swing/OptionsFrame.java bridge/src/org/aspectj/bridge/Version.java bridge/testsrc/org/aspectj/bridge/VersionTest.java weaver/src/org/aspectj/weaver/AjAttribute.java
129525	Don't Dump Bytecodes to Syserr in LTW	"The load-time weaving system can produce truly massive quantities of output when there's a weaving error, since the system dumps the bytecode to syserr. It would be much better to produce an ajcore file and just point to it, or use some other log. I agree we should make better use of ajcore files. However they will be times when, due to a SecurityManager, the weaver does not have access to the disk and all data will still need to be sent to stderr.What other log do you suggest? I would suggest:1) try to write an ajcore file2) failing that, try to use java.util.logging to log the information at an error level3) failing that, writing to System.error I have changed the LTW message handler so that it no longer causes an AbortException when an error is issued. My original intention was to fail the loading of the class concerned but this doesn't happen because the exception is caught somewhere else in weaver/loadtime and it may not be desirable anyway. This should result in fewer ""trouble in: ..."" type messages where there is actually no problem with weaving.I have opened Bug 155033 ""Use ajcore for LTW problems"" to look at a more appropriate method of information capture. I ran into a case where the new code still dumps a spectacular amount of data to the console by dumping bytecode for each class, this with a very recent dev build. I reran with stdout and stderr redirected and have 2 megs of output from startup. This is the kind of scenario that would be greatly improved with ajcore files!In this case, it was a circularity error from some test advice (which was obscured badly by the obscure message and the volumes of bytecode dumped):[PolicyClassLoader@13631582] error at glassbox\monitor\AbstractMonitor.aj:115::0 can't determine precedence between two or more pieces of advice that apply to the same join point: method-execution...[PolicyClassLoader@13631582] abort trouble in:... Fix available in aspectj-DEVELOPMENT-20060824191234.jar. "	2006-02-27 03:18:33	1141030000.0	resolved fixed	04fa1dc	1156440000.0	loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java loadtime/src/org/aspectj/weaver/loadtime/WeavingURLClassLoader.java tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java
150271	Allow multiple levels of LTW information	"It would be nice if basic information about load-time weaving (what version of AspectJ is being used, what loaders are doing weaving and what configuration is being used) was available without all of the -verbose information listing of all classes woven or not woven.It's also unfortunate that the flags for weaving level are 2 quite different ones:-Daj.weaving.verbose -Dorg.aspectj.weaver.showWeaveInfoWhy not something like -Dorg.aspectj.weaver.level=[none|summary|info|verbose]summary: just what configuration is usedinfo: list affected join points etc. (like showWeaveInfo)verbose: all (like verbose now) I assume you would always like warnings and errors to come out? In which case they need context i.e. what aspects are registered and which aop.xml files were used. Therefore I think it makes sense to put out what you call ""summary"" information by default. Perhaps a better approach would be -silent which (for whatever reason) allows a user to turn of all messages. The -verbose and –showWeaveInfo options, which of cause are not peculiar to LTW, would remain the same.The aop.xml file will remain the primary configuration mechanism because in a complex system it is easier to use than System properties (in my experience) and has none of the security implications. However we should revisit the names used as they are quite old. I suspect org.aspectj.weaver.loadtime.XXX would be a good start. Another option would be for many of the current info messages in LTW to be debug. We don't seem to use this level of messages at the moment so their is no support for a -debug flag but it would be consistent with other tools like Ant. So that way we would have:default:        warning, error-verbose:       info including AspectJ version, classloader, configuration-showWeaveInfo: weave -debug:         debug including weaving, not weaving, generating, ...We could also keep the initial configuration messages and dump them when we get the first warning or error for context. I would definitely like errors to come out. I would like to be able to configure warnings to suppress known ones but otherwise they should too. I quite like the idea of dumping configuration information when an error or warning is emitted. The other case where configuration information is helpful to see is when nothing is happening (e.g., -javaagent isn't being passed in, the aop.xml file isn't present, possibly one aop.xml file turns off something in another one: that is a possible warning itself).I would also be quite happy with some kind of log adapter so that AspectJ messages could be configured through normal logging mechanisms. I agree that configuring anything possible within the aop.xml file is the preferred place: the one place where system-wide flags make sense is for global configuration (e.g., troubleshooting if you have set up your aop configuration correctly).-Dorg.aspectj.weaver.loadtime.XXX sounds good to me, and the levels sound right. I would suggest leaving -verbose as a deprecated alias for -debug:default:        warning, error-info:          info including AspectJ version, classloader, configuration-showWeaveInfo: weave PLUS info-debug:         debug including weaving, not weaving, generating, ...                 PLUS showWeaveInfo-verbose:       same as -debug with deprecated warning message (or not)How hard would it be to allow plugging in a log message handler instead of writing to the console? It seems like this is a good area to define a Plugin API with a simple interface so people can create adapters for Log4J, RAS, JULI/jdk, commons logging, sl4j, etc.  >I would like to be able to configure warnings to suppress known ones but >otherwise they should too.I will ask the same question as I did for Xlint: which warnings do you feel the need to suppress? The product should work out of the box if coding guidelines are followed. The messages are there for me as well as you :-)>e.g., -javaagent isn't being passed in,I’m not sure how we can handle this one as we are not in the loop at all>the aop.xml file isn't present, possibly one aop.xml file turns off >something in another one: that is a possible warning itselfWe already list the aop.xml files that are used. Using include/exclude for aspects can cause “aspectExcludedByConfiguration” to be issued. We already issue “not woven” messages (which should probably be debug) but I could add a reason why a class is exluded>How hard would it be to allow plugging in a log message handler instead >of writing to the console?Probably not very. Andy and I have been talking about problem diagnosis for LTW. I have just opened Bug 150487 “Tracing and Logging Framework”.With the growing popularity of load-time weaving it is becoming increasing difficult to diagnose complex problems given the limited diagnostic information available: stack trace, verbose output, and dumped byte-code. With compiler errors it is usually possible for the bug raiser to attach a testcase but this is not possible when the problem may concern environment or integration with middleware. I therefore propose we implement a tracing/logging mechanism that will capture low level entry/exit information as well as existing informational messages (see Ron’s comment in Bug 150271 “Allow multiple levels of LTW information”) and route them to one of the existing logging infrastructures such as JDK 1.4 or Jakarta Commons logging. >I will ask the same question as I did for Xlint: which warnings do you feel the>need to suppress? The product should work out of the box if coding guidelines>are followed. The messages are there for me as well as you :-)Almost any of the warnings that are reasonable to suppress today have been made configurable through Xlint, which is good. As an example of something of the sort, suppose there's a runtime limitation like not being able to inline around advice because of the aspect configuration (e.g., shared library aspects from the system classpath aren't being woven). That should be a warning, but it should also be supressable. The system may well work just fine without inlined around advice and an administrator shouldn't have to see a warning about it if the developer realizes the limitation and has tested for it. This wouldn't be a weaver issue since it's really an LTW configuration warning, so I don't think it should go in Xlint.properties. But that one is hypothetical. A quick look through the loadtime module shows a few other candidates:* warnings for missing DTD's (dumped directly to syserr in DocumentParser)* define generated class failed (ClassLoaderWeavingAdaptor): as noted in the code, there might be situtations where this happens but it's not an error. There may also be systems that recover properly from a runtime limitation like this and don't want it emitted to the output.Of course the current aop.xml mechanism does allow you to suppress warnings, but unfortunately it suppresses all of them. I think only a few should be suppressable, based on analysis that indicates it might be expected to run with the warning occurring, rather than it being a problem that should always be fixed.>>e.g., -javaagent isn't being passed in,>I知 not sure how we can handle this one as we are not in the loop at allThe best way to test for this is a simple output to indicate that the LTW system has started with the AspectJ version. I.e., without any configuration, did the system print something? I'd be glad to have that one line of information come out (e.g., at INFO level in a log) by default unless you start with a silent flag. >...I could add a reason why a class is exludedThat sounds good for debug purposes.Re: bug #150487, that sounds great. Thanks for creating that! I was hoping for a list of existing warnings that you felt the need to suppress rather that a list of new ones that if I added you would like to be able suppress. As with Bug 149322 “Change Xlint cantFindType default to warning” I believe warnings and errors should not be suppressed as a matter of course. If there are situations when a change to your code cannot remove the warning/error but you feel the resulting application behaves correctly then we should review the message.Let’s discuss the new ones you mentioned:-	Not being able to inline around advice: I believe warnings should be used to help people. If the compiler issues a warning which the user can do nothing about, as in this situation, apart from suppress it then the message is pointless. I have opened Bug 149802 “Support inlining of all eligible around advice” to investigate whether we can apply the optimization more widely.-	warnings for missing DTD's: This should be an error, not even Xlint.-	define generated class failed:	This should also be an error. I was nervous about making it one because certain message handles abort on errors. There is not a situation that I can think of where not being able to define a closure on which a class we have just woven has a hard dependency is OK. I don’t agree with the comment in the code. We should either ignore the explicit case mentioned or stop the situation occurring (it might be related to Bug 119657 “IllegalAccessError with around advice on interface method call”). There aren't any other cases of warnings that I've encountered that I might like to suppress other than Xlint warnings and the two examples I listed. There might be some others that I've not encountered, but if there are they're either rare or not relevant to configurations I've used. > ...I might like to suppress other than Xlint warningsWhich ones? I don't think we are explicit enough about the purpose of Xlint but my understanding of the process from conversations the Jim H. is that it is an experimental area rather than a generalized process for suppressing errors/warnings. When I add an Xlint error I do so because I feel I might break a user who cannot avoid it. When we understand the situation better either the message goes away or becomes a hard error. Here are the Xlint properties that default to warning that I have been suppressing:invalidAbsoluteTypeName [needed to support optional 3rd party libraries]typeNotExposedToWeaver [needed to support optional 3rd party libraries]unmatchedSuperTypeInCall [these are of course valid and intended to not match]adviceDidNotMatch [ditto]runtimeExceptionNotSoftened [I don't want to soften runtime exceptions]Of course cantFindType/cantFindTypeAffectingJPMatch are the subject of a different bugzilla issue. I have gone for the approach in Comment #2 although there is not yet support for dumping configuration information by default at the first error. This should reduce the amount of output generated when just trying to obtain configuration information.>Why not something like -Dorg.aspectj.weaver.level=[none|summary|info|verbose]Unfortunately we don't yet have the concept of ""levels"": weaveInfo is completely separate although you coud imagine: default(warning & error), -verbose(info), -debug(debug) -showWeaveInfo(weaveInfo) with one automatically including those above. Of course this only applies to the default WeavingAdaptorMessageWriter and you are free to supply you own. >... A quick look>through the loadtime module shows a few other candidates:>* warnings for missing DTD's (dumped directly to syserr in DocumentParser)Are you referring to DocumentParser. resolveEntity() in which case do you have a situation where this arised so that I can write a test. Or are you referring to this type of Exception which is thrown for badly formed aop.xml and for which we issue a warning (not error) but the stack trace is dumped by default:[AppClassLoader@9627532] warning parse definitions failed -- (SAXParseException) The element type ""concrete-aspect"" must be terminated by the matching end-tag ""</concrete-aspect>"".The element type ""concrete-aspect"" must be terminated by the matching end-tag ""</concrete-aspect>"".org.xml.sax.SAXParseException: The element type ""concrete-aspect"" must be terminated by the matching end-tag ""</concrete-aspect>"". 	at com.sun.org.apache.xerces.internal.util.ErrorHandlerWrapper.createSAXParseException(ErrorHandlerWrapper.java:236) 	at com.sun.org.apache.xerces.internal.util.ErrorHandlerWrapper.fatalError(ErrorHandlerWrapper.java:215) 	at com.sun.org.apache.xerces.internal.impl.XMLErrorReporter.reportError(XMLErrorReporter.java:386)… I was indeed referring to DocumentParser.resolveEntity. I believe you could trigger one warning by writing an aop.xml file with an unknown DTD (e.g., -//AspectJ//DTD 1.5.3//EN). The other one would be hard to test: you'd need a configuration where the weaving agent is unable to read the aspectj_1_5_0.dtd resource (which would be a broken one!)I noticed these warnings from reviewing the code when you asked what other warnings might need to be supressed. But in general, neither of these two warnings should be suppressed. If we add another version of the DTD then the weaver should continue to be backwards-compatible and support the old ones... Leaving this one for now until after I have investigated the use of ajcore for FFDC. "	2006-07-11 11:31:28	1152630000.0	resolved fixed	8549d86	1156330000.0	loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java loadtime/src/org/aspectj/weaver/loadtime/DefaultMessageHandler.java loadtime/src/org/aspectj/weaver/loadtime/Options.java tests/java5/ataspectj/ataspectj/TestHelper.java weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java
149560	[@AspectJ] Incorrect weaving of static initialization join point	"This error occurs if static initialization of one aspect class is woven with an advice from another aspect. It worked fine in version 1.5.0 - see the decompiled code snippet:    static     {        Object obj = new Factory(""ItoMonitoringAspect.java"", Class.forName(""cz.kb.usermanagement.ito.ItoMonitoringAspect""));        ajc$tjp_0 = ((Factory) (obj)).makeSJP(""staticinitialization"", ((Factory) (obj)).makeInitializerSig(""8"", ""cz.kb.usermanagement.ito.ItoMonitoringAspect""), 0);        obj = Factory.makeJP(ajc$tjp_0, null, null);                        // the static initialization of this aspect class is deliberately woven using        // advice from another aspect defined elsewhere.                try        {            UserManagementLogAspect.aspectOf().beforeClassInit(((org.aspectj.lang.JoinPoint) (obj)));        }        catch(Throwable throwable)        {            if(throwable instanceof ExceptionInInitializerError)            {                throw (ExceptionInInitializerError)throwable;            } else            {                UserManagementLogAspect.aspectOf().afterClassInit();                throw throwable;            }        }        UserManagementLogAspect.aspectOf().afterClassInit();                // this line below was there when compiling using AspectJ 1.5.0         // but is missing in when using AJC 1.5.2. (Note: the line is, however, present if the static        // initialization of this aspect class is NOT woven by advice from the other aspect).        ajc$postClinit();   }As a result of the missing call to ajc$postClinit() the aspect instance is not created and it's method .aspectOf() throws org.aspectj.lang.NoAspectBoundException. I'm afraid I need a little more to go on ... This program works fine for me:=============public aspect A1 {  static {  }  public static void main(String []argv) {    System.err.println(""A1  = ""+A1.aspectOf());    System.err.println(""A2  = ""+A2.aspectOf());  }}aspect A2 {  before(): staticinitialization(A1) {System.err.println(""tjp=""+thisJoinPointStaticPart);}}============what is different between my program and your configuration?  are you using per clauses? Created attachment 46062Woven aspect Created attachment 46063weaving aspect Hi,it seems that the problem occurs when @After advice is used with static initialization join point. Please see attachments - it works when only @Before advice is used, but fails if @After is uncommented. Decompiled static initializers for the respective cases:    // A1 static initializer with A2 defining only before advice    static     {        A2.aspectOf().beforeClassInit();        System.out.println(""... initializing A1 ... "");        ajc$postClinit();    }        // A1 static initializer with A2 defining both before and after advices    static     {       try            {                A2.aspectOf().beforeClassInit();                System.out.println(""... initializing A1 ... "");            }  catch(Throwable throwable) {                if(throwable instanceof ExceptionInInitializerError) {                    throw (ExceptionInInitializerError)throwable;                } else {                    A2.aspectOf().afterClassInit();                    throw throwable;             }       }       A2.aspectOf().afterClassInit();    } I have two programs.This one won't run:--8<-------import org.aspectj.lang.annotation.*;import org.aspectj.lang.*;@Aspectclass MyAspect {  @After(""staticinitialization(*)"")  public void x() {    System.out.println(""... after class init advice ..."");  }}public aspect AnnStyle {  static {  }  public static void main(String []argv) {    System.err.println(""Instance  = ""+Aspects.aspectOf(MyAspect.class));  }}--8<-------This one will run:--8<-------import org.aspectj.lang.*;aspect MyAspect {  after(): staticinitialization(*) {    System.out.println(""... after class init advice ..."");  }}public aspect CodeStyle {  static {  }  public static void main(String []argv) {    System.err.println(""Instance  = ""+Aspects.aspectOf(MyAspect.class));  }}--8<-------But I don't know if they demonstrate your problem because the failing one fails on AspectJ1.5.0 and the latest whilst the working one works on AspectJ1.5.0 and the latest.  The difference between them is code vs annotation style - is that perhaps what you meant by your original comment ""It worked fine in version 1.5.0"" - did it start failing when you switched to annotation style?Attaching decompiled code won't help me fix this bug, I need a viable testcase - if the above doesn't show your problem, please can you modify them as simple standalone programs that show the problem and reattach them, then I can look into it. (In reply to comment #5)> I have two programs.> This one won't run:> --8<-------> import org.aspectj.lang.annotation.*;> import org.aspectj.lang.*;> @Aspect> class MyAspect {>   @After(""staticinitialization(*)"")>   public void x() {>     System.out.println(""... after class init advice ..."");>   }> }> public aspect AnnStyle {>   static {>   }>   public static void main(String []argv) {>     System.err.println(""Instance  = ""+Aspects.aspectOf(MyAspect.class));>   }> }> --8<-------> This one will run:> --8<-------> import org.aspectj.lang.*;> aspect MyAspect {>   after(): staticinitialization(*) {>     System.out.println(""... after class init advice ..."");>   }> }> public aspect CodeStyle {>   static {>   }>   public static void main(String []argv) {>     System.err.println(""Instance  = ""+Aspects.aspectOf(MyAspect.class));>   }> }> --8<-------> But I don't know if they demonstrate your problem because the failing one fails> on AspectJ1.5.0 and the latest whilst the working one works on AspectJ1.5.0 and> the latest.  The difference between them is code vs annotation style - is that> perhaps what you meant by your original comment ""It worked fine in version> 1.5.0"" - did it start failing when you switched to annotation style?> Attaching decompiled code won't help me fix this bug, I need a viable testcase> - if the above doesn't show your problem, please can you modify them as simple> standalone programs that show the problem and reattach them, then I can look> into it.Hi, I will check your samples to see if there are any dependencies on the annotation vs. AspectJ language style, but that was not my case. I have always used the annotation style, i.e. as of the version 1.5.0. The sample provided in my attachments should demonstrate the problem - they work when compiled with AspectJ 1.5.0 compiler and run either on 1.5.0 or on 1.5.2 RT and they fail if compiled with AspectJ 1.5.2 compiler (in fact also if compiled with 1.5.1 compiler). The decompilation is provided just to point out what is missing from the static initializer if compiled by 1.5.2. I've fixed the problem I can see - and from I can get to work of your program, it fixes that too.  Two things I had to fix:  Annotation style creation of the staticinitialization was broken, creating a try/catch block with a handler destination that was inside the try/catch.  Also the staticinitializer was being manipulated too late, the postclinit call was added at completely the wrong time and I had to move all that code to an earlier stage in the process.None of these problems occur using code style syntax.If you want to try it on your code, I've put a driver here since we are having some trouble with our automatic build process at the mo:http://www.eclipse.org/downloads/download.php?file=/technology/aspectj/dev/aspectj-1.5.3-dev.jarit will take a while for this file to replicate around the servers so you can download it. (In reply to comment #7)Hi, the 1.5.3-dev version works fine with annotation style. I did not test with the code style. Regards ok - thanks for testing it.  Fixes are in latest dev build available from download page now. "	2006-07-04 07:47:44	1152010000.0	resolved fixed	945a257	1156260000.0	tests/bugs153/pr149560/AnnStyle.java tests/bugs153/pr149560/CodeStyle.java tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java weaver/src/org/aspectj/weaver/bcel/BcelPerClauseAspectAdder.java weaver/src/org/aspectj/weaver/patterns/PerSingleton.java
154332	[annotations] Incorrect handling of java.lang annotations when matching	"As raised by Mr Bodkin on the list:Can anyone tell me why this compiling this program produces warnings for marker but not for deprecated (in a recent dev build of AJDT)? Is this just a bug? Both have runtime retention, so I would expect equivalent behavior. @Deprecated @Markerpublic aspect Annot {     pointcut test() : within(@Marker *);// *);       declare warning: staticinitialization(@Deprecated *): ""deprecated"";       declare warning: staticinitialization(@Marker *): ""marker"";          public static void main(String argz[]) {        new Baz().foo();    }} @Deprecated @Markerclass Baz {    public void foo() {}} @Retention(RetentionPolicy.RUNTIME)public @interface Marker { } test and fix committed - some silly code that chopped java.lang off the front and left us with something that wouldn't resolve (doh!) - who writes this rubbish... "	2006-08-18 03:49:03	1155890000.0	resolved fixed	59123b0	1155890000.0	tests/bugs153/pr154332/Annot.java tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java
153535	Bug in reflection delegate signature for array of object type	<Pyinson Data Over Head> Created attachment 47752Patch to weaver module showing unexpected signature in reflection delegate Yep, this definitely looks wrong. We should never see dots in a signature string. I've seen this before - it is a java spec thing that arrays get the different signatures for their component types.  I did try and find the bug that involved this problem previously so I could refer to it here, but I can't find it.testcase and fix committed. The fix is also working as expected in the original case where calls were not matching correctly with LTW on a 1.4 VM.Please feel free to mark as FIXED whenever you have released it (it's probably already in a dev build?) fix available. 	2006-08-11 03:34:59	1155280000.0	resolved fixed	82e3e13	1155640000.0	weaver/src/org/aspectj/weaver/reflect/ReflectionWorld.java weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java weaver5/java5-testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java
148219	Wrong warning is reported	"Created attachment 45088sceenshot reproduced with latest dev builds (once the JDT ""parameter is never read"" option is set to warning). The warning is issued against the pointcut, which doesn't really make much sense for a pointcut. Passing over to the compiler. fix committed in AJ tree. fix available in AJ. I used ajdt_1.3.1_for_eclipse_3.1.zip on Eclipse 3.1.2.Below is my aspectj code.public aspect MyMessages {    pointcut getResourceString(String key): args(key, ..) &&    call (* CommonPlugin.getResourceString(String, ..));    String around(String key):getResourceString(key) {    	return key;    }}The warning message isThe parameter key is never read. See my screenshot. "	2006-06-22 10:05:18	1150990000.0	resolved fixed	07c2189	1155050000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java tests/bugs153/PR148219/MyMessages.java tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java
152161	Contribution: Support -Xset in Load-Time Weaving Configuration	I needed this to try out a setting in the pipelined compilation (-Xset:runMinimalMemory=true) ... I was able to verify that it parsed and set an option correctly in the debugger. I also have included a test that sets all the currently available options. Created attachment 46956Patch to loadtime module Created attachment 46957Patch to tests module Created attachment 46961Updated tests to set values both ways. To verify that the settings take effect, we'd need more output from the weaver or a case where we could observe pipelining versus not... pipelining wont make any difference to LTW, it is a compiler thing. there are some changes to other types around the system (BcelObjectType) that will affect LTW but they are unrelated to pipelining, they are just things I noticed along the way.A possible follow on enhancement could be binary weaving pipelining, but again, that won't affect LTW which is already effectively pipelining.But I like the enhancement to allow Xset through (although I thought LTWWorld already had that forced to true whereas batch did not). patches in. 	2006-07-28 11:51:55	1154100000.0	resolved fixed	039be68	1155050000.0	loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java loadtime/src/org/aspectj/weaver/loadtime/Options.java tests/src/org/aspectj/systemtest/ajc150/ltw/LTWTests.java
152388	NPE in MessageUtil.addExtraSourceLocations	"I get this message from an error in a recent dev build of AspectJ with load-time weaving. I don't know how there is a null source location associated with this message, but either it shouldn't be there or MessageUtil line 806 should use this patch:Index: src/org/aspectj/bridge/MessageUtil.java===================================================================RCS file: /home/technology/org.aspectj/modules/bridge/src/org/aspectj/bridge/MessageUtil.java,vretrieving revision 1.11diff -u -r1.11 MessageUtil.java--- src/org/aspectj/bridge/MessageUtil.java	1 Jun 2006 09:36:37 -0000	1.11+++ src/org/aspectj/bridge/MessageUtil.java	31 Jul 2006 22:32:16 -0000@@ -803,7 +803,7 @@ 		writer.println(baseMessage); 		for (Iterator iter = message.getExtraSourceLocations().iterator(); iter.hasNext();) { 		    ISourceLocation element = (ISourceLocation) iter.next();-		    writer.print(""\tsee also: "" + element.toString());+		    writer.print(""\tsee also: "" + element); 		    if (iter.hasNext()) { 		        writer.println(); 		    }NPE follows:java.lang.NullPointerException	at org.aspectj.bridge.MessageUtil.addExtraSourceLocations(MessageUtil.java:806)	at org.aspectj.bridge.MessageUtil.renderMessage(MessageUtil.java:793)	at org.aspectj.bridge.Message.toString(Message.java:177)	at org.aspectj.bridge.MessageWriter.render(MessageWriter.java:73)	at org.aspectj.weaver.tools.WeavingAdaptor$WeavingAdaptorMessageHandler.render(WeavingAdaptor.java:471)	at org.aspectj.bridge.MessageWriter.handleMessage(MessageWriter.java:41)	at org.aspectj.weaver.tools.WeavingAdaptor$WeavingAdaptorMessageHandler.handleMessage(WeavingAdaptor.java:425)	at org.aspectj.weaver.bcel.BcelTypeMunger.error(BcelTypeMunger.java:378)	at org.aspectj.weaver.bcel.BcelTypeMunger.enforceDecpRule1_abstractMethodsImplemented(BcelTypeMunger.java:273)	at org.aspectj.weaver.bcel.BcelTypeMunger.mungeNewParent(BcelTypeMunger.java:194)	at org.aspectj.weaver.bcel.BcelTypeMunger.munge(BcelTypeMunger.java:106)	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:450)	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:115)	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1613)	at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1564)	at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1341)	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1163)	at org.aspectj.weaver.tools.WeavingAdaptor.getWovenBytes(WeavingAdaptor.java:288)	at org.aspectj.weaver.tools.WeavingAdaptor.weaveClass(WeavingAdaptor.java:214)	at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:76)	at org.aspectj.ext.ltw13.ClassPreProcessorAdapter.preProcess(ClassPreProcessorAdapter.java:65)	at org.codehaus.aspectwerkz.hook.impl.ClassPreProcessorHelper.defineClass0Pre(ClassPreProcessorHelper.java:107)	at java.lang.ClassLoader.defineClass(ClassLoader.java:539)...NOTE: I'm using Alex Vasseur's adaptor to invoke AspectJ LTW from a 1.4 VM, but with recursion protection added. I don't think that should change the expected behavior of Aj. Hmmm ... I'd rather see a testcase for the problem that leads to this... It was triggered by the current problems in LTW with ITD's. The system gets confused because of loading order for an ITD and it produces invalid bytecode so it dumps the bytecode in an abort. This bug meant that while producing the message output it hit an NPE, thereby obscuring the real error. With the patch I submitted I saw the real error message instead. Creating a test for this means forcing the weaver to crash, which shouldn't be possible, of course. With the ITD bug in place it's surely possible but it is dependent on order of loading in a large system (simple attempts fail)I have temporarily fixed the original crash by working around the bug by using maps instead of ITD's. With that change the woven bytecode is valid and the bug doesn't happen. reworked suggestion integrated. you have caught me in a good mood today. "	2006-07-31 18:31:46	1154390000.0	resolved fixed	a38edd3	1155040000.0	bridge/src/org/aspectj/bridge/MessageUtil.java
152979	Optimization: Reference Use and URL Caching in ClassLoader Repository	I have found that a lot of memory can get pinned by the BCEL ClassLoaderRepository. For example, on a test configuration of Glassbox with WebLogic over 40 megabytes were pinned in memory due to this loader. (*)I also notice that some of the time spent with loading and parsing redundant classes for shared weaving configuration could be reduced by having a global cache of bytes for URL's instead, i.e., the ClassLoaderRepository is local to a loader, so even if the same class on disk is resolved multiple times in different loaders, it isn't read from cache. This latter issue will be reduced if loading types from a parent loader use reflection delegates instead but BCEL still has to be used for aspects on <1.5 VM's... The attached patch has some metrics in it to measure what's happening and it also uses SoftReferences to cache without pinning the reference types and uses a two-step look up process to maintain a global URL cache. When I run this on WebLogic 9.2 with Glassbox and view their admin console and some smaller apps I get this output:BCEL repository total load time: 7733 ms, in url: 6029 ms for 1427 url cache hits = 1683 missEvicted = 0 missUrlEvicted= 0 all misses = 1427, loader hits = 0On Tomcat 5.5 with some different sample apps:BCEL repository total load time: 4945 ms, in url: 4319 ms for 636 url cache hits = 548 missEvicted = 0 missUrlEvicted= 190 all misses= 446, loader hits = 3So at least in my configuration the URL-based cache is quite effective (with almost a 50% hit rate) whereas the loader-based cache provides little value. From what I've seen, it's worth considering not even using the loader-based BCEL cache at all but others may have configurations where it helps.(*) This test was on a development build of AspectJ which I had modified so that the LTWWorld evicts classes after loading Created attachment 47478Patch to bcel-builder module to use soft references, use a URL cache, and track metrics. I should point out that I haven't tested this approach in a build-time weaving or IDE environment. However, I'd be happy to do so after hearing some feedback on it. patches applied - slightly reworked it - hope I haven't broken it - my rudimentary tests confirm it is behaving but I don't have any decent ltw configs.I had to remove nanoTime - that's a 1.5 api, I'm not sure how accurate the totals will be with currentTimeMillis().stats have to be requested, they aren't dumped out every X seconds, could make this configurable if we're unsure it's behaving.A system property can turn off the sharing if it starts misbehaving (org.aspectj.apache.bcel.useSharedCache=false)I don't currently see how keys/values are ever removed from the URL cache - i know they are smaller since only softrefs on one end, but we should be tidying up.  Maybe a queue and tidy up when queue isn't empty and a load/find is attempted.Don't think it's relevant for command line one off compilation (one world) but AJDT may benefit from something similar when there are multiple AspectJ projects. You're right: the URL cache should probably be managed with a size limit or timing scheme to evict items. Using references would just mean the whole cache could be evicted when memory is low (nothing is going to have a handle on the URL's normally), so you could just have a soft reference to the cache as a whole.I remember you had brought up some other LRU cache that's in Eclipse that might be suitable for use with the type map. Would that help here? I tested with AspectJ from CVS HEAD including this improved version of the repository code and it is working well, and improving performance. My profile shows that of 27.4 million bytes pinned by AspectJ the static cache is pinning 32k, so it's a pretty low memory user. However, it is better to clean up, so I added that logic and also added some tests. I don't want to use a reference queue to clean up because then we'd need a reverse map from references to URLs. Instead, I just compress the repository every N accesses, iterating over it and purging any entry with a null value. I also added a property to allow changing the frequency of compaction. To disable it, set the value to zero.Also, this static map has to be thread-safe (to avoid concurrent errors when so I updated the code to use a concurrent map. I just copied & pasted code from LTWWorld, but it would be better to make a public method makeConcurrentMap() on some ConcurrentFactory class that's shared between the bcel and weaver modules. I also made a small update (to track whether the map is synchronized, so we can synchronize the purge operation). In what module should the shared class go?Note: the timings in the multi-threaded tests are not accurate in that they count elapsed time per thread, i.e., the threads are often waiting to run at the same time, so the times reported are four times too big. Even with heavy contention (with a quite high compacting frequency), a fairly big cache, and extremely frequent updates the time spent compacting is tiny (<10 ms in a total of 34 seconds, with a ridiculuous frequency of 1 in 10 it's only 170 ms).I also proved that the multi-threaded tests were testing the right thing: I forgot to set the flag for is this a shared map and got a concurrent modification exception in that case (that's just a problem in the test case, which I fixed). Whew. Created attachment 47559Patch to weaver module to update tests for repository. Created attachment 47560Additional patch to bcel-builder, building on Andy's updates in HEAD. Ron - can I ask why we don't just make the url cache a WeakHashMap? Do you know of somebody artificially holding onto the URL objects meaning the keys/values will never get cleared?  Or are you concerned that a WeakHashMap may be GC'd a bit too much for our liking by the VM? (in which case a LRU queue, of fixed size, from classname->URL may keep the most relevant entries alive) are we happy we have done enough on this for 1.5.3 ? This looks good to me. Thanks! 	2006-08-07 11:04:12	1154960000.0	resolved fixed	387c3ac	1155040000.0	bcel-builder/src/org/aspectj/apache/bcel/util/ClassLoaderRepository.java bcel-builder/testsrc/org/aspectj/apache/bcel/classfile/tests/AllTests.java bcel-builder/testsrc/org/aspectj/apache/bcel/classfile/tests/ClassloaderRepositoryTest.java
152873	Optimize shouldWeaveAnnotationStyleAspect with Patch	The current implementation of shouldWeaveAnnotationStyleAspect is surprising because it weaves annotation aspects without regard as to whether they are registered in an aop.xml file. If an annotation-style aspect is loaded, it is always woven, even if it doesn't match the for what classes should be woven in the aop.xml file, and even if not registered therein. This is both unexpected and it imposes significant overhead on configurations where they aren't used and simple fast match exclusions prevent weaving (see bug #152871).Is there really a need to weave annotation style aspects like this? Why can't it be done by using the aop.xml configuration mechanism that all other aspects use? In a large system, the CPU overhead of parsing and creating BCEL objects for all loaded classes should be avoided where possible. not my code ... but I believe they have to be included in the weaving because they may be half finished (have no aspectOf/hasAspect).  Hence they are not subject to the same rules as regular code styles aspects that are always already finished.You might well exclude them at some level but if they are included at a different level and *do* apply then that code will be woven with calls to aspectOf() that will go bang unless the @AJ aspect was finished off by getting woven when first discovered. It is possible, through the use of a custom IWeavingContext for example, to include an aspect for a weaver that was excluded by another visible aop.xml file. In which case the locally defined classes will be woven with an “unfinished” aspect and get NoSuchMethodError for aspectOf(). We therefore cannot exclude @AspectJ aspects and should issue a warning message if the user attempts to do so either by using either include or exclude in the weaver section. It looks like avoiding this check altogether would be hard. However, the main objective here is to reduce the time spent testing for annotation-style aspects. Eugene Kuleshov wrote a simple ASM visitor that I adapted and plugged in, and I also avoided testing for annotation aspects in classes like javax..* that can't be woven. This patch should also be a bit faster when AspectJ uses ASM 3.0, so it could add flags to skip parsing methods and fields too (I tested short-circuitng those tests by throwing a runtime exception but that was actually slower).The attached patch contains tests that validate this logic works both for excluded @Aspect annotations and that it doesn't match for other annotations.I have measured that this patch reduces cpu time used in shouldWeaveAnnotationStyleAspect when starting WebLogic from over 1000 ms to 200 ms (an 80% reduction in overhead and a 10% reduction in total weaving time).Longer term, I think it should be a requirement that an annotation-style aspect should always be listed with an aspect element in an aop.xml configuration visible to its loader. That seems much better than having to parse the bytecode of all loaded types to see if they are, in fact, an annotation-style aspects. If such a rule were agreed upon then it would be important to not allow including aspects that aren't woven to avoid a NoSuchMethodError from unfinished aspects. Unfortunately, it seems like doing this would require weaver context support so you could determine if the aspect class is loaded by this loader or not. In the former case, simply requiring the aspect to not be excluded (as Matthew noted) and if there's a non-empty inclusion list requiring the aspect to be in that would work. If we could determine the aspect is provided by an external loader, then we could instantiate a reflection delegate for it and test that it had the required woven methods. Maybe when #133770 is fixed we can revisit this. In the meanwhile, this patch dramatically reduces the overhead for annotation-style aspects. Created attachment 47497testing module patch: need to add asm-aj.jar to test classpath Created attachment 47498Tests module patch: tests that verify the ASM visitor corrects identifies whether classes with annotations are @Aspect aspects Created attachment 47499Weaver module patch: use ASM to test for @AspectJ aspects if no delegate and don't even test for classes excluded from weaving by package (e.g., org.aspectj..*) Created attachment 47500Weaver module patch: use ASM to test for @AspectJ aspects if no delegate and don't even test for classes excluded from weaving by package (e.g., org.aspectj..*)Includes copyright in module header and a few minor cleanups. AspectJ doesn't currently have a hard dependency on asm - if asm isn't there, it continues to work fine.  Some products that reship AJ don't currently have permission to include asm.  I've made this use of asm conditional also (I think).I will look at including asm 3.0 when it goes final.I'm not a fan of tests that pass regardless of whether the patch to the mainline code is applied or not...applied. available. 	2006-08-04 15:21:07	1154720000.0	resolved fixed	f239f2a	1155020000.0	testing/newsrc/org/aspectj/testing/AntSpec.java tests/java5/ataspectj/ataspectj/bugs/NotAspect.java tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java weaver/src/org/aspectj/weaver/World.java weaver/src/org/aspectj/weaver/tools/IsAtAspectAnnotationVisitor.java weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java
152835	ArrayIndexOutOfBoundsException in EclipseAdapterUtils.makeLocationContext	Got the following exception during startup of Eclipsejava.lang.ArrayIndexOutOfBoundsExceptionat org.aspectj.ajdt.internal.core.builder.EclipseAdapterUtils.makeLocationContext(EclipseAdapterUtils.java:65)at org.aspectj.ajdt.internal.core.builder.EclipseAdapterUtils.makeSourceLocation(EclipseAdapterUtils.java:121)at org.aspectj.ajdt.internal.core.builder.EclipseAdapterUtils.makeMessage(EclipseAdapterUtils.java:130)at org.aspectj.ajdt.internal.core.builder.AjBuildManager$4.acceptResult(AjBuildManager.java:959)at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.acceptResult(AjPipeliningCompilerAdapter.java:402)at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.afterProcessing(AjPipeliningCompilerAdapter.java:375)at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$after$org_aspectj_ajdt_internal_compiler_CompilerAdapter$5$6b855184(CompilerAdapter.aj:98)at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:533)at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:891)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:246)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:165)at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)ArrayIndexOutOfBoundsException thrown: -2 passing over to compiler If this is a constant problem, a temporary workaround may be:-Xset:pipelineCompilation=falsein the 'other > options' for your workspace or projects. A test project for this scenario would be useful.  Without one I can merely guard on it occurring but that may mean in AJDT that we start to lose some of the contextual information that appears (it is possible some of the red squigglies may go missing or appear in funny places).  I guess the best we can do is guard for now and fix that when a simpler test scenario can be created. guard committed. Andy, are you asking for a test project from me? hmmm, only half seriously because I imagine it would be hard for you to create one?  I've put the guard in, maybe we should make do with that - and if we get bug reports in about incorrect error messages we can investigate further at that time. Great, because (sadly) I wouldn't be able to share my projects or workspace.Will the guard for this section of code be in the next development version or how does this work? it'll be in the next dev version of AspectJ - then AJDT a few days later.  if its always happening, try the workaround I suggest in comment #2. is this all working for you now? can I close the bug? seems to working for me now. haven't experienced it for a while ok, let's consider it fixed.  As usual, reopen if you see something like this again... thanks for responding so quickly. 	2006-08-04 06:00:33	1154690000.0	resolved fixed	908b405	1154690000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseAdapterUtils.java
152631	Problem with decp on an aspect using cflow	"<Pyinson Data Over Head> Created attachment 47247Self-contained AJDT project that reproduces the problemThis uses an already-built version of Glassbox built by a recent but earlier dev build. The failure depends on the effects of at least one other aspect. By the way, the previous dev build that works is actually from July 28. i think i know what it'll be. ...but I would like to recreate it first.  Is that project really standalone?  I get all kinds of errors if I try and build it:eg. ""can't determine whether missing type javax.servlet.ServletContext is an instance of""So I used the 5meg of jars we have had before from you and stuffed them on the classpath, now it fails with:""can't determine whether missing type glassbox.bootstrap.log.BootstrapLog is an instance of glassbox.util.logging.api.LogOwner""are you running with cant find type switched off?  Are you getting this on a full build or an incremental build? Hi Andy,I think I didn't see the missing classpath entries because I ran into this error before I got that far. But I commented out the erroring out part and you are right: if you compile with -Xlint:ignore or turn off cantFindType switched off (although it looks like AJDT no longer lets you configure this) it should work unless you add the extra advice. I am uploading the glassboxBootstrap.jar that resolves some missing type references. The other jar that you will is the commons http client which I'll attach too. This is interesting because it isn't even on the build path of the project when compiling the jar but resolving this pointcut at weave time with the jar on the aspect path seems to require it:    args(org.apache.commons.httpclient.HostConfiguration, httpMethod, ..)This error happens with both full and incremental builds.  Created attachment 47339Jar for classpath Created attachment 47341Commons httpclient jar for classpath A simple standalone testcase for the problem:====public aspect EMA {    before() : cflow(execution(* *(..))) {}}aspect Goo {  declare parents: EMA extends C;  public void EMA.m() {}}abstract class C {  abstract void m();}====this occurs because of the declare parents targeting the aspect and the aspect has a cflow pointcut in it.  this fix is as expected, coping with null - but it was nice to verify that it is completely safe.  (Fails on 1.5.1a/1.5.2/HEAD)testcase and fix committed ... and nothing to do with pipelining ;) fix available. "	2006-08-02 13:26:23	1154540000.0	resolved fixed	ff2377a	1154690000.0	tests/bugs153/pr152631/EMA.java tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java
151991	Missing copyright/license in recently added modules	"BuildModuleTests does not test for licenses in ajdoc, loadtime, loadtime5, weaver5. When I added the necessary logic there were a couple of failures. Could the owners please step forward ...epl-cpl-ibm|parc|xerox|others   LICENSE FAIL: C:\workspaces\org.aspectj-Restructure\weaver5\java5-src\org\aspectj\weaver\reflect\DeferredResolvedPointcutDefinition.javaepl-cpl-ibm|parc|xerox|others COPYRIGHT FAIL: C:\workspaces\org.aspectj-Restructure\weaver5\java5-src\org\aspectj\weaver\reflect\DeferredResolvedPointcutDefinition.javaepl-cpl-ibm|parc|xerox|others   LICENSE FAIL: C:\workspaces\org.aspectj-Restructure\weaver5\java5-src\org\aspectj\weaver\reflect\InternalUseOnlyPointcutParser.javaepl-cpl-ibm|parc|xerox|others COPYRIGHT FAIL: C:\workspaces\org.aspectj-Restructure\weaver5\java5-src\org\aspectj\weaver\reflect\InternalUseOnlyPointcutParser.javaTotal passed: 7 failed: 2I also noticed the following messages. Does anyone know what they mean?BuildModuleTest: Define ""run.build.tests"" as a system property to run tests to build run-all-junit-tests (this is the only warning)class org.aspectj.internal.build.BuildModuleTest.testNoDuplicates() incompleteerror building module weaver	at org.aspectj.internal.tools.ant.taskdefs.BuildModule.build(BuildModule.java:145)	at org.aspectj.internal.tools.ant.taskdefs.BuildModule.execute(BuildModule.java:117)	at org.aspectj.internal.build.BuildModuleTest.doTask(BuildModuleTest.java:445)	at org.aspectj.internal.build.BuildModuleTest.testNoDuplicates(BuildModuleTest.java:178)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)	at java.lang.reflect.Method.invoke(Method.java:585)	at junit.framework.TestCase.runTest(TestCase.java:154)	at junit.framework.TestCase.runBare(TestCase.java:127)	at junit.framework.TestResult$1.protect(TestResult.java:106)	at junit.framework.TestResult.runProtected(TestResult.java:124)Module 	at junit.framework.TestResult.run(TestResult.java:109)	at junit.framework.TestCase.run(TestCase.java:118)	at junit.framework.TestSuite.runTest(TestSuite.java:208)	at junit.framework.TestSuite.run(TestSuite.java:203)	at junit.framework.TestSuite.runTest(TestSuite.java:208)	at junit.framework.TestSuite.run(TestSuite.java:203)	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128)	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) Created attachment 46878New license checks in BuildModuleTests Fixed in BuildModuleTests.java,1.2, by adding copyrights to various weaver5 files, and by writing a section on how to add a module in readme-build-and-test-aspectj.html. "	2006-07-27 08:58:44	1154010000.0	resolved fixed	7aa6cfe	1154620000.0	build/testsrc/org/aspectj/build/BuildModuleTests.java
152589	[pipeline] adding a whitespace results in adviceDidNotMatch warning	"Given the following------------------------------------------------------------public aspect A {    after () throwing (Throwable th) :  execution(* *(..)) {		System.err.println(thisEnclosingJoinPointStaticPart);	}}class C1 {	public void anotherMethod() {			}}--------------------------------------------------adding a whitespace before the aspect declaration results in an adviceDidNotMatch warning even though weaving took place and the advice clearly matches. Output from the AJDT event trace shows:14:38:23 ===========================================================================================14:38:23 Build kind = AUTOBUILD14:38:23 Project=bug92895, kind of build requested=Incremental AspectJ compilation14:38:23 build: Examined delta - source file changes in required project bug9289514:38:23 Classpath=/home/hawkinsh/eclipse/workspace32/runtime-New_configuration/bug92895/bin:/home/hawkinsh/javas/jdk1.5.0_05/jre/lib/rt.jar:/home/hawkinsh/javas/jdk1.5.0_05/jre/lib/jsse.jar:/home/hawkinsh/javas/jdk1.5.0_05/jre/lib/jce.jar:/home/hawkinsh/javas/jdk1.5.0_05/jre/lib/charsets.jar:/home/hawkinsh/javas/jdk1.5.0_05/jre/lib/ext/sunjce_provider.jar:/home/hawkinsh/javas/jdk1.5.0_05/jre/lib/ext/sunpkcs11.jar:/home/hawkinsh/javas/jdk1.5.0_05/jre/lib/ext/dnsns.jar:/home/hawkinsh/javas/jdk1.5.0_05/jre/lib/ext/localedata.jar:/home/hawkinsh/eclipse/eclipse32/plugins/org.aspectj.runtime_1.5.3.20060801095103/aspectjrt.jar:14:38:23 Preparing for build: planning to be an incremental build14:38:23 Starting incremental compilation loop 1 of possibly 514:38:23 AJC: compiling source files14:38:23 Timer event: 215ms: Time to first compiled message14:38:23 AJC: compiled: /home/hawkinsh/eclipse/workspace32/runtime-New_configuration/bug92895/src/pack/A.aj14:38:23 addSourcelineTask message=advice defined in pack.A has not been applied [Xlint:adviceDidNotMatch] file=/home/hawkinsh/eclipse/workspace32/runtime-New_configuration/bug92895/src/pack/A.aj line=414:38:23  Dropping back to full build14:38:23 Preparing for build: not going to be incremental because no successful previous full build14:38:23 AJC: compiling source files14:38:23 AJC: compiled: /home/hawkinsh/eclipse/workspace32/runtime-New_configuration/bug92895/src/pack/A.aj14:38:23 AJC: processing reweavable state14:38:23 AJC: adding type mungers14:38:23 Timer event: 452ms: Time to first woven message14:38:23 AJC: woven aspect pack.A (from /home/hawkinsh/eclipse/workspace32/runtime-New_configuration/bug92895/src/pack/A.aj)14:38:23 AJC: woven class pack.C1 (from /home/hawkinsh/eclipse/workspace32/runtime-New_configuration/bug92895/src/pack/A.aj)14:38:23 AspectJ reports build successful, build was: FULL14:38:23 AJDE Callback: finish. Was full build: true14:38:23 Timer event: 517ms: Total time spent in AJDE14:38:23 Timer event: 6ms: Create element map (2 rels in project: bug92895)14:38:23 Types affected during build = 114:38:23 Timer event: 3ms: Add markers (2 markers)14:38:24 Timer event: 1274ms: Total time spent in AJBuilder.build()namely, the adviceDidNotMatch warning was added and then we fell back to a full build and the warning wasn't cleared. Performing a ""clean"" build fixes the problem. This is since the pipelining changes. Created attachment 47216failing testcaseApply this patch to the tests project.Failing testcase which reproduces the problem. the whole mechanism for producing adviceDidNotMatch changed in pipeling (almost had to be removed entirely).  The fix for this bug is to recognize when we are dropping back to a full build and dont attempt to produce the messages in that case.test and fix committed. fix available. "	2006-08-02 09:33:47	1154530000.0	resolved fixed	9664058	1154590000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjPipeliningCompilerAdapter.java tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java
151938	Handle Duplicate -javaagent entries more gracefully	If you start a java 5 VM with AspectJ's load-time weaver specified more than once using the -javaagent flag, if there is an aop.xml file defined, it chokes badly: it tries to reweave the woven AspectJ code and emits massive amounts of bytecode. It would be better if AspectJ detected that it was specified more than once and gave a warning then disabled all but one of the agents. Failing that, it would be better to fail and give an error message than emit the bytecode.This issue came up for our automated installer, which adds a -javaagent flag to VM startup commands. If the script is wrapped twice, it can generate a duplicate. We are making our scripts more intelligent to avoid this issue, but we are probably not the only people who will hit this issue (e.g., if someone manually edits both setclasspath.bat and catalina.bat to add the flag for a Tomcat instance...) This is probably a good piece of self defence. We can simply test in Agent.preMain() whether we have already been call, put a simple message to stderr and return immdiately. I'm just trying to write a failing testcase. Fix available. 	2006-07-26 19:33:29	1153960000.0	resolved fixed	bebb364	1154460000.0	loadtime5/java5-src/org/aspectj/weaver/loadtime/Agent.java tests/java5/ataspectj/HelloWorld.java tests/java5/ataspectj/MessageHandler.java tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java
151978	[3.2compiler] Generics program fails to compile	"generics problem, reported on newsgroup by Thomas Darimont//package de.tutorials.aspectj;public interface IMessage {  void publish();}interface IErrorMessage extends IMessage{  StackTraceElement[] getStackTrace();}interface IObjectFactory<E> {  public <T extends E> T create(Class<T> theObjectType, Object[] theParameters);}class MessageFactory implements IObjectFactory<IMessage>{  public <T extends IMessage> T create(Class<T> theObjectType, Object[] theParameters) {    return null;  }}class Main {  public static void main(String[] args) {    IErrorMessage message = new MessageFactory().create(IErrorMessage.class, new Object[]{""Foo"",""Bar""});  }} As I expected - this is a bug in the Eclipse 3.1 version of the JDT compiler upon which AspectJ is based.  It is fixed in the 3.1.1 version of the JDT compiler (and so in 3.2 also).I can't quite decide whether to dig around and work out what the fix was, or to wait until we move to the 3.2 compiler which should be happening in the coming couple of months. testcase in Ajc153 tests - commented out.  > Generics program fails to compileI believe I have encountered this issue with Eclipse Europa (3.3.0) and AJDT (1.5.1rc1).I have a large codebase, which heavily uses generics. When using the Eclipse JDT compiler, everything is fine (no reported errors). But, when switching the project to AspectJ, the compiler reports many generics errors, of the following variety: * The method XXX is ambiguous for the type YYY * Name clash: The method AAA of type BBB has the same erasure as XXX of type ZZZ but does not override itThe following quote indicates updating the compiler: > I can't quite decide whether to dig around and work out what the fix was, or > to wait until we move to the 3.2 compiler which should be happening in the > coming couple of months.Will that solve the issues I have encountered? What is happening on this front? >> I can't quite decide whether to dig around and work out what the fix was, or>> to wait until we move to the 3.2 compiler which should be happening in the>> coming couple of months.> Will that solve the issues I have encountered? What is happening on this front?When AspectJ 1.5.4 is released (before christmas), I will commit the 1000 cvs changes that take us to being based on Eclipse JDT 3.3 compiler, which I have been working on for the past month.  I haven't confirmed whether this particular bug is fixed by the move to this compiler yet (other generics bugs have been...), but the dev builds will be available shortly to try it out. > When AspectJ 1.5.4 is released (before christmas), I will commit the 1000 cvs> changes that take us to being based on Eclipse JDT 3.3 compiler, which I have> been working on for the past month.  I haven't confirmed whether this> particular bug is fixed by the move to this compiler yet (other generics bugs> have been...), but the dev builds will be available shortly to try it out.Ok, sounds good. When it is ready, I will try it out and let you whether it resolves the problems. This appears fixed in the latest AJDT 1.5.2 dev builds for Eclipse 3.3 - available from the dev download site and update site:http://www.eclipse.org/ajdt/downloads/http://download.eclipse.org/tools/ajdt/33/dev/updateThis includes AspectJ1.6.0m1 fixed "	2006-07-27 07:15:06	1154000000.0	resolved fixed	68c36e3	1154090000.0	tests/bugs153/pr151978/IMessage.java tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java
151673	Incorrect weaving of after returning when 'input' bytecode is of a strange form	"We have had a user report a problem where after advice being woven into a particular method is producing code that does not verify.  The problem occurs if the bytecode being input to the weaving process includes a subroutine that contains the return from the method.Here is the problematic snippet produced by some unknown compiler:   200:	invokespecial	#17; //Method com/MyException.""<init>"":(Ljava/lang/String;)V   203:	athrow   204:	aload_3   205:	astore	6   207:	jsr	234   210:	aload	6   212:	areturn   213:	astore	4   215:	aload	4   217:	invokevirtual	#79; //Method java/lang/Throwable.printStackTrace:()V   220:	jsr	234   223:	goto	238   226:	astore	7   228:	jsr	234   231:	aload	7   233:	athrow   234:	astore	8   236:	aload_3   237:	areturn   238:	return  Exception table:   from   to  target type     2   213   213   Class javax/ejb/FinderException     2   226   226   anysee the jsr's jump to 234, but before the subroutine return at 238 there is an areturn out of the method (this method returns a String).After weaving we get something like this:   200:	invokespecial	#17; //Method com/MyException.""<init>"":(Ljava/lang/String;)V   203:	athrow   204:	aload_3   205:	astore	6   207:	jsr	238   210:	aload	6   212:	astore	9   214:	goto	248   217:	astore	4   219:	aload	4   221:	invokevirtual	#79; //Method java/lang/Throwable.printStackTrace:()V   224:	jsr	238   227:	goto	246   230:	astore	7   232:	jsr	238   235:	aload	7   237:	athrow   238:	astore	8   240:	aload_3   241:	astore	9   243:	goto	248   246:	astore	9   248:	invokestatic	#299; //Method After.aspectOf:()LAfter;   251:	invokevirtual	#302; //Method After.ajc$afterReturning$After$1$26d6d4a7:()V   254:	aload	9   256:	returnsee how the areturn has been lost - this code will blow up with a verify error (the string is on the stack, we just ignore it and 'return' normally) the neatest fix here is that when we collect up the returns for a method, if this is a method with a non-void return type we don't try and use 'RETURN' - which is what happens at the moment in BcelShadow.Whilst working on this I discovered a bug where duplicate RETURNs (second is harmless) are inserted in woven code for methods woven with a VOID return value.  also fixing that. fixes committed. fix available. "	2006-07-25 05:45:06	1153820000.0	resolved fixed	e4ab0ae	1153990000.0	weaver/src/org/aspectj/weaver/bcel/BcelShadow.java
151845	NPE while building	Building of a large project fails while weaving. NPE in EclipseSourceContext.removeUnnecessaryProblems(..)The project was just migrated to Eclipse 3.2Eclipse newly installed with Eclipse SDK and via Update manager withAJDT, CDT, Web/J2EE tools, SubClipse, SpringIDE.Same Project workes in Eclipse 3.1.Simple Test AspectJ-Project workes OKBuilding with Ant/AspectJ compiler (as external Tools Launch in Eclipse)works.I tried the following, but got the error anyway: - Checked out as a new AspectJ Project - upgraded to the developement Version of AJDT <Pyinson Data Over Head> Passing over to compiler fix committed.  NPE guard. *** Bug 152024 has been marked as a duplicate of this bug. *** fix available in AJ dev builds. 	2006-07-26 09:44:50	1153920000.0	resolved fixed	54f7bb4	1153990000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseSourceContext.java
151182	NPE in BcelWeaver using LTW	"Hi,I created a logging aspect for our application some time ago using 1.5.0 of AspectJ. I enabled this from time to time using Load Time Weaving.I have recently recompiled the aspect using 1.5.2 and tried to run it also using the 1.5.2 weaver jar, but it fails with a NullPointerException.This is part of one of the many stacktraces:20 jul 2006 07:42:49,046 - java.lang.NullPointerException20 jul 2006 07:42:49,062 - 	at org.aspectj.weaver.bcel.BcelWeaver.weaveParentTypeMungers(BcelWeaver.java:1367)20 jul 2006 07:42:49,062 - 	at org.aspectj.weaver.bcel.BcelWeaver.weaveParentsFor(BcelWeaver.java:1237)20 jul 2006 07:42:49,062 - 	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1072)20 jul 2006 07:42:49,062 - 	at org.aspectj.weaver.tools.WeavingAdaptor.getWovenBytes(WeavingAdaptor.java:284)20 jul 2006 07:42:49,062 - 	at org.aspectj.weaver.tools.WeavingAdaptor.weaveClass(WeavingAdaptor.java:212)20 jul 2006 07:42:49,062 - 	at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:65)20 jul 2006 07:42:49,062 - 	at org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter.transform(ClassPreProcessorAgentAdapter.java:55)20 jul 2006 07:42:49,062 - 	at sun.instrument.TransformerManager.transform(Unknown Source)20 jul 2006 07:42:49,062 - 	at sun.instrument.InstrumentationImpl.transform(Unknown Source)20 jul 2006 07:42:49,062 - 	at java.lang.ClassLoader.defineClass1(Native Method)20 jul 2006 07:42:49,062 - 	at java.lang.ClassLoader.defineClass(Unknown Source)I then tried with the 1.5.0 weaver jar (although the aspect was compiled using 1.5.2) and this ran without problems. Created attachment 46562Aspect source code and compiled class file Created attachment 46573JDK 1.4 Logging ConfigurationWe think this is a threading problem: two different threads are trying to load, weave and define a class using the same class loader. There is a race where one initializes the weaver while the other uses it before the process is complete hence the NPE. We assume, possibly incorrectly, that this situation cannot occur because the class loader lock prevents it.Can you give some more information:-	Are you using AspectJ 1.5.2 Final from 30th June?-	Which JDK are you using (“java –version”) e.g. Sun 1.5.0_05-	Are you using a dual processor or dual core machine (where threading issues are more likely)?Recent development builds have a new tracing infrastructure that may help us track down the problem. Could you try the “Last Known Good developer build”? If the problem still occurs could you please use the attached logging.properties file, either by replacing the one in <JAVA_HOME>/jre/lib or by specifying it using “-Djava.util.logging.config.file=logging.properties”, and send us the resulting “/Documents and Settings/<USER>/java0.log”. I *think* I'm using the final version. The manifest file shows this:Manifest-Version: 1.0Name: org/aspectj/weaver/Specification-Title: AspectJ Weaver ClassesSpecification-Version: 1.5.2Specification-Vendor: aspectj.orgImplementation-Title: org.aspectj.weaverImplementation-Version: 1.5.2Implementation-Vendor: aspectj.orgPremain-Class: org.aspectj.weaver.loadtime.AgentCan-Redefine-Classes: trueand it's dated 29/06/2006 16:31. Most of the class files are also from that date, although some are from 8/05/2006 6:47.JDK VERSION:java version ""1.5.0_06""Java(TM) 2 Runtime Environment, Standard Edition (build 1.5.0_06-b05)Java HotSpot(TM) Client VM (build 1.5.0_06-b05, mixed mode)I'm not on a multi-core pc. I'm using a Dell OPTIPLEX GX260 Pentium 4 2.4 GHz and 1 GB RAM.I won't be able to test it with the logging today and I'm out of the office for the next three weeks. I will test this when I get back. See also bug #140709 with a patch I developed to deal with race conditions like this. As noted in that bug, it had been a while since I'd seen one, so I wasn't sure it was possible without another extension I was trying out to share state among weavers... It seems to me that the root cause of these problems is the implementation of Unsafe (what an appropriate name) on the Sun JVM.-	Bug 99861	“Deadlock in Java5 Load Time Weaving on Sun VM”-	Bug 109344	“Another LTW Deadlock on Sun VMs”-	Bug 140709	“[ltw] Patch: Handle weaving while initializing properly”-	Bug 151182	“NPE in BcelWeaver using LTW”The implementation of Aj assumes that the classloader lock is held before it is invoked, either directly or through JVMTI. If it isn’t there are 3 potential consequences:1.	ClassLoader and HashMap locks taken in different orders2.	A race condition with ClassLoaderWeavingAdaptor.initialize() 3.	Multi-threaded invocation of ClassLoaderWeavingAdaptor.weaveClass()The Weaver must be initialized just once before weaving byte-code. The Weaver is not thread safe so must be protected. The obvious solution is to use the ClassLoader lock which under normal conditions will have been taken. This can be used to protect both initialize() and weaveClass(). I therefore propose the following in Aj.preprocess():    try {        synchronized (loader) {            WeavingAdaptor weavingAdaptor = WeaverContainer.getWeaver(loader, weavingContext);            if (weavingAdaptor == null) {               	return bytes;            }            return weavingAdaptor.weaveClass(className, bytes);	}    } catch (Exception t) {    …If we already have the lock then taking it again should not be expensive on modern JVMs. The code could be moved to ClassPreProcessorAgentAdapter so that JRockit and direct invokers are not penalized. I will wait until we have some more information, in particular a full stack trace to see if Unsafe is indeed implicated. If Unsafe is the problem then it may not be caused by reflection delegates. These use a special class loader that since bug 120473 (incorrectly shown as 120743 in the History for Aj) for whicn we no longer create WeavingAdaptor instance. This bug occurs when creating and initializing an adaptor. Fix available. Awaiting verfication. See http://dev.eclipse.org/mhonarc/lists/aspectj-users/msg06584.html. Changing to FIXED after a month on inactivity and anecdotal evidence that the solution works. "	2006-07-20 02:50:53	1153380000.0	resolved fixed	397a19d	1153990000.0	loadtime/src/org/aspectj/weaver/loadtime/Aj.java
150671	declare error on set of volatile field does not work	"When an aspect has a declare error statement involving a pointcut that captures the setting of a volatile field, a compilation error is not produced.  This bug can be reproduced as follows.  Consider the following class:class A {   private volatile int state;   public void foo() {      state = 0;   }}Now consider this aspect:aspect FSM {   declare error: set(* A.state): ""Changing state"";}The setting of the state field in method foo() does not result in a compilation error as expected.  I originally noticed this bug when using AJDT 1.4 with Eclipse 3.2.  However this has been reproduced and confirmed with the aspectj 1.5.2 compiler. Created attachment 46703failing testcaseApply this patch to the tests project.Failing testcase that fits into the AJ test suite using the example code provided by Arjun. Note: this bug is not specific to deow statements. Advice is also not applied if the variable 'state' is declared volatile.The reason this bug is happening is that in the case of the volatile variable we enter the following if statement (SignaturePattern line 307):  if (aMember.isBridgeMethod() && !allowBridgeMethods) {    return FuzzyBoolean.MAYBE;  }When 'volatile' is removed we bypass this if statement because aMember.isBridgeMethod() returns false. The reason for the difference is in ResolvedMemberImpl.isBridgeMethod() whose implementation is:   public boolean isBridgeMethod() {    	return (modifiers & Constants.ACC_BRIDGE)!=0;    }where Constants.ACC_BRIDGE = 0x0040. The field with the 'volatile' keyword has modifers = 66 which is why this returns true. I thought it might be something like this.  Modifier flags sometimes 'share' bit values (presumably to keep more available for future use).  You can't have a volatile method and you can't have a bridge field - so they are safely mutually exclusive.  the problem is with our code not saying the first condition of being a bridge method is that you *are a method* ... if we also checked it was a method then the isBridgeMethod() wont return true for fields... Created attachment 46711patch containing fixApply this patch to the weaver project.This patch contains a proposed fix to only return true in ResolvedMemberImpl.isBridgeMethod() if &'ing the modifiers and bridge constants returns non zero and if the ResolvedMemberImpl has kind Member.METHOD. patches committed. fixes available in the latest dev build "	2006-07-14 12:19:01	1152890000.0	resolved fixed	357bbe9	1153810000.0	tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java
148409	[generics] ClassCastException in UnresolvedType.java:348	"I am using AspectJ load time weaving with Spring 2.0 RC1 to inject my entities, and I am getting the following exception:java.lang.ClassCastException: org.aspectj.apache.bcel.classfile.Signature$TypeVariableSignature	at org.aspectj.weaver.UnresolvedType.forGenericTypeSignature(UnresolvedType.java:348)	at org.aspectj.weaver.bcel.BcelWorld.addSourceObjectType(BcelWorld.java:385)	at org.aspectj.weaver.loadtime.ClassLoaderWeavingAdaptor.accept(ClassLoaderWeavingAdaptor.java:492)	at org.aspectj.weaver.tools.WeavingAdaptor.shouldWeave(WeavingAdaptor.java:230)	at org.aspectj.weaver.tools.WeavingAdaptor.weaveClass(WeavingAdaptor.java:210)	at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:65)	at org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter.transform(ClassPreProcessorAgentAdapter.java:55)	at sun.instrument.TransformerManager.transform(TransformerManager.java:122)	at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:155)	at java.lang.ClassLoader.defineClass1(Native Method)...Having examined the call stack under the debugger, this seems to happening when the weaver is attempting to determine whether a particular class should be weaved. The exception is thrown in the following method, at the cast highlighted below.    public static UnresolvedType forGenericTypeSignature(String sig,String declaredGenericSig) {    	UnresolvedType ret = UnresolvedType.forSignature(sig);    	ret.typeKind=TypeKind.GENERIC;    	    	ClassSignature csig = new GenericSignatureParser().parseAsClassSignature(declaredGenericSig);    	    	Signature.FormalTypeParameter[] ftps = csig.formalTypeParameters;    	ret.typeVariables = new TypeVariable[ftps.length];    	for (int i = 0; i < ftps.length; i++) {			Signature.FormalTypeParameter parameter = ftps[i];			Signature.ClassTypeSignature cts = (Signature.ClassTypeSignature)parameter.classBound; // EXCEPTION HERE!			ret.typeVariables[i]=new TypeVariable(ftps[i].identifier,UnresolvedType.forSignature(cts.outerType.identifier+"";""));		}    	ret.signatureErasure = sig;    	ret.signature = ret.signatureErasure;    	return ret;    }The class in question (which is not one that requires weaving), has the following signature:public class HibernateEntityDAO<interfaceT extends SecurityEntity, concreteT extends interfaceT> extends HibernateDaoSupport        implements EntityDAO<interfaceT> The exception is happening because the parameter.classBound member is not of type Signature.ClassTypeSignature, but an instance of Signature.TypeVariableSignature.The loop variable i is 1, and parameter.identifier is “concreteT”, so it looks like it's the signature of the second type parameter (concreteT) that is tripping up the weaver. Created attachment 45187Debugger Screenshot thanks for the clear bug report - I've recreated it, added a testcase and committed the fix into CVS.  waiting on build... fix available in latest AspectJ dev builds. "	2006-06-23 12:29:03	1151080000.0	resolved fixed	369de87	1152190000.0	tests/bugs153/pr148409/Blurgh.java tests/bugs153/pr148409/X.java tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java weaver/src/org/aspectj/weaver/UnresolvedType.java
148693	woven class does not pass org.apache.bcel.verifier.statics.Pass2Verifier	<Pyinson Data Over Head> Can I ask which bcel verifier you are using, the one in AspectJ or the one from the standard bcel project?Is this class actually causing you a problem when you run it or are you just raising the issue because you happened to try it through a verifier?The verifier is complaining because there are no local variables for the aspectOf() method and yet there is a LocalVariableTable attribute.  Now the LocalVariableTable attribute is empty but because there is one and 'one' is greater than the number of localvariables for the method then it fails verification.  I think the verifier should have checked how many variables got defined in that local variable table entry...  However, it is an optimization to skip the attribute creation when there are none, so I'm seeing what impact that has on the AspectJ test suite.  I'm nervous about preventing its creation entirely as some funky coverage tools or debugging tools may like to see it... I'm using the one in BCEL 5.1 and 5.2 The class is OK at runtime, but I just happened to try bcel Verifier Although I cannot find anywhere in the JVM spec that specifies an empty local variable table is invalid, I think this optimization is OK.  Hopefully the coverage/debugger tools out there won't barf when they can't find it - I mean they shouldn't be looking, there are no local variables...  we'll have to keep an eye out...and deactivate this optimization if anything unusual happens in the wild.I've created a utility method called verifyClass() that will run the bcel verifier over a class from the sandbox - we may use this more in the future, see it being used in Ajc153Tests. 	2006-06-26 13:29:29	1151340000.0	resolved fixed	82f217f	1152090000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java tests/src/org/aspectj/testing/Utils.java
148737	IllegalStateException for non-generic type	"I believe this is similar to 112880.  The message and stack trace I am getting are -- (IllegalStateException) Can't ask to parameterize a member of non-generic type: com...object  kind(raw)Can't ask to parameterize a member of non-generic type: com...object  kind(raw)java.lang.IllegalStateException: Can't ask to parameterize a member of non-generic type: com....object  kind(raw)	at org.aspectj.weaver.ResolvedMemberImpl.parameterizedWith(ResolvedMemberImpl.java:612)	at org.aspectj.weaver.ResolvedMemberImpl.parameterizedWith(ResolvedMemberImpl.java:597)	at org.aspectj.weaver.ReferenceType.getDeclaredMethods(ReferenceType.java:508)	at org.aspectj.weaver.ResolvedType$4.get(ResolvedType.java:225)	at org.aspectj.weaver.Iterators$3$1.hasNext(Iterators.java:118)	at org.aspectj.weaver.Iterators$5.hasNext(Iterators.java:171)	at org.aspectj.weaver.Iterators$3.hasNext(Iterators.java:128)	at org.aspectj.weaver.ResolvedType.lookupMember(ResolvedType.java:345)	at org.aspectj.weaver.ResolvedType.lookupMethod(ResolvedType.java:326)...The same code was able to be weaved under 1.5.0.  The reason why this is a major issue is 1.5.0 suffers from a StackOverflowException. The stackoverflow bug was 125101. Does comment #1 about 125101 apply to this bug?  since the exception included in the initial text is an IllegalStateException?I've seen this IllegalState occur for a few reasons.  Can I ask if you are doing a regular command line compile or are you in AJDT or are you doing loadtime weaving?Did the code compile/weave ok under AspectJ 1.5.1a or did it also fail there?  I'm very confused by the text of the message as it says the declaring type is 'com...object' ??!  Do you have a package called that?  Is there any way you can summarize your type hierarchy (the part that includes generic signatures) so that I can investigate further? have you managed to try this on 1.5.1a yet? Created attachment 45597Simple class with non-utilized generic Created attachment 45598Class that extends B Created attachment 45599Class that obtains an aspect. Created attachment 45601""Controlling method"" used in the aspect Created attachment 45602aspect that causes the parameterization error Hi Andy,I was able to create a small test reproducible test case.  You will have to forgive the obfuscation, but it was the best I could do.  I have attached the following files:  A.java, B.java, C.java, D.java, and TestAspect.aj.  The command I used to compile the files is% ajc -source 5 -target 5 -inpath C:\Software\hibernate.org\hibernate-3.1\hibernate3.jar A.java B.java C.java D.java TestAspect.ajObviously, you will need the hibernate3.jar for the compilation.The bug 148738 is related to this bug as you will see from the output.The same problem happens with 1.5.1a.If you have any questions, please let me know. I've made a shorter test program that demonstrates the failure (didn't need hibernate):=========8<============public abstract class A<E> {	    public A() { }    public void setUniqueID(Object o) {}}class B extends A {    public B() {}    }class D {    public void method() {        B b = new B();        b.setUniqueID(null);    }}aspect TestAspect {	before(): call(public void *.*()) { }    }=========8<============ajc -source 5 -target 5 A.javaIt turns out the actual problem is that you are supplying ""-source 5"" rather than ""-source 1.5"".  Although the compiler sees these as equivalent, the weaver only understands ""1.5"".  Typically we invoke the compiler with this shorthand:ajc -1.5 A.javaSo - I've made the weaver understand ""5"".Just to confirm this is what you are seeing, can you try supplying the option as ""1.5"".  My fix should be in a dev build shortly (this is probably the fix for the other bug too...) fix to also support ""5"" is in the latest AJ dev build. fix is available - please reopen if you continue to have problems. "	2006-06-26 20:09:45	1151370000.0	resolved fixed	f6834c7	1151930000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java tests/bugs153/pr148737/A.java tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java
148972	problems with binary weaving declare parents in mixed environment.	These have been reported to me on a large system doing some intricate weaving where some classes are 1.2, some 1.4, some 1.5 and the VM is 1.5.  Binary weaving declare parents sometimes refuses to allow the modification of the hierarchy because it sees a clash between two methods when there is none.  The two cases I'm fixing are:  1. sometimes the signatures of the return types differ with the '.' or '/' problem (fix == be consistent)  2. sometimes the syntheticness of the methods in the relationship isn't determined correctly 'fix' committed. see BcelTypeMunger.mungeNewParent() 	2006-06-28 07:24:43	1151490000.0	resolved fixed	2f2f568	1151500000.0	tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java
148727	Can't call synthetic aspectOf method on aspect in library jar	"Separate compilation of the following program breaks on 1.5.2rc1 because of the recent change to marking aspect methods as synthetic:public aspect Asp {}public class Client {    public static void main(String argz[]) {        System.out.println(""Can call aspectOf? ""+Asp.aspectOf());    }}C:\devel\scratch\synthetic>ajc -classpath asp.jar;%CLASSPATH% Client.javaC:\devel\scratch\synthetic\Client.java:3 [error] The method aspectOf() is undefined for the type AspSystem.out.println(""Can call aspectOf? ""+Asp.aspectOf());1 errorC:\devel\scratch\synthetic>javac -classpath asp.jar;%CLASSPATH% Client.javaClient.java:3: cannot find symbolsymbol  : method aspectOf()location: class Asp        System.out.println(""Can call aspectOf? ""+Asp.aspectOf());                                                    ^1 errorClearly it's vital that external users of a library be able to call API methods like aspectOf on library aspects.This works:C:\devel\scratch\synthetic>ajc *.aj Client.javaC:\devel\scratch\synthetic>java ClientCan call aspectOf? Asp@b89838Patch with test integrated into CVS tree to follow... I think the best fix for this problem would be to enhance the iajc compiler to allow calls to the synthetic aspectOf and hasAspect methods. It's reasonable to require the use of an AspectJ-aware compiler to call these methods. For users who only use javac, they should already be using @AspectJ (i.e., it seems appropriate to fix this with the AspectJ compiler and not require the methods to be visible to javac). Created attachment 453352 added test cases: integrated compilation works, separate compilation breaks. thanks for the test programs.Enabling ajc to allow calls to synthetic methods isn't trivial, it requires compiler changes and the changes may have unexpected side effects.  Currently the compiler deliberately filters out synthetic methods (and <clinit>s) from types it loads, meaning they are not available when resolving program statements (ofc they still exist in the bytecode).  And if we do choose to expose any synthetic methods at all, I'm not sure what impact that has on the rest of the JDT compiler.options appear to be:- go back to the old days of these two methods being AjSynthetic and not 'really' synthetic but ensuring they have a dummy line number table to keep other tools happy      (straightforward)- expose all synthetic methods in the compiler as callable      (no!)- expose just hasAspect/aspectOf in the compiler as callable      (doable, but not something I'd prefer to do in an RC, I'm not sure we can tell that we're loading an aspect at that point either, so may have to make these available for all types - not that they are likely to occur in classes of course.  And requires a careful extension to the compiler rather than hacking 'aspectOf/hasAspect' directly into JDT) Doh. It's obvious in hindsight that this would happen. I think the best solution for 1.5.2 is:  ""- go back to the old days of these two methods being AjSynthetic and not  'really' synthetic but ensuring they have a dummy line number table to keep  other tools happy        (straightforward)""it's only two methods, and they are part of the programming model so I guess in this case it's ok to have them not be fully synthetic. We could possibly look at making them truly synthetic and allowing calls to them from in the compiler, but that's a further out thing (and possibly doesn't add much value over the approach above).Note that generating the line number table will be needed if we make them non-synthetic otherwise Emma et al. will break again (but JAXB and ORM tools will be happy). I've just committed the code to go back to the old way for aspectOf()/hasAspect() - had to modify the existing testcode and I've committed Rons test program too.I've manually inspected that the (fake) line number table was there for the two methods but haven't written a test for it. fix looks good, thanks Andy. Enjoyed the droids ;) fix available. "	2006-06-26 16:46:03	1151350000.0	resolved fixed	21e06a6	1151490000.0	tests/bugs152/pr148727/Client.java tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java weaver/src/org/aspectj/weaver/NameMangler.java
148911	NPR compiling Spring	The Spring 2.0 RC1 project contains two directories with aspects. Since the eclipse project does not compile cleanly with just the java nature, I decided to try adding the aspectj nature and giving the aspectj builder a shot. I don't have any idea what might be the trigger to the problem, but simply checking out Spring 2.0 RC1 and adding the aspectj nature should be able to reproduce. If I learn more I will add to this bug.----java.lang.NullPointerExceptionat org.aspectj.org.eclipse.jdt.internal.compiler.ast.SingleTypeReference.getTypeBinding(SingleTypeReference.java:39)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:132)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:123)at org.aspectj.ajdt.internal.core.builder.AsmElementFormatter.setParameters(AsmElementFormatter.java:311)at org.aspectj.ajdt.internal.core.builder.AsmElementFormatter.genLabelAndKind(AsmElementFormatter.java:258)at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.visit(AsmHierarchyBuilder.java:392)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:185)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1250)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.traverse(QualifiedAllocationExpression.java:392)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.traverse(LocalDeclaration.java:242)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:212)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1195)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:339)at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.internalBuild(AsmHierarchyBuilder.java:145)at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.buildStructureForCompilationUnit(AsmHierarchyBuilder.java:87)at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.finishedCompilationUnit(EclipseFactory.java:941)at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterProcessing(AjCompilerAdapter.java:210)at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$after$org_aspectj_ajdt_internal_compiler_CompilerAdapter$4$6b855184(CompilerAdapter.aj:91)at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:533)at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:887)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:244)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:163)at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)NullPointerException thrown: null i have put a guard in for the NPE.  It is actually going bang building the structure model rather than doing anything intricate in the compiler.  The NPE guard may now reveal an underlying compiler error in the source... as I can't really see why the scope was null at that point in building the model. NPE guard is in latest dev build - please try it out if you can. npe fix is shipped - please reopen if you get a chance to try it out and still can't build spring. 	2006-06-27 19:29:58	1151450000.0	resolved fixed	b59b036	1151480000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmElementFormatter.java
148388	LTW weaver produces a debug message at the begining	"Using the code in bug #148381 (with any of the working options), LT weaver produces what seems a debug message:""? WeavingClassFileProvider.acceptResult() test.Main->test.Main$AjcClosure1""> java -javaagent:%ASPECTJ_LIB_HOME%\aspectjweaver.jar test.Main? WeavingClassFileProvider.acceptResult() test.Main->test.Main$AjcClosure1Method Main.foo() took longer than expected        Max expected = 1000, actual = 65371 That was me, some debug info left over from fixing Bug 139936. going to close out for final 1.5.2 if we just need to remove a line? Fix committed Fix available "	2006-06-23 09:55:32	1151070000.0	resolved fixed	99d1c18	1151430000.0	weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java
148786	new array construction join point can fail for freaky array constructors	"Took me a while to discover how to recreate this problem, but this class:public class A {  public static void main(String []argv) {    byte[][] bytes = new byte[][]{{0},{1}};  }}causes this bytecode:0:   iconst_21:   anewarray       #18; //class ""[B""and this causes the newarray joinpoint code to go bang.(eg. before(): call(*[].new(..)) {})java.lang.NullPointerException        at org.aspectj.weaver.bcel.BcelWorld.fromBcel(BcelWorld.java:236)        at org.aspectj.weaver.bcel.BcelWorld.makeJoinPointSignatureForArrayConstruction(BcelWorld.java:483)        at org.aspectj.weaver.bcel.BcelShadow.makeArrayConstructorCall(BcelShadow.java:801)        at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2510)        at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2325)        at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:490)        at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:115)        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1574)        at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1525)        at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1305)        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1127) tiny localized fix committed (only changes anything when -Xjoinpoints:arrayconstruction active) "	2006-06-27 05:42:49	1151400000.0	resolved fixed	792d1df	1151410000.0	tests/bugs152/pr148786/A.java tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java weaver/src/org/aspectj/weaver/bcel/BcelWorld.java
147711	Add an option to generate aj-synthetics with true synthetic flag	"In a number of cases tools are getting confused over generated aj members that are  ""aj-synthetic"" but not marked with the synthetic attribute (because in the past, this has upset other tools). The most recent example was a JAXB posting on the list - by having a perthis() clause in an aspect that matched a type with JAXB 2 annotations the user was no longer able to use JAXB. This is a serious issue, and will prevent the usage of JAXB 2 with any type into which we introduce properties as aj-synthetic members. The JAXB 2 solution to ignore such fields is to annotate them with @XmlTransient, but since the field does not exist in the user program they can't even do this! would be good to do this in 1.5.2 if there is time... Also note, making these members truly synthetic will presumably make them disappear from java.lang.reflect access - which the AjTypeSystem currently depends on... some thinking to be done there. I ran into this issue with the Emma code coverage tool before, so this option would be valuable to try out. But it would be much less attractive if it broke the AspectJ reflection access... Note, a related issue has now been seen ""in the wild"" with Hibernate Entity Manager mappings.On the reflection API point I raised earlier, we need to be careful, but I don't think there's going to be a big problem. The members that reflection most needs to see are members within aspects - we can keep those as regular members. It's the members we add into woven types (for private ITDs, per-clauses, @DeclareParents, etc.) that really need to be truly synthetic, and AjTypeSystem does not depend on visibility of any of those.  good news, bad news.Good news is that the synthetic changes will absolutely not affect the AjTypeSystem.Bad news is that synthetic members are still fully visible via reflection (I'd assumed they wouldn't be, but for no good reason it transpires). In JDK 1.4 and below, there isn't even any way you can tell that they are synthetic. JDK 1.5 adds an isSynthetic() operation so you can tell :- let's hope JAXB et. al. take note of it (since they're all annotation driven, they are at least on JDK 1.5). I've been able to get the synthetic flag/attribute on the relevant members with very little effort - full test suite still passes. Need to do some more checking on members we create in the front-end compiler before checking in. I've changed the compiler to add the synthetic attribute / flag (as appropriate for JDK 1.4/1.5) to all synthetic aspect members. Tests show that this seems to be working very well. I wrote some aspects from hell that exercised every language feature, advised the same target type with all of them, and then ran the results through Emma without any issue.Only slight nit is that Emma still showed the synthetic members in its coverage report (which looks a little ugly) - but it certainly worked. fix committed in tree now available in latest build See bug #148727 (https://bugs.eclipse.org/bugs/show_bug.cgi?id=148727)I don't think it's reasonable to mark API methods like aspectOf and hasAspect as synthetic, which prevents seprate compilation of code that refers to these methods from working.  Also, I found cases in our code where Emma was still complaining about AspectJ generated classes not having debug information. If there's a fix to iajc to allow keeping synthetic markers, I will investigate this further. I've read that emma used to not recognized Java5 classes, and so it didn't know that with Java5 synthetic became a bit flag and not an attribute...  AspectJ will be correctly making it a bit flag when producing Java5 level classes. Changing OS from Mac OS to Mac OS X as per bug 185991 "	2006-06-19 08:15:25	1150720000.0	resolved fixed	c9f311a	1151150000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AdviceDeclaration.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/DeclareDeclaration.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PointcutDeclaration.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java weaver/src/org/aspectj/weaver/NameMangler.java weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java
148007	boolean methods with after advice return incorrect result on JRockit under WLS	"n 21/06/06, Stearns, Randy <RStearns@knowledgestorm.com> wrote:    I've been able to create a reproducible test. My (really pared down) aspect:         public aspect LoggingAspect {          pointcut logPointcut() :      execution (* *.*(..))      && !within(LoggingAspect);          before() : logPointcut() {       System.out.println(""entering"");     }             after() : logPointcut() {                System.out.println(""exiting"");        }    }    As it only appears in JRockit *while running in WebLogic*, I created a test servlet (below)    As long as there is an after advice, tests 2 and 5 in the servlet return incorrect results.    If I remove it, everything works. Also, if tests 2 and 5 return Boolean objects, it works.         It appears AJ not like after advice on methods returning primitives.    Is there a way to bypass them?         Randy              package test;         import javax.servlet.ServletException;    import javax.servlet.http.HttpServlet;    import javax.servlet.http.HttpServletRequest;    import javax.servlet.http.HttpServletResponse;    import java.io.IOException;    import java.io.PrintWriter;         /**     * Hello world!     */    public class TestServlet extends HttpServlet {             protected void service(HttpServletRequest request, HttpServletResponse response)                throws ServletException, IOException {            booleanTest(response);        }             private void booleanTest(HttpServletResponse response) throws ServletException {            PrintWriter out = null;            try {                out = response.getWriter();            } catch (IOException ioe) {                throw new ServletException(""Could not get writer."");            }                 out.println(""Test 1a. Should be false. Was: "" + invert1a());            out.println(""Test 1b. Should be true. Was: "" + invert1b());            out.println(""Test 2. Should be false. Was: "" + invert2());            out.println(""Test 3. Should be true. Was: "" + invert3());            out.println(""Test 4. Should be true. Was: "" + invert4());            out.println(""Test 5. Should be false. Was: "" + invert5());        }             private boolean invert1a() {            return ! true;        }             private boolean invert1b() {            return ! false;        }             private boolean invert2() {            return ! isTrue();        }             private boolean invert3() {            return ! isFalse();        }             private boolean invert4() {            boolean temp = isFalse();            return ! temp;        }             private boolean invert5() {            boolean temp = isTrue();            return ! temp;        }             private boolean isTrue() {            return true;        }             private boolean isFalse() {            return false;        }    } Here's the bytecode generated by ajc for test 2 (invert2):private boolean invert2();  org.aspectj.weaver.MethodDeclarationLineNumber: length = 0x8   00 00 00 2C 00 00 04 FFFFFFB5   Code:   Stack=2, Locals=2, Args_size=1   0:	invokestatic	#105; //Method LoggingAspect.aspectOf:()LLoggingAspect;   3:	invokevirtual	#108; //Method LoggingAspect.ajc$before$LoggingAspect$1$9fd5dd97:()V   6:	aload_0   7:	invokespecial	#92; //Method isTrue:()Z   10:	ifeq	17   13:	iconst_0   14:	goto	18   17:	iconst_1   18:	goto	30   21:	astore_1   22:	invokestatic	#105; //Method LoggingAspect.aspectOf:()LLoggingAspect;   25:	invokevirtual	#111; //Method LoggingAspect.ajc$after$LoggingAspect$2$9fd5dd97:()V   28:	aload_1   29:	athrow   30:	invokestatic	#105; //Method LoggingAspect.aspectOf:()LLoggingAspect;   33:	invokevirtual	#111; //Method LoggingAspect.ajc$after$LoggingAspect$2$9fd5dd97:()V   36:	ireturn  Exception table:   from   to  target type     0    21    21   Class java/lang/Throwable  LocalVariableTable:    Start  Length  Slot  Name   Signature   6      15      0    this       LTestServlet;  LineNumberTable:    line 45: 6 Here's an analysis of the bytecode for invert2, it looks to be completely correct to me...private boolean invert2();  org.aspectj.weaver.MethodDeclarationLineNumber: length = 0x8   00 00 00 2C 00 00 04 FFFFFFB5   Code:   Stack=2, Locals=2, Args_size=1   // call LoggingAspect.aspectOf(), leaving result on operand stack   0:	invokestatic	#105; //Method LoggingAspect.aspectOf:()LLoggingAspect;   // call the before advice method, and pop the aspect reference from   // the stack   3:	invokevirtual	#108; //Method LoggingAspect.ajc$before$LoggingAspect$1$9fd5dd97:()V   // load a reference to ""this"" onto the stack   6:	aload_0   // call isTrue, pop the ""this"" reference from the stack, and    // push the result (literal 'true') onto the stack   7:	invokespecial	#92; //Method isTrue:()Z   // pop the return value from the stack and compare against 0 (false), if matched, goto 17   10:	ifeq	17   // we get here if isTrue returned true, push false onto the operand   / /stack (code is ! isTrue() )...   13:	iconst_0   14:	goto	18   // we get here if isTrue returned false, push true onto the operand   // stack (code is ! isTrue())   17:	iconst_1   18:	goto	30   // we get here if there is an exception thrown by any of the preceding   // logic   // save the thrown exception   21:	astore_1   // call aspectOf   22:	invokestatic	#105; //Method LoggingAspect.aspectOf:()LLoggingAspect;   // invoke the after advice   25:	invokevirtual	#111; //Method LoggingAspect.ajc$after$LoggingAspect$2$9fd5dd97:()V   // load the thrown exception   28:	aload_1   // and rethrow it   29:	athrow   // call LoggingAspect.aspectOf, after this operand stack contains   // [aspect instance, return value]   30:	invokestatic	#105; //Method LoggingAspect.aspectOf:()LLoggingAspect;   // call the after advice, pops the aspect instance from the stack,   // leaving the return value   33:	invokevirtual	#111; //Method LoggingAspect.ajc$after$LoggingAspect$2$9fd5dd97:()V   // return - value will be correct according to the code we compiled   36:	ireturn  Exception table:   from   to  target type     0    21    21   Class java/lang/Throwable  LocalVariableTable:    Start  Length  Slot  Name   Signature   6      15      0    this       LTestServlet;  LineNumberTable:    line 45: 6We also need to look at the compiled code for isTrue() of course, to make sure there are no surprises there either... bytecode for isTrue():private boolean isTrue();  org.aspectj.weaver.MethodDeclarationLineNumber: length = 0x8   00 00 00 3E 00 00 05 FFFFFFCF   Code:   Stack=2, Locals=2, Args_size=1   0:	invokestatic	#105; //Method LoggingAspect.aspectOf:()LLoggingAspect;   3:	invokevirtual	#108; //Method LoggingAspect.ajc$before$LoggingAspect$1$9fd5dd97:()V   6:	iconst_1   7:	goto	19   10:	astore_1   11:	invokestatic	#105; //Method LoggingAspect.aspectOf:()LLoggingAspect;   14:	invokevirtual	#111; //Method LoggingAspect.ajc$after$LoggingAspect$2$9fd5dd97:()V   17:	aload_1   18:	athrow   19:	invokestatic	#105; //Method LoggingAspect.aspectOf:()LLoggingAspect;   22:	invokevirtual	#111; //Method LoggingAspect.ajc$after$LoggingAspect$2$9fd5dd97:()V   25:	ireturn  Exception table:   from   to  target type     0    10    10   Class java/lang/Throwable  LocalVariableTable:    Start  Length  Slot  Name   Signature   6      4      0    this       LTestServlet;  LineNumberTable:    line 63: 6 Analysis of isTrue() bytecode, also looks to be completely correct:private boolean isTrue();  org.aspectj.weaver.MethodDeclarationLineNumber: length = 0x8   00 00 00 3E 00 00 05 FFFFFFCF   Code:   Stack=2, Locals=2, Args_size=1   // call LoggingAspect.aspectOf, leaving object ref on stack   0:	invokestatic	#105; //Method LoggingAspect.aspectOf:()LLoggingAspect;   // invoke before advice, popping object ref from stack   3:	invokevirtual	#108; //Method LoggingAspect.ajc$before$LoggingAspect$1$9fd5dd97:()V   // load 1 (true) onto stack   6:	iconst_1   7:	goto	19   // we only get here if an exception is thrown in the preceding logic   // store the thrown exeception   10:	astore_1   // call the after advice   11:	invokestatic	#105; //Method LoggingAspect.aspectOf:()LLoggingAspect;   14:	invokevirtual	#111; //Method LoggingAspect.ajc$after$LoggingAspect$2$9fd5dd97:()V   // put the thrown exception back on the stack   17:	aload_1   // and re-throw it   18:	athrow   // call LoggingAspect.aspectOf, on return stack is   // [aspectref, true]   19:	invokestatic	#105; //Method LoggingAspect.aspectOf:()LLoggingAspect;   // call the after advice, popping aspectref from stack, stack is now   // [true]   22:	invokevirtual	#111; //Method LoggingAspect.ajc$after$LoggingAspect$2$9fd5dd97:()V   // return true   25:	ireturn  Exception table:   from   to  target type     0    10    10   Class java/lang/Throwable  LocalVariableTable:    Start  Length  Slot  Name   Signature   6      4      0    this       LTestServlet;  LineNumberTable:    line 63: 6 code for a straight javac compile of the same class (no aspects involved):private boolean isTrue();  Code:   Stack=1, Locals=1, Args_size=1   // load constant 1 (true)   0:	iconst_1   // return it!   1:	ireturn  LineNumberTable:    line 63: 0private boolean invert2();  Code:   Stack=1, Locals=1, Args_size=1   // push 'this' onto stack   0:	aload_0   // call isTrue, after this stack will contain [ true ]   1:	invokespecial	#26; //Method isTrue:()Z   // if the return value was not zero (true) then goto 11   4:	ifne	11   // we get here if isTrue returned false, push 1 (true)   7:	iconst_1   8:	goto	12   // we get here if isTrue returned true, push 0 (false)   11:	iconst_0   // return   12:	ireturn  LineNumberTable:    line 45: 0 Attempting to create an equivalent pure java program to see how that compiles...// an ""aspect"" with the appropriate memberspublic class MyMockAspect {  public static MyMockAspect aspectOf() {     return new MyMockAspect();  }  public void doBeforeAdvice() {}  public void doAfterAdvice() {}}     and the relevant parts of ""MyTestServlet"" (everything else is the same):    private boolean invert2() {        try {            MyMockAspect.aspectOf().doBeforeAdvice();          return ! isTrue();        }        finally {            MyMockAspect.aspectOf().doAfterAdvice();        }    }    private boolean isTrue() {        try {            MyMockAspect.aspectOf().doBeforeAdvice();            return true;        }        finally {            MyMockAspect.aspectOf().doAfterAdvice();        }    }                                                                                            byte code resulting from compiling this with javac:private boolean invert2();  Code:   Stack=1, Locals=3, Args_size=1   0:	invokestatic	#26; //Method MyMockAspect.aspectOf:()LMyMockAspect;   3:	invokevirtual	#27; //Method MyMockAspect.doBeforeAdvice:()V   6:	aload_0   7:	invokespecial	#28; //Method isTrue:()Z   10:	ifne	17   13:	iconst_1   14:	goto	18   17:	iconst_0   18:	istore_1   19:	invokestatic	#26; //Method MyMockAspect.aspectOf:()LMyMockAspect;   22:	invokevirtual	#29; //Method MyMockAspect.doAfterAdvice:()V   25:	iload_1   26:	ireturn   27:	astore_2   28:	invokestatic	#26; //Method MyMockAspect.aspectOf:()LMyMockAspect;   31:	invokevirtual	#29; //Method MyMockAspect.doAfterAdvice:()V   34:	aload_2   35:	athrow  Exception table:   from   to  target type     0    19    27   any    27    28    27   any  LineNumberTable:    line 46: 0   line 47: 6   line 50: 19   line 51: 25   line 50: 27   line 51: 34private boolean isTrue();  Code:   Stack=1, Locals=3, Args_size=1   0:	invokestatic	#26; //Method MyMockAspect.aspectOf:()LMyMockAspect;   3:	invokevirtual	#27; //Method MyMockAspect.doBeforeAdvice:()V   6:	iconst_1   7:	istore_1   8:	invokestatic	#26; //Method MyMockAspect.aspectOf:()LMyMockAspect;   11:	invokevirtual	#29; //Method MyMockAspect.doAfterAdvice:()V   14:	iload_1   15:	ireturn   16:	astore_2   17:	invokestatic	#26; //Method MyMockAspect.aspectOf:()LMyMockAspect;   20:	invokevirtual	#29; //Method MyMockAspect.doAfterAdvice:()V   23:	aload_2   24:	athrow  Exception table:   from   to  target type     0     8    16   any    16    17    16   any  LineNumberTable:    line 70: 0   line 71: 6   line 74: 8   line 75: 14   line 74: 16   line 75: 23 byte code resulting from compiling with the Eclipse JDT compiler:private boolean invert2();  org.aspectj.weaver.MethodDeclarationLineNumber: length = 0x8   00 00 00 2C 00 00 04 FFFFFFB7   Code:   Stack=1, Locals=4, Args_size=1   0:	invokestatic	#95; //Method MyMockAspect.aspectOf:()LMyMockAspect;   3:	invokevirtual	#98; //Method MyMockAspect.doBeforeAdvice:()V   6:	aload_0   7:	invokespecial	#101; //Method isTrue:()Z   10:	ifeq	17   13:	iconst_0   14:	goto	18   17:	iconst_1   18:	istore_3   19:	jsr	30   22:	iload_3   23:	ireturn   24:	astore_2   25:	jsr	30   28:	aload_2   29:	athrow   30:	astore_1   31:	invokestatic	#95; //Method MyMockAspect.aspectOf:()LMyMockAspect;   34:	invokevirtual	#104; //Method MyMockAspect.doAfterAdvice:()V   37:	ret	1  Exception table:   from   to  target type     0    22    24   any  LineNumberTable:    line 46: 0   line 47: 6   line 49: 24   line 51: 28   line 49: 30   line 50: 31   line 51: 37  LocalVariableTable:    Start  Length  Slot  Name   Signature   0      39      0    this       LMyTestServlet;private boolean isTrue();  org.aspectj.weaver.MethodDeclarationLineNumber: length = 0x8   00 00 00 44 00 00 06 5D   Code:   Stack=1, Locals=3, Args_size=1   0:	invokestatic	#95; //Method MyMockAspect.aspectOf:()LMyMockAspect;   3:	invokevirtual	#98; //Method MyMockAspect.doBeforeAdvice:()V   6:	jsr	17   9:	iconst_1   10:	ireturn   11:	astore_2   12:	jsr	17   15:	aload_2   16:	athrow   17:	astore_1   18:	invokestatic	#95; //Method MyMockAspect.aspectOf:()LMyMockAspect;   21:	invokevirtual	#104; //Method MyMockAspect.doAfterAdvice:()V   24:	ret	1  Exception table:   from   to  target type     0     9    11   any  LineNumberTable:    line 70: 0   line 71: 6   line 73: 11   line 75: 15   line 73: 17   line 74: 18   line 75: 24  LocalVariableTable:    Start  Length  Slot  Name   Signature   0      26      0    this       LMyTestServlet; the most instructive here is to compare the code that javac generates for e.g. isTrue() with the code that ajc created.I'll reorder the instructions slightly to ease the comparisonjavac                         ajc====================================================invokestatic aspectOf         invokestatic aspectOfinvokevirtual before_advice   invokevirtual before_adviceiconst_1                      iconst_1istore_1                      -invokestatic aspectOf         invokestatic aspectOfinvokevirtual after_advice    invokevirtual after_adviceiload_1                       -ireturn                       ireturn// finally blockastore_2                      astore_1invokestatic aspectOf         invokestatic aspectOfinvokevirtual after_advice    invokevirtual after_adviceaload_2                       aload_1athrow                        athrowhere you can see that javac surrunds the after advice dispatch in the main body with an astore/load pair, whereas ajc does not. my conclusions until we get details of exact JRockit and WLS versions etc...:This is a JRockit bug triggered by optimisations performed when JRockit is running under WLS. The bug is not often seen in the wild, because aspectj is generating a perfectly legal bytecode pattern, but one that is different to that produced by javac.Note that using the jdt compiling with the -inlineJSR flag *also* produces the store/load pairs:private boolean invert2();  org.aspectj.weaver.MethodDeclarationLineNumber: length = 0x8   00 00 00 2C 00 00 04 FFFFFFB7   Code:   Stack=1, Locals=3, Args_size=1   0:	invokestatic	#95; //Method MyMockAspect.aspectOf:()LMyMockAspect;   3:	invokevirtual	#98; //Method MyMockAspect.doBeforeAdvice:()V   6:	aload_0   7:	invokespecial	#101; //Method isTrue:()Z   10:	ifeq	17   13:	iconst_0   14:	goto	18   17:	iconst_1   18:	istore_2   19:	invokestatic	#95; //Method MyMockAspect.aspectOf:()LMyMockAspect;   22:	invokevirtual	#104; //Method MyMockAspect.doAfterAdvice:()V   25:	iload_2   26:	ireturn   27:	astore_1   28:	invokestatic	#95; //Method MyMockAspect.aspectOf:()LMyMockAspect;   31:	invokevirtual	#104; //Method MyMockAspect.doAfterAdvice:()V   34:	aload_1   35:	athrowSince these pairs seem uneccessary from a reading of the JVM spec., but both compilers do it (jdt tries to mirror javac of course), if we could get ajc to do the same it would probably help to avoid triggering bugs of this nature in JVMs in the future... Created attachment 44988Test setup to replicate issueWeb test executed on Weblogic 8.1 sp4. Startup notice: <Jun 21, 2006 6:47:20 AM EDT> <Info> <WebLogicServer> <BEA-000377> <Starting WebLogic Server with BEA WebLogic JRockit(TM) 1.4.2_05 JVM R24.4.0-1 Version ari-38120-20041118-1131-win-ia32 from BEA Systems, Inc.><Jun 21, 2006 6:47:21 AM EDT> <Info> <Configuration Management> <BEA-150016> <This server is being started as the administration server.><Jun 21, 2006 6:47:21 AM EDT> <Info> <Management> <BEA-141107> <Version: WebLogic Server 8.1 SP4  Mon Nov 29 16:21:29 PST 2004 471647 I am now able to duplicate the problem outside WLS. The UnitTest is in the test setup zip file. Compiled using AspectJ 1.5.0 release. Works as expected when WLS running Sun JVM. Also works using JRockit if the methods return an Object (Boolean) rather than a primitive. e.g. return new Boolean(! isTrue());Let me know if I can assist further. fantastic, thank you. I've downloaded the jrockit 1.4.2_08 vm and am able toreproduce this failure in the AspectJ test suite using it. That's a big stepforward towards a solution... Now that I can reproduce locally, I've been able to narrow this down further.The bare minimum aspect you need to reproduce the bug is:public aspect LoggingAspect { after() returning : execution(* invert2(..)) {}}The byte codes that upset the latest JRockit VM (1.4.2_08) are:private boolean invert2();  org.aspectj.weaver.MethodDeclarationLineNumber: length = 0x8   00 00 00 25 00 00 03 58  Code:   Stack=2, Locals=1, Args_size=1   0:   aload_0   1:   invokespecial   #70; //Method isTrue:()Z   4:   ifeq    11   7:   iconst_0   8:   goto    12   11:  iconst_1   12:  goto    15   15:  invokestatic    #82; //Methodtest/LoggingAspect.aspectOf:()Ltest/LoggingAspect;   18:  invokevirtual   #85; //Methodtest/LoggingAspect.ajc$afterReturning$test_LoggingAspect$1$188fbb36:()V   21:  ireturn  LocalVariableTable:   Start  Length  Slot  Name   Signature   0      15      0    this       Ltest/BooleanUnitTest;  LineNumberTable:   line 38: 0 If I change the compiler temporarily to force in the extra store / load instructions as shown in the following generated code, it *still fails*! So I have to reject the store/load hypothesis for now..private boolean invert2();  org.aspectj.weaver.MethodDeclarationLineNumber: length = 0x8   00 00 00 25 00 00 03 58  Code:   Stack=1, Locals=2, Args_size=1   0:   aload_0   1:   invokespecial   #70; //Method isTrue:()Z   4:   ifeq    11   7:   iconst_0   8:   goto    12   11:  iconst_1   12:  goto    15   15:  istore_1   16:  invokestatic    #82; //Method test/LoggingAspect.aspectOf:()Ltest/LoggingAspect;   19:  invokevirtual   #85; //Method test/LoggingAspect.ajc$afterReturning$test_LoggingAspect$1$188fbb36:()V   22:  iload_1   23:  ireturn  LocalVariableTable:   Start  Length  Slot  Name   Signature   0      15      0    this       Ltest/BooleanUnitTest;  LineNumberTable:   line 38: 0 This very similar bytecode (missing one goto) compiled without any aspects from the source codeprivate boolean invert2() {  boolean ret = ! isTrue();  LoggingAspect.aspectOf().after();  return ret;}works without any problem.private boolean invert2();  org.aspectj.weaver.MethodDeclarationLineNumber: length = 0x8   00 00 00 25 00 00 03 5C  Code:   Stack=1, Locals=2, Args_size=1   0:   aload_0   1:   invokespecial   #70; //Method isTrue:()Z   4:   ifeq    11   7:   iconst_0   8:   goto    12   11:  iconst_1   12:  istore_1   13:  invokestatic    #76; //Method purejava/LoggingAspect.aspectOf:()Lpurejava/LoggingAspect;   16:  invokevirtual   #79; //Method purejava/LoggingAspect.after:()V   19:  iload_1   20:  ireturn  LineNumberTable:   line 38: 0   line 39: 13   line 40: 19  LocalVariableTable:   Start  Length  Slot  Name   Signature   0      21      0    this       Lpurejava/BooleanUnitTest;   13      8      1    ret       ZSo there are two possible hypothesis left: the extra goto is confusing JRockit, or there's something in the difference between the aspectOf and after() methods in my ""hand written"" aspect and the same methods in the ajc compiled aspect that is upsetting JRockit. ok, next piece of evidence. I changed my ""hand written"" aspect to have identical names to the ajc compiled aspect.This let me generate with straight javac the following byte code:private boolean invert2();  org.aspectj.weaver.MethodDeclarationLineNumber: length = 0x8   00 00 00 25 00 00 03 58  Code:   Stack=1, Locals=2, Args_size=1   0:   aload_0   1:   invokespecial   #70; //Method isTrue:()Z   4:   ifeq    11   7:   iconst_0   8:   goto    12   11:  iconst_1   12:  istore_1   13:  invokestatic    #76; //Method test/LoggingAspect.aspectOf:()Ltest/LoggingAspect;   16:  invokevirtual   #79; //Method test/LoggingAspect.ajc$afterReturning$test_LoggingAspect$1$188fbb36:()V   19:  iload_1   20:  ireturn  LineNumberTable:   line 38: 0   line 39: 13   line 40: 19  LocalVariableTable:   Start  Length  Slot  Name   Signature   0      21      0    this       Ltest/BooleanUnitTest;   13      8      1    ret       Zthis is *identical* to the ajc compiled with aspects code, bar the additional goto instruction. The test still passes with this code.Furthermore, it then enabled me to replace the LoggingAspect.class file from my ""simulated"" aspect with the ""real"" LoggingAspect.class file as compiled from aspect source by ajc. The test *still* passed - eliminating any difference caused by the aspect methods that are invoked.So... the *only* difference between the working and failing code is that extraneous goto. This *should* be harmless - it is definitely a JRockit bug, I can say that categorically at this point. Now to see if I can get rid of that unwanted goto and prove the point beyond all doubt...[apologies to those on cc for the volume of comments on this bug] conclusive proof. Changing the compiler to eliminate that goto causes the test to pass - I can even remove the store/load pair that I added earlier and we are still in the clear.So this is a very bad JRockit bug, whereby having a goto instruction in which the target of the goto is simply the next instruction causes JRockit to do terrible things.AspectJ is adding that goto because a method body may have several return statements, so each return statement is replaced by a goto that jumps to the after returning advice dispatch. An optimisation whereby we don't add this goto if there is only one return and it is the last statement in the method (i.e. it would just be a goto-next-instruction goto) could be added that would help in this case. Then I need to do further experimentation to see how  JRockit handles the case of multiple return statements... I've properly implemented an optimisation that prevents generation of a goto for after returning advice when the target is the next instruction. This passes all tests in the suite, *and* makes the test pass on JRockit.Changing the advice from after returning back to plain after advice still hits the bug though, so I need to look at that code path now. after advice is implemented as ""weaveAfterThrowing(); weaveAfterReturning();""when weaving ""throwing"" before ""returning"" like this JRockit fails. Here's the bytecode: private boolean invert2();  org.aspectj.weaver.MethodDeclarationLineNumber: length = 0x8   00 00 00 25 00 00 03 58  Code:   Stack=2, Locals=2, Args_size=1   0:   aload_0   1:   invokespecial   #70; //Method isTrue:()Z   4:   ifeq    11   7:   iconst_0   8:   goto    12   11:  iconst_1   12:  goto    24   15:  astore_1   16:  invokestatic    #82; //Method test/LoggingAspect.aspectOf:()Ltest/LoggingAspect;   19:  invokevirtual   #85; //Method test/LoggingAspect.ajc$after$test_LoggingAspect$1$9fd5dd97:()V   22:  aload_1   23:  athrow   24:  invokestatic    #82; //Method test/LoggingAspect.aspectOf:()Ltest/LoggingAspect;   27:  invokevirtual   #85; //Method test/LoggingAspect.ajc$after$test_LoggingAspect$1$9fd5dd97:()V   30:  ireturn  Exception table:   from   to  target type     0    15    15   Class java/lang/ThrowableAs an experiment if I swap the order, JRockit has no trouble...weaving ""returning"" before ""throwing"" (works):private boolean invert2();  org.aspectj.weaver.MethodDeclarationLineNumber: length = 0x8   00 00 00 25 00 00 03 58  Code:   Stack=2, Locals=2, Args_size=1   0:   aload_0   1:   invokespecial   #70; //Method isTrue:()Z   4:   ifeq    11   7:   iconst_0   8:   goto    12   11:  iconst_1   12:  nop   13:  invokestatic    #82; //Method test/LoggingAspect.aspectOf:()Ltest/LoggingAspect;   16:  invokevirtual   #85; //Method test/LoggingAspect.ajc$after$test_LoggingAspect$1$9fd5dd97:()V   19:  ireturn   20:  astore_1   21:  invokestatic    #82; //Method test/LoggingAspect.aspectOf:()Ltest/LoggingAspect;   24:  invokevirtual   #85; //Method test/LoggingAspect.ajc$after$test_LoggingAspect$1$9fd5dd97:()V   27:  aload_1   28:  athrow  Exception table:   from   to  target type     0    20    20   Class java/lang/Throwable (note of course that the order swap is not an acceptable solution, it would mean that an exception throw by the after advice body would cause the after advice body to run a second time...) I think I've nailed it... I've got the compiler to generate this:private boolean invert2();  org.aspectj.weaver.MethodDeclarationLineNumber: length = 0x8   00 00 00 25 00 00 03 58  Code:   Stack=1, Locals=3, Args_size=1   0:   aload_0   1:   invokespecial   #70; //Method isTrue:()Z   4:   ifeq    11   7:   iconst_0   8:   goto    12   11:  iconst_1   12:  istore_2   13:  goto    25   16:  astore_1   17:  invokestatic    #82; //Method test/LoggingAspect.aspectOf:()Ltest/LoggingAspect;   20:  invokevirtual   #85; //Method test/LoggingAspect.ajc$after$test_LoggingAspect$1$9fd5dd97:()V   23:  aload_1   24:  athrow   25:  invokestatic    #82; //Method test/LoggingAspect.aspectOf:()Ltest/LoggingAspect;   28:  invokevirtual   #85; //Method test/LoggingAspect.ajc$after$test_LoggingAspect$1$9fd5dd97:()V   31:  iload_2   32:  ireturn  Exception table:   from   to  target type     0    16    16   Class java/lang/Throwablethis implementation avoids gotos where it can, and stores the return value before branching when a branch is needed. The return value is restored beforereturning. I believe this works around all known variations of the JRockit bug.time to run the full suite again... fix committed. This does two things: 1) avoids generating a goto that merely branches to the next instruction (replaces  the return in question with a nop instead)2) stores the return value on the top of the stack into a temp var before branching to the after advice dispatch, and restores it later before returningThe code produced by ajc when weaving after [returning] advice is now closer to what would be produced by javac for similar code written by hand, hopefully lessening the chance of triggering other vm bugs in the future.From the evidence I would suggest that the JRockit bug is that the (top of the?) stack is getting corrupted on a goto under certain conditions. The VM spec. is very clear that a goto does *not* change the stack.I'm going to keep this report open as now that I have committed working code, I want to refactor it a little since the current code here is looking a little tired now... Refactoring complete - weaveAfterReturning is now nice and clean, easy to follow. Note that other methods in BcelShadow - esp. e.g. weaveAroundInline could do with the same treatment, we should continue to refactor and tidy up the code base as we have to open up different areas for maintenance and enhancements...Will close this report when fix is available in a build. Will also raise bug against JRockit and post bug number here when I have it. JRockit issue number is CR283379 (there is no publicly visible issue database for JRockit, but BEA support will understand this number). Thanks to the excellent bug report and repro, I tracked the problem down in 15 minutes and have submitted a one line fix to the JRockit code - the next time we ship public bits it will be included.  I'll file this as a request for a patch for 8.1 as well.Now let the other VM vendors try to beat that turnaround time ;) Regards,Marcus Lagergren Now that's service :) thanks. fix now available in latest build for download. Adrian,Kudo to you for the expeditiousness of the fix, and to BEA for the prompt attention, as well.Randy Changing OS from Mac OS to Mac OS X as per bug 185991 "	2006-06-21 05:27:01	1150880000.0	resolved fixed	426cbdc	1150950000.0	tests/bugs152/pr148007/purejava/test/BooleanUnitTest.java tests/bugs152/pr148007/purejava/test/LoggingAspect.java tests/bugs152/pr148007/test/BooleanUnitTest.java tests/bugs152/pr148007/test/TestServlet.java tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java weaver/src/org/aspectj/weaver/bcel/BcelShadow.java weaver/src/org/aspectj/weaver/bcel/Utility.java
147801	java.lang.ClassFormatError: Repetitive method name/signature	I get a ClassFormatError trying to perform runtime-weaving on a DB2 class.The class being woven is COM.ibm.db2.jdbc.app.DB2PreparedStatement.  The full message exception is: java.lang.ClassFormatError: Repetitive method name/signature in class file COM/ibm/db2/jdbc/app/DB2PreparedStatement.In examining the post-weave class file, it looks as if Aspectj is defininga duplicate method within the class called getParameterMetaData().  Here are the messages from the weaver:04:21:13,640 INFO  [STDOUT] info weaving 'COM.ibm.db2.jdbc.app.DB2CallableStatement'04:21:13,640 INFO  [STDOUT] info weaver operating in reweavable mode.  Need to verify any required types exist.04:21:13,671 INFO  [STDOUT] info weaving 'COM.ibm.db2.jdbc.app.DB2PreparedStatement'04:21:13,671 INFO  [STDOUT] info weaver operating in reweavable mode.  Need to verify any required types exist.04:21:13,703 INFO  [STDOUT] weaveinfo Join point 'method-execution(java.sql.ResultSet COM.ibm.db2.jdbc.app.DB2PreparedStatement.executeQuery())' in Type 'COM.ibm.db2.jdbc.app.DB2PreparedStatement' (DB2PreparedStatement.java:1679) advised by before advice from 'com.ibm.tivoli.itcam.toolkit.ai.aspectj.captureJDBC.CaptureSQLStatement' (CaptureSQLStatement.aj:747) [with runtime test]04:21:13,703 INFO  [STDOUT] weaveinfo Join point 'method-execution(java.sql.ResultSet COM.ibm.db2.jdbc.app.DB2PreparedStatement.executeQuery())' in Type 'COM.ibm.db2.jdbc.app.DB2PreparedStatement' (DB2PreparedStatement.java:1679) advised by afterReturning advice from 'com.ibm.tivoli.itcam.toolkit.ai.aspectj.captureJDBC.CaptureSQLStatement' (CaptureSQLStatement.aj:946) [with runtime test]04:21:13,718 INFO  [STDOUT] weaveinfo Join point 'method-execution(java.sql.ResultSet COM.ibm.db2.jdbc.app.DB2PreparedStatement.executeQuery())' in Type 'COM.ibm.db2.jdbc.app.DB2PreparedStatement' (DB2PreparedStatement.java:1679) advised by afterThrowing advice from 'com.ibm.tivoli.itcam.toolkit.ai.aspectj.captureJDBC.CaptureSQLStatement' (CaptureSQLStatement.aj:971) [with runtime test]04:21:13,718 INFO  [STDOUT] weaveinfo Join point 'method-execution(boolean COM.ibm.db2.jdbc.app.DB2PreparedStatement.execute())' in Type 'COM.ibm.db2.jdbc.app.DB2PreparedStatement' (DB2PreparedStatement.java:3971) advised by before advice from 'com.ibm.tivoli.itcam.toolkit.ai.aspectj.captureJDBC.CaptureSQLStatement' (CaptureSQLStatement.aj:833) [with runtime test]04:21:13,718 INFO  [STDOUT] weaveinfo Join point 'method-execution(boolean COM.ibm.db2.jdbc.app.DB2PreparedStatement.execute())' in Type 'COM.ibm.db2.jdbc.app.DB2PreparedStatement' (DB2PreparedStatement.java:3971) advised by afterReturning advice from 'com.ibm.tivoli.itcam.toolkit.ai.aspectj.captureJDBC.CaptureSQLStatement' (CaptureSQLStatement.aj:946) [with runtime test] i've been sent the classes privately - it looks like multiple bridge methods are being created.  I need to work out why there should be any first, and if there should be any then why there is more than one. Ok, in the unwoven class we have a method:public COM.ibm.db2.jdbc.app.DB2ParameterMetaData getParameterMetaData()        throws java.sql.SQLException;In the woven class we end up with:public COM.ibm.db2.jdbc.app.DB2ParameterMetaData getParameterMetaData()        throws java.sql.SQLException;public java.sql.ParameterMetaData getParameterMetaData()              throws java.sql.SQLException;public java.sql.ParameterMetaData getParameterMetaData()              throws java.sql.SQLException;the extra two methods look like this:public java.sql.ParameterMetaData getParameterMetaData()       throws java.sql.SQLException;  Code:   Stack=1, Locals=1, Args_size=1   0:   aload_0   1:   invokevirtual   #1902; //Method getParameterMetaData:()LCOM/ibm/db2/jdbc/app/DB2ParameterMetaData;   4:   areturn  LineNumberTable:   line 1: 0  Exceptions:   throws java.sql.SQLExceptionThey look like bridge methods, but I've not checked the access flags to verify that.  The class file version before and after weaving is 45.3 (Java 1.1).So, I need to:- confirm if they are bridge methods- if so, determine why they are getting created, since the method takes no parameters it looks like the compiler believes covariance  is occurring or generic types are involved and so it needs to put them in - thats not right.The class declaration is:public class COM.ibm.db2.jdbc.app.DB2PreparedStatement      extends COM.ibm.db2.jdbc.app.DB2Statement   implements java.sql.PreparedStatement,com.ibm.db2.jcc.SQLJPreparedStatementSo, I need to see the class in the hierarchy that declares getParameterMetaData, which could be DB2Statement/PreparedStatement or SQLJPreparedStatement.And why on earth are there two of them? I've put in a 'fix' for this.  I have recreated a situation where an incorrect bridge method is created, but I've not been able to recreate a situation where two are created as in this case.  Having obtained more of the types involved in this situation, it is very peculiar.The compiler is assuming covariance is occurring and generating a bridge method.It thinks this method in DB2PreparedStatement:public COM.ibm.db2.jdbc.app.DB2ParameterMetaData getParameterMetaData()        throws java.sql.SQLException;is implementing this method in PreparedStatement because DB2PreparedStatement implements PreparedStatementpublic java.sql.ParameterMetaData getParameterMetaData()              throws java.sql.SQLException;It makes the assumption that if you have two methods like that in a hierarchy then one is the implementation....But in this case it looks like DB2PreparedStatement was compiled against an old version of PreparedStatement that didnt have a getParameterMetaData() method.  This *has* to be the case because DB2ParameterMetaData type returned by the implementation extends Object... it is not covariance.Then it just so happens that when the application is run, it finds the more up to date version of PreparedStatement that does include this getParameterMetaData() method.  Whether this code actually behaves, I don't know - I'm a little surprised there is no verify problem.Anyway, to cover this case i now verify absolutely that there is some kind of relationship between the return type of the submethod and the return type of the super method - if there isn't then it's not covariance.I've also exposed bridge method debugging via the option:-Xset:debugBridging=trueWith that option, here is an example of the output for the testcase:Bridging: Determining if we have to bridge to Foo.getParameterMetaData()LSub;Bridging: Checking supertype java.lang.Object  Bridging:checking for override of getParameterMetaData in java.lang.ObjectBridging:checking superinterface PreparedStatement  Bridging:checking for override of getParameterMetaData in PreparedStatement  Bridging:seriously considering this might be getting overridden 'ParameterMetaData PreparedStatement.getParameterMetaData()'  Bridging:checking for override of getParameterMetaData in java.lang.ObjectBridging:checking superinterface java.io.Serializable  Bridging:checking for override of getParameterMetaData in java.io.Serializable  Bridging:checking for override of getParameterMetaData in java.lang.Object fix has been tested and confirmed to work... 	2006-06-19 18:07:26	1150750000.0	resolved fixed	13dde4e	1150890000.0	tests/bugs152/pr147801/Foo.java tests/bugs152/pr147801/PreparedStatement.java tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java weaver/src/org/aspectj/weaver/World.java weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java
147845	Generic abstract aspect hierarchies 3 deep or higher can fail when type parameters have bounds	The program below should compile happily, but fails with:[error] Type B does not meet the specification for type parameter 1 (A extends MyBase) in generic type Baseabstract aspect Middle<B extends MyBase> extends Base<B> {}                ^^^^^                                      The test program:------------------interface MyBase {};interface MyMarker extends MyBase {}abstract aspect Base<A extends MyBase> {}abstract aspect Middle<B extends MyBase> extends Base<B> {}aspect Sub extends Middle<MyMarker> {} fix now available in latest builds Changing OS from Mac OS to Mac OS X as per bug 185991 	2006-06-20 06:16:42	1150800000.0	resolved fixed	791f8a7	1150800000.0	tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java weaver/src/org/aspectj/weaver/TypeVariable.java
136707	iajc should print summary like javac	The iajc ant task should produce a summary of what it is doing, like the javac task does:[javac] Compiling 189 source files to C:\project\classes Thanks for the bug.  iajc will print the full ajc command line when in verbose mode.  The problem with trying to calculate a summary is that the iajc task does not enumerate files the way javac does - there could be any number of arg files, source roots, source files, etc. Reopen this if verbose isn't working for you or you have a proposal for useful info-level output (I thought perhaps when forking...). How about just printing a count of the number of top level input items (directories, inpath entries, source roots, etc.)? Verbose output is good for debugging, but it's helpful to see some summary of how much is being compiled in a batch build without so much information. Fixed in AjcTask.java:1.55 with new logCommand option that emits the entire command to INFO (verbose mode does the same, but also adds all other verbose messages).  No summary is correct in the presence of command editors, so the actual command is the best option absent heinous code to parse and summarize the command as edited.  I also left the command elements in [array, mode] to make parsing easier if need be. 	2006-04-13 14:23:22	1144950000.0	resolved fixed	008efca	1150230000.0	taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.java
146546	"Remove hard coded dependency on ""|"" in getFileName(..) methods"	"As part of bug 141730 we need to remove the hard coded dependency on ""|"" in methods which use handles to get the filename. These methods are:AsmManager.getFileName(String)AspectJElementHierarchy.getFileName(String) Created attachment 44132proposed fixApply this patch to the asm project.The proposed fix is to delegate to the IElementHandleProvider to get the filename for the given handle. committed. "	2006-06-12 07:59:26	1150110000.0	resolved fixed	38cc0dd	1150120000.0	asm/src/org/aspectj/asm/AsmManager.java asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java
122580	Fix & Bug: Circularity Failure for Verbose Loading on JRockit 1.4.2_08 Agent	"<Pyinson Data Over Head> By the way, this error occurs with *no* aop.xml file even defined. Just enabling the AspectJ JRockIt agent and starting Weblogic causes it... Ok this appears to be symptomatic of a deeper problem. The older BEA VM's are choking because the classloader agent is part of the classpath and we are weaving everything on the system classpath. The Java 5 agents are on the bootstrap classpath and so are never woven and I think that Java is it may also be  My first fix allows not weaving, but I needed to add some additional logic to prevent trying to weave before the ClassLoaderWeavingAdaptor has been fully initialized.With the attached patch, I can start up and weave classes into Weblogic running on a JRockIt 1.4.2_08 VM. Created attachment 32450Patch to loadtime module to fix problems weaving on older JRockIt VM Created attachment 32451Patch to weaver module to fix problems weaving on older JRockIt VM The problem here is that we are trying to weave the contents of aspectjweaver.jar which should be avoided altogether. The classloader used is entirely at the discretion of the user rather than being dependent on the JVM e.g. the aj5.bat launcher uses –javaagent and aspectjweaver.jar is loaded from CLASSPATH. I suspect the difference between Sun and JRockit lies with how/when the agent is initialized: either a startup or on first reference. We must avoid weaving _any_ AspectJ classes because of potiential ClassCircularityErrors but clearly the existing mechanism in WeavingAdaptor.shouldWeave() comes too late. There are several approaches:1.	Use a classloader that performs no weaving i.e. the bootstrap loader but modifying bootclasspath is either frowned upon or prohibited.2.	Use CodeSource (obtained from ProtectionDomain) passed on a modified preProcess() method  to identify those classes loaded from the same URL as Aj. Unfortunately the com.bea.jvm.ClassPreProcessor does not supply this information.3.	Perform no weaving on the classloader used to define Aj/JRockitAgent/ClassPreProcessorAgentAdapter. This would require a change to aj5.4.	Simply exclude classes whose names begin “org.aspectj.” but much earlier. This only works if we rename any classes we ship.Patch 32450 uses option #4. Why did you find it necessary to add the addional logic? I think you're right here Matthew: it's enough to just exclude weaving into org/aspectj types earlier in the cycle. However, Patch 32451 has most of the logic to actually exclude weaving earlier in the process whereas 32450 just comments out the test when it's too late. I probably started off with the logic to handle weaving while being initialized and then fell back on adding the earlier check in Aj.I tested using -Xmanagement on JRockIt 1.4.2 with just the logic to exclude AspectJ classes in Aj instead of the WeavingAdaptor, i.e., without the logic to detect ""am I initializing"" and it worked for a version of GlassboxInspector on Tomcat 4.1.x.Let's leave bug 140709 to track any possible need of handling self-weaving while initializing and apply the rest of these patches so that the JRockIt agent works properly. Reference to BEA JRockit JMAPI: http://edocs.bea.com/jrockit/docs142/jmapi/javadoc/Management%20API/index.html <Pyinson Data Over Head> That sounds like a good approach to me. Thanks! An article on writing a JRockit ClassPreProcessor with a nice sample implementation : http://dev2dev.bea.com/pub/a/2004/01/class_preprocessing.html 1. Re-implemented JRockitAgent using recursion protection2. Removed “loadtime” dependency on managementapi-jrockit81.jar and implemented to the necessary JRockit classes to aid testing3. Added JRockitAgentTest with from-scratch class loader to test recursion protection4. Relaxed ""catch (Throwble)"" to ""catch (Exception)"" in Aj.preProcess() to protect agent users against weaver problems but allow reporting of unrecoverable errors.My only concern with the recursion protection relates to around closure generation. When these are defined dependencies that have not yet been loaded may be passed to the weaver. This causes recursion in the agent/adaptor (although not in the weaver itself) which with the new agent may result in certain closures not being woven.Awaiting JRockit testing. That sounds great. Should I sync to head and build a copy to test it? 1. Re-implemented JRockitAgent using recursion protection2. Removed “loadtime” dependency on managementapi-jrockit81.jar and implemented to the necessary JRockit classes to aid testing3. Added JRockitAgentTest with from-scratch class loader to test recursion protection4. Relaxed ""catch (Throwble)"" to ""catch (Exception)"" in Aj.preProcess() to protect agent users against weaver problems but allow reporting of unrecoverable errors.My only concern with the recursion protection relates to around closure generation. When these are defined dependencies that have not yet been loaded may be passed to the weaver. This causes recursion in the agent/adaptor (although not in the weaver itself) which with the new agent may result in certain closures not being woven.Awaiting JRockit testing. Ron: Good news: I just installed it in Tomcat running against JRockit 1.4.2 and it was able to start up and weave aspects as required. I will do more testing, but the first smoke test worked well (and fails with 1.5.1a or recent dev builds). GreatAre we sure the thread local stack approach in there has no side effect when classloading gets into this recursive behavior ? Seems like if there is recursion, we won't weave the class at all since we 'll return bytecode from this thread local stack - which is fine if we assume the weaver only is the root cause of the recursion. Noone came across this in AspectWerkz - so I guess that 's because we had a slightly different weaver initialisation behaviorAlex The only reason for recursion is class loading while weaving using the class loader that actually defines the weaver. This can happen at any point, not just during initialization. It cannot and should not happen while resolving types necessary to weave a class: until now these have been loaded using getResourceAsStream() and with LTWWorld Class.forName is used only for bootstrap classes and these are exluded from weaving in Aj.preProcess(). I do not believe that the weaver is re-entrant.One issue previously noted concerns generated closures and will only be potential a problem for non-inlined around advice applied to classes loaded by the same loader used by the weaver. My advice is don’t weave classes on the same classpath as AspectJ! Awaiting build. Fix available "	2006-01-03 20:19:46	1136340000.0	resolved fixed	75afb31	1149850000.0	loadtime/src/org/aspectj/weaver/loadtime/Aj.java loadtime/src/org/aspectj/weaver/loadtime/JRockitAgent.java loadtime/testsrc/LoadtimeModuleTests.java loadtime/testsrc/org/aspectj/bea/jvm/ClassLibraryImpl.java loadtime/testsrc/org/aspectj/bea/jvm/JVMImpl.java loadtime/testsrc/org/aspectj/weaver/loadtime/JRockitAgentTest.java
145322	Failure of testCompareSubclassDelegates() on J9 1.5.0 SR1	"This would appear to be a regression of bug 120909 which was fixed for 1.5.0. The latest J9 can be obtained here http://www-128.ibm.com/developerworks/java/jdk/index.html.TESTROOTRunTheseBeforeYouCommitTestsAllTestsBcweaverModuleTests15org.aspectj.weaver.TestJava5ReflectionBasedReferenceTypeDelegatetestCompareSubclassDelegates(org.aspectj.weaver.TestJava5ReflectionBasedReferenceTypeDelegate)junit.framework.AssertionFailedError: Should be one extra (clinit) in BCEL case, but bcel=41 reflect=41	at junit.framework.Assert.fail(Assert.java:47)	at junit.framework.Assert.assertTrue(Assert.java:20)	at org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegateTest.testCompareSubclassDelegates(ReflectionBasedReferenceTypeDelegateTest.java:286)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:615)	at junit.framework.TestCase.runTest(TestCase.java:154)	at junit.framework.TestCase.runBare(TestCase.java:127)	at junit.framework.TestResult$1.protect(TestResult.java:106)	at junit.framework.TestResult.runProtected(TestResult.java:124)	at junit.framework.TestResult.run(TestResult.java:109)	at junit.framework.TestCase.run(TestCase.java:118)	at junit.framework.TestSuite.runTest(TestSuite.java:208)	at junit.framework.TestSuite.run(TestSuite.java:203)	at junit.framework.TestSuite.runTest(TestSuite.java:208)	at junit.framework.TestSuite.run(TestSuite.java:203)	at junit.framework.TestSuite.runTest(TestSuite.java:208)	at junit.framework.TestSuite.run(TestSuite.java:203)	at junit.framework.TestSuite.runTest(TestSuite.java:208)	at junit.framework.TestSuite.run(TestSuite.java:203)	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128)	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) fixed forgot to set target! "	2006-06-05 08:12:02	1149510000.0	resolved fixed	3e0650d	1149580000.0	weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java
145086	NPE when weak reference set in signature	"Simon ran into the same problem in setting the values. I will attach a patch to fix this, with test cases to properly verify it works in both cases.java.lang.NullPointerException	at org.aspectj.runtime.reflect.SignatureImpl$CacheImpl.set(SignatureImpl.java:224)	at org.aspectj.runtime.reflect.SignatureImpl.toString(SignatureImpl.java:57)	at org.aspectj.runtime.reflect.SignatureImpl.toString(SignatureImpl.java:62) Created attachment 43360Test and fix of NPE on set of weak reference (ugh) fix committed "	2006-06-02 11:35:11	1149260000.0	resolved fixed	f821ca3	1149320000.0	runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java runtime/testsrc/org/aspectj/runtime/reflect/JoinPointImplTest.java runtime/testsrc/org/aspectj/runtime/reflect/SignatureTest.java
132591	Duplicate exception with aop.xml file on aspectpath	See also bug #57666 which is related (but has to do with manifests):I have a META-INF/aop.xml file in my aspectpath and another one in the source path. That shouldn't even be a duplicate, because the aspectpath resource should NOT be copied to output at all.In AspectJ build:  1.5.1.20060309143651I am now getting:java.util.zip.ZipExceptionat java.util.zip.ZipOutputStream.putNextEntry(ZipOutputStream.java:163)at java.util.jar.JarOutputStream.putNextEntry(JarOutputStream.java:90)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.writeOutxmlFile(AjBuildManager.java:549)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:320)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:163)at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)ZipException thrown: duplicate entry: META-INF/aop.xml I the problem is occuring because you are using either -outxml or -outxmlfile. Could you post the commandline or Ant options you are using? This option will generate an aop.xml file for those aspects visible to the weaver which is probably clashing with the one in the source path. We don't copy resources from aspectpath.Now of cause we shouldn't throw an exception so I propose the first come first served approach we used for manifests. Therefore in you case we will ignore the -outxml/outfile option. But should we issue and error/warning? 1. Added test for existing aop.xml to OutXmlTest2. Modified NullIdeProperties to allow testProjectPath to be overriden by sourceRoots3. Issue warning message inAjBuildManager.writeResource() to say -outxml ignored You are right - there was both a META-INF/aop.xml file in the sources and an -outxml file option. The project was having this error in AJDT. Removing the -outxml option fixes the problem. Thanks and as you say this is a good condition to detect and warn about, with then not generating a file. Fix available 	2006-03-20 15:51:21	1142890000.0	resolved fixed	319a0d1	1149250000.0	ajde/testsrc/org/aspectj/ajde/NullIdeProperties.java ajde/testsrc/org/aspectj/ajde/OutxmlTest.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
120739	LTW Optimization: Disable World if it has No Aspects	This optimization disables weaving for a ClassLoader where there are no aspects defined. This is actually useful if you have aspect exclusions that exclude all the aspects defined in a parent class loader. It is also helpful in the trivial/rare case where there is an aop.xml definition with no aspect definitions. Created attachment 31686Disable weaving if no aspects are defined. check status for 1.5.1 why haven't we put this in? This is a good optimization. I have added a message, similar to that issued when no aop.xml is found, and a 1.5.2 testcase. In the long run it might be better to more aggressively parse the XML into a Configuration object (paving the way for a programmatic API) so that we don’t create then throw away the Weaver and World. 4 tests failed: testLTWDump/BeforeAndAfter/Proxy and testCompileTimeAspectsDeclaredToLTWWeaver because they don't have an aspect and hence no weaving took place or the new message caused problems. I amended the expected messages and added EmptyAspect.aj/EmptyAtAspect.java to the compile step and relevant aop.xml files. Fix available I agree that parsing into an options file would be better. This would also be a step towards reusing the parsing when aop.xml files are shared by multiple ClassLoaders (based on the same URL). That in turn would allow sharing initial weaver state (using a test to make sure that there isn't a different class definition between the different ClassLoaders, e.g., by nondelegation) 	2005-12-13 16:10:55	1134510000.0	resolved fixed	4513e92	1149180000.0	loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java tests/java5/ataspectj/ataspectj/ltwreweavable/EmptyAtAspect.java tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java
144717	org.aspectj.weaver.BCException: Do not call nameToSignature with something that looks like a signature (descriptor): '[Ljava.lang.String;'	"The exception below is produced when parsing a pointcut that uses an array type in args using the reflection world pointcut parser support.org.aspectj.weaver.BCException: Do not call nameToSignature with something that looks like a signature (descriptor): '[Ljava.lang.String;'	at org.aspectj.weaver.UnresolvedType.nameToSignature(UnresolvedType.java:741)	at org.aspectj.weaver.UnresolvedType.forName(UnresolvedType.java:311)	at org.aspectj.weaver.reflect.Java15ReflectionBasedReferenceTypeDelegate.getDeclaredPointcuts(Java15ReflectionBasedReferenceTypeDelegate.java:260)	at org.aspectj.weaver.ReferenceType.getDeclaredPointcuts(ReferenceType.java:526)	at org.aspectj.weaver.ResolvedType$7.get(ResolvedType.java:468)	at org.aspectj.weaver.Iterators$6.hasNext(Iterators.java:118)	at org.aspectj.weaver.Iterators$5.hasNext(Iterators.java:128)	at org.aspectj.weaver.ResolvedType.findPointcut(ResolvedType.java:479)	at org.aspectj.weaver.patterns.ReferencePointcut.resolveBindings(ReferencePointcut.java:151)	at org.aspectj.weaver.patterns.Pointcut.resolve(Pointcut.java:194)	at org.aspectj.weaver.tools.PointcutParser.resolvePointcutExpression(PointcutParser.java:330)	at org.aspectj.weaver.tools.PointcutParser.parsePointcutExpression(PointcutParser.java:308)	at org.aspectj.weaver.tools.Java15PointcutExpressionTest.testArrayTypeInArgs(Java15PointcutExpressionTest.java:304)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)	at java.lang.reflect.Method.invoke(Method.java:585)	at junit.framework.TestCase.runTest(TestCase.java:154)	at junit.framework.TestCase.runBare(TestCase.java:127)	at junit.framework.TestResult$1.protect(TestResult.java:106)	at junit.framework.TestResult.runProtected(TestResult.java:124)	at junit.framework.TestResult.run(TestResult.java:109)	at junit.framework.TestCase.run(TestCase.java:118)	at junit.framework.TestSuite.runTest(TestSuite.java:208)	at junit.framework.TestSuite.run(TestSuite.java:203)	at junit.framework.TestSuite.runTest(TestSuite.java:208)	at junit.framework.TestSuite.run(TestSuite.java:203)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) fixed in tree, waiting on build before closing. fix now available in latest builds from aspectj download page Changing OS from Mac OS to Mac OS X as per bug 185991 "	2006-05-31 12:43:19	1149090000.0	resolved fixed	97cd71a	1149100000.0	weaver/src/org/aspectj/weaver/tools/PointcutParser.java weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java weaver5/java5-testsrc/org/aspectj/weaver/tools/Java15PointcutExpressionTest.java
143930	create constructor ipe in same was as method ipes	"At the moment the way the constructor ipes are constructed is different to that of methods. For example, for a method which has signaturepublic void myMethod(String s, int i)the corresponding ipe is firstly constructed with name ""myMethod"" and then the arguments are added. Adding the arguments results in an ipe with name ""myMethod(java.lang.String,int)"".With a constructor that has signaturepublic MyClass(String s, int i)the corresponding ipe is constructed with name ""MyClass(String,int)"" and no arguments are associated with it. Up until now there hasn't been a use case to change this. However, due to enhancement bug 141730 (updating handles not to rely on source locations) it is necessary for the constructor ipes to have arguments associated with them. Also, if the ipes of methods and constructors had similar properties then the processing for creating the new handles can be the same. Created attachment 42704proposed fixThis zip file contains four patches:- pr143930-ajdoc-patch.txt: apply to the ajdoc project- pr143930-ajdt-core-patch.txt: apply to the org.aspectj.ajdt.core project- pr143930-tests-patch.txt: apply to the tests project- pr143930-weaver-patch.txt: apply to the weaver projectAlong with the fix for the current bug, this contains the modified fix to bug 143924 mentioned in that bug report along with the test also supplied in that bug report. patches committed. "	2006-05-26 07:12:00	1148640000.0	resolved fixed	26a8a86	1148980000.0	ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmElementFormatter.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java
142466	[ltw] Fail at runtime if abstract methods are not implemented in a hierarchy that finishes with an XML aspect	see pr125480 - copying the test for that will be a good basis for a test for this bug.  We don't check that when defining a concrete aspect there are no unimplemented abstract methods in the aspect we are concretizing. fix available. 	2006-05-18 07:32:08	1147950000.0	resolved fixed	69e24e9	1148370000.0	loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.java tests/bugs152/pr142466/AtAspectTestConcreteMethods.java tests/bugs152/pr142466/HelloWorld.java tests/bugs152/pr142466/case2/AtAspectTestConcreteMethods.java tests/bugs152/pr142466/case2/HelloWorld.java tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java
138223	Compiler crash on two binding @xxx pcds in one compound expression	<Pyinson Data Over Head> See test case in bugs152/pr138223 to reproduce. <abracadabra> this now works </abracadabra>testcase is beefed up to prove it. *** Bug 145048 has been marked as a duplicate of this bug. *** Changing OS from Mac OS to Mac OS X as per bug 185991 	2006-04-24 13:17:07	1145900000.0	resolved fixed	6b2d9ae	1147880000.0	tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java
141956	Null Pointer Exception when trying to skip Parent Mungers.	"<Pyinson Data Over Head> There are certainly situations where errors only occur on incremental compilation - we record state during the full build to optimize subsequent incremental builds.  I don't fully understand what is going wrong in this scenario though - from the description I might expect it to happen on a full build, so there is possibly something more serious lurking.  It needs the combination of a perclause of some kind and using @AJ syntax, is your aspect particularly complicated?To just help you progress I am tempted to put in your simple null check extension to that test if we can't work out a simplistic scenario in which this happens reliably.You could try running with the AJDT event trace open - it will tell us exactly what is getting recompiled/rewoven on an incremental build and that may give us a clue as to what is happening.  (You might have to press some magic switch to get the event trace to produce all its diagnostics info, either on the view window itself or in the AspectJ project/workbench properties). The aspect is fairly simple: @Aspectpublic class ExpirableToucher {	@Before(""within(com.residencycentral.app.Expirable+) && execution(public * *(..)) && !execution(* touch()) && target(target)"")	public void touchBeforeExecute(Expirable target) {		target.touch();	}}I will try my best to figure out the circumstances that reproduce this bug. <Pyinson Data Over Head> Ok I have debugged some more and I think I'm closer to the source of the bug.When I do a clean and compile, in BcelWeaver.prepareForWeave() it sets the typeMunger list on line 464:    typeMungerList = xcutSet.getTypeMungers();    lateTypeMungerList = xcutSet.getLateTypeMungers();    declareParentsList = xcutSet.getDeclareParents();when going from a clean compile xcutSet.getTypeMungers() returns a bunch of mungers but not the BcelPerClauseAspectAdder munger that is the source of the segfault later on. the BcelPerClauseApectAdder is returned by the second call to xcutSet.getLateTypeMungers(), but this is fine because this list is not checked in the code that caused the segfault.When doing the incremental compile,  the xcutSet.getTypeMungers() gets modified by org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.finishTypeMungers():// XXX by Andy: why do we mix up the mungers here? it means later we know about // two sets and the late ones are a subset of the complete set? (see pr114436)        baseTypeMungers.addAll(getWorld().getCrosscuttingMembersSet().getLateTypeMungers());I'm not sure why this is done or what it does as I don't really understand all the inner workings of AspectJ. But what happens is now those LateTypeMungers (which include the BcelPerClauseAspectAdder mungers that cause the problem) now get added to the list returned by xcutSet.getTypeMungers();.In fact, it seems this is not intended, because if I edit the code and recompile several times, it keeps appending those BcelPerClauseAspectAdder to the end of the list so after a while I have 5-6 mungers followed by 40+ BcelPerClauseAspectAdder mungers. I'd appreciate any further clarification of what this code does and how it could be fixed. I don't fully understand  what the BcelPerClauseAspectAdder does or what a LateTypeMunger is or why it is merged... etc... but I hope the debugging information I'm providing can get this solved soon. More good work Daniel ;)based on what you have said, I've created a testcase that shows us leaking the typemungers on incremental compiles.Late type mungers are 'special' ones that can only perform their job after the pointcuts have been matched and the advice applied.  (Normal type mungers are applied before the pointcuts are matched and advice is applied - here 'normal' means things like ITDs).The BcelPerClauseAspectAdder creates the methods aspectOf() and hasAspect() - for each kind of aspect these vary depending on the per clause in use.  Specifying no perclause means you get the default of 'persingleton'.  In the old days before annotation style development came along, the compiler generated aspectOf() and hasAspect().  Nowadays with annotation style it is possible the aspect is built using regular javac - which won't create these aspectof()/hasAspect() methods.  So the BcelPerClauseAdder was created which adds these methods at weave time for @AJ aspects.As you have discovered, I put a comment in the code against something another developer did:// XXX by Andy: why do we mix up the mungers here? it means later we know about // two sets and the late ones are a subset of the complete set? (see pr114436)       baseTypeMungers.addAll(getWorld().getCrosscuttingMembersSet().getLateTypeMungers());which I wanted to revisit at some point when I had time to investigate. Now based on my testcase and your observation about the collection constantly growing on compiles, I've removed that line of code.  All our tests continue to execute fine.  I have also put in the guard for a null munger that was described in the initial comment in this bug report.  So the code should be much more reliable now.the fixes will be in a dev build shortly, then in an AJDT build a little after that.thanks for the investigation work! fix available in latest AJ dev build. fixed. "	2006-05-16 05:12:06	1147770000.0	resolved fixed	5f6a6b1	1147870000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java tests/multiIncremental/PR141956/base/A.java tests/multiIncremental/PR141956/base/C.java tests/multiIncremental/PR141956/inc1/C.java tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java weaver/src/org/aspectj/weaver/ResolvedType.java
130722	poincut references in percflow instantiation model aspects can not be resolved	"Take these two aspects and this litte class:// source1package test1;import test.Test;public aspect PointcutProvider {	public pointcut test(): execution(* Test.*(..));}// source2package test;import test1.PointcutProvider;public aspect PointcutConsumer percflow(flow()) {        // compiler issues the following line with        // can not find pointcut test on test.PointcutConsumer	pointcut mytest(): PointcutProvider.test();        // this also does not work with the same error message        pointcut mytest(): test1.PointcutProvider.test();		pointcut flow(): mytest();}// source3package test;public class Test {	public void foo() {			}}Changing the consumer aspect to singleton instantiation model works. the problem is caused by attempting to concretize the per-clause pointcut too early (before the pointcut it references has been resolved). In fact we don't need to concretize the per-clause at all when completing type bindings (only when weaving), so I've defered the concretization until the weaving phase. Test now passes as expected.Fix committed in tree, waiting on build... Fix now available for download in developer builds "	2006-03-07 05:53:19	1141730000.0	resolved fixed	b166a7e	1147790000.0	tests/bugs152/pr130722/test/Test.java tests/src/org/aspectj/systemtest/ajc150/GenericITDsDesign.java tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java weaver/src/org/aspectj/weaver/CrosscuttingMembers.java weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java weaver/src/org/aspectj/weaver/ResolvedType.java weaver/testsrc/org/aspectj/weaver/bcel/NonstaticWeaveTestCase.java weaver/testsrc/org/aspectj/weaver/bcel/PointcutResidueTestCase.java weaver/testsrc/org/aspectj/weaver/bcel/WeaveOrderTestCase.java
141945	Compiler issues message concerning aop.xml even when not doing LTW	From the mailing list:=============I am executing the command as below, COMMAND: ajc -inpath woven_hello1.jar -aspectpath aspect2.jar -outjar woven_hello2.jar I am getting same old error,woven_hello1.jar [error] aspect 'aspect1' woven into 'Hello' must be declared in an aop.xml file.(no source information available)I have placed both aspect1.class and aspect2.class in CLASSPATH system variable.==============We shouldn't be putting out messages about aop.xml when we are not doing LTW - this message points the user to a solution that will not work in this case! fixed in tree. fix now available in download builds Changing OS from Mac OS to Mac OS X as per bug 185991 	2006-05-16 04:10:25	1147770000.0	resolved fixed	fc7db25	1147780000.0	tests/java5/ataspectj/ataspectj/ltwreweavable/MainReweavableLogging.java
135068	VerifyError with LTW and @AJ style aspects	"I get ""VerifyError: Incompatible object argument for function call"" error when using LTW with @Aspect stype aspects. Interestingly enough, LTW works as expected with equivalent .aj style aspect. Compile time weaving works with both aspect styles. Tested on Linux with AspectJ 1.5.0, 1.5.1 and DEVELOPMENT-20060404163823 and SUN 1.5.0_06 and IBM 1.5.0SR1 JVMs. I will attach example project shortly. Created attachment 37768sample project that demonstrates the problemMake sure your JAVA_HOME points to Java5 installation and run ""ant -f test:ltw"" from ajtestjava directory to reproduce the problem. Raising priority of verify error, though I haven't validated the test case. I've recreated the problem using the supplied testcase.  Currently debugging through it.On running the class C, which is woven with the around advice, I get:Exception in thread ""main"" java.lang.VerifyError: (class: t/C, method: test signature: ()V) Incompatible object argument for function callLTW isn't required, you can recreate this just compiling source code:ajc -1.5 -XnoInline -d output t/C.java t/Ajava.javaXnoInline - which causes closure generation, is what leads to the problem. the problem here is that the advice in the @AJ case is declared static.  We let that through and then generate code that fails verification at runtime.  If you tried to make code style advice static you would get:""illegal modifier on advice, only strictfp is allowed""I've just committed changes to also police this for @AJ aspects - and added a few testcases.If you make your around advice non-static, everything works fine. fix available in latest dev build to police this. "	2006-04-05 12:15:45	1144250000.0	resolved fixed	9ffc63b	1147770000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java tests/bugs152/pr135068/A.java tests/bugs152/pr135068/Ajava.java tests/bugs152/pr135068/Ajava2.java tests/bugs152/pr135068/C.java tests/bugs152/pr135068/C2.java tests/bugs152/pr135068/t/Ajava.java tests/bugs152/pr135068/t/Ajava2.java tests/bugs152/pr135068/t/C.java tests/bugs152/pr135068/t/C2.java tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java
133117	Lots of warnings with noGuardForLazyTjp	"When the noGuardForLazyTjp compiler option is set to warning or error and a piece of advice causes this warning to show up, you get one warning for every join point matched by the advice.  I think just one would probably be enough... Created attachment 36876Test project I've recreated this within the MultiprojectIncrementalTests (although this is nothing to do with incremental building you have more control to test the number of warning messages). The current situation, for the provided test project, is that you get three xlint messages:[warning at before() : publicMethods() {^^^^^^^^^^^^^^^^^^^^^C:\temp\ajcSandbox\ajcTest16013.tmp\PR133117\Tracing.aj:5:0::0 can not build thisJoinPoint lazily for this advice since it has no suitable guard.  The advice applies at method-execution(int MainClass.hashCode()) [Xlint:noGuardForLazyTjp]	see also: C:\temp\ajcSandbox\ajcTest16013.tmp\PR133117\Tracing.aj:22::0, warning at before() : publicMethods() {^^^^^^^^^^^^^^^^^^^^^C:\temp\ajcSandbox\ajcTest16013.tmp\PR133117\Tracing.aj:5:0::0 can not build thisJoinPoint lazily for this advice since it has no suitable guard.  The advice applies at method-execution(java.lang.String MainClass.toString()) [Xlint:noGuardForLazyTjp]	see also: C:\temp\ajcSandbox\ajcTest16013.tmp\PR133117\Tracing.aj:17::0, warning at before() : publicMethods() {^^^^^^^^^^^^^^^^^^^^^C:\temp\ajcSandbox\ajcTest16013.tmp\PR133117\Tracing.aj:5:0::0 can not build thisJoinPoint lazily for this advice since it has no suitable guard.  The advice applies at method-execution(void MainClass.main(java.lang.String[])) [Xlint:noGuardForLazyTjp]	see also: C:\temp\ajcSandbox\ajcTest16013.tmp\PR133117\Tracing.aj:13::0]Each one is associated with the piece of advice (so warning icon in AJDT is marked against the advice and the same goes for the problems view), however, each warning is different. They each specify the joinpoint which is affected by the advice.The question is is this reasonable behaviour? It does seem a little messy to have multiple warnings against the same piece of advice all pretty much saying the same thing. This clutter could obscure other messages within the problems view when run within AJDT.  A possible fix is to remove the information about where the advice is matching from the xlint warning and then within BcelAdvice remember whether the warning has already been applied to the advice and only add it if it hasn't been done before. This requires changes to the Xlint tests for those which look for messages including the joinpoint information. Created attachment 37891testcase patchApply this patch to the tests project.This patch contains both a failing testcase for this bug as well as the changes to the xlint tests due to the change in xlint message. Created attachment 37893patch containing possible fixApply this patch to the weaver project. patches committed. fixes available. "	2006-03-24 04:47:58	1143190000.0	resolved fixed	3fa4d24	1147450000.0	tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java weaver/src/org/aspectj/weaver/Lint.java weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java
129704	BCException	"<Pyinson Data Over Head> Are you able to supply any more information? what were you doing at the time? are you using Java5? are you using annotations? are you using annotation binding pointcuts? Did it occur on a full build or an incremental compile? (I suspect the 1.2.1 level of AJ that you raised the bug against isnt quite right... I assume you are on AspectJ 5)The line number has 'moved' since the version in which this stack trace is reported (but I know we haven't made recent AJs available in AJDT yet) - but although it has moved it could still be a bug as I haven't knowingly fixed anything in this area. Yeah sure. Sorry The bug export was so good I couldn't touch it. :)Anyways, I think it is due the fact that that class being tried to be vowen has java 1.5 templates and template was refered in a matched method... The bug occured o n every build triger.A snipped version of the code is here:public class DomainContentProvider<T extends GenericDomainObject> implements		IRefreshableStructuredContentProvider<T> {<...>	@DAOOperation(clazz = SummaryDAO.class, remove = DAORemoveCondition.ALWAYS)	private void getData(SummaryDAO dao, IProgressMonitor monitor,			boolean includeDeleted) {		summaries = (List<T>) dao.getSummaries(clazz, includeDeleted);		if (includeDeleted)			state = State.FULL_INITIALIZED;		else			state = State.LIGHT_INITIALIZED;	}<...>} Problem recreated with this small test program:=======8<========================import java.lang.annotation.*;interface GDO {}@Retention(RetentionPolicy.RUNTIME) @interface Marker { }class DCP<T extends GDO> { @Marker void getData(){}}aspect X {  before(Marker a): execution(* getData(..)) && @annotation(a) { System.err.println(a);  }}public class A {	public static void main(String[] args) {		new DCP().getData();	}}=======8<========================(thanks for giving me your code snippet to work from)As suspected by the raiser, the combination of generics and annotations is the problem.  We start working with the raw type when we should be working with the generic type when discovering the annotations.  The fix is when working with a raw or parameterized type, use the generic type to locate annotations.fix committed. "	2006-02-27 20:32:19	1141090000.0	resolved fixed	3ca976f	1147430000.0	tests/bugs152/pr129704/A.java tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java weaver/src/org/aspectj/weaver/bcel/BcelShadow.java
138384	java.lang.ClassFormatError: Invalid method Code length  83071 in class file org/eclipse/jdt/internal/compiler/impl/Constant	"The weaver generates invalid bytecode when weaving a large method. Instead it should issue an error (or even split the method). The problem has been reported before but for a different reason: bug 113796. If this change is made to org.aspectj.apache.bcel.generic.InstructionList in BCEL:   /**   * When everything is finished, use this method to convert the instruction   * list into an array of bytes.   *   * @return the byte code ready to be dumped   */  public byte[] getByteCode() {    // Update position indices of instructions    setPositions();    ByteArrayOutputStream b   = new ByteArrayOutputStream();    DataOutputStream      out = new DataOutputStream(b);    try {      for(InstructionHandle ih=start; ih != null; ih = ih.next) {	Instruction i = ih.instruction;	i.dump(out); // Traverse list      }    } catch(IOException e) {       System.err.println(e);      return null;    }    byte[] byteCode = b.toByteArray();    if (byteCode.length > Constants.MAX_CODE_SIZE) throw new ClassGenException(""Code size too big: "" + byteCode.length);    return byteCode;  }then the following helpful error message is issued:error at org\eclipse\jdt\internal\compiler\impl\Constant.java::0 problem generating method org.eclipse.jdt.internal.compiler.impl.Constant.<clinit> : Code size too big: 83071 Just need to double check that is the right place to throw the exception before we stick this in... fixes checked in.  My only concern is that some people may today be weaving code and producing methods that are too large but never executing them.  With this change we will notice at compile time and fail up front - instead of producing code that won't execute.  For the users that never run this broken code ... hmmm ... they will start seeing a new error... Users will only be getting away with this if they are weaving but never _loading_ a class. The ClassFormatError occurs when the class is defined. The classic workaround, which I essentially used by defining the vanilla class after catching the error, is to exclude failing classes with a pointcut. indeed ... we just have to watch out for anyone on the list now starting to complain about this new message.  fix is available in latest build. Hi there, I'm getting a similar error when I'm doing LTW on a jsp page:problem generating method org.apache.jsp.main_jsp._jspService : Code size too big: 70282When I go to the web app, it gives me a: javax.servlet.ServletException: org/apache/jsp/main_jsp (Code attribute is absent in method that is not abstract or native)	org.apache.jasper.servlet.JspServlet.service(JspServlet.java:244)	javax.servlet.http.HttpServlet.service(HttpServlet.java:802)......When I try to decompile it with jad, I get: Couldn't fully decompile method _jspServiceThe jsp is fine without weaving. Is this a separate bug for LTW? Jennie, your comments should be on bug 175814.  The problem you are seeing is exactly the same as described on that other bug. Oops.. I've copied the comment to the correct bug. Thanks. "	2006-04-25 10:58:41	1145980000.0	resolved fixed	5d2b5b8	1147420000.0	bcel-builder/src/org/aspectj/apache/bcel/generic/InstructionList.java tests/bugs152/pr138384/BigMethod.java tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java
140357	NPE or StackOverflow when resolving reference pointcut in ReflectionWorld	"Given a type such as :private static class NamedPointcutResolution {		  @Pointcut(""execution(* *(..))"")  public void a() {}				    @Pointcut(""this(org.aspectj.weaver.tools.Java15PointcutExpressionTest.A)"")  public void b() {}		  @Pointcut(""a() && b()"")  public void c() {}}The reflection based delegate is unable to resolve the pointcut c() failingwith either (1) an NPE, or (2) a StackOverflow, depending on the order of thepointcut definitions in the type.The problem occurs because in resolving ""c()"" we get all the pointcuts in thetype, which gets a(), b(), and c(), and tries to resolve them... To solve this I had to split the getDeclaredPointcuts operation in Java15ReflectionBasedDelegate into 3 distinct phases:first populate the pointcuts array with DeferredResolvedPointcutDefinitions :- these know there name and parameters, but not yet the Pointcut object they contain.secondly resolve all the pointcutsthirdly concretize all the pointcutsDriving through these phases in this order (as oppose to trying to resolve and concretize the first pointcut before the others have even been defined) prevents the errors described. .. this is a high priority bug for the Spring community fix committed in tree. fix available Changing OS from Mac OS to Mac OS X as per bug 185991 "	2006-05-05 09:43:03	1146840000.0	resolved fixed	b954b26	1146840000.0	weaver/src/org/aspectj/weaver/tools/PointcutParser.java weaver5/java5-src/org/aspectj/weaver/reflect/DeferredResolvedPointcutDefinition.java weaver5/java5-src/org/aspectj/weaver/reflect/InternalUseOnlyPointcutParser.java weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java weaver5/java5-testsrc/org/aspectj/weaver/tools/Java15PointcutExpressionTest.java
134371	ClassCastException in AjState.recordClassFile()	"I got this exception while working on a static inner aspect. A full rebuild avoided the problem. java.lang.ClassCastException: org.aspectj.weaver.MissingResolvedTypeWithKnownSignature	at org.aspectj.ajdt.internal.core.builder.AjState.recordClassFile(AjState.java:774)	at org.aspectj.ajdt.internal.core.builder.AjState.noteResult(AjState.java:627)	at org.aspectj.ajdt.internal.core.builder.AjBuildManager$3.acceptResult(AjBuildManager.java:867)	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterProcessing(AjCompilerAdapter.java:206)	at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$4$6b855184(CompilerAdapter.aj:90)	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:528)	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:845)	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:266)	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:168)	at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)	at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191) I got a similar exception (ClassCastException thrown in recordClassFile) when using a perthis(..) aspect.  A full rebuild fixed it.However this aspect, even after it builds, is causing me problems with Spring.  Basically, I'm using Spring AOP to decorate the object with transaction semantics, and also using a plain-old compile-time aspect (this one), and I think they are interacting poorly.  I don't know if perthis() is part of the problem.  I'll probably open up another bug if it comes up.(In reply to comment #0)> I got this exception while working on a static inner aspect. A full rebuild> avoided the problem. > > java.lang.ClassCastException:> org.aspectj.weaver.MissingResolvedTypeWithKnownSignature>         at> org.aspectj.ajdt.internal.core.builder.AjState.recordClassFile(AjState.java:774)>         at> org.aspectj.ajdt.internal.core.builder.AjState.noteResult(AjState.java:627)>         at> org.aspectj.ajdt.internal.core.builder.AjBuildManager$3.acceptResult(AjBuildManager.java:867)>         at> org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterProcessing(AjCompilerAdapter.java:206)>         at> org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$4$6b855184(CompilerAdapter.aj:90)>         at> org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:528)>         at> org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)>         at> org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:845)>         at> org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:266)>         at> org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:168)>         at> org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)>         at> org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)>  Created attachment 39519patch containing failing testcaseWhilst trying to recreate another bug I stumbled into this one. The attached patch should be applied to the tests project and contains a failing testcase. nice little testcase ;)  initially looks like just an unnecessary cast... interesting that the 'missing type' is actually one generated during weaving:A$ajcMightHaveAspectin Helens case (caused by the PerThis).   Created attachment 39642patch containing proposed fixApply the attached patch to the org.aspectj.ajdt.core project.From discussions with Andy......the fix involves removing the unnecessary cast along with putting the A$ajcMightHaveAspect into the tMap within the world. It was placed in the typeXtoBinding map in the EclipseFactory but wasn't recorded in the world (Note that the first time through on the full build the A$ajcMightHaveAspect isn't generated because of the ""abstract"" keyword. When ""abstract"" is removed we generate this class.) This fix means that in all the tests the check ""!newResolvedType.isMissing()"" (AjState.java:784) returns true. test and fix committed. "	2006-04-01 12:05:56	1143910000.0	resolved fixed	299c3a4	1146820000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java
135780	Java 1.2 dependency in aspectjrt.jar bug with fix	"The thisJoinPoint.printString() fails on a 1.1 VM because it relies on a java.lang.ref.SoftReference. I need this to work because we're using AspectJ on an embedded device that is still using a pre-1.2 VM.The problem lies in org.aspectj.runtime.reflect.SignatureImpl. The attached patch fixes it and passes all the tests. I tested the failing program manually on a 1.1 VM, but automating the test would require adding a 1.1 VM to the regression test infrastructure.Sample:public aspect Java11Test {    before() : execution(* *(..)) {        System.out.println(thisJoinPoint.toString());    }    public static void main(String args[]) {}}>ajc -target 1.1 Java11Test.aj>\java\jre1.1.8_010\bin\jre -cp .;%CLASSPATH% Java11TestException in thread ""main"" java.lang.NoClassDefFoundError: java/lang/ref/SoftReference        at org.aspectj.runtime.reflect.JoinPointImpl$StaticPartImpl.toString(JoinPointImpl.java:43)        at org.aspectj.runtime.reflect.JoinPointImpl$StaticPartImpl.toString(JoinPointImpl.java:48)        at Java11Test.ajc$before$Java11Test$1$3444dde4(Java11Test.aj:3)        at Java11Test.main(Java11Test.aj) Created attachment 38106Patch to the runtime module (in SignatureImpl) to fix this bug.The patch adds a cache private static inner interface and class that encapsulates the dependency on SoftReference. For a 1.1 VM, failure to find the SoftReference class results in disabling caching but the code still functions. patches integrated.  relevant aspectjrt.jars upgraded in the build system. fixed "	2006-04-09 22:27:37	1144640000.0	resolved fixed	cb5dfe7	1146670000.0	runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java
138798	BCException on invalid annotation match	<Pyinson Data Over Head> Created attachment 39623testFortunately, fixed in HEAD. This is fixed in CVS HEAD. It's worth including the test though. test added. dup of 138158 	2006-04-26 20:53:07	1146100000.0	resolved fixed	c5c18aa	1146120000.0	tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java
138286	perthis() causes ClassCastException	<Pyinson Data Over Head> Created attachment 39367Abstract aspect Created attachment 39368Concrete aspect Created attachment 39369Annotation Created attachment 39541patch containing failing testcaseFrom the supplied testcase I've narrowed it down to a smaller version which reproduces the problem. Apply the attached patch to the tests project. I've fixed this - based on the fix I've slightly reworked the testcase to confirm it's behaving as expected when the code runs.  The problem is that the perthis() is entirely depending on annotation existence - which (somewhere in the depths) causes us problems when we try and treat an AnnotationTypePattern as a TypePattern, when they are different things.  We have to create an 'AnyWithAnnotationTypePattern()' whose contents are the AnnotationTypePattern - then we can treat this new object as a standard TypePattern. clear ;) fix available, will be in AJDT shortly. 	2006-04-24 18:29:34	1145920000.0	resolved fixed	c667bcb	1146070000.0	tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java weaver/src/org/aspectj/weaver/patterns/PerThisOrTargetPointcutVisitor.java
138540	Patch to add support for -Xset: options	"I needed to add X=""set:activateLightweightDelegates=false” to my ant build configuration, to troubleshoot the out of memory permgen condition. However, the ant task support doesn't currently support adding the new -Xset style options Andy added.Here is a small patch to pass any -Xset: options through, that worked for me. Created attachment 39494add -Xset option support for AspectJ ant taskI didn't see any place to add a test for this kind of thing. patch committed. thanks. fix available. "	2006-04-25 20:18:31	1146010000.0	resolved fixed	99882cb	1146040000.0	taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java
136585	NullPointerException in PerObjectInterfaceTypeMunger.java:33	AspectJ 1.5.1a + AJDT 1.4.0-dev on Eclipse 3.2M6Using the Sapcewar example, open Game.java and add:   public void foo() {}save and an incremental build will fail with:java.lang.NullPointerExceptionat org.aspectj.weaver.PerObjectInterfaceTypeMunger.equals(PerObjectInterfaceTypeMunger.java:33)at org.aspectj.weaver.bcel.BcelTypeMunger.equals(BcelTypeMunger.java:1672)at java.util.AbstractList.equals(AbstractList.java:610)at org.aspectj.weaver.CrosscuttingMembers.replaceWith(CrosscuttingMembers.java:321)at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect(CrosscuttingMembersSet.java:73)at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.addCrosscuttingStructures(AjLookupEnvironment.java:397)at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.collectAllITDsAndDeclares(AjLookupEnvironment.java:333)at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:173)at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301)at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:862)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:269)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:168)at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)NullPointerException thrown: null Just added test and committed fix for this. latest builds include this fix.Date of build: 04/19/2006 17:36:26Time to build: 70 minutes 14 secondsLast changed: 04/19/2006 14:36:44Last log entry: test and fix for 136585: NullPointerException in PerObjectInterfaceTypeMunger.java:33 *** Bug 144086 has been marked as a duplicate of this bug. *** 	2006-04-13 05:38:44	1144920000.0	resolved fixed	1535ee7	1145450000.0	tests/multiIncremental/PR136585/base/Hello.java tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java weaver/src/org/aspectj/weaver/PerObjectInterfaceTypeMunger.java
136665	Bug: ajc fails on missing classpath entries with fix	<Pyinson Data Over Head> Created attachment 38517Changes classpath manager to just remove missing classpath entries instead of failing when they are discoveredThis patch makes the failing code I tested work in practice. Otherwise, it can be horrid to manage classpaths in a build, where you have to have each module explicitly include the jars that have been already built. reasonable change - committed.  We have other bugs where crazy people run with missing jars on the classpath .... build available. 	2006-04-13 11:34:02	1144940000.0	resolved fixed	d1a252e	1145360000.0	weaver/src/org/aspectj/weaver/bcel/ClassPathManager.java
135001	NPE at at org.aspectj.weaver.bcel.BcelShadow.weaveAroundInline	java.lang.NullPointerExceptionat org.aspectj.weaver.bcel.BcelShadow.weaveAroundInline(BcelShadow.java:2109)at org.aspectj.weaver.bcel.BcelAdvice.implementOn(BcelAdvice.java:232)at org.aspectj.weaver.Shadow.implementMungers(Shadow.java:639)at org.aspectj.weaver.Shadow.implement(Shadow.java:456)at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:2236)at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:491)at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:109)at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1560)at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1511)at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1291)at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1113)at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:311)at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:183)at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:862)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:242)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:161)at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191) Passing over to the compiler.Please can you add your exact AJDT and AspectJ version numbers. org.aspectj.weaver_1.5.0.20060405045058org.eclipse.aspectj_1.3.1.20060405045058 *** Bug 135213 has been marked as a duplicate of this bug. *** Antti, can you possibly try something for me on your scenario that might help me narrow things down?Can you remove the -XnoInline workaround I asked you to use and instead try '-Xset:activateLightweightDelegates=false' - does it still fail?thanks. Also Antti, can you tell me if your aspects are compiled from source in this build or are they coming from a jar file in binary form? whilst waiting for feedback from Antti - I've put in a guard so the NPE can't happen - a message will be reported that we cant implement inlining and we'll fall back on closure - THIS WILL AFFECT PERFORMANCE OF THE GENERATED CODE - and so hopefully we can resolve what is leading to the NPE. (In reply to comment #4)> Antti, can you possibly try something for me on your scenario that might help> me narrow things down?> > Can you remove the -XnoInline workaround I asked you to use and instead try> '-Xset:activateLightweightDelegates=false' - does it still fail?  Yes, this seems to fix the problem:D:\work\napa\jnapa\core>ajc -nowarn -Xlint:ignore -Xset:activateLightweightDelegates=false -source 1.5 -target 1.5 -d build\classes -cp ..\commons\utils\build\napa_utils.jar;lib\aspectjrt.jar;lib\dom4j-1.5.2.jar;lib\groovy-all-1.0-jsr-05.jar;..\commons\test_commons\lib\junit.jar -sourceroots src;gen_src;test_srcD:\work\napa\jnapa\core>  I added the -nowarn and -Xlint:ignore, but also tried w/out them, so they do not seem to affect this bug.  As for your other question, some aspects are in source form and some come from a jar, though not via inpath but via aspects in this project extending abstract aspects contained in one of the jars. thanks for responding quickly! I think that description tells me what it is - i'll write a test program to verify. yey! recreated thanks to Antti I have recreated this and fixed it.  The problem is due to the fast delegates we support that are based on the ASM bytecode toolkit.  Fast delegates don't have any instructions loaded for methods within them - this causes a problem if the weaver attempts to inline around advice.  Normally we know which types it is safe to create fast delegates for but this was a case we hadn't been testing, you need to have:- an abstract super aspect containing *inlinable around advice*- a concrete sub aspectThe abstract super aspect needs to be on the classpath, not on the aspectpath or in source form.In this situation when the super aspect is resolved we see it on the classpath and think we can create a fast delegate - but we can't because we may want to extract the instructions from the around advice and inline them at some matched join point.The fix is a little ugly right now but this is quite serious and I wanted to get something minimal through so AJDT can ship its 1.3.1 version.  The fix is to fallback to BCEL if we create a fast delegate and discover it is an aspect, ideally we could know if we were loading the supertype for an aspect and ensure it was loaded via BCEL but that's a little messier as when the resolution occurs we don't know the context in which it is occurring.couple of tests are failing now due to expecting ASM types for aspects sometimes, I'm working on fixing those then i'll commit. fix available in latest dev build. 	2006-04-05 07:10:58	1144240000.0	resolved fixed	1a6f695	1144320000.0	tests/bugs152/pr135001/AbstractAspect.java tests/bugs152/pr135001/ConcreteAspect.java tests/bugs152/pr135001/Foo.java tests/src/org/aspectj/systemtest/AllTests15.java tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java tests/src/org/aspectj/systemtest/ajc152/AllTestsAspectJ152.java weaver/src/org/aspectj/weaver/bcel/BcelShadow.java weaver/src/org/aspectj/weaver/bcel/BcelWorld.java weaver/testsrc/org/aspectj/weaver/bcel/AsmDelegateTests.java
134541	adviceDidNotMatch's line number doesn't keep up with line number of advice	When advice doesn't match in a 1.5.0 enabled project, there is an adviceDidNotMatch warning against the line number of the advice. If you insert a line before this advice and save then the warning stays associated with the original line and not the new one. Full building puts the warning against the new line. This is a regression and didn't happen in AJ 1.5.0. Created attachment 37544failing testcaseApply this patch to the tests project. I think part of the fix for bug 129163 caused this bug. Within CrosscuttingMembers.replaceWith(..) we only calculate the changes to the shadowmungers and typemungers if we careAboutShadowMungers. If we change to always  calculate the changes to the shadowmungers and typemungers then this bug no longer occurs. The problem is the equals method in Advice. At the moment its only using kind, pointcut and signature to see if two pieces of advice are the same. In the case of this bug they are the same, however, they have different sourceLocations. Because we're thinking they're equal we're not updating the list of shadowMungers and so the original one is used in the calculation of the xlint warning (which gives the original line number). The reason part of the fix for bug 129163 causes this problem is that if we always check shadowmunger equality the first time we compare we compare something with nothing which is a change and the second time we check nothing against something. This forces the update. This is a regression because for 1.5.0 we always thought there was a change so we always updated (due to various implementations of equals). The fix is to add implementation of the equals and hashcode methods within Advice and EclipseSourceLocation. Within Advice I've added a check for the equality of the SourceLocation to the equals method and in EclipseSourceLocation I've said that two are equal if they have the same start position, same end position and if their sourceFiles are equal. Created attachment 37720patch implementing equals and hashcode in EclipseSourceLocationApply this patch to the org.aspectj.ajdt.core project. Created attachment 37721patch improving equals and hashcode methods in AdviceApply this patch to the weaver project. Created attachment 37722testcase patch synchronized with the latest version in HEADApply this patch to the tests project. Created attachment 37727testcase patch which tests that adding whitespace doesn't force full buildApply this patch to the tests project. Created attachment 37728patch which doesn't force full build if there's a whitespace changeApply this patch to the weaver project. An explanation for the previous two patches (comment #8 and comment #9)...By changing the equals methods as described in comment #4 this does have the knock on effect of thinking there's been a change if the sourcelocation changes. Which means that if there's a whitespace change then we force a full build...not really something we want to be doing......An alternative solution is to go ahead and work out whether there's been a change as we have been doing previously, however, to copy over the new list of shadowmungers regardless of whether we think there's been a change (this is all in CrosscuttingMembers.replaceWith(..)). That way we pick up any changes in sourcelocation without forcing a full build. This does require us to reset the list of shadowmungers in CrosscuttingMembersSet if we care about the shadowmungers otherwise we wont pick up the new ones.  The fix for this has been checked in and is available in both the latest AJ and AJDT dev builds. Therefore, closing this as fixed. 	2006-04-03 12:03:09	1144080000.0	resolved fixed	94d8b82	1144320000.0	tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java weaver/src/org/aspectj/weaver/CrosscuttingMembers.java weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java
130837	Exception while trying to edit Annotation based Aspect Class  (normal Java class)	java.lang.NullPointerExceptionat org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVisitor.buildFormalAdviceBindingsFrom(ValidateAtAspectJAnnotationsVisitor.java:417)at org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVisitor.resolveAndSetPointcut(ValidateAtAspectJAnnotationsVisitor.java:364)at org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVisitor.validateAdvice(ValidateAtAspectJAnnotationsVisitor.java:336)at org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVisitor.visit(ValidateAtAspectJAnnotationsVisitor.java:186)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:185)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1195)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:339)at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.beforeAnalysing(AjCompilerAdapter.java:154)at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$before$org_aspectj_ajdt_internal_compiler_CompilerAdapter$7$db78446d(CompilerAdapter.aj:101)at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:517)at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:824)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:234)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:189)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:164)at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)NullPointerException thrown: null Looks like it is this line:TypeBinding argTypeBinding = mDecl.binding.parameters[i];and the binding is null. fix for NPE committed. fix available in latest AJ. 	2006-03-07 19:52:08	1141780000.0	resolved fixed	41f1f3a	1143530000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java
132087	NPE from unbound variable in advice	I get this error from having an unbound reference to a variable in an aspect. See attached AJDT project for an example.java.lang.NullPointerExceptionat org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.visit(AsmHierarchyBuilder.java:412)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:185)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1250)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.traverse(QualifiedAllocationExpression.java:392)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.traverse(LocalDeclaration.java:242)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:212)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1195)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:339)at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.internalBuild(AsmHierarchyBuilder.java:143)at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.buildStructureForCompilationUnit(AsmHierarchyBuilder.java:82)at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.finishedCompilationUnit(EclipseFactory.java:927)at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterProcessing(AjCompilerAdapter.java:201)at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$4$6b855184(CompilerAdapter.aj:90)at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:528)at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:843)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:243)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:163)at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)NullPointerException thrown: null Created attachment 36384sample project with the NPE Looks like an AspectJ bug. project is too complex for me to use - lots of dependencies. but I've tracked the line with the NPE in and put in a reasonable change so it can no longer happen. so i believe this is fixed. I got almost the same stack trace with a project based on Ramnivas Laddad's Authorization Project (AspectJ project) from chapter 10 of his book:java.lang.NullPointerExceptionat org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.visit(AsmHierarchyBuilder.java:402)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:185)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1250)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.traverse(QualifiedAllocationExpression.java:392)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.traverse(LocalDeclaration.java:242)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.Block.traverse(Block.java:127)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TryStatement.traverse(TryStatement.java:553)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:212)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1195)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:339)at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.internalBuild(AsmHierarchyBuilder.java:143)at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.buildStructureForCompilationUnit(AsmHierarchyBuilder.java:85)at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.finishedCompilationUnit(EclipseFactory.java:927)at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterProcessing(AjCompilerAdapter.java:201)at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$4$6b855184(CompilerAdapter.aj:90)at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:528)at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:845)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:241)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:161)at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)NullPointerException thrown: nullAJDTVersion: 1.4.0Build id: 20060324064654AspectJ version: 1.5.1.20060320075953Eclipse: Version 3.2.0 Build id: I20060217-1115-Barry (In reply to comment #4)I'd like to add that this was also due to an unimported class in an about advice.-Barry> I got almost the same stack trace with a project based on Ramnivas Laddad's> Authorization Project (AspectJ project) from chapter 10 of his book:> >[***SNIP***]> AJDT> Version: 1.4.0> Build id: 20060324064654> AspectJ version: 1.5.1.20060320075953> > > Eclipse: Version 3.2.0 Build id: I20060217-1115> -Barry>  fix for this should be in 1.5.1 and its related AJDT (due in a day or so) npe can't happen any more (I bravely claim) - please reopen if you any of you see something similar on the most up to date AJ/AJDT. 	2006-03-15 23:56:13	1142480000.0	resolved fixed	fa2ed1b	1143500000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java
132160	NPE in SingleTypeReference	I was C&P'ing the guts of another aspect into a new file (from another project that I'm porting over).  There are a number of errors in the aspect (as most of the references point to the other project).  I just changed an object from one type (in the other project) to a type in the project that the file is in.Eclipse SDKVersion: 3.1.2Build id: M20060118-1600Version: 1.3.0Build id: 20051220093604AspectJ version: 1.5.0----------------------------------------------------------------java.lang.NullPointerExceptionat org.aspectj.org.eclipse.jdt.internal.compiler.ast.SingleTypeReference.getTypeBinding(SingleTypeReference.java:39)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeReference.getTypeBindingPublic(TypeReference.java:98)at org.aspectj.ajdt.internal.core.builder.AsmElementFormatter.genLabelAndKind(AsmElementFormatter.java:230)at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.visit(AsmHierarchyBuilder.java:399)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:185)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1250)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.traverse(QualifiedAllocationExpression.java:392)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.traverse(LocalDeclaration.java:242)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:212)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1195)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:339)at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.internalBuild(AsmHierarchyBuilder.java:142)at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.buildStructureForCompilationUnit(AsmHierarchyBuilder.java:82)at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.finishedCompilationUnit(EclipseFactory.java:926)at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterProcessing(AjCompilerAdapter.java:195)at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$4$6b855184(CompilerAdapter.aj:89)at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:528)at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:230)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:185)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:163)at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)NullPointerException thrown: null Passing over to compiler i'll put in a test for the null method declaration in genLabelAndKind() null check is committed. will be in next build. fix available in latest AJ - will be in AJDT shortly. 	2006-03-16 09:52:40	1142520000.0	resolved fixed	91473b3	1143490000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmElementFormatter.java
133307	declare parents implementing generic interface referencing same type	I have the following construct:public interface TestIF<T extends TestIF> {}public class TestClass {}public aspect TestAspect {    declare parents: TestClass implements TestIF<TestClass>; }The later aspect does not compile, although public class TestClass implements TestIF<TestClass> {}is a valid class. As I expected - it's a problem with not allowing for this 'recursive' case.  The problem is that we check bounds during the completion of type bindings, when we should in fact complete the type bindings and then verify the system is coherent... fix checked in. fix available in AJ:BUILD COMPLETE -  build.732Date of build: 03/27/2006 15:13:01Time to build: 87 minutes 56 secondsLast changed: 03/27/2006 14:42:37 	2006-03-26 21:05:35	1143430000.0	resolved fixed	c9a60e5	1143470000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java weaver/src/org/aspectj/weaver/patterns/IVerificationRequired.java weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java
132926	Compiler crashes processing annotations	"Just upgraded to latest AJDT (Version: 1.3.1, Build id: 20060322082516AspectJ version: 1.5.1.20060320075953)and the compiler crashed while rebulding the project (which used to work fine using using the March 16th version). Retrying with 'clean' build produced thesame crash.java.lang.NullPointerExceptionat org.aspectj.weaver.AnnotationX.ensureAtTargetInitialized(AnnotationX.java:158)at org.aspectj.weaver.AnnotationX.specifiesTarget(AnnotationX.java:98)at org.aspectj.weaver.bcel.BcelWeaver.verifyTargetIsOK(BcelWeaver.java:1450)at org.aspectj.weaver.bcel.BcelWeaver.applyDeclareAtType(BcelWeaver.java:1417)at org.aspectj.weaver.bcel.BcelWeaver.weaveParentTypeMungers(BcelWeaver.java:1366)at org.aspectj.weaver.bcel.BcelWeaver.weaveParentsFor(BcelWeaver.java:1223)at org.aspectj.weaver.bcel.BcelWeaver.weaveParentsFor(BcelWeaver.java:1211)at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1058)at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:311)at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:183)at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:845)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:241)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:161)at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)NullPointerException thrown: null I wonder if this is related to #128655. There is one major difference, though. #128655 crahsed only during incremental compilation, whereas this one crahses on full build. this is no doubt because of the ASM support I added recently which has only just made it into an AJDT build.  Can you try putting this in the 'non standard options' field for the offending project?-Xset:activateLightweightDelegates=falsedoes it help it get past the NPE? after looking a little further at it - I'm even more convinced its the ASM code since now annotations can be of two types depending on whether we loaded an ASM delegate for a type or a BCEL delegate for a type.  I missed a path in the annotation processing code that should have done different things based on the kind of delegate loaded. I just tried the suggested ""-Xset:activateLightweightDelegates=false"" option and could get a successful compilation. Excellent - the option is doing exactly what I wanted - it deactivates the loading of classes via the ASM bytecode toolkit which is the problem here. I'll fix the bug soon as I can, now that I've finished doing my 40,000 sessions at AOSD. fix for this checked into AJ now. fix available now in 1.5.1 - will be in AJDT shortly. "	2006-03-22 20:05:02	1143080000.0	resolved fixed	2fb86fe	1143200000.0	tests/bugs151/Deca/DecA.java tests/bugs151/pr132926/AffectedType.java tests/bugs151/pr132926/InputAnnotation.java tests/bugs151/pr132926/InputAnnotation2.java tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java weaver/src/org/aspectj/weaver/AnnotationX.java
132130	Missing relationship for declare @method when annotating a co-located method	"For this program (when all entered into *one* file) I don't see a marker from the declare to the annotated method.  If the annotated method is in another file, I do... (not sure if fields/ctors/types are also a problem..)public aspect basic {        declare @method:                 * debit(..):                 @Secured(role=""supervisor"");}class BankAccount {        public void debit(long accId,long amount) {        }}@interface Secured {        String role();} I'm seeing the reported behaviour both when everything is in one file and when the annotated method is in a different file. The reason it's failing is that when we come to add the declare annotation relationship we look for the IProgramElement with signature ""debit(long,long)"". Unfortunately, the IProgramElement corresponding to the debit method has signature ""debit(long, long)"". Therefore we fail quietly because we can't find the method. Due to the way the previous comment was formatted, the difference didn't show up :-( To emphasise...we look fordebug(long,long)          ^whereas the ipe has signature:debug(long, long)           ^ Note this isn't a problem with fields, types or constructors, just methods. The reason for this:fields: we use field.getName() for the signature to look fortypes: we dont use signaturesconstructors: the signatures of these don't have the extra space in themThe fix is to make the comparison within AspectJElementHierarchy more robust by stripping out the extra spaces before we check for string equality. Created attachment 36479testcase patchApply to the tests project. Created attachment 36480patch containing fixApply this patch to the asm project. Created attachment 36481testcase patch without dumping structure modelApply this patch to the tests project testcase committed - and I reworked the fix a bit.  I changed it to ensure the signature for programelements doesnt have a space (methods now match ctors in this respect).  This makes things consistent and avoids any string processing (removing spaces) when looking through the programelements.  It does mean I had to change a couple of test programs that had the space in... Closing as fixed - fix available in latest aspectj dev build. "	2006-03-16 06:24:40	1142510000.0	resolved fixed	9dca72e	1142610000.0	ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java ajde/testsrc/org/aspectj/ajde/AsmRelationshipsTest.java ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java asm/src/org/aspectj/asm/internal/ProgramElement.java tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java
131932	structure model bug: generic method ITD	"import java.util.List;public aspect Slide74 {	public X Bar<X>.getFirst() {		return lts.get(0);	}		static class Bar<T> {		List<T> lts;	}}in AJDT, this program incorrectly shows the relationship from the TYPE to the Bar class rather than from the ITD to the Bar class. The problem is occuring because the ResolvedTypeMunger used when adding the ITD relationships doesn't have a sourcelocation. The sourcelocation of the originating aspect is then used which is why the arrows appear against the type rather than the itd.The reason this is happening is the call to ResolvedType.fillInAnyTypeParameters(munger) during the weaving process. Within this method we replace munger with the value of munger.parameterizedFor(actualTarget). At this point, munger is a BcelTypeMunger whose parameterizedFor(..) method returns a new BcelTypeMunger whose own munger is calculated via the NewMethodTypeMunger.parameterizeFor(..) method. This creates a new NewMethodTypeMunger with the correct signature, however, doesn't set the sourcelocation. The constructor for the BcelTypeMunger doesn't do anything with sourcelocations (unlike the EclipseTypeMunger which we are the first time we do all this) and so the sourcelocation remains null. The fix is to set the sourcelocation before returning from NewMethodTypeMunger.parameterizeFor(..). Created attachment 36400patch containing failing testcaseApply this patch to the tests project. Created attachment 36401patch containing fixApply this patch to the weaver project.Contains the fix described in previous comment. Note that this is probably also going to happen for the other types of itds....this too needs fixing in the same way. Created attachment 36404failing testcase patchApply this patch to the tests project.This testcase tests method, constructor and field itds...it's a little large :-( Created attachment 36405patch containing fixapply this patch to the weaver project.This patch fixes the method,constructor and field itd cases. fixes checked in. Closing as fixed - fixes available in latest aspectj build. Will soon be in AJDT. "	2006-03-15 09:45:01	1142430000.0	resolved fixed	e2703cf	1142520000.0	tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java weaver/src/org/aspectj/weaver/NewConstructorTypeMunger.java weaver/src/org/aspectj/weaver/NewFieldTypeMunger.java weaver/src/org/aspectj/weaver/NewMethodTypeMunger.java
131933	grotty ClassCastException on referring to pointcut in generic type	"import java.util.List;public aspect Slide71 {	before(): GenericType<String>.foo() {}	before(): GenericType<MyList>.foo() {}	//before(): GenericType.foo() {}}	class GenericType<T> {	public pointcut foo(): execution(* T.*(..));}that programs gives:  (because MyList is not a known type)java.lang.ClassCastExceptionat org.aspectj.weaver.patterns.TypePattern.resolveExactType(TypePattern.java:193)at org.aspectj.weaver.patterns.ReferencePointcut.resolveBindings(ReferencePointcut.java:130)at org.aspectj.weaver.patterns.Pointcut.resolve(Pointcut.java:194)at org.aspectj.ajdt.internal.compiler.ast.PointcutDesignator.finishResolveTypes(PointcutDesignator.java:84)at org.aspectj.ajdt.internal.compiler.ast.AdviceDeclaration.resolveStatements(AdviceDeclaration.java:118)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:400)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1088)at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.resolve(AspectDeclaration.java:116)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1137)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:305)at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:514)at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:843)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:268)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:170)at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)ClassCastException thrown: org.aspectj.weaver.patterns.WildTypePattern Created attachment 36393patch containing failing testcaseApply this patch to the tests project. Created attachment 36394patch containing proposed fixApply this patch to the weaver project.The fix is to return ResolvedType.MISSING if the typePattern isn't an ExactTypePattern. This causes the supplied testcase to produce a compiler error of the form ""can't bind type name 'MyList'"". patches committed. Closing as fixed - fix available in latest build. "	2006-03-15 09:46:31	1142430000.0	resolved fixed	f2cd94f	1142510000.0	tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java weaver/src/org/aspectj/weaver/patterns/TypePattern.java
131505	Generated aop.xml files contain aspects for all the projects ever built	"Using the -outxml option in AJDT the generated aop.xml files are not correct after the first build and contain all the aspects that have ever been built (including those in different projects and duplicates if an aspect has been built twice).  It seems that there is a global list of aspects (aspectNames in AjBuildManager) that is never cleared. I have also just noticed that the generated names are wrong for inner classes.  I think ""spacewar.Display2$SpaceObjectPainting"" should be ""spacewar.Display2.SpaceObjectPainting"". The aspectNames list should either be moved into AjState or removed entirely.  If moved into AjState we will need it to be aware of file deletions as that may affect the set of aspects - hmmm, but now I come to type that, it might be that aspect deletions force a full build anyway, which creates a new state and would empty the set of aspects.The alternative would be to remove the list entirely and just work it out at the point we create the xml file. Created attachment 36324patch containing testcaseApply this patch to the tests project. Created attachment 36325patch containing fixApply this patch to the org.aspectj.ajdt.core project.This patch contains a proposed fix. Namely, to move the list of aspectNames to the AjState. Note that when any changes are made to an aspect (including the deletion of one) we go back to source and do a full build. This creates a new AjState and consequently a new aspectNames list. patches committed. fix available. "	2006-03-13 05:37:45	1142250000.0	resolved fixed	b3cd01d	1142430000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java tests/multiIncremental/PR131505/base/C.java tests/multiIncremental/PR131505/inc2/C.java tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java
101411	SerialVersionUID handling	from emails - needs a decision---------------Hi Andyis there a way for the weaver to add to weaved classes the serial veruid field based on the pre-weaved bytecode computation.Right now it issues lint warning when a Serializable class withoutserial ver uid is encountered and due to evil #75442 this is veryannoying for LTW.A first step would be to at least deal with that when we had theperObbjectTypeMunger (then should not change any kind previous stuff).Alex------------Andy,Generating the suid sounds like a nice idea but the code the JVM used isprivate inside ObjectStreamClass. Also we need to take care with ITD fieldsto ensure correct behaviour when sending and receiving from non-wovenclasses. Basically the programmer needs to be engaged, it only affectsserializable classes and in 1.5 there is a warning if you don't declare thefield so there is a strong hint to the programmer to solve the problem. ForLTW we should make an enhancement to allow the user to configure Lint andother things. For example they may or may not be interested in advice notmatching.Matthew Webster----------------------Alex,We should make a distinction between benign changes to suid and those thataffect members. Generating suid when we add a static initializer (tosupport thisJoinPoint or the staticinitialization join point), accessormethods for privileged aspects or transient per-fields is OK. Doing forITDs is more problematic.Matthew Webster won't fix until user complains someone complained...I've just committed the implementation for this.New option: -XaddSerialVersionUID(currently -X, may graduate...)Specifying this option means when a type is woven that implements Serializable then the compiler will calculate the serialversionuid (using the same algorithm as serialver) and add the necessary field to the woven type.90% of the time this a good things as the 'funky' members we add to support advice/etc interfere with the suid when in fact the serialized form of the class hasnt changed at all.An xlint (default ignore) can show which classes we are generating the suid for (and actually the value...)We could add another to warn for ITDfields that could be suppressed by code that specifies that it knows what it is doing when it encounters a serialized form which doesnt include the field. now available. 	2005-06-23 03:47:48	1119510000.0	resolved fixed	6e6658a	1141930000.0	bcel-builder/src/org/aspectj/apache/bcel/generic/ClassGen.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.java tests/features151/serialveruid/AnAspect.java tests/features151/serialveruid/Basic.java tests/features151/serialveruid/BigHorribleClass.java tests/src/org/aspectj/systemtest/ajc151/AllTestsAspectJ151.java tests/src/org/aspectj/systemtest/ajc151/SerialVersionUIDTests.java weaver/src/org/aspectj/weaver/Lint.java weaver/src/org/aspectj/weaver/World.java weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java
130300	Remove, hide or obfuscate -XnoWeave	This option is redundant apart from use in AspectJ development and maintenance. It is confusing to users and is a source new problems for LTW. I've got this all done in a workspace at home, I'll check it in over the weekend.  You won't get a message with -XnoWeave (or -noweave which also works), it will just FAIL FAIL FAIL FAIL FAIL. its gone. 'fix' available :) 	2006-03-03 06:27:21	1141390000.0	verified fixed	b225911	1141580000.0	ajde/testsrc/org/aspectj/ajde/BuildConfigurationTests.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/core/AspectJCore.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.java org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AjCompilerOptionsTest.java taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.java testing/src/org/aspectj/testing/harness/bridge/CompilerRun.java tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java tests/src/org/aspectj/systemtest/inpath/InPathTests.java
129298	Contribution: Remove Memory Consuming Declared Signature	The code for weaver.Member#getDeclaredSignature() is never used in the weaver. My memory analysis showed this can pin several megabytes of memory in a large system. This patch removes it. YAGNI :-) Created attachment 35291weaver module patch to remove unneeded field & accessors As the comment in the code says:private final String declaredSignature; // TODO asc Is this redundant? Is it needed for generics?And that 'asc' knows what he's talking about ;) fix in. done. 	2006-02-24 03:45:34	1140770000.0	resolved fixed	a116142	1140780000.0	weaver/src/org/aspectj/weaver/JoinPointSignature.java weaver/src/org/aspectj/weaver/Member.java weaver/src/org/aspectj/weaver/MemberImpl.java
121312	[performance]Contribution: Refactoring to Support LTW World with Reflection Delegates for Bootstrap Types	This patch adds an IReflectionWorld interface, changes the various places in code where casts are made to ReflectionWorld to use that interface, creates some common methods and creates an LTWWorld that implements this interface, and sets up the ClassLoaderWeavingAdaptor to use it. It's important that the LTWWorld have just one type map for performance and memory efficiency. Created attachment 31898Weaver module patch to allow a reflective LTW world. Created attachment 31900Patch to loadtime module for reflective LTW world implementation The LTWTests pass on a 1.4 VM but they fail in Eclipse on a 1.5 VM because org.aspectj.weaver.reflect.Java15ReflectionBasedReferenceTypeDelegate is not on the classpath for the tests module...  Created attachment 31901Weaver module patch to allow a reflective LTW world.Fixes bug in Java 1.4 implementation I'm a little confused by the patch for loadtime ... since it just adds one commented out line?!?  I presume it is meant to include the change to use LTWWorld?I'm committed the other changes - but I really would like some kind of testcase that verifies it at least behaves itself... Andy has asked for a test, but Ron produced none.  This should be closed as stalebug since the patch has been committed after the need for a test has been recorded elsewhere.  If we had a tests module in bugzilla, I'd just reassign this. presumed dealt with... 	2005-12-17 02:53:28	1134810000.0	resolved fixed	cafdecb	1140690000.0	weaver/src/org/aspectj/weaver/ltw/LTWWorld.java weaver/src/org/aspectj/weaver/reflect/IReflectionWorld.java weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java weaver/src/org/aspectj/weaver/reflect/ReflectionShadow.java weaver/src/org/aspectj/weaver/reflect/ReflectionWorld.java weaver/testsrc/org/aspectj/weaver/reflect/ReflectionWorldTest.java
122742	[@AspectJ] VerifyError with @AfterThrowing/@AfterReturning and extra JoinPoint argument	"If an @AspectJ aspect advises itself using after throwing advice that itself throws an exception running the resulting program causes a VerifyError:java.lang.VerifyError: (class: A, method: stop signature: ()V) catch_type not a subclass of Throwable	at java.lang.Class.getDeclaredMethods0(Native Method)	at java.lang.Class.privateGetDeclaredMethods(Class.java:2365)	at java.lang.Class.getMethod0(Class.java:2611)	at java.lang.Class.getMethod(Class.java:1579)	at org.aspectj.tools.ajc.AjcTestCase.run(AjcTestCase.java:608)	at org.aspectj.testing.RunSpec.execute(RunSpec.java:56)	at org.aspectj.testing.AjcTest.runTest(AjcTest.java:68)	at org.aspectj.testing.XMLBasedAjcTestCase.runTest(XMLBasedAjcTestCase.java:111)	at org.aspectj.systemtest.ajc150.Ajc150Tests.testError(Ajc150Tests.java:877)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)	at java.lang.reflect.Method.invoke(Method.java:585)	at junit.framework.TestCase.runTest(TestCase.java:154)	at junit.framework.TestCase.runBare(TestCase.java:127)	at junit.framework.TestResult$1.protect(TestResult.java:106)	at junit.framework.TestResult.runProtected(TestResult.java:124)	at junit.framework.TestResult.run(TestResult.java:109)	at junit.framework.TestCase.run(TestCase.java:118)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) Created attachment 32514Testcase I'm not sure this verify error only occurs when the @AfterReturning advice affects itself that throws an exception. I think it's to do with the extra JoinPoint argument in the list of method args. I've been able to reproduce the problem by running the following:---------------------------------------------------------------------------import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.AfterThrowing;import org.aspectj.lang.annotation.Aspect;@Aspectpublic class A {		public static void main(String[] args) {		try {			new B().start();		} catch (Exception e) {			e.printStackTrace();		}	}		@AfterThrowing(pointcut = ""execution(public void B.start())"", throwing = ""ex"")	public void handleException(JoinPoint jp, Exception ex) {		}}class B implements I {	public void start() throws Exception {		throw new IllegalArgumentException();	}	}interface I {	public void start() throws Exception;}---------------------------------------------------------------------------------------------------Changing the @AfterThrowing advice to:	@AfterThrowing(pointcut = ""execution(public void B.start())"", throwing = ""ex"")	public void handleException(Exception ex) {		}and then rerunning does not result in a verify error.Looking at the output from decompiling B when there is a verify error, the Exception table for the start() method has   Exception table:   from   to  target type     9    17    17   Class org/aspectj/lang/JoinPointwhich would result in a verify error saying that the type isn't a subclass of Throwable. Created attachment 34912patch containing failing testcaseApply to the tests project.Testcase mentioned in previous comment. The problem is that Advice.getExtraParameterType() returns the UnresolvedType corresponding to the first argument, so in the example aspect this is org.aspectj.lang.JoinPoint. The fix is to make allowances for the extra parameter corresponding to JoinPoint in the case of annotation style aspects.Advice.getExtraParameterType() is used in the processing of the extra parameter both for after throwing and after returning advice. Currently if used with the following advice:@AfterReturning(pointcut = ""execution(public B1 B1.start())"", returning = ""r"")public void afterJP(JoinPoint jp, B1 r) {     r.stop();}it results in a verify error of the form:Exception in thread ""main"" java.lang.VerifyError: (class: B1, method: start signature: ()LB1;) Incompatible argument to function at A1.main(A1.java:9) Created attachment 34995patch containing failing testcase for @AfterThrowing and @AfterReturningApply this patch to the tests project.This patch replaces the previously attached one as it improves on the tests for @AfterThrowing and adds tests for @AfterReturning. Created attachment 34996patch containing proposed fixApply to the weaver project.Patch containing proposed fix mentioned above. fix committed. fix available. "	2006-01-05 06:31:44	1136460000.0	resolved fixed	3fa1bdd	1140540000.0	tests/bugs151/pr122742/AfterReturningTest.java tests/bugs151/pr122742/AfterThrowingTest.java tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java weaver/src/org/aspectj/weaver/Advice.java
128618	[incremental] XLint warnings in the wrong place with incremental compilation	"The zip file I am about to attach contains two AspectJ  project, one depending on the other.  If you make a small change to MainClass.java in 'Test Project' and save you will see a strange warning in that class - ""advice defined in ras.FFDC has not been applied [Xlint:adviceDidNotMatch]"".  If you do a full build the warning goes away.  Note that the error would be on line 36 if there were 36 lines in the class, which relates to a line in the FFDC aspect that contains advice. Created attachment 34998Test projects Note that this is only reproducible with a 1.5 JRE and a 5.0 compliance setting on both projects because the XLint warning is 5.0 specific. Looking at the warning message it's saying:message: advice defined in ras.FFDC has not been applied [Xlint:adviceDidNotMatch]resource: MainClass.java	line: 45	There is already a warning with exactly the same message and line number against the SubFFDCAspect. When you do a full build it realises this. The problem with the incremental build is that it's placing the warning against the wrong resource. The warning marker is appearing at the top of the file because there aren't 45 lines in the MainClass.java file. After more investigation on two even smaller projects this is what I see happening:test setup----------* aj project pr128618_1 containing abstract FFDC aspect (ras.FFDC.aj) with an abstract pointcut and some before advice using the pointcut.* aj project pr128618_2 depending on pr128618_1. This contains ras.concrete.SubFFDCAspect.aj which extends ras.FFDC and provides a concrete version of the abstract pointcut. There is also a mainpackage.MainClass which has some methods in it which aren't going to be matched by the advice in ras.FFDCAfter full build----------------This results in an adviceDidNotMatch message of the form ""advice defined in ras.FFDC has not been applied"". This has the line number corresponding to the before advice in ras.FFDC, however is marked against resource SubFFDCAspect.aj. When viewed in AJDT this is clearly wrong since the warning icon is against an empty line.After incremental build (resulting in making a change in MainClass)-----------------------This results in a new adviceDidNotMatch warning with the same message and line number. However, this time it is marked against resource MainClass. Again this is clearly wrong when viewed in AJDT.What I think is happening is that the warnings are being marked against the last CompilationUnitResult. In the case of the incremental build, the only thing which is being built is the MainClass which is why the warning is marked against that. Similarly in the full build case it is the SubFFDCAspect which is the CompilationUnitResult. Therefore, my previous comment is wrong (comment #3) in that the resource shouldn't be SubFFDCAspect it should be the ras.FFDC aspect. This is also not strictly an incremental bug since if we can get it to use the correct resource on the full build it should be able to on the incremental one.As a further note - if everything is in the same project then the warning is marked against the ras.FFDC aspect. Interestingly though, if you make similar changes to the MainClass to force an incremental build, you get duplicate adviceDidNotMatch messages in the problems view. This duplication should not happen. Created attachment 35013failing testcaseApply this patch to the tests project.This patch contains a failing MultiProjectIncrementalTest which follows the scenario mentioned in the above comment. There have been other bugs opened for different warning messages which show the correct message and line number, just the wrong file - see bug 60015 and bug 62073. In particular, a comment in bug 62073 explains what is happening and why:""There is an unasserted rule in the message handling code (ours and the JDTs) that goes something like this:If you log an error whilst processing a resource, the primary sourcelocation must be in that resource and not in some other resource.  If you violate this rule you get the bizarre source contexts that this bug highlights.  It is a reasonable rule as when we log errors, we record them against the compilation result that the source location points to and when we have finished processing the resource we ask the infrastructure to 'accept' the compilation result and thats when the messages get put out.""It may even be that this bug is covered under bug 62073 which was moved out to be an enhancement to sort out the error handling and fix the unhelpful source locations - to do after the release of 1.5.0 final. Actually I think bug 62073 wasn't refering to 1.5.0 final...it was referring to 1.2.0 final :-) Created attachment 35065patch containing proposed fixApply this patch to the org.aspectj.ajdt.core project.This bug can be fixed in a similar way to the fix for bug 62073. The fix in that case was to check whether the sourceLocation was an EclipseSourceLocation. If so then check whether what we were current weaving was the same as the compilationUnitResult associated with the EclipseSourceLocation. If not, then do less processing with the message. The reason that fix doesn't fix the current bug is that we're not an EclipseSourceLocation. Instead we're a SourceLocation. The fix, however, is a variation on the above. Rather than using the compilationUnitResult (which SourceLocation's don't have) it is possible to check that the filename of what we're currently weaving matches the filename in the SourceLocation. If they're not equal then we do less processing with the message and the warning has the correct resource. I believe the duplication issue mentioned at the end of comment #4 is an ajdt bug - I've raised bug 128803 to cover this.  fix committed. fix available. "	2006-02-20 06:36:46	1140440000.0	resolved fixed	89d66dc	1140540000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverMessageHandler.java tests/multiIncremental/PR128618_2/base/mainpackage/MainClass.java tests/multiIncremental/PR128618_2/inc1/mainpackage/MainClass.java tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java
128237	[@AspectJ] NPE on @AJ code with pointcut which contains logical OR operation.	"<Pyinson Data Over Head> For this bug to materialize we require the following:* a pointcut of the form ""(pc1 || pc2) && this(Type)"" where pc1 includes a wildcard* advice which uses the Type in ""this"" and also has the extra argument required for use of JoinPoint. i.e.:    @Pointcut(""(execution(public * Foo.anotherMethod*(..)) || execution(public *                 Foo.methodA(..))) && this(obj)"")    protected void methodExec(Object obj){};            @Before(""methodExec(obj)"")    public void beforeMethodExec(JoinPoint thisJoinPoint, Object obj) {      	System.out.println(""Before "" + thisJoinPoint.getSignature().toString());    } Created attachment 34907patch containing failing testcaseApply this patch to the tests project. Created attachment 34908patch containing proposed fixApply to the weaver project.When rewritten the pointcut becomesLHS = (execution(public * Foo.anotherMethod*(..)) && this(BindingTypePattern(java.lang.Object,1))) && persingleton(AbstractTracer)RHS = (execution(public * Foo.methodA(..)) && this(BindingTypePattern(java.lang.Object,1))) && persingleton(AbstractTracer)When we come to see if the LHS and RHS could ever match the same join points we return true. If the wildcard isn't there this returns false. Because it's true we then check the name of the binding associated with the LHS with that associated with the RHS. If they're not equal then we add this to the list of ambiguousNames and raise an error. This is where the NPE is coming from because the binding associated with the LHS is null.The reason we're failing here with the @AJ aspect in comment #1 is the addition of the ""thisJoinPoint"" in the method signature. When we come to validate the bindings we include this extra argument. Consequently, the array of bindings has 2 entries rather than 1. We find the BindingTypePattern(java.lang.Object,1)) and enter this as the second entry in the array of bindings. However, there aren't any others so the first entry in the array of bindings remains null. This causes the NPE when we ask if it's name is the same as the corresponding entry for the RHS (which is also null).I think it's reasonable to add a null check here. If the entry in the LHS array of bindings is null then add the corresponding name to the list of ambiguousNames iff the corresponding entry in the RHS array of bindings isn't null. If they're both null then this is ok. fix committed. fix available "	2006-02-16 11:21:26	1140110000.0	resolved fixed	ba42a09	1140540000.0	tests/bugs151/pr128237.java tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java
128744	LTW doesn't work using JRE1.4 in Eclipse	"LTW doesn't work using JRE1.4 in Eclipsenow I want to support JRE1.4 when LTW.I defined a aop.xml file in application META-INF path, it works fine using JRE1.4 in command-line, aop.xml file is used when LTW, the command as below:""D:\work\BTM\eclipse 3.1.1\eclipse-SDK-3.1.1-win32\eclipse-1.4.2\jre\bin\java"" -classpath ""C:\aspectj1.5\lib\aspectjweaver.jar"" ""-Djava.system.class.loader=org.aspectj.weaver.loadtime.WeavingURLClassLoader"" ""-Daj.class.path=D:\work\BTM\eclipse 3.1.1\jre1.4.2\myTest;C:\aspectj1.5\doc\examples\armtest\jar\btm-deps-e3.1.jar;C:\aspectj1.5\doc\examples\armtest\jar\btm-rt.jar"" Hellobut it doesn't work in Eclipse, I added upper command to VM arguments, it can't find aop.xml, because if I changed aop.xml to be wrong, there is no any error when execute the application in Eclipse , but there will be error when execute it in command-line, based on this point, I think that aop.xml didn't be used in Eclipse, I also tried to add ""-Daj.aspect.path=D:\work\BTM\eclipse 3.1.1\jre1.4.2\myTest"", but it is still. so I want to confirm if AspectJ only supports command-line for JRE1.4? doesn't support Eclipse for JRE1.4?BTW, my Eclipse env: eclipse 3.1.1 + ajdt_1.3_for_eclipse_3.1 + Sun JDK 1.4.2.I also tried to use eclipse 3.1.2, but this problem is still existed. Created attachment 35059my test applicationthe attached file Test.jar(only 3KB) is my test application, which includes four files: Hello.java, World.aj, run.bat and aop.xml in META-INF, Hello.java only prints ""Hello"", and World.aj and aop.xml will print ""World"". if I execute run.bat, there will print ""Hello"" and ""World"". but I run the class Hello in Eclipse, there is only print ""Hello"". snapshot.doc is my executed result in my env, you can refer to it. Created attachment 35060executed result snapshot I think you just need to adjust your launch configuration slightly.  Could you try this one that I'm about to attach?  Put it in your project and then right click > Run As > Run.. and select ""Hello"". Created attachment 35067Launch configuration Based on you attached file , I fixed this problem, the cause is to must add aspectjweaver.jar to User Entries even if already added it to Java Build Path, and remove current project in User Entries in run Classpath tab,  Thanks for you helps "	2006-02-20 23:38:48	1140500000.0	resolved fixed	7a2087e	1140540000.0	loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.java tests/bugs151/pr128744/Hello.java tests/bugs151/pr128744/World.java tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java
128699	"Incorrect error on ""declare"" statements"	"The error associated with the declare construct is incorrect. The current message is:""expected one of error, warning, parents, soft, dominates""dominates should be changed to ""precendence"" and new annotation related declararions should be mentioned. Here is a suggestion:""expected one of error, warning, parents, soft, precedence, @type, @method, @constructor, @field"" Fixed - as per the suggestion (thanks!) - will be in next dev build of AJ and AJDT soon... "	2006-02-20 13:08:17	1140460000.0	resolved fixed	f95d2c9	1140460000.0	weaver/src/org/aspectj/weaver/patterns/PatternParser.java
123553	Can't use named pointcut in advice decl. in generic aspect	"When defining a generic aspect with a paramterized PC, using that PC in an advice declaration causes an 'incompatible type' error. Example:public abstract aspect GenericAspect<Par1> {   abstract pointcut checkpoint(Par1 par1);   // advice declaration causes error   after(Par1 par1): checkpoint(par1) {// do something}}Using 1.3.0.20051220093604 and AspectJ 1.5.0, the compiler complains:""incompatible type, expected java.lang.Object found BindingTypePattern(TPar1;, 0).  Check the type specified in your pointcut""  Since it is possible to paramterize a named PC in subaspects:public abstract aspect GenericAspect<Par1> {       abstract pointcut checkpoint(Par1 par1);}public aspect SubAspect1 extends GenericAspect<Main>{   pointcut checkpoint(Main main): call(void Main.test()) && target(main);   after (Main main): checkpoint(main) {       System.out.println(""Caught by 1."");   }}public aspect SubAspect2 extends GenericAspect<Main2>{    pointcut checkpoint(Main2 main): call(void Main2.test()) && target(main);   after (Main2 main): checkpoint(main) {       System.out.println(""Caught by 2."");   }} ... and since it is possible to use generic PC utilizing unnamed PCs in a generic aspect: public abstract aspect GenericAspect<Par1> {       // works   after(Par1 par1): call(void Par1.test()) && target(par1) {// something }} ... it seems that this is a bug. Passing over to compiler This was broken in 1.5.0 but is fixed in HEAD (I assume by Adrian or Andy.)  I'm going to close it as such, at the risk of missing an issue they've found but which is not covered by the test case below, which fails in 1.5.0, passes now, and is checked in as tests/bugs151/pr123553:---------------------------------------------------public class A {    static Object s;    public static void main(String[] args) {        String t = ""Hello, World!"";        t.toString();        if (s != t) throw new Error();    }    static abstract aspect GenericAspect<T> {        abstract pointcut checkpoint(T t);        // advice declaration causes error        after(T t): checkpoint(t) { s = t;}    }    static aspect AAA extends GenericAspect<String>{        pointcut checkpoint(String s) : target(s) &&             call(String String.toString());    }  } "	2006-01-12 00:56:24	1137050000.0	resolved fixed	1f1ace1	1140210000.0	tests/bugs151/pr123553/A.java tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java
122370	[@AspectJ] @DeclareParents/declare parents not equivalent	"<Pyinson Data Over Head> Created attachment 34841patch containing failing testcaseApply this patch to the test project.This patch contains two tests converted from the supplied testcase. The first is the failing case with @AspectJ style and the second is the code style. The code style test is only there for investigation and shouldn't be checked into HEAD. Decompiling AnnotationMoodIndicator we see the following:   0:   aload_0   1:   getfield        #19; //Field ajc$moody_AnnotationMoodIndicator$moody_AnnotationMoodIndicator$Moody:Lmoody/AnnotationMoodIndicator$Moody;   4:   ifnull  7                                       <---- cause of failure   7:   aload_0   8:   new     #21; //class moody/AnnotationMoodIndicator$MoodyImpl   11:  dup   12:  invokespecial   #22; //Method moody/AnnotationMoodIndicator$MoodyImpl.""<init>"":()V   15:  putfield        #19; //Field ajc$moody_AnnotationMoodIndicator$moody_AnnotationMoodIndicator$Moody:Lmoody/AnnotationMoodIndicator$Moody;   18:  aload_0for both the getMood() and setMood(moody.Mood) methods. In other words, no matter what, we always create a new instance of MoodyImpl rather than using the one we've got. Instead what we want to do is to only create a new one if we don't already have one. Changing BcelTypeMunger.mungeMethodDelegate(..) to do this results in:   0:   aload_0   1:   getfield        #19; //Field ajc$moody_AnnotationMoodIndicator$moody_AnnotationMoodIndicator$Moody:Lmoody/AnnotationMoodIndicator$Moody;   4:   ifnonnull       18   7:   aload_0   8:   new     #21; //class moody/AnnotationMoodIndicator$MoodyImpl   11:  dup   12:  invokespecial   #22; //Method moody/AnnotationMoodIndicator$MoodyImpl.""<init>"":()V   15:  putfield        #19; //Field ajc$moody_AnnotationMoodIndicator$moody_AnnotationMoodIndicator$Moody:Lmoody/AnnotationMoodIndicator$Moody;   18:  aload_0and everything works as expected. Created attachment 34845failing testcaseApply this patch to the tests project.Replaces the previous testcase patch as removes the code style case. Created attachment 34846patch containing fixApply this patch to the weaver project.This patch contains the fix described in comment #2. patch is committed - I dont think the code gen can have been tested, this is a very serious bug.  Luckily our 1.5.1 release is imminent.It now correctly creates and *keeps* an instance for the multiple calls to get/set.The fix will be available in a development build soon. fix available. "	2005-12-30 00:54:07	1135920000.0	resolved fixed	e874581	1140110000.0	tests/bugs151/pr122370/moody/AnnotationMoodImplementor.java tests/bugs151/pr122370/moody/AnnotationMoodIndicator.java tests/bugs151/pr122370/moody/MainClass.java tests/bugs151/pr122370/moody/Mood.java tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java
121616	[@AspectJ]Lacking import for JoinPoint crahes the compiler	"<Pyinson Data Over Head> That's one for me... Created attachment 34833zip containing test and fix patchesThe attached zip file contains two patches:* pr121616-org-aspectj-ajdt-core-patch.txt - apply to the org.aspectj.ajdt.core project - contains the proposed fix* pr121616-tests-patch.txt - apply to the tests project - contains the testcaseThe problem is occuring when the only error is the lack of import for JoinPoint. In this case there are no errors marked against any other types and we visit the MethodDeclaration's using a ValidateAtAspectJAnnotationsVisitor. When we come to the MethodDeclaration corresponding to public @Before(""execution(* main(..))"") void log(JoinPoint thisJoinPoint) {}we go ahead without checking first whether there are any errors marked against it and then blow up with the NPE. In the case of there not being an import for @Aspect as well as JoinPoint, we don't get this far because the traverse() method in TypeDeclaration has a check first to see if there's an error reported against the typedeclaration (which there is because the import of @Aspect is missing) and if there is it just returns (and hence no NPE). In the case of there just being no import for @Before then everything is ok because no adviceAnnotations or pointcutAnnotations have been added and so we don't enter the code which is causing the NPE. Therefore the proposed fix is to add a check for errors at the start of the ValidateAtAspectJAnnotationsVisitor.visit(MethodDeclaration, ClassScope). If there are errors, then just return false. fix checked in. Closing this bug as fixed as the patch has been integrated into AspectJ. Moreover,  AJDT 1.3.1.20060309111525 for Eclipse 3.1 includes an AspectJ which contains this fix and the next build of AJDT for Eclipse 3.2M5 will also contain the fix. "	2005-12-20 14:58:14	1135110000.0	resolved fixed	d4219e1	1140080000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java tests/bugs151/pr121616.java tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java
119882	BCException when deleting a java-source-file	"org.aspectj.weaver.BCExceptionat org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1087)at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:300)at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:178)at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:254)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:163)at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)BCException thrown: Can't find bcel delegate for training.casino.Konto type=class org.aspectj.weaver.ReferenceTypewhen weaving classes when weaving when incrementally building BuildConfig[C:\Documents and Settings\mheidt\workspace 3.1.1\.metadata\.plugins\org.eclipse.ajdt.core\AspJTraining.generated.lst] #Files=11deleted  a java-source-file before (but not the class-file), possibly pointed by a LogAspect. Created a new source file. Error occurs after saving the new file. Created attachment 33701patch containing testcasePatch containing multiproject incremental testcase - apply to the tests project.I've tried reproducing this problem and have created a testcase which throws a BCExcpetion at the same line which is reported here - the stack trace is:org.aspectj.weaver.BCExceptionat org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1095)at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:300)at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:178)at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:254)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:163)at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)BCException thrown: Can't find bcel delegate for pack.C2 type=class org.aspectj.weaver.ReferenceTypewhen weaving classes when weaving when incrementally building BuildConfig[C:\eclipse_installations\aspectj\eclipse\runtime-workspace-20050923-testcaseInvestigation\.metadata\.plugins\org.eclipse.ajdt.core\test2.generated.lst] #Files=4since 8 lines have been added to the beginning of the BcelWeaver class between the time this bug was raised and now. I'm not sure if the testcase follows exactly the same scenario as that reported. The steps the testcase takes are: Stage 1: Compile the 4 files, pack.A2 extends pack.A1 (aspects) where          A2 uses a protected field in A1 and pack.C2 extends pack.C1           (classes) where C2 uses a protected field in C1 Stage 2: make the field private in class C1 ==> compile errors in C2 Stage 3: make the field private in aspect A1 whilst there's the compile          error <<-- this causes the BCExceptionAs you can see from this it was necessary for there to be compilation errors in order to produce the BCException, plus I didn't have to delete the file (although deleting the file did produce the same error).Could you confirm whether this scenario is similar to the one when you originally saw the problem? The BCException is occuring only if the error is introduced during an incremental build (doing a full build before making the change to the aspect doesn't show this problem). This is because, in the case of a full build, each compilation unit is asked whether it has errors within AjCompilerAdapter.afterProcessing(..). If any return true then the ""reportedErrors"" field is set to true. Consequently in the AjCompilerAdapter.afterCompiling(..) method there is a check for whether any errors have been reported and if they have then we don't bother to do a weave. In the incremental case, we only check whether there are any errors against the changed compilation unit (in the test scenario in comment #1 this is pack.C1) which returns false. Therefore, when we come to decide whether to weave or not, ""reportedErrors"" is false, even though there is an error against the subclass pack.C2. Going on to do a weave when there are reported errors leads to the reported BCException because the BcelObjectType for pack.C2 is an EclipseSourceType rather than a BcelObjectType. Expanding on comment #2.....this is the flow of what's happening:Stage 1: compile all aspects and classes - there are no compilation errors and this is a full build.Stage 2: make the field private in class C1. This forces an incremental build of C1. No errors are reported so we weave C1 (there is only C1 in the list of resultsPendingWeave). We then do an incremental build of C2 (since this is a subclass of C1). There are errors reported against C2 (as expected) so we finish without weaving.Stage 3: make the field private in aspect A1. This forces an incremental build of both A1 and C1 (C1 is in the list of binary files to compile held in the AjState instance). There are no errors reported against the compilation of A1 or C1, therefore we decide to weave. Because we're weaving A1 we need to reweave the world and so all known class files are added to the weave list. This includes the class file for C2 which has an error reported against it. Consequently when we come to weave we go through each one of these classes in turn and when we get to C2 the BCException is thrown.A possible fix could be to only add those classes which don't have compiler errors (since this would mirror the behaviour of a full build). However, this breaks another incremental test (testPr113531) which has two aspects A and A1 where A1 sets a protected field in A. This field is then made private and there is a resultant compile error against A1. A new aspect is then added whilst there is a compile error against A1, however, this error is then lost. Another possible fix is to mirror the fix for bug 113531. This bug dealt with the case when there was an error against an aspect when an incremental build took place. The fix was to get assert that if there was an error then the delegate would be an EclipseSourceType in which case this can be ignored without weaving as the error will be reported later. The current bug is the same problem, just with an error against a class. Therefore, a fix would be to put similar logic into the loop where the non-aspects are woven in BcelWeaver.weave(..). Created attachment 34559zip containing testcase and fixThe attached zip file contains two patches:* pr119882-tests-patch2.txt - apply to the tests project. This differs from the previously attached test by adding an extra assert that the error message is still there.* pr119882-weaver-patch.txt - apply to the weaver project. This contains the fix described in comment #4.Unfortunately, after synchronizing with the latest code in HEAD, this bug disappears (or at least the bug that this testcase recreates). This is due to the changes with comment ""go 'back to source' on incremental aspect change"".  However, since the proposed fix mirrors the behaviour of when an aspect has compile errors, I believe it should probably still be applied. i agree - i've committed the fix.  there are probably other bugs we have that are also fixed now with this change... *** Bug 124813 has been marked as a duplicate of this bug. *** *** Bug 122096 has been marked as a duplicate of this bug. *** *** Bug 118859 has been marked as a duplicate of this bug. *** Closing this bug as fixed as the patch has been integrated into AspectJ. Moreover,  AJDT 1.3.1.20060309111525 for Eclipse 3.1 includes an AspectJ which contains this fix and the next build of AJDT for Eclipse 3.2M5 will also contain the fix. "	2005-12-08 10:53:59	1134060000.0	resolved fixed	0b39aa5	1139830000.0	tests/multiIncremental/PR119882/base/src/pack/C1.java tests/multiIncremental/PR119882/base/src/pack/C2.java tests/multiIncremental/PR119882/inc1/src/pack/C1.java tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java
120356	@AJ decl err/warn does not show cross structure view	Perhaps an issue in the ASM struct for DEOWsince cross struct. is empty in AJDT , despite error / warning gutter and message is ok. Created attachment 34335patch containing failing testcaseApply the patch to the tests project.Even though the @AJ deow are showing up in the gutters in AJDT the related location is wrong - it points to the first line in the @AJ java file. This mismatch is the reason the relationships are not showing in the xref view. Dumping out the structure model (with only the @DeclareWarning) gives:--------------------------------------------------------------------------------------------------------------------------------------------------=== MODEL STATUS REPORT ========= After a batch build<root>  [java source file]   C.java  [java source file] C:\temp\ajcSandbox\ajcTest55011.tmp\C.java:1::0    import declarations  [import reference]     C  [class] C:\temp\ajcSandbox\ajcTest55011.tmp\C.java:3::17      warningMethod()  [method] C:\temp\ajcSandbox\ajcTest55011.tmp\C.java:5::37      badMethod()  [method] C:\temp\ajcSandbox\ajcTest55011.tmp\C.java:8::76  A.java  [java source file] C:\temp\ajcSandbox\ajcTest55011.tmp\A.java:1::0    import declarations  [import reference]       org.aspectj.lang.annotation.DeclareError  [import reference] C:\temp\ajcSandbox\ajcTest55011.tmp\A.java:4::105      org.aspectj.lang.annotation.DeclareWarning  [import reference] C:\temp\ajcSandbox\ajcTest55011.tmp\A.java:3::53      org.aspectj.lang.annotation.Aspect  [import reference] C:\temp\ajcSandbox\ajcTest55011.tmp\A.java:2::9    A  [aspect] C:\temp\ajcSandbox\ajcTest55011.tmp\A.java:7::172      warning  [field] C:\temp\ajcSandbox\ajcTest55011.tmp\A.java:10::255=== END OF MODEL REPORT ============ RELATIONSHIPS REPORT ========= After a batch buildHid:1:(targets=1) C:\temp\ajcSandbox\ajcTest55011.tmp\C.java|5|0|37 (matches declare) C:\temp\ajcSandbox\ajcTest55011.tmp\A.java|1|0|-1Hid:2:(targets=1) C:\temp\ajcSandbox\ajcTest55011.tmp\A.java|1|0|-1 (matched by) C:\temp\ajcSandbox\ajcTest55011.tmp\C.java|5|0|37=== END OF RELATIONSHIPS REPORT ===== Properties of the model and relationships map =====FileMapSize=2aspect=1RelationshipMapSize=2java source file=3import reference=5class=1field=1method=2---------------------------------------------------------------------------------------------------The offending thing here is that in the relationship report it says that the java source file, rather than the warning [field], is matched by the warningMethod. This is due to the setting of the location of the DeclareErrorOrWarning in AtAjAttributes.handleDeclareErrorOrWarningAnnotation(..). In both error and warning cases this is set to:deow.setLocation(struct.context, -1, -1);whereas it should be set to (in the above example)deow.setLocation(struct.context, 255, 269 );The problem is how to get hold of the correct start and end position........... Created attachment 34355zip containing updated tests and proposed short-term fixThis zip contains two patchts:* pr120356-tests-patch2.txt - apply to the tests project. This includes the previous tests patch plus an added test for running without the -emacssym flag* pr120356-weaver-patch2.txt - apply to the weaver project. The weaver patch contains a proposed short-term fix for this bug. When the structure model is created all the IProgramElements have the correct location. By querying the structure model for the IProgramElement corresponding to the @DeclareWarning or @DeclareError field we can use the ISourceLocation to get the offset and set the location on the DeclareErrorOrWarning correctly. This clearly only fixes the problem when the structure model is generated, however, this means that when used within AJDT the cross references view shows the correct information and the navigation from the markers is correct.There are other possibilities for a more long-term fix:1. The information within ajcDeclareSoft could be used. This requires that the possition of the message is set correctly (I'm not sure if it is or isn't - I haven't investigated this yet). This would also only fix the case when compiled with ajc but not when compiled with javac.2. Creating a new AjAttribute called FieldDeclarationLineNumberAttribute (much like MethodDeclarationLineNumberAttribute) which we could ask for the offset. This would fix both cases, when compiled with ajc and javac. Just a quick comment whilst its fresh in my mind, after Helen and I discussed it:> 1. The information within ajcDeclareSoft could be used. This requires that...I think thats ajcDeclareEow - seems this is something ajcDeclareEow should have been designed for, but we have to be very careful with supporting old format annotations if we change it (whole new can-o-worms)> 2. Creating a new AjAttribute called FieldDeclarationLineNumberAttribute (much> like MethodDeclarationLineNumberAttribute) which we could ask for the offset.> This would fix both cases, when compiled with ajc and javac.It would fix the case for ajc compilation with or without -emacssym, it wouldn't fix javac compilation unfortunately. The ajcDeclareEow annotation is created in DeclareDeclaration.addAtAspectJAnnotations(), which itself is called from AddAtAspectJAnnotationsVisitor.visit(MethodDeclaration, ClassScope). Within this method there are instance checks as to whether the MethodDeclaration is an AdviceDeclaration, PointcutDeclaration, DeclareDeclaration or InterTypeDeclaration. If the instance check returns true then the corresponding addAtAspectJAnnotations() method is called. However, in the case of @AJ aspects the advice is an AjMethodDeclaration rather than any of the subtypes. Moreover, the @DeclareError and @DeclareWarning's are FieldDeclarations. Therefore, none of the addAtAspecTJAnnotations() methods are called. Looking into what is required to create a FieldDeclarationLineNumberAttribute this is not straightforward and requires a lot of new code and infrastructure. For starters, a new AjFieldDeclaration ASTNode would need to be created, as well as extra methods on the IDeclarationFactory interface. Moreover, there is no obvious mechanism for adding the attribute (unlike in the method case) so would required quite a bit of work. Finally, as Andy pointed out in comment #3, at the end of the day, this wouldn't fix the javac case.All of this (including comment #3 and comment #4), plus the fact that the fix using the IProgramElement (comment #2) is straight forward and enables users within AJDT to see the xrefs in the cross reference view, means that if that fix is integrated, this bug should probably be closed as fixed and only revisited if users ask for it. fix checked in - i agree we shouldn't do any more until someone starts complaining.waiting on build. fix available in latest build. Created attachment 34490patch containing comment fixApply this patch to the weaver project.This patch fixes the wrong statement in the comment for AtAjAttributes.setDeclareErrorOrWarningLocation(..) made in the last patch. 	2005-12-12 07:07:55	1134390000.0	resolved fixed	f743fb2	1139570000.0	tests/bugs151/pr120356/A.java tests/bugs151/pr120356/C.java tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java
123212	Skip subversion resources when copying files from input to output folders	"Exception when compile a project under svn.java.io.FileNotFoundExceptionat java.io.FileOutputStream.open(Native Method)at java.io.FileOutputStream.<init>(FileOutputStream.java:179)at java.io.FileOutputStream.<init>(FileOutputStream.java:131)at org.aspectj.util.FileUtil.makeOutputStream(FileUtil.java:1258)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.writeResource(AjBuildManager.java:466)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.copyResourcesFromFile(AjBuildManager.java:444)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.copyResourcesToDestination(AjBuildManager.java:386)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:298)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:185)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:163)at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)FileNotFoundException thrown: /home/chomats/Fede/svn/fede-repos/Tool.Product.ProductServer/classes/.svn/format (Permission non accordée) I presume svn is subversion.the compiler appears to be failing to copy a resource from input to output because of a permissions problem.  Are the permissions on that file set such that the compiler should be able to access it? Comment from Stephane that didnt get on the bug:> Yes,the project is under subversion control but in this cas, svn> plugin is not installed. The file 'format' is read only. but it's> allready present in output folder.> -r--r--r--  1 chomats users   2 d?c 23 11:11 format> The aspecj compiler must not copy the .svn resource form input to> output.It looks like I just need to augment our ignore list with svn information, it currently reads that we ignore:(resourceName.startsWith(""CVS/"")) ||(resourceName.indexOf(""/CVS/"") != -1) ||(resourceName.endsWith(""/CVS"")) ||(resourceName.endsWith("".class"")) ||			(resourceName.toUpperCase().equals(MANIFEST_NAME))		    can you tell me if there is a suitable pattern for svn files, are they always in a .svn directory? in which case this will work:resourceName.indexOf(""/.svn/"") != -1) ||resourceName.indexOf("".svn/"") != -1) ||resourceName.indexOf(""/.svn"") != -1) || SVN uses directories named "".svn"" (with a whole bunch of files and folders underneath them). thx Adrian.  Proposed fix committed. waiting on build. fix available in latest AspectJ build - will be in AJDT shortly. "	2006-01-10 04:12:29	1136880000.0	resolved fixed	d856e4f	1139560000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
125809	AjTypeDeclaration in the dom shouldn't have the properties of it's subtype AspectDeclaration	The AjTypeDeclaration should not have the properties 'privileged' and 'perClause' which it's subtype AspectDeclaration has. This was shown up whilst building an aspectj for ajdt and a failure in one of the visitor tests. Created attachment 33854patch containing fix and testcaseThe problem was that the AspectDeclaration was using the property descriptors list from TypeDeclaration. If an AspectDeclaration had been initialized before a TypeDeclaration, then the TypeDeclaration had the properties associated with the AspectDeclaration (privileged and perClause). This meant that when the visitor visited the properties on the typeDeclaration it blew up when it came to the perClause and privilege because TypeDeclarations don't have these. There would be a similar problem with AjTypeDeclarations and TypeDeclarations.The fix is to ensure that each subclass of TypeDeclaration must define it's own list of property descriptors. It can add all the property descriptors from its superclass, it just needs to have it's own if it starts defining its own properties.The attached patch contains the fix and testcase for this. Apply the patch to the org.aspectj.ajdt.core project. patch committed fix available in latest dev build 	2006-01-31 06:23:53	1138710000.0	resolved fixed	eec4990	1138710000.0	org.aspectj.ajdt.core/src/org/aspectj/org/eclipse/jdt/core/dom/AjTypeDeclaration.java org.aspectj.ajdt.core/src/org/aspectj/org/eclipse/jdt/core/dom/AspectDeclaration.java org.aspectj.ajdt.core/testsrc/org/aspectj/tools/ajc/AjASTTest.java
125657	NullPointerException from BcelShadow.java:1313	"From within Eclipse 3.0 (RAD 6.0.1) I get an error with the (partial) details listed below.  My aspect looks like this:public aspect AAwtEventDispatcherThreadProtection{  pointcut awtComponentMethod(java.awt.Component component):    target(component) && call(* *.*(..));  before(java.awt.Component component): awtComponentMethod(component) {    if (!SwingUtilities.isEventDispatchThread() && component.isDisplayable())    {      System.err.println(""AWT Component method called from another Thread than the AWT-EventDispatchThread! source: "" +                          thisJoinPoint.getSourceLocation() + "", target: "" + thisJoinPoint.toLongString());    }  }}----------------DETAILS (shortened because the size exceeded the 65k limit):java.lang.NullPointerExceptionat 	at org.aspectj.weaver.bcel.BcelShadow.ensureTargetTypeIsCorrect(BcelShadow.java:1313)at 	at org.aspectj.weaver.bcel.BcelShadow.initializeTargetVar(BcelShadow.java:1274)at 	at org.aspectj.weaver.bcel.BcelShadow.getTargetVar(BcelShadow.java:968)at 	at org.aspectj.weaver.patterns.ThisOrTargetPointcut.findResidueInternal(ThisOrTargetPointcut.java:185)at 	at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:268)at 	at org.aspectj.weaver.patterns.AndPointcut.findResidueInternal(AndPointcut.java:97)at 	at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:268)at 	at org.aspectj.weaver.patterns.AndPointcut.findResidueInternal(AndPointcut.java:97)at 	at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:268)at 	at org.aspectj.weaver.bcel.BcelAdvice.specializeOn(BcelAdvice.java:132)at 	at org.aspectj.weaver.bcel.BcelShadow.prepareForMungers(BcelShadow.java:313)at 	at org.aspectj.weaver.Shadow.implement(Shadow.java:404)at 	at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:2146)at 	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:467)at 	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:102)at 	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1543)at 	at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1494)at 	at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1275)at 	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1097)at 	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:300)at 	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:178)at 	at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)at 	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)at 	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811)at 	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:230)at 	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:156)at 	at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)at 	at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)trouble in: public class com.sun.imageio.plugins.gif.GIFImageMetadata extends javax.imageio.metadata.IIOMetadata: Created attachment 33769Complete details from AJDT dialog Relevant section from the attached log concerns clone():===when implementing on shadow method-call(java.lang.Object java.lang.Object.clone())when weaving type com.sun.imageio.plugins.gif.GIFImageMetadata===The code in BcelShadow has changed since 1.5.0 shipped and now the relevant line is probably 1360 to do with determining the type for a clone call that is probably on an array.  A possible workaround is to extend your point to ignore clone:  pointcut awtComponentMethod(java.awt.Component component):    target(component) && call(* *.*(..)) && !call(* clone(..));I can put a guard in to prevent us NPEing - but it may just cause us to fail later.  It appears to NPE when the local variable table info for a method is missing so we can't determine the type for an array clone call.  So, this class: GIFImageMetadata, is probably missing local variable info (debug info) - I guess you are just using this class from some jar?I'll commit the change to avoid the NPE. Thanks for the quick response.The class is from the graphics.jar in a version of JRE 1.4.2 from IBM.However, after applying your suggestion to my pointcut I got a new bug: Bug 125670. Helen - is this resolved now? I've just retested this with the aspectj 1.5.1a, and although the originally reported NPE is no longer happening, I am now seeing the following BCException (note this is only when using the originally posted aspect that doesn't exclude clone() as suggested in comment #2):org.aspectj.weaver.BCExceptionat org.aspectj.weaver.bcel.BcelShadow.ensureTargetTypeIsCorrect(BcelShadow.java:1397)at org.aspectj.weaver.bcel.BcelShadow.initializeTargetVar(BcelShadow.java:1334)at org.aspectj.weaver.bcel.BcelShadow.getTargetVar(BcelShadow.java:1026)at org.aspectj.weaver.patterns.ThisOrTargetPointcut.findResidueInternal(ThisOrTargetPointcut.java:192)at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:267)at org.aspectj.weaver.patterns.AndPointcut.findResidueInternal(AndPointcut.java:93)at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:267)at org.aspectj.weaver.patterns.AndPointcut.findResidueInternal(AndPointcut.java:93)at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:267)at org.aspectj.weaver.bcel.BcelAdvice.specializeOn(BcelAdvice.java:132)at org.aspectj.weaver.bcel.BcelShadow.prepareForMungers(BcelShadow.java:325)at org.aspectj.weaver.Shadow.implement(Shadow.java:455)at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:2236)at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:491)at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:109)at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1560)at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1511)at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1291)at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1113)at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:311)at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:183)at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:862)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:242)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:161)at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191) Created attachment 38398File containing full exception dump Closing this bug as WONTFIX since the BCException is a limitation to do with the clone method and not being able to work out who clone was called on. A valid workaround is to exclude clone within the pointcut as suggested in comment #2. "	2006-01-29 18:45:17	1138580000.0	resolved wontfix	4934132	1138620000.0	weaver/src/org/aspectj/weaver/bcel/BcelShadow.java
123901	NPE in AccessForInlineVisitor.endVisit(AccessForInlineVisitor.java:105)	java.lang.NullPointerExceptionat org.aspectj.ajdt.internal.compiler.ast.AccessForInlineVisitor.endVisit(AccessForInlineVisitor.java:105)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference.traverse(QualifiedNameReference.java(Compiled Code))at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MessageSend.traverse(MessageSend.java(Compiled Code))at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MessageSend.traverse(MessageSend.java(Compiled Code))at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java(Compiled Code))at org.aspectj.ajdt.internal.compiler.ast.AdviceDeclaration.resolveStatements(AdviceDeclaration.java:172)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java(Compiled Code))at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java(Compiled Code))at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.resolve(AspectDeclaration.java:115)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java(Inlined Compiled Code))at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java(Compiled Code))at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:514)at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java(Compiled Code))at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:230)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:185)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:163)at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)NullPointerException thrown: null please can you confirm the exact version of AspectJ you are using as line 105 in AccessForInlineVisitor doesn't seem to be able to NPE right now.  Are you definetly on 1.5.0 final?Are you able to attach a testcase that demonstrates this failure at all, from the exception I cannot tell what you are doing that may have led to it occurring. I really use the latest release build. I download it from eclipse website. It' must be aspecj1.5 if the website is not wrong.NOTE: What I used is ajdt_1.3_for_eclipse_3.1.zip, not aspectj-1.5.0.jar. I guess they are the same. If they are not the same, please let me know. And it is helpful for me to open another defectI don't have that test case. I just met this defect during my work. Hello,I tried to recreate a small program using the stack trace provided in the bug description. The generated stack trace is similar, but the offending line in the AccessForInlineVisitor.java file is different.Eduardo----------------------------A.java----------------------------package a;public class A {   public void x(){} }----------------------------B.aj----------------------------package a;public aspect B {   void around():call(void *(..)){       A a = new A();      a.A.a.x(); // This line raises the NPE          proceed();       }}StackTrace:---------------------------------------java.lang.NullPointerExceptionat org.aspectj.ajdt.internal.compiler.ast.AccessForInlineVisitor.endVisit(AccessForInlineVisitor.java:102)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference.traverse(QualifiedNameReference.java:1004)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MessageSend.traverse(MessageSend.java:458)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:212)at org.aspectj.ajdt.internal.compiler.ast.AdviceDeclaration.resolveStatements(AdviceDeclaration.java:172)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:400)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1088)at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.resolve(AspectDeclaration.java:115)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1137)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:305)at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:514)at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:254)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:163)at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)NullPointerException thrown: null Using Eduardos test program, I recreated this and fixed it. 	2006-01-15 08:39:40	1137330000.0	resolved fixed	693945f	1138530000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java tests/bugs151/pr123901/A.java tests/bugs151/pr123901/B.java tests/bugs151/pr125475/TestEmptyPointcutAtAspect.java tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java
121395	invalid aspectj path throws filenotfoundexception	"An invalid aspectj path (missing jar file) throws an filenotfoundexception:java.io.FileNotFoundExceptionat java.io.FileInputStream.open(Native Method)at java.io.FileInputStream.<init>(FileInputStream.java:106)at org.aspectj.weaver.bcel.BcelWeaver.addAspectsFromJarFile(BcelWeaver.java:202)at org.aspectj.weaver.bcel.BcelWeaver.addLibraryJarFile(BcelWeaver.java:192)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.initBcelWorld(AjBuildManager.java:623)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:209)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:185)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:163)at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)FileNotFoundException thrown: /Users/frankstolle/Documents/workspace/lib_aspects/deploy/lib_aspects.jar (No such file or directory)should generate an problem entry in the problems-list. This seems to be ok on the command line - you get a message saying ""Bad aspectpath ..."".  In the AJDT environment we'd like the compiler to return a compile problem rather than throw an exception. command line verification is done in BuildArgParser.  AJDT takes a different route into the weaver. I've changed AjBuildManager to report a problem for entries on the aspectpath that don't exist.I also upgraded the AJDT-like test harness we had to allow setting of an aspectpath for a project.fix checked in, waiting on build. fix available. "	2005-12-19 06:28:40	1134990000.0	resolved fixed	551b446	1138370000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.java tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java
125295	fix for bug 58520 caused AJDT test failures	"The fix for bug 58520 has caused two AJDT marker tests to fail. The reason for the failures is that the test is checking that the markers have a specific message i.e. advises Demo.foo(int, Object) (runtime test). However, due to the fix for bug 58520, the message is now saying advises Demo.foo(int, java.lang.Object) (runtime test). Since everything in AJDT works of the same model, the xref view is also showing the fully qualified arguments. However, this is inconsistent with the Outline view.The fix is along the lines of adding the capability to choose whether you want the fully qualified name or not. Created attachment 33646zip containing fix and testsThis zip contains the following patches:* pr125295-asm-patch.txt - apply to the asm project. This contains the changes to IProgramElement and ProgramElement mentioned below* pr125295-org-aspectj-ajdt-core-patch.txt - apply to the org.aspectj.ajdt.core project. This contains a change to the AsmElementFormatter.setParameters(..) method detailed below.* pr125295-tests-patch.txt - apply to the tests project. This contains the test for this fixThe fix is to add methods toLabelString(boolean), toLinkLabelString(boolean) and toSignatureString(boolean) to the IProgramElement interface and in the implementation within ProgramElement, have the zero argument form of the methods call the new methods with argument true. That way, the default is to return the fully qualified arg types. The fix also included a change to the AsmElementFormatter.setParameters(..) method. Within this method there is a check whether or not to accept the argument types. If the method has argument java.lang.Object, before the fix for bug 58520, this check was done with the string ""Object"". After the fix, this was done with the string ""java.lang.Object"". This is ok, except for the case when the argument of a method is something like org.aspectj.lang.JointPoint, as in the case of one of the failing AJDT marker tests. Before the fix for bug 58520 the check was done against ""JoinPoint"" and the argument was added. However, post the fix, the check was done with ""org.aspectj.lang.JoinPoint"" and the argument wasn't added. The change I've made is to decide whether or not to accept the argument based on the original string (pre 58520 fix). patch checked in. fix available. "	2006-01-26 04:12:48	1138270000.0	resolved fixed	7e40a60	1138290000.0	asm/src/org/aspectj/asm/IProgramElement.java asm/src/org/aspectj/asm/internal/ProgramElement.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmElementFormatter.java tests/bugs151/pr125295/pkg/C.java tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java
125101	StackOverFlow in ReferenceType.isAssignableFrom()	"Hi.I am weaving two aspects into a jar file ""jar-to-jar"". ajc 1.5.0 gives me a huge error message (see attachement). Would be great if I could get any recommendations on this.Thanks!Eric Created attachment 33558the output generated by ajcfirst 4 lines might be caused by the javac compilation that happens before and builds the jar (not to confuse you) Created attachment 33559the jar I weave into Comment on attachment 33559the jar I weave intoI will replace this... Created attachment 33560this contains the jar I weave into and all dependencies (I hope) The commandline I use:ajc -sourceroots ""/home/user/ebodde/bin/sabs/install/benchmarks/Java/jlo-rt/aspects:/home/user/ebodde/bin/sabs/install/benchmarks/Java/jlo-rt/perf-tests"" -classpath ""/home/user/ebodde/bin/sabs/install/benchmarks/Java/jlo-rt/util/jasminclasses-2.2.2.jar:${CLASSPATH}:/home/user/ebodde/bin/sabs/local/system/temp/Java/jlo-rt/jlo-rt.jar:/home/user/ebodde/bin/sabs/install/benchmarks/Java/jlo-rt/lib/junit.jar:/home/user/ebodde/bin/sabs/install/benchmarks/Java/jlo-rt/lib/commons-collections-3.1.jar"" -injars ""/home/user/ebodde/bin/sabs/local/system/temp/Java/jlo-rt/jlo-rt.jar"" -outjar ""/home/user/ebodde/bin/sabs/local/system/temp/Java/jlo-rt/jlo-rt-instr.jar""So - last mail for today. I promise :-) Created attachment 33566still found this aj core dump It appears java.util.Collection is coming into the system as a 'simple' type - neither in its generic form or raw form - so it gets put into the typemap as a simple type.  this gets us horribly confused later when we are working with a subclass of it that treats it as raw.(thanks for the code - I was able to recreate it here...) thanks for finding that out so quickly. could you please let me know ASAP when a fix is available - we are doing some benchmarks on AJ compilers and it would be a pity ajc not being one of them. Thanks! do you have to use a 1.5 VM for this? If you use an earlier one with a non-generic form of Collection in it, it will probably work. or ... compile with the -1.5 flag - but I suspect that will affect performance numbers you collect as we have more type analysis to do.  Oh great, that worked! We are testing the runtime performance of the generated code, so that should be fine. I thought -1.5 would be a default option (at least if you encounter Java 5 code) ... fix checked in for the problem.-1.5 is not default unless LTW. build failed to upload last night, should be there a little later this morning.  Anyway, the real problem here was processing code built with 1.5 when running ajc in 1.4 mode.  We didn't do the right thing and attempted to create raw types rather than simple types in the weaver where the compiler had done the right thing and created simple types.  Basically the fix was to put a check in our weaver to only build raw types if the system was running in 1.5 mode. fix available. "	2006-01-24 19:40:36	1138150000.0	resolved fixed	efb20c5	1138210000.0	weaver/src/org/aspectj/weaver/bcel/BcelWorld.java
124999	[generics] Incorrect call to generic inherited method in around advice	"The following case produces a runtime error:package aj;public abstract aspect GenericInheritedMethod<T> {    protected final T getSomething() {        return null;    }}package aj;aspect UseInheritedMethod extends GenericInheritedMethod<Integer> {    // works as expected    before() : execution(void someMethod()) {        System.out.println(getSomething());    }    // Runtime Error    void around() : execution(void someMethod()) {        System.out.println(getSomething());    }    public static void main(String[] args) {        someMethod();    }    private static void someMethod() {    }}>java aj.UseInheritedMethodnullException in thread ""main"" java.lang.NoSuchMethodError: aj.UseInheritedMethod.getSomething()Ljava/lang/Integer;        at aj.UseInheritedMethod.ajc$inlineAccessMethod$aj_UseInheritedMethod$aj_UseInheritedMethod$getSomething(UseInheritedMethod.aj)        at aj.UseInheritedMethod.ajc$around$aj_UseInheritedMethod$2$c74e36b7(UseInheritedMethod.aj:12)        at aj.UseInheritedMethod.someMethod(UseInheritedMethod.aj:1)        at aj.UseInheritedMethod.main(UseInheritedMethod.aj:16)The ""inlineAccessMethod"" should call ""getSomething()Ljava/lang/Object;"" as the before advice does. fix for this is checked in and available in the latest dev build. fixed. "	2006-01-24 08:41:13	1138110000.0	resolved fixed	a4bd19d	1138120000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java
124399	AJDT AspectJ Internal Compiler Error	"<Pyinson Data Over Head> hmmm.  I added a testcase for this to the harness we have for exercising incremental compilation - works for me :(   I created the version without the printf pointcut then added that and performed an inc-compile.  The test is commented out for now (even though it works) until someone gets more time to play around and investigate this bug.  I believe we don't have any test programs that use printf() so wouldnt be surprised if there was some kind of problem... I've spent some time trying to recreate this problem and so far have had no success...In the output it says that it's building two files - is it possible to attach the other file to this bug?(As a note the failing line number is 1230 in the latest codebase in HEAD). Here's the other file, which is a pure .java file:package edu.ucsd.aosd;import java.util.Arrays;import java.util.List;import java.util.ListIterator;public class GenericsMapTest{    public interface BinaryFunction<T>    {        T apply(T x, T y);    }    public interface UnaryFunction<T>    {        T apply(T x);    }    // main    public static void main(String[] args) {        List<Integer> list = Arrays.asList(new Integer[]{1,2,3,4,5});        Integer sum = reduce(list, 0, new BinaryFunction<Integer>() {            public Integer apply(Integer x, Integer y) {                return x + y;            }        });        applyAll(list, new UnaryFunction<Integer>() {            public Integer apply(Integer x) {                return x * x;            }        });        System.out.printf(""sum = %d\n"", sum);        for (Integer i: list) {            System.out.printf(""%d "", i);        }    }    static <T> T reduce(List<T> list, T identity, BinaryFunction<T> fun) {        T result = identity;        for (T item: list) {            result = fun.apply(result, item);        }        return result;    }    static <T> void applyAll(List<T> list, UnaryFunction<T> fun) {        ListIterator<T> it = list.listIterator();        while (it.hasNext()) {            it.set(fun.apply(it.next()));        }    }}####Unfortunately I don't recall the order in which I typed in things, made errors, resaved/recompiled, changed the other .java file to .aj, et cetera... I assume order is important for this. I'll add anything else if it happens again. I've still not had any success reproducing this bug, although as a note the reason for the BCExcpetion is that the LazyMethodGen associated with the around advice is no longer in the list of methodGens for the aspect....how or why this happened I don't know and can't investigate further until I reproduce it.However, since the changes entitled ""go 'back to source' on incremental aspect change"" were checked in to HEAD, the testcase for this bug which Andy checked in and commented out (mentioned in comment #1) is now failing because the changes now force a full build rather than an incremental one. Therefore, I don't believe that the failing scenario described in this bug can be reproduced since any change to the aspect or class within MyApplication now results in a full build and the problem is an incremental one. *** Bug 130720 has been marked as a duplicate of this bug. *** Closing this bug as fixed as per the comment #4. The scenario described in this bug can no longer happen as any changes made to aspects now results in us going back to the source and doing a full build, whereas this bug was seen on an incremental build after changes to an aspect. This is available in the latest AJDT 1.3.1 dev build and will be available in the next AJDT 1.4 dev build. "	2006-01-18 16:59:18	1137620000.0	resolved fixed	d916002	1138100000.0	tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java
124654	Capture method annotation in generic aspect does not compile	The following aspect won't compile with aspect 1.5:package aj;import java.lang.annotation.Annotation;public abstract aspect GenericAnnotation<A extends Annotation> {    pointcut annotatedCall(A a) : call(@A * *.*(..)) && @annotation(a);    /* does not compile */    before(A a) : annotatedCall(a) {        System.out.println(a.annotationType());    }    /* */    /* OK */    before(A a) : call(@A * *.*(..)) && @annotation(a) {        System.out.println(a.annotationType());    }}---------------------->ajc -1.5 -d aj src\aj\*...\src\aj\GenericAnnotation.aj:10 [error] incompatible type, expected java.lang.annotation.Annotation found BindingTypePattern(TA;, 0).  Check the type specified in your pointcut before(A a) : annotatedCall(a) {1 error----------------Commenting out the first advice lets this program run as expected:package aj;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;public class Main {    @Retention(RetentionPolicy.RUNTIME)    @interface MyAnnotation {    }    static aspect ConcreteAnnotation extends GenericAnnotation<MyAnnotation> {    }    public static void main(String[] args) {        someMethod();    }    @MyAnnotation    private static void someMethod() {    }} appears the code putting out the message isnt being smart about encountering type variables... fix checked in. fix available. 	2006-01-20 10:32:07	1137770000.0	resolved fixed	28f8c69	1138030000.0	tests/bugs151/pr124654/GenericAnnotation.java tests/bugs151/pr124654/TestSubAspect.java tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java
124808	[generics] detecting field-get of field of parameterized type.	"Hi,Here is the second generics issue:Java code:==========public class Test<T extends Integer> {	Set<T> ints = new HashSet<T>();	public Set<T> foo() {		return ints;	}	public static void main(String[] args) {		Test<Integer> t = new Test<Integer>();		Set<Integer> ints = t.foo();	}}Aspect:=======public privileged aspect TestAspect {    pointcut gettingMemberCollection(Test t) :                   target(t) &&                   get(!public Set<Number+> com.mprv.secsph.*.*) &&                   !within(TestAspect);	after (Test test) : gettingMemberCollection(test) {		System.out.println(""GO Aspects!"");	}}Compiler output:================warning at after (Test test) : gettingMemberCollection(test) {^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^/root/IdeaProjects/aspectsTest/src/com/mprv/secsph/TestAspect.aj:19:0::0 advice defined in com.mprv.secsph.TestAspect has not been applied [Xlint:adviceDidNotMatch]I would expect ""gettingMemberCollection"" to catch access to ""ints"" member of ""Test"" ...Thanks a lot!Misha. fix checked in.  changed: ExactTypePattern and TypePattern. (In reply to comment #1)> fix checked in.  changed: ExactTypePattern and TypePattern.I have no words ... :)Thanks for the fixes! fix available. "	2006-01-22 11:12:27	1137950000.0	resolved fixed	01a8b2e	1138030000.0	tests/bugs151/pr124808/Test.java tests/bugs151/pr124808/TestAspect.java tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java weaver/src/org/aspectj/weaver/patterns/TypePattern.java
124803	[generics] mixing and matching numbers of type variables/parameters in a hierarchy	<Pyinson Data Over Head> fix committed.  Involved the code that sorts out the object hierarchy in ReferenceType taking into account that your super interface may not have the same number of type variables as you do.waiting on build. fix available. 	2006-01-22 09:50:51	1137940000.0	resolved fixed	8676df9	1138010000.0	tests/bugs151/pr124803/Test.java tests/bugs151/pr124803/Test2.java tests/bugs151/pr124803/TestAspect.java tests/bugs151/pr124803/TestAspect2.java tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java weaver/src/org/aspectj/weaver/ReferenceType.java
122347	Contribution: Memory Efficient Expendable Type Map	"Here is a patch for a single file (weaver/src/org/aspectj/weaver/World) that significantly improves the memory footprint of weaves (see details below). I would like help in resolving the one bug that this hit in the AspectJ weaver tests.It does the following:* Keeps Weak References to the values in the expendable map to allow evicting them (whereas the Weak Hash Map keeps weak references only to the keys)* Allows configuring the expendable map to keep hard references to up to N types with -Dorg.aspectj.weaver.World.cacheRetention=number (the current default is 0). It's a nice tuning option so projects can use a bit more memory to avoid evicting types.* Moves the isExpendible check from the typeMap to the world, to allow different worlds (such as the LTWWorld) to change what's evictable (this lets the LTWWorld not keep references to already defined classes)This change breaks 3 tests in the ""run these tests before checking in code"" suite, all of them an NPE in the same line of ReferenceType.getTypeVariables for generic signatures. Presumably this code is implicitly relying on ""expendable"" types never being evicted. I have attached the error output for all 3 cases.My initial tests have shown a relatively small performance loss in return for significant memory footprint gains. E.g., using the AspectJ in CVS HEAD with the standard BcelWorld implementation (not LTWWorld) as the world, in Tomcat with the Glassbox Inspector & 4 web apps the AspectJ overhead with this optimization is 48 million heap bytes (of 60 million total heap bytes) versus 61 million bytes using CVS HEAD. The optimization has limited benefit for a BcelWorld where almost all the code is exposed to the weaver (since few types are expendible). However, Martin Lippert tried a version of this in his AJEER Eclipse load-time weaving environment and reported a reduction from 230 MB of heap to 30 MB heap used at a cost of a 25% increase in start up time. Likewise, this facility is the major contributor to enabling my other LTW optimizations that can reduce the heap overhead in my test case to 9 million heap bytes (principally having the LTW world allow evicting types that are already woven and using reflective proxies). I see similar start up times when using this expendable map in my tests. The ability to increase the number of hard references in cache should provide users an ability to allocate more memory to speed up performance.Note that the only hard reference to the keys (the signatures) is from the values (at least I haven't noticed any cases in my load-time weaving tests), so the weak hash map is compacting itself properly: when the reference type is weakly reachable, the key is then weakly reachable and the map ultimately purges theses entries. Created attachment 32339Patch to weaver module that makes the expendable type map types truly expendable. Created attachment 32340JUnit test failures in running all tests required before committing.ReferenceType.getTypeVariables gets an NPE for a null delegate, which it isn't expecting... One additional follow up to this. I checked out the Spring framework sources from CVS and then converted to an AJDT project using the AspectJ 1.5.0 tools. Unsurprisingly it bombed with an out of memory error even with -Xmx512m. I then swapped in my experimental build of AspectJ with this feature and was happily able to build in the same memory space ... in fact I see only 330 megabytes of heap used using jconsole to connect to the VM running Eclipse. This is the only significant optimization that would effect incremental compilation in Eclipse... let me look at putting this in. I'm still getting to the bottom of the test errors - I see different problems to you Ron and they vary on each run - no doubt related to when the JVM decides to evict the contents of the weak references.Can I ask why you chose WeakRefs rather than SoftRefs - Weak being evicted as soon as possible which Soft get evicted when memory becomes an issue?Although no doubt the failures are due to the gc of typemap entries - the connection is not obvious.  In the failing case a delegate is null and it appears to usually be the one for java.lang.Object - sometimes whilst resolving recursive type definitions (like the type parameters for Enum) we create placeholders for certain types (may have null delegates), it looks like these are leaking out of the recursive case handling code.Basically the typeMap does not appear to be behaving as a true 'cache' so evicting its contents needs a little more work.Also, although the weakreferences are collected, no-one seems to remove the redundant key->weakref pointers that continue to exist in the typemap.  I'd expect to see a referencequeue attached to the created WeakRefs that can then be used to remove the redundant keys from the typemap...(<disclaimer> I'm not a references expert ... ) Hi Andy,>Can I ask why you chose WeakRefs rather than SoftRefs - Weak being evicted as>soon as possible which Soft get evicted when memory becomes an issue?I think quick eviction is important for scenarios like load-time weaving, where memory gets consumed on start-up and might not be evicted until a server gets very busy. If a user has a maximum of 256m allocated to a server, it can degrade performance significantly to have it all used on start up (which is easily possible with LTW). I could imagine making it another configurable choice. It's probably also good for testing, since if something could be evicted, it's good to see what happens when it is. It would be interesting to see how tests behave with different -Xmx, -Xms and GC settings on different VMs. Or with an aspect that forces GC after n type map entries...>Although no doubt the failures are due to the gc of typemap entries - the>connection is not obvious.  In the failing case a delegate is null and it>appears to usually be the one for java.lang.Object - sometimes whilst resolving>recursive type definitions (like the type parameters for Enum) we create>placeholders for certain types (may have null delegates), it looks like these>are leaking out of the recursive case handling code.>Basically the typeMap does not appear to be behaving as a true 'cache' so>evicting its contents needs a little more work.Aha - so the typeMap needs to hold on some expendible type for the duration of an operation? In my experimental optimized LTW implementation I hold on to hard references to all these types while in the midst of weaving, so I may be avoiding this issue. I can follow up with the latest patch containing this (not in bugzilla to avoid confusion)!>Also, although the weakreferences are collected, no-one seems to remove the>redundant key->weakref pointers that continue to exist in the typemap.  I'd>expect to see a referencequeue attached to the created WeakRefs that can then>be used to remove the redundant keys from the typemap...I thought about that but I see they are removed in large scale tests. I believe that's because the weak hash map has a reference queue for the keys (signature strings). If I understand correctly, the keys are reachable only from the values. So when the values are collected, the keys are only weakly reachable and are eligible for GC. If there's a case where a signature string is held by something else, I would suggest revising it, but I found the maps were keeping small. WeakRefs/SoftRefs - I can see your point for LTW, but I guess I'm more biased to enhancing the AJDT experience where I'd want to use as much mem as I can to speed up AJDT but allow it to be freed up if absolutely necessary.  Configurability is probably the answer but not exposing unnecessary switches to the user - default one way when running inside AJDT, the other when running LTW.I've now got Weak/Soft/NoReferences as options and have been tinkering with them. (numbers a little further down...)>>Basically the typeMap does not appear to be behaving as a true 'cache' so>>evicting its contents needs a little more work.>>Aha - so the typeMap needs to hold on some expendible type for the duration of> an operation? Not quite that cut and dry ... it seems the solution for now is to prevent expendable types with null delegates from getting into the typemap at all.  At least with that option I have the tests passing.  I'm still thinking about why this causes a problem now when its been happening all along.>>Also, although the weakreferences are collected, no-one seems to remove the>>redundant key->weakref pointers that continue to exist in the typemap.  I'd>>expect to see a referencequeue attached to the created WeakRefs that can then>>be used to remove the redundant keys from the typemap...>>I thought about that but I see they are removed in large scale tests. I believe>that's because the weak hash map has a reference queue for the keys (signature>strings). If I understand correctly, the keys are reachable only from the>values. So when the values are collected, the keys are only weakly reachable>and are eligible for GC. If there's a case where a signature string is held by>something else, I would suggest revising it, but I found the maps were keeping>small.Doh! ignore me, of course you are right Ron. I didn't see that typemap was already a weakhashmap, I guess I assumed because it was behaving so badly that it wasnt one !  yes, my tests too suggest it is purging itself as we'd like it to as entries referenced through Weak/Soft refs are collected.Right, what have I found.  I needed a big bunch of code to compile - so I compiled the AspectJ shadows project that includes a few aspects.memory set at Xmx512M:  (1stRun / 2ndRun / 3rdRun / ...)No references being used:max entries in expendableMap = 509/509entries collected through GC = 0/0Soft Refs:max entries = 408/414entries collected = 365/359Weak Refs:max entres = 308/310entries collected = 990/988summarizeXmx512M:NoRefs                    SoftRefs                   WeakRefs509/509                    408/414                    308/3100/0                        365/359                    990/988Xmx256M:NoRefs                    SoftRefs                   WeakRefs509                         424/414                   314/3110                           353/369                  1040/1030Xmx210M:NoRefs                    SoftRefs                   WeakRefsOOMemory                    314                       297                            635                      1285so... the use of references definetly reduces required memory - and weak references keep it particularly low.  I'm going to commit some of what I have right now - defaulting to SoftRefs initially but it is configurable through setting a field in the typemap class. <Pyinson Data Over Head> Doing work relating to this under bug 227484 now - referenced this bug in that one "	2005-12-29 18:49:19	1135900000.0	resolved wontfix	04067a6	1137610000.0	weaver/src/org/aspectj/weaver/World.java weaver/src/org/aspectj/weaver/bcel/BcelWorld.java
123612	ArrayIndexOutOfBoundsException with incremental and declare @type	"Given the following code:-------------------------------------------------public aspect A {	declare @type : C : @MyAnnotation;}@interface MyAnnotation {	}class C {}-------------------------------------------------if you comment out the declare @type statement and do an incremental build, then the following ArrayIndexOutOfBoundsException occurs:java.lang.ArrayIndexOutOfBoundsException: 0	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.doDeclareAnnotations(AjLookupEnvironment.java:754)	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:571)	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveIntertypes(AjLookupEnvironment.java:357)	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:209)	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301)	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315)	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811)	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:254)	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:163)	at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)	at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)This is against the latest code in HEAD. Created attachment 32913testcase patchPatch containing MultiProjectIncrementalTest.Apply to the tests project. fixed - needed to clear the cache of old dec@s so they didn't interfere on a later compile. fix available. "	2006-01-12 11:08:45	1137080000.0	resolved fixed	ab2f89b	1137510000.0	tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java
58524	ajdoc should not use the Declaration and SymbolManager classes	In order to speed up porting porting to the old HTML generation code ajdoc continues to use the following classes:  org.aspectj.tools.ajdoc.Declaration  org.aspectj.tools.ajdoc.SymbolManagerThese funtion only as a wrapper to the ASM, and are not needed.  The next refactoring effort should get rid of them (and all those static methods as well!). Hi Mik,I've made a start on this refactoring and just wanted to check that I fully understand what is required. Regarding the first point I've removed the use of org.aspectj.tools.ajdoc.Declaration and org.aspectj.tools.ajdoc.SymbolManager and replaced it with using IProgramElements directly instead. Regarding the second - are the static methods you're talking about, the ones in HtmlDecorator?Thanks, Helen  Yes Helen, you're exactly on the right track.  The static methods thing is seperate, and should not be considered part of this report.  The issue there is that ajdoc does not have an OOP architecture, and instead relies on static methods and global state.  Gregor originally mocked it up this way and it has grown a bit too large for that architecture.  I would only consider doing this substantial refactoring at your convenience, i.e. when you feel that modifying the code in the current format is costing you more overhead than it would take to refactor it.  But note that there isn't a sufficient 'parachute' (i.e. unit test coverage) for this refactoring, so making it would be a good opportunity to improve on that. Timing wise it would be good to consider whether the 1.6 JDK has any substantial ajdoc changes, since that could be good timing for a refactoring. Thanks Mik :-) I'm doing a bit of work on the test coverage of ajdoc as part of bug 121711 which will help me test whether my removal of Declaration and SymbolManager is correct.As for the static part, I agree with you....currently it's not a problem modifiying the current format so I'll leave it as is and see what happens with Java6. In the mean time I'll keep trying to add to the tests so that when the time comes it will be easier.  Created attachment 33075patch containing fixApply patch to the ajdoc project.There are no tests specifically written for testing the fix for this bug, however, the tests which were written as part of bug 121711 are able to test it.This patch removes the dependency on the Declaration and SymbolManager classes. patch is in. fixed. 	2004-04-14 13:42:37	1081960000.0	resolved fixed	f4c8bf9	1137430000.0	ajdoc/src/org/aspectj/tools/ajdoc/Declaration.java ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java ajdoc/src/org/aspectj/tools/ajdoc/Main.java ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java ajdoc/src/org/aspectj/tools/ajdoc/SymbolManager.java
122248	BUG for ajdt_1.3_for_eclipse_3.1.zip	Hi !!I use ajdt_1.3_for_eclipse_3.1.zip with eclipse 3.1.1 and fick this error when the eclipse try to make the workbrench:java.lang.IllegalStateExceptionat org.aspectj.weaver.TypeFactory.createParameterizedType(TypeFactory.java:42)at org.aspectj.weaver.bcel.BcelGenericSignatureToTypeXConverter.classTypeSignature2TypeX(BcelGenericSignatureToTypeXConverter.java:82)at org.aspectj.weaver.bcel.BcelGenericSignatureToTypeXConverter.classTypeSignature2TypeX(BcelGenericSignatureToTypeXConverter.java:42)at org.aspectj.weaver.bcel.BcelObjectType.unpackGenericSignature(BcelObjectType.java:657)at org.aspectj.weaver.bcel.BcelObjectType.getSuperclass(BcelObjectType.java:181)at org.aspectj.weaver.ReferenceType.getSuperclass(ReferenceType.java:514)at org.aspectj.weaver.bcel.BcelWeaver.weaveParentsFor(BcelWeaver.java:1192)at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1047)at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:300)at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:178)at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:230)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:156)at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)IllegalStateException thrown: Expecting raw type Is there any way you can attach the source code that shows this problem?  I'm guessing you are using the December 20th release of AJDT that included AspectJ 5 final? I saw this behaviour reproduced in another context. It happens when the world is set NOT to behave in a Java 5 way. The impact of this is that the world creates only simple types rather than raw or generic types.However, BcelObjectType.unpackGenericSignature was *always* unpacking the generic signature, whether the world was in Java 5 mode or not. If a class had a parameterized superclass, the type converter was getting the base class from the world (and getting a simple type, rather than the expected generic or raw type) and then trying to parameterize it - leading to the illegal state exception. The solution to all this is to only unpack generic signatures when the world is set to behave in a java 5 way (which sounds emminently sensible). I'm verifying that change in BcelObjectType, BcelMethod, and BcelField against the test suite... fix commited in tree, waiting on build... build available. will appear in AJDT in a few days. 	2005-12-28 09:35:06	1135780000.0	resolved fixed	3f77e75	1137360000.0	weaver/src/org/aspectj/weaver/bcel/BcelField.java weaver/src/org/aspectj/weaver/bcel/BcelMethod.java weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java weaver/testsrc/org/aspectj/weaver/MemberTestCase15.java
122417	[waiting-on-website-doc-refresh] Typo in org.aspectj.lang.JoinPoint String constant symbolic name	"Methinks the  n_a_m_e  of the preinitialization constant is misspelledJoinPoint.PREINTIALIZATION    is lacking an ""I"" between the N and the TJoinPoint.PREINITIALIZATION   might be the correct versionNote: The value of the constant (""preinitialization"") is spelled correctly.Sorry for the inconvenience.Harald fix checked in - thanks for the bug report. fixed in the codebase - next website doc refresh should include it. hmm, i thought adrian updated the docs today but this still looks broken. updated at last. "	2005-12-31 05:11:31	1136020000.0	resolved fixed	a9ef1b0	1136910000.0	runtime/src/org/aspectj/lang/JoinPoint.java weaver/src/org/aspectj/weaver/Shadow.java
122458	java.lang.StringIndexOutOfBoundsException when compiling (build no.: 20051220093604)	"This exception occurs using the ajdt eclipse plugin when compiling a project the first time I add the ajdt nature. There are no aspects defined in the project.I suppose the exception occurs when compiling a class (sorry I can't post the entire source code) with this signature: public class FixedWidthParser<T> extends TabularDataParser<T>The only noticeable things about this class are the presence of an inherited type parameter (and redefined with same name) some custom annotations on methods and a varags on a method parameter, but all of this things are present on other classes in the same project that AspectJ apprently compiles well (I'm not sure about the fact it compiles them).Hope I helped you with this clues, here's the complete stacktrace.java.lang.StringIndexOutOfBoundsExceptionat java.lang.String.substring(Unknown Source)at org.aspectj.weaver.TypeFactory.createTypeFromSignature(TypeFactory.java:86)at org.aspectj.weaver.TypeFactory.createTypeFromSignature(TypeFactory.java:116)at org.aspectj.weaver.UnresolvedType.forSignature(UnresolvedType.java:430)at org.aspectj.weaver.UnresolvedType.makeArray(UnresolvedType.java:286)at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBinding(EclipseFactory.java:214)at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeResolvedMember(EclipseFactory.java:516)at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeResolvedMember(EclipseFactory.java:494)at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeResolvedMember(EclipseFactory.java:451)at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.genBytecodeInfo(AsmHierarchyBuilder.java:525)at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.visit(AsmHierarchyBuilder.java:400)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:185)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1195)at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:339)at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.internalBuild(AsmHierarchyBuilder.java:142)at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.buildStructureForCompilationUnit(AsmHierarchyBuilder.java:82)at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.finishedCompilationUnit(EclipseFactory.java:926)at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterProcessing(AjCompilerAdapter.java:195)at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$4$6b855184(CompilerAdapter.aj:89)at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:528)at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:230)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:156)at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)StringIndexOutOfBoundsException thrown: String index out of range: -2 I tried to debug the aspectj weaver code and I found that the signature generating the error is:Pcom/lynxit/parsers/fixedwidth/FixedWidthParser$Column;It seems that the lack of '<' character is the problem.Investigating a little more I discovered that a inner class (even static) of a generic class inherits the type parameters, I don't know if this is in the Java language specs or an eclipse bug but this is surely the cause of the bug I submitted since extracting the inner class to a new type file I'm able to compile the project.Hope this helps.Many thanks in advance. Can I ask the ID of the AJDT build that is the problem?  (Its somewhere in the eclipse about menus), something like 1.3.0.XXXXX.I fixed a problem similar to this near to completion of 1.5.0.  The problem was that a generic signature was being put out for a type that included a 'P' prefixed type signature.  'P' signatures should never be included in the output bytecode, they are our AJ internal representation for a parameterized type, enabling us to quickly determine if something is parameterized without digging round for the '<'. The ajdt build number is:1.3.0.20051220093604 Ok, thats 1.5.0 final - so there is something lurking here. but I just can't seem to tease it out and recreate it.  My current attempts look something like:===import java.util.*;class A<T> { }class B<T> extends A<T> {  static class C { T t;}  class D extends C {}  List<C>  lcs;  C[] csArray;}===but that works fine.Were you able to determine where the P signature originated from?  Was it a signature attribute on some other type or declaration?  Where/How is the Column member type used?  If you could send me the ""javap -verbose -private"" output for the problem class that would help ... are you able to send it me privately if you can't append it here? I eventually succeded in producing a test case that can really isolate the problem:public class TestCase<T, V>{    public void setInnerClasses(InnerClass[] classes){};        public static class InnerClass {}}Compiling this class alone (using ajdt) I get the error. aha... it was being used as a parameter, I see.  Thanks for taking the time to create a smaller failing case.  I can now recreate it on the command line with:ajc -1.5 Testcase.java -emacssym(-emaccsym is required to ensure that from the command line we drive the structure model building code that AJDT drives - and thats where it is failing)I'll get to work on a fix. I'm glad I helped you guys.My little contribute to your great job! testcases and fix checked in. fix is in latest AJ - will be in AJDT in a few days. "	2006-01-02 12:16:49	1136220000.0	resolved fixed	24a785f	1136890000.0	weaver/src/org/aspectj/weaver/TypeFactory.java
112458	Property Editor still shows the properties of layout items when switch to Master page viewer.	Description:Property Editor still shows the properties of layout items when switch to Master page viewer.Steps to reproduce:1. New a report and insert a label.2. Select the label.(Property Editor shows label's properties)3. Switch to Master Page.Expected result:Property Editor changs to reflect Master Page properties.Actual result:It still showed the label's properties. This will confuse customers if they thought it as Master Page Editor and set properties without click Master Page viewer at first. Sync selection when page changes.The logic is there, but code has minor problem to use new multipage structure.Call syncCurrentSelection method in pageChange method. Fixed.Verify in build 20051019 	2005-10-13 07:31:44	1129200000.0	closed fixed	53284da	1136890000.0	tests/src/org/aspectj/systemtest/AllTests15.java tests/src/org/aspectj/systemtest/ajc150/AllTestsAspectJ150.java tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java tests/src/org/aspectj/systemtest/ajc151/AllTestsAspectJ151.java weaver/src/org/aspectj/weaver/TypeFactory.java
122728	ajdoc crashes	"When trying to run ajdoc on a moderate size code base (266 classes / interfaces / aspects), ajdoc crashes. Here's what happens:D:\work\napa\jnapa\core>ajdoc -source 1.5 -classpath D:\work\napa\jnapa\core\lib\aspectjrt.jar;D:\work\napa\jnapa\core\lib\dom4j-1.5.2.jar;D:\work\napa\jnapa\core\lib\groovy-all-1.0-jsr-03.jar -d D:\work\napa\jnapa\core\build\doc\internal -author -package -argfile D:\work\napa\jnapa\core\jnapafilelist34352.lst> Calling ajc...D:\work\napa\jnapa\commons\utils\src\fi\napa\util\aspects\CachingAspect.aj:72 [warning] advice defined in fi.napa.util.aspects.CachingAspect has not been applied [Xlint:adviceDidNotMatch]1 warning> Building signature files...An internal error occured in ajdocPlease copy the following text into an email message and send it,along with any additional information you can add to:       aspectj-dev@eclipse.orgjava.lang.IndexOutOfBoundsException: Index: 3, Size: 3java.lang.IndexOutOfBoundsException: Index: 3, Size: 3        at java.util.ArrayList.RangeCheck(ArrayList.java:546)        at java.util.ArrayList.get(ArrayList.java:321)        at org.aspectj.tools.ajdoc.StubFileGenerator.processMembers(StubFileGenerator.java:124)        at org.aspectj.tools.ajdoc.StubFileGenerator.processTypeDeclaration(StubFileGenerator.java:99)        at org.aspectj.tools.ajdoc.StubFileGenerator.processMembers(StubFileGenerator.java:113)        at org.aspectj.tools.ajdoc.StubFileGenerator.processTypeDeclaration(StubFileGenerator.java:99)        at org.aspectj.tools.ajdoc.StubFileGenerator.processFile(StubFileGenerator.java:61)        at org.aspectj.tools.ajdoc.StubFileGenerator.doFiles(StubFileGenerator.java:38)        at org.aspectj.tools.ajdoc.Main.main(Main.java:157)  The file jnapafilelist34352.lst contains only file entries w/ absolute paths, e.g. D:\work\napa\jnapa\core\src\fi\napa\core\tableprocessing\transfer\mapping\Transformation.javaI am using ajc and ajdoc 1.5.0 release version. I'll be happy to provide any other information that may help in solving this issue.D:\work\napa\jnapa\core>ajdoc -vajdoc version 1.5.0D:\work\napa\jnapa\core>ajc -vAspectJ Compiler 1.5.0 built on Tuesday Dec 20, 2005 at 12:05:54 GMT I suppose this is the same bug, so I'll add this as a comment. I tried to run ajdoc on the same source files w/ a little different settings. It still crashes:D:\work\napa\jnapa\core>ajdoc -source 1.5 -classpath D:\work\napa\jnapa\core\lib\aspectjrt.jar;D:\work\napa\jnapa\core\lib\dom4j-1.5.2.jar;D:\work\napa\jnapa\core\lib\groovy-all-1.0-jsr-03.jar -d D:\work\napa\jnapa\core\build\doc\internal -author -package -sourcepath D:\work\napa\jnapa\core\gen_src;D:\work\napa\jnapa\core\src;D:\work\napa\jnapa\commons\utils\src fi.napa.legacy.nativeaccess fi.napa fi.napa.core fi.napa.core.geometry fi.napa.core.geometry.basic fi.napa.core.geometry.legacy fi.napa.core.loadingconditions fi.napa.core.loadingconditions.lightweight fi.napa.core.loadingconditions.lightweight.legacy fi.napa.core.project fi.napa.core.project.legacy fi.napa.core.referencesystem fi.napa.core.referencesystem.legacy fi.napa.core.shipmodel fi.napa.core.shipmodel.legacy fi.napa.core.steel fi.napa.core.steel.legacy fi.napa.core.steel.opt fi.napa.core.tableprocessing fi.napa.core.tableprocessing.legacy fi.napa.core.tableprocessing.transfer fi.napa.core.tableprocessing.transfer.bootstrap fi.napa.core.tableprocessing.transfer.link fi.napa.core.tableprocessing.transfer.link.napa fi.napa.core.tableprocessing.transfer.link.rdbms fi.napa.core.tableprocessing.transfer.mapping fi.napa.core.topology fi.napa.core.topology.legacy fi.napa.legacy fi.napa.legacy.jservicefunctions fi.napa.legacy.jservicefunctions.invoker fi.napa.util fi.napa.util.aspects> Calling ajc...D:\work\napa\jnapa\commons\utils\src\fi\napa\util\aspects\CachingAspect.aj:72 [warning] advice defined in fi.napa.util.aspects.CachingAspect has not been applied [Xlint:adviceDidNotMatch]1 warning> Building signature files...An internal error occured in ajdocPlease copy the following text into an email message and send it,along with any additional information you can add to:       aspectj-dev@eclipse.orgjava.lang.IndexOutOfBoundsException: Index: 4, Size: 4java.lang.IndexOutOfBoundsException: Index: 4, Size: 4        at java.util.ArrayList.RangeCheck(ArrayList.java:546)        at java.util.ArrayList.get(ArrayList.java:321)        at org.aspectj.tools.ajdoc.StubFileGenerator.processMembers(StubFileGenerator.java:124)        at org.aspectj.tools.ajdoc.StubFileGenerator.processTypeDeclaration(StubFileGenerator.java:99)        at org.aspectj.tools.ajdoc.StubFileGenerator.processMembers(StubFileGenerator.java:113)        at org.aspectj.tools.ajdoc.StubFileGenerator.processTypeDeclaration(StubFileGenerator.java:99)        at org.aspectj.tools.ajdoc.StubFileGenerator.processFile(StubFileGenerator.java:61)        at org.aspectj.tools.ajdoc.StubFileGenerator.doFiles(StubFileGenerator.java:38)        at org.aspectj.tools.ajdoc.Main.main(Main.java:157) Yes, this is the same bug. The problem is that we're blowing up in the following loop during the processing of enums:										if (member.getKind().equals(IProgramElement.Kind.ENUM_VALUE)){  if (((IProgramElement)members.get(members.indexOf(member)+1)). <--- PROBLEM           getKind().equals(IProgramElement.Kind.ENUM_VALUE)){     .....  }}I've therefore been able to recreate this bug with just the following enum:--------------------------------package pack;public enum MyEnum {		A;	}--------------------------------and running ajdoc against this. Created attachment 32513patch containing fix and testApply this patch to the ajdoc project.The fix involves adding an extra check to see if there are any more members before checking whether the next member is also an enum. Created attachment 32518patch containing fix and testooops - forgot to add the new testcase EnumTest to the ajdoc test suite. This patch does that and this is the only difference between the two.Apply to the ajdoc project. fix checked in. fixes available. "	2006-01-05 03:21:00	1136450000.0	resolved fixed	d69ce9a	1136810000.0	ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java ajdoc/testdata/pr122728/src/pack/ClassWithInnerEnum.java ajdoc/testdata/pr122728/src/pack/EnumWithMethods.java ajdoc/testdata/pr122728/src/pack/MyEnum.java ajdoc/testsrc/org/aspectj/tools/ajdoc/AjdocTests.java ajdoc/testsrc/org/aspectj/tools/ajdoc/EnumTest.java
121385	around advice does not work when LTW	"<Pyinson Data Over Head> my test Hello class:public class Hello {	/**	 * @param args	 */	public static void main(String[] args) {		// TODO Auto-generated method stub		sayHello();	} 	 	public static void sayHello() {		System.out.println(""Hello"");		sayWorld();	} 		public static int sayWorld() {		System.out.println(""World"");		return 0;	}} Matthew is going to try and recreate this with the supplied info. This can easily be reproduces with supplied testcase (thanks). The priority should be to find a good workaround if possible.1. User confirms that before/after rather than works 2. I can confirm that defining a concrete sub-aspect using code style (rather than XML) also works but defining one using annotation style fails in a similar way. I also get the failure with both source and binary weaving.3. It may work if the abstract aspect is defined using annotation style This can easily be reproduced with supplied testcase (thanks). The priorityshould be to find a good workaround if possible.1. User confirms that before/after rather than around advice works 2. I can confirm that defining a concrete sub-aspect using code style (ratherthan XML) also works but defining one using annotation style fails in a similarway. I also get the failure with both source and binary weaving.3. It may work if the abstract aspect is defined using annotation style BTW looking at the weaver options ""-XlazyTjp"" is unecessary because it is now the default (although ironically it does not apply to around advice) and -Xreweavable should not be used (-XnotReweavable is the default for LTW) because it is unlikely that the code will need to be rewoven before going straight into the JVM and probably hurts performance (see Bug 114897). It does occur because of the mixing of styles.  The abstract aspect being code style, then the concrete sub-aspect (generated from the XML) being annotation style.  The problem is that when 'collecting' up the advice as part of processing the sub-aspect, the super aspect is returning 'true' for hasExtraParameter() and yet the extraVar is null.  A simple guard on the null value gets us over the problem in this case - but there is possibly something to look into, examining why hasExtraParameter() is returning true.the null guard is in 1.5.0 final. Created attachment 32085Failing LTW testcaseUnfortunately while the NPE is cured we have a VerifyError instead. The World1 sub-aspect is generated and defined. The test is woven but cannot be defined.java.lang.VerifyError: (class: Hello, method: sayWorld signature: ()I) Unable to pop operand off an empty stack	at java.lang.Class.getDeclaredMethods0(Native Method)	at java.lang.Class.privateGetDeclaredMethods(Class.java:2365)	at java.lang.Class.getMethod0(Class.java:2611)	at java.lang.Class.getMethod(Class.java:1579)	at org.aspectj.tools.ajc.AjcTestCase.run(AjcTestCase.java:608)	at org.aspectj.testing.RunSpec.execute(RunSpec.java:56)	at org.aspectj.testing.AjcTest.runTest(AjcTest.java:68)	at org.aspectj.testing.XMLBasedAjcTestCase.runTest(XMLBasedAjcTestCase.java:111)	at org.aspectj.systemtest.ajc150.Ajc150Tests.testNPEInBcelAdviceWithConcreteAspect_pr121385(Ajc150Tests.java:873)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)	at java.lang.reflect.Method.invoke(Method.java:585)	at junit.framework.TestCase.runTest(TestCase.java:154)	at junit.framework.TestCase.runBare(TestCase.java:127)	at junit.framework.TestResult$1.protect(TestResult.java:106)	at junit.framework.TestResult.runProtected(TestResult.java:124)	at junit.framework.TestResult.run(TestResult.java:109)	at junit.framework.TestCase.run(TestCase.java:118)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)info AspectJ Weaver Version DEVELOPMENT built on info register classloader org.aspectj.weaver.loadtime.WeavingURLClassLoaderinfo using /C:/temp/ajcSandbox/ajcTest24128.tmp/META-INF/aop.xmlinfo generating class 'World1'info weaving 'Hello'info weaver operating in reweavable mode.  Need to verify any required types exist.weaveinfo Join point 'method-execution(void Hello.sayHello())' in Type 'Hello' (Hello.java:7) advised by around advice from 'World1' (World.aj:7)weaveinfo Join point 'method-execution(int Hello.sayWorld())' in Type 'Hello' (Hello.java:12) advised by around advice from 'World1' (World.aj:7)info generating class 'Hello$AjcClosure1'info generating class 'Hello$AjcClosure3' Interesting that there is something missing off the stack and the code now commented out with a null check would load a value onto the stack. The problem may lie with trying to define the sub-aspect while initializing the weaving adaptor. When running in a different environment (AOSGi) I noticed that when World1 is defined the super-aspect World is loaded and weaving is attempted. In the harness this does not happen as the WeavingURLClassLoader uses a flag to avoid recursion during adaptor initialization. However although aspect World1 is woven during the generation process, World will not be woven (see Bug 119657).There are 2 other concrete aop.xml tests in the harness in AtAjLTWTests . Changing them to use around instead of before advice only causes the AspectJ test to fail with a VerifyError; the @AspectJ one passes. So this may be a problem with around advice and/or mixing styles. However these tests use inner aspects so are not the same as the new test. Matthew - here is a patch - can you apply it to the weaver project and see if it helps your situation?==========8<================Index: src/org/aspectj/weaver/bcel/BcelAdvice.java===================================================================RCS file: /home/technology/org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java,vretrieving revision 1.43diff -u -r1.43 BcelAdvice.java--- src/org/aspectj/weaver/bcel/BcelAdvice.java	19 Dec 2005 15:06:51 -0000	1.43+++ src/org/aspectj/weaver/bcel/BcelAdvice.java	21 Dec 2005 16:33:35 -0000@@ -400,7 +400,8 @@ 		if (exposedState.getAspectInstance() != null) { 			il.append(BcelRenderer.renderExpr(fact, world, exposedState.getAspectInstance())); 		}-        final boolean isAnnotationStyleAspect = getConcreteAspect()!=null && getConcreteAspect().isAnnotationStyleAspect();+		boolean x = this.getDeclaringAspect().resolve(world).isAnnotationStyleAspect();+        final boolean isAnnotationStyleAspect = getConcreteAspect()!=null && getConcreteAspect().isAnnotationStyleAspect() && x;         boolean previousIsClosure = false;         for (int i = 0, len = exposedState.size(); i < len; i++) {         	if (exposedState.isErroneousVar(i)) continue; // Erroneous vars have already had error msgs reported!@@ -455,12 +456,14 @@ 	                } else if (hasExtraParameter()) {                         previousIsClosure = false;                         //extra var can be null here (@Aj aspect extends abstract code style, advice in code style)-                        if (extraVar != null) {+//                        if (extraVar != null) {                             extraVar.appendLoadAndConvert(                                 il,                                 fact,                                 getExtraParameterType().resolve(world));-                        }+                        +//                        } else+//                            il.append(InstructionConstants.ACONST_NULL);                     } else {                         previousIsClosure = false;                         getConcreteAspect().getWorld().getMessageHandler().handleMessage(Index: src/org/aspectj/weaver/bcel/BcelShadow.java===================================================================RCS file: /home/technology/org.aspectj/modules/weaver/src/org/aspectj/weaver/bcel/BcelShadow.java,vretrieving revision 1.86diff -u -r1.86 BcelShadow.java--- src/org/aspectj/weaver/bcel/BcelShadow.java	12 Dec 2005 10:48:46 -0000	1.86+++ src/org/aspectj/weaver/bcel/BcelShadow.java	21 Dec 2005 16:33:36 -0000@@ -2221,7 +2221,7 @@ 				munger.getAdviceArgSetup( 					this, 					null,-                    (munger.getConcreteAspect().isAnnotationStyleAspect())?+                    (munger.getConcreteAspect().isAnnotationStyleAspect() && munger.getDeclaringAspect().resolve(world).isAnnotationStyleAspect())?                         this.loadThisJoinPoint(): 					    new InstructionList(InstructionConstants.ACONST_NULL))); 		    // adviceMethodInvocation ===========8<================ the bug appears to be that we use two mechanisms to build the arguments for an around advice call - which mechanism we use depends on whether the advice was declared in a code style aspect or an annotation style aspect.The problem here is that we ask the advice for the style used by the concrete aspect and the concrete aspect is annotation style.  But of course the advice was declared in a code style aspect.  We shouldn't check the concrete aspect but the declaring aspect for the advice.  Changing the code to do this check fixes this problem and we can remove the null check that was added just before 1.5.0 final. proper fix checked in. will be in the next dev build. fix available. "	2005-12-19 05:32:32	1134990000.0	resolved fixed	a778ac4	1135190000.0	tests/bugs150/pr121385/A.java tests/bugs150/pr121385/Hello.java tests/bugs150/pr121385/WorldAt.java tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java weaver/src/org/aspectj/weaver/bcel/BcelShadow.java
58520	ajdoc doesn't navigate to target details in some cases	"When a file is advised, javadoc uses the following naming convention for setting its ""A NAME"":  convertCheckedException(java.lang.Throwable)However, ajdoc uses the unqualified name for the argument, resuting in the follwing in-file anchor link:  <class-name>.html#convertCheckedException(Throwable) Which fails to navigate to the anchor within the file, although it does always go to the right file. This is a low-priority bug, but would be nice to fix in the next round of ajdoc updates.  The fix may be a little less straightforward than it sounds because fully-qualified parameter names aren't currently in the ASM. Created attachment 32016zip containing fix and testcase patchesThe attached zip file contains two patches:- pr58520-ajdoc-patch.txt : apply to the ajdoc project. This patch contains a testcase which uses the same sample project as supplied in the patch for bug 119453 (it's included in this patch because the patch for 119453 hasn't been applied yet)- pr58520-org-aspectj-ajdt-core-patch.txt : apply to the org.aspectj.ajdt.core project. This patch contains the proposed fix.The fix for this bug required changing the logic in AsmElementFormatter.setParameters(..) to use the fully qualified name when setting the arguments. This resulted in adding an extra check in AsmHierarchyBuilder.visit(MethodDeclaration, ClassScope) to check for main(java.lang.String[]) rather than main(String[]).A consequence of this fix is that as well as the links mentioned when this bug was raised now working, ajdoc also includes the fully qualified name in the signature. For example, if you declare a constructor ITD on a class C which takes a String argument:public C.new(String s){ this();};the ajdoc used to show this as:C.C(String).It now shows it asC.C(java.lang.String)which is more consistent with javadoc. I applied 119453 and have just applied this one (skipping the files that were from 119453) - the new test fails.  Are there definetly no differences between the sample project in each case?Failure is:junit.framework.AssertionFailedError: Advice summary should have link to 'C.html#method3(java.lang.String)'	at junit.framework.Assert.fail(Assert.java:47)	at junit.framework.Assert.assertTrue(Assert.java:20)	at org.aspectj.tools.ajdoc.FullyQualifiedArgumentTest.checkContentsOfA(FullyQualifiedArgumentTest.java:93)	at org.aspectj.tools.ajdoc.FullyQualifiedArgumentTest.testPr58520(FullyQualifiedArgumentTest.java:58)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)	at java.lang.reflect.Method.invoke(Method.java:585)	at junit.framework.TestCase.runTest(TestCase.java:154)	at junit.framework.TestCase.runBare(TestCase.java:127)	at junit.framework.TestResult$1.protect(TestResult.java:106)	at junit.framework.TestResult.runProtected(TestResult.java:124)	at junit.framework.TestResult.run(TestResult.java:109)	at junit.framework.TestCase.run(TestCase.java:118)	at junit.framework.TestSuite.runTest(TestSuite.java:208)	at junit.framework.TestSuite.run(TestSuite.java:203)	at junit.framework.TestSuite.runTest(TestSuite.java:208)	at junit.framework.TestSuite.run(TestSuite.java:203)	at junit.framework.TestSuite.runTest(TestSuite.java:208)	at junit.framework.TestSuite.run(TestSuite.java:203)	at junit.framework.TestSuite.runTest(TestSuite.java:208)	at junit.framework.TestSuite.run(TestSuite.java:203)	at junit.framework.TestSuite.runTest(TestSuite.java:208)	at junit.framework.TestSuite.run(TestSuite.java:203)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) Created attachment 32070updated ajdoc patch to encorporate fixes for 119453There is an extra method in C.java that is required for this test:	public void method3(String s) { 	}The attached patch is an updated version which has synchronized against the latest changes in HEAD (i.e. with pr119453 having been applied).Apply to the ajdoc project. fixes checked in. fix available. "	2004-04-14 13:29:14	1081960000.0	resolved fixed	bbdd496	1135160000.0	ajdoc/testdata/pr119453/src/pack/C.java ajdoc/testsrc/org/aspectj/tools/ajdoc/AjdocTests.java ajdoc/testsrc/org/aspectj/tools/ajdoc/FullyQualifiedArgumentTest.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmElementFormatter.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java
120909	Test failures using IBM Java 5	<Pyinson Data Over Head> Created attachment 31760Fixes to 2 harness tests Created attachment 31804Fixes to harness testsAlso remove public constructors that use Class.getClassLoader(). fix now available 	2005-12-14 11:58:04	1134580000.0	resolved fixed	9abfc40	1134660000.0	loadtime/src/org/aspectj/weaver/loadtime/DefaultWeavingContext.java weaver/src/org/aspectj/weaver/reflect/ReflectionWorld.java weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java weaver/testsrc/org/aspectj/weaver/reflect/ReflectionWorldTest.java
120743	Improvements to define new server wizard page	On the panel where the server location and button to install the server is shown, a couple of usability improvements could be made...(1) If I choose browse and choose a location.  Then hit install server, the fs browser should not be brought back up since I have already hitten browse and selected a location.(2) If (1) and the location chosen contains no server, and the server is downlodable, classpath validation errors should not show, but a message stating that no server is found but can be installed by selecting the install server button. Another issue is the following.  And this will be a usability issue for all downloadble servers, not just geronimo.  If I hit Install Server, the FS location panel pops up and I choose the location on my fs where I want to install to.  For example... /home/sppatel/.At this point the App Server Location field says /home/sppatel and the server is download and installed.  But the current location is not valid and afterward you have to hit Browse a second time to choose /home/sppatel/geronimo-1.0.I wonder if there is a generic way that this could be solved.  Or if we need another attribute in the extension point that defines the root directory of the install which gets appended to the appserver location after the server is unzipped. Lowering severity on this.  I'm implementing my own server wizard fragment to address these issues. After implementing my own wizard fragment to enchance this support, and looking at the generic server wizard fragment code it may be better to leave it as simple as possible but focus on making sure the decorators can be reused and overridden easily if someone wants to add more function or is unhappy with default behavior.  If you feel the same feel free to mark this as WONT FIX. Marking this as won't fix.  I think the generic implementation is suffient and adopters can override the behavior if necessary. Closing old bugs. Changing OS from Mac OS to Mac OS X as per bug 185991 	2005-12-13 16:15:50	1134510000.0	closed wontfix	588e7b9	1134510000.0	loadtime/src/org/aspectj/weaver/loadtime/Aj.java
120693	Contribution: More Efficient Lint Warnings: ~15% Performance Increase	In profiling a load-time weaving configuration from HEAD, I found that 9% of total time (over 10% of weaving time) is spent in org.aspectj.weaver.Lint.clearSuppressions(), mostly from use inside BcelClassWeaver.matchI made a small change in the parts of BcelAdvice that clear suppressions to save the list that was cleared and to only clear these. This alone saves about 15% of total CPU time in start up on my sample configuration. Created attachment 31681Patch to weaver module that significantly reduces performance impact of supressing lint warnings (about 20%) made it into RC1 by the skin of its teeth! I'm currently testing an almost identical solution to your patch (which I added before the patch was attached to the bug report). If the bar stays green I'll put it in. fix now in tree fix available 	2005-12-13 15:03:54	1134500000.0	resolved fixed	bdafe31	1134510000.0	weaver/src/org/aspectj/weaver/Lint.java weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java
120543	Issue version message during load-time weaving	"It would be very useful to know exactly which version of the weaver is being used for LTW. An informational message could be issued when each WeavingAdaptor instance is created (it is possible to have multiple versions of AspectJ in a system). This message could be similar to the that issued by ""ajc -version"". Created attachment 31629Modified testcase and implementation1. Modified test XML to check for version message2. Issue information message during WeavingAdaptor creation fix checked in. fix available. "	2005-12-13 06:40:30	1134470000.0	resolved fixed	9d32b76	1134480000.0	weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java
120521	named pointcut not resolved in pertarget pointcut	"Get incorrect error ""can't find pointcut ..."" when declaring pertarget pointcut using pointcut declared outside the aspect.  True of HEAD right now.  Not true of pointcuts declared inside the aspect or issingleton aspects.I thought this was reported and fixed, but I couldn't find the bug.  Sorry if it is a duplicate.-------------------------------------------------package bugs;public class PerTargetSubaspectError {	public static void main(String[] args) {		C.run();	}	static class C {		static void run() {}	}	pointcut doit() : execution(void C.run());	// no error if not pertarget	static aspect CPT pertarget(pc()){                 // no error if doit() defined in CPT		protected pointcut pc() : doit(); // unexpected CE		before() : doit() {} // no CE	}} this is a recent regression - I have a dev build from 30th November that doesnt have this problem. right, I've found it.  Not soooo much of a regression as exposing a problem we always had.  Sometimes during resolution we just 'defaulted' to persingleton as the perclause and used the right one later on.  To solve a problem with parameterized pertypewithin clauses I made the code return the *right* perclause in every case - so now we concretize the pc() in the pertarget clause - and we don't check the outertype for the pointcut definition.  I've fixed this to check the outertype - seems to work fine.waiting on build. fix available. "	2005-12-13 03:18:43	1134460000.0	resolved fixed	ae500c6	1134470000.0	tests/bugs150/pr120521/PerTargetSubaspectError.java tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java
120401	add signature to UnresolvedType.parameterize(..) exception	"I keep getting UnresolvedType UnsupportedOperationException unhelpful message ""resolve this type first,"" so I'm adding the signature to the message (without permission, hence the bug as notice).throw new UnsupportedOperationException(""unable to parameterize unresolved type: "" + signature);-------------------------------java.lang.UnsupportedOperationExceptionat org.aspectj.weaver.UnresolvedType.parameterize(UnresolvedType.java:218)at org.aspectj.weaver.patterns.ExactTypePattern.parameterizeWith(ExactTypePattern.java:242)at org.aspectj.weaver.patterns.TypePatternList.parameterizeWith(TypePatternList.java:195)at org.aspectj.weaver.patterns.DeclareParents.parameterizeWith(DeclareParents.java:77)at org.aspectj.weaver.ReferenceType.getDeclares(ReferenceType.java:484)at org.aspectj.weaver.ResolvedType.collectDeclares(ResolvedType.java:523)at org.aspectj.weaver.ResolvedType.collectCrosscuttingMembers(ResolvedType.java:488)at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect(CrosscuttingMembersSet.java:60)at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.addCrosscuttingStructures(AjLookupEnvironment.java:378)at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.addCrosscuttingStructures(AjLookupEnvironment.java:388)at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.collectAllITDsAndDeclares(AjLookupEnvironment.java:314)at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:168)at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301)at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:230)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:185)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:163)at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)UnsupportedOperationException thrown: resolve this type first so ....  are you able to recreate this with a nice signature coming out now Wes?  I guess it'll require you hacking your change into AJDT.  It just might be related to your other bug (119570) which was to do with processing types in the wrong order... change is now available in the latest build. "	2005-12-12 12:11:27	1134410000.0	resolved fixed	3ac4627	1134410000.0	weaver/src/org/aspectj/weaver/UnresolvedType.java
120363	LTW weaver include and exclude does not behave correctly	"According to the specification (http://www.eclipse.org/aspectj/doc/next/adk15notebook/ltw-configuration.html) ""The set of types to be woven are those types matched by at least one weaver include element and not matched by any weaver exclude element."" However if an includ elemement can be fast matched e.g. ""com.foo..*"" any exclude elements are ignored (see bug 117854). There is no explicit test in the harness for this feature. Created attachment 31562Testcase and fix for uding include and exclude together1. Modified dump before and after testcase to weave test but not accompanying ""proxy"" i.e. class with funny name2. Fix to ClassLoaderWeavingAdaptor.accept() to only perform fast match for include if there are no exclude patterns. patches checked in. fix available. "	2005-12-12 08:42:34	1134400000.0	resolved fixed	9edb4b6	1134400000.0	loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java tests/java5/ataspectj/ataspectj/Test$$EnhancerByCGLIB$$12345.java tests/java5/ataspectj/com/foo/bar/Test$$EnhancerByCGLIB$$12345.java tests/java5/ataspectj/com/foo/bar/Test.java tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java
120351	cflowbelow issue when binding, in @AJ	"<Pyinson Data Over Head> spotted issue in exposed statedcommiting fixnote: Sam, pointcut is not what you want in your sample:        @Pointcut(""this(testCase) && this(TestCase) && execution(void test*())"")                                          ^^^^^^^^^^^// need FQN in @AJ, and actually don't need it since you use a binding with another this(testCase)        public void inTestClass(TestCase testCase) { fix available "	2005-12-12 05:17:15	1134380000.0	resolved fixed	979124d	1134380000.0	tests/java5/ataspectj/ataspectj/bugs/CflowBelowStackTest.java tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java weaver/src/org/aspectj/weaver/bcel/BcelShadow.java
119451	AJDoc produces incorrect warning for package accessed aspects	"// Main.javapackage bug;public class Main {}aspect LogMain {	}Generating ajdoc through Eclipse (AJDT 1.3.0.20051206092602, AspectJ 1.5.0.20051206103951) generate incorrect warning for the LogMain aspect:> Calling ajc...> Building signature files...> Calling javadoc...Loading source file C:\work\aop\src\ajdocworkingdir\bug\Main.java...Constructing Javadoc information...C:\work\aop\src\ajdocworkingdir\bug\Main.java:11: class LogMain is public, should be declared in a file named LogMain.javapublic class  LogMain {       ^Standard Doclet version 1.5.0_04Building tree for all the packages and classes...Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\bug/\LogMain.html...Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\bug/\Main.html...Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\bug/\package-frame.html...Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\bug/\package-summary.html...Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\bug/\package-tree.html...Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\constant-values.html...Building index for all the packages and classes...Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\overview-tree.html...Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\index-all.html...Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\deprecated-list.html...Building index for all classes...Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\allclasses-frame.html...Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\allclasses-noframe.html...Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\index.html...Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\help-doc.html...Generating c:\work\aop\src\workspace\AJDocPackageAspect\doc\stylesheet.css...1 warning> Decorating html files...> Decorating C:\work\aop\src\workspace\AJDocPackageAspect\doc\bug\Main.html...> Removing generated tags (this may take a while)...> Finished. The issue here might be that aspects are always considered public by the compiler and hence by the ASM.  I recall Adrian doing something to address that at some point back.  What does AJDT do to recognize package visibility of aspects? As far as I'm aware AJDT doesn't do anything to recognise the package visibility of aspects - this is all handled by the compiler. All the error messages that come out when aspects aren't visible come from the compiler. Is this what you meant? Just as a note...> The issue here might be that aspects are always considered public by the> compiler and hence by the ASM.  I recall Adrian doing something to address that> at some point backI believe this was done as part of bug 82752. This stuff is in AsmHierarchyBuilder, and as you point out Helen it's failing to pring the right source signature even though the accessibility on the node is correct.  So it looks like the following method:	private String genSourceSignature(TypeDeclaration typeDeclaration) {		StringBuffer output = new StringBuffer();		typeDeclaration.printHeader(0, output);		return output.toString();	}Should print modifiers explicitly, possibly more like this one:private String genSourceSignature(ConstructorDeclaration constructorDeclaration) {		StringBuffer output = new StringBuffer();		ASTNode.printModifiers(constructorDeclaration.modifiers, output);But ensuring to use Adrian's getDeclaredModifiers() fix:        int typeModifiers = typeDeclaration.modifiers;        if (typeDeclaration instanceof AspectDeclaration) {        	typeModifiers = ((AspectDeclaration)typeDeclaration).getDeclaredModifiers();        }	Let me know how it goes. Created attachment 31460zip file of patches containing fix and testsThanks Mik that fixes the problem:-) What I've done is to keep the logic within genSourceSignature(TypeDeclaration typeDeclaration) as is and instead modified the printHeader(int,StringBuffer) method within AspectDeclaration to use the declaredModifiers field that Adrian introduced as part of the fix for bug 82752 rather than the modifiers field which has the ""public"" added to it. One consequence of the fix to remove ""public"" from the source signature is that in StubFileGenerator.genSourceSignature(IProgramElement) which translates ""aspect"" to ""class"", there was a check that fistly ""aspect"" was there and secondly it wasn't "".aspect"". However this assumes that there is something before the ""aspect"" which is no longer certain. Therefore, I've added an extra check for ""aspect"" being the first word in the signature.The attached zip file contains 3 patches:- pr119451-ajde-patch.txt : apply to the ajde project. This contains an added assert in one of the tests to check that ""public"" isn't in the signature of an aspect not declared public- pr119451-ajdoc-patch.txt : apply to the ajdoc project. This contains the change to StubFileGenerator mentioned above- pr119451-org-aspectj-ajdt-core-patch.txt : apply to the org.aspect.ajdt.core project. This contains the change to AspectDeclaration also mentioned above. Helen, shall I go ahead and apply these, or is someone doing that on your end? Hi Mik, I think Andy has committed the patches :-) Excellent.  Nice work helen :)Ajdoc has some pretty horrible modularity and could use some serious refactoring, but without any major feature needs it's probably easiest to leave it as-is. fix available. oops, forgot to mark resolved! "	2005-12-06 12:39:40	1133890000.0	resolved fixed	5f8d2cd	1134120000.0	ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java
119353	Inconsistent Implementations of ReferenceType.getDeclaredMethods()	"I am running into a problem in load-time weaving when I use reflection delegates because the weaver is generating an incorrect bridge method when I perform an inter-type declaration on Struts.ActionServlet for the init method. On investigation, the BCEL world is recognizing this as an overriding method, because its version of getDeclaredMethods is returning the declared methods for all ancestor superclasses. However, the reflection world is returning only the declared methods for this one class. It therefore appears that the weaver expects getDeclaredMethods to return all of them (making the name quite misleading). I think previously the method was being implemented inconsistently between 1.5 reflection and <1.5 reflection delegates. But it looks like it needs to be handled consistently to include all superclass methods.However, I don’t know what other places (e.g., the MAP) are really expecting getDeclaredMethods and its siblings to behave like Java reflection's version…I started work on adding a getAllDeclaredMethods method to ReferenceType and delegates, as an alternative to provide the weaver the ability to check method overriding as in this case, but it's a little bit involved and I wanted to flag the issue first.Here's a test that fails and illustrates the issue:Index: ReflectionBasedReferenceTypeDelegateTest.java===================================================================RCS file: /home/technology/org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java,vretrieving revision 1.5diff -u -r1.5 ReflectionBasedReferenceTypeDelegateTest.java--- ReflectionBasedReferenceTypeDelegateTest.java	28 Nov 2005 17:44:40 -0000	1.5+++ ReflectionBasedReferenceTypeDelegateTest.java	6 Dec 2005 04:11:41 -0000@@ -238,6 +238,18 @@         assertTrue(""Superclass for Map generic type should be Object but was ""+rt2,rt2.equals(UnresolvedType.OBJECT));              }     +    public void testCompareSubclassDelegates() {+        world.setBehaveInJava5Way(true);+        +        BcelWorld bcelWorld = new BcelWorld();+        bcelWorld.setBehaveInJava5Way(true);+        UnresolvedType javaUtilHashMap = UnresolvedType.forName(""java.util.HashMap"");+        ReferenceType rawType = (ReferenceType)bcelWorld.resolve(javaUtilHashMap );+        +        ReferenceType rawReflectType = (ReferenceType)world.resolve(javaUtilHashMap );+        assertEquals(rawType.getDelegate().getDeclaredMethods().length, rawReflectType.getDelegate().getDeclaredMethods().length);+    }+     	// todo: array of int	  	protected void setUp() throws Exception {This results in:junit.framework.AssertionFailedError: expected:<41> but was:<29>	at junit.framework.Assert.fail(Assert.java:47)	at junit.framework.Assert.failNotEquals(Assert.java:282)	at junit.framework.Assert.assertEquals(Assert.java:64)	at junit.framework.Assert.assertEquals(Assert.java:201)	at junit.framework.Assert.assertEquals(Assert.java:207)	at org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegateTest.testCompareSubclassDelegates(ReflectionBasedReferenceTypeDelegateTest.java:250)	at java.lang.reflect.Method.invoke(Native Method)	at junit.framework.TestCase.runTest(TestCase.java:154)	at junit.framework.TestCase.runBare(TestCase.java:127)	at junit.framework.TestResult$1.protect(TestResult.java:106)	at junit.framework.TestResult.runProtected(TestResult.java:124)	at junit.framework.TestResult.run(TestResult.java:109)	at junit.framework.TestCase.run(TestCase.java:118)	at junit.framework.TestSuite.runTest(TestSuite.java:208)	at junit.framework.TestSuite.run(TestSuite.java:203)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) Two small clarifications: the incorrect bridge method results in a VerifyError. If I use only BCEL delegates then the system behaves properly. I modified the test program to output what the differences are between the two sets.  Interesting results:Couldn't find java.util.HashMap java.util.HashMap.init(int) in the bcel setCouldn't find java.util.HashMap java.util.HashMap.init() in the bcel setCouldn't find java.util.HashMap java.util.HashMap.init(java.util.Map) in the bcel setCouldn't find java.util.HashMap java.util.HashMap.init(int, float) in the bcel setCouldn't find void java.util.HashMap.<init>(int, float) in the reflection setCouldn't find void java.util.HashMap.<init>(int) in the reflection setCouldn't find void java.util.HashMap.<init>() in the reflection setCouldn't find void java.util.HashMap.<init>(java.util.Map) in the reflection setCouldn't find void java.util.HashMap.<clinit>() in the reflection setI don't like the disagreement between the 'init' and '<init>' strings.  I suspect that is the root of this problem.  I'm not sure about the <clinit> - but at least we know that can't have an impact on bridge methods ;)I'm not sure how this quite ties up with Rons description that getDeclaredMethods() is differing in each case as the initial fix here just seems to be transforming the reflection based entries for ctors to indicate <init>... Created attachment 31379Patch to the delegates (1.5 and < 1.5)Ron ... this zip contains two patches, one for the weaver project, one for weaver5 - can you try it out and see if it helps your situation with the rogue bridge method?  Basically I've made the reflection world return the same thing as the bcel world.  The test I modified still fails because of the <clinit> method but that shouldnt impact bridge method creation. Hmmm .. I just re-read the original append by Ron.In my case I wasn't getting 41 and 29, I was getting 41 and 40.perhaps I'm not running it in quite the same way - i'll keep hacking away - but if you could try the patch it might help with the bridge problem. I will try the patches and report back...On closer examination, the 29 vs 41 methods I was seeing was on a Java 1.3.1 VM but running in Eclipse where the Java 1.5 JRE was on the classpath and BCEL was using that to resolve types (!). When corrected to use a 1.3 JRE in Eclipse, I see 29 vs 30 methods on a Java 1.3 VM and I always saw 40 vs 41 on a Java 1.5 VM. Hopefully this test will show 29 vs 30 when run via ant (the docs on how to run ant tests for a module from the command line aren't working for me...)Reflect:put, clone, get, access$000, access$100, values, size, access$200, clear, remove, access$300, loadFactor, keySet, entrySet, isEmpty, containsValue, containsKey, rehash, putAll, writeObject, readObject, capacity, getHashIterator, access$308, access$110, init, init, init, initBCEL:<init>, <init>, <init>, <init>, size, isEmpty, containsValue, containsKey, get, rehash, put, remove, putAll, clear, clone, keySet, values, entrySet, getHashIterator, writeObject, readObject, capacity, loadFactor, access$000, access$100, access$200, access$308, access$110, access$300, <clinit> It looks like those patches fix the problem (although I had to patch the patches to use an IReflectionWorld interface that my LTWWorld implementation also implements :-)). I am not seeing the same error messages and things appear to be working properly on a quick run. Thanks! fixes checked in - thanks for trying them out Ron. waiting on build. oops - closed prematurely.  i'm really waiting on the build... fix available. "	2005-12-05 23:11:15	1133840000.0	resolved fixed	b52515f	1134120000.0	weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java
109614	[waiting-on-build] [iajc.task] java.lang.RuntimeException: Ranges must be updated with an enclosing instructionList	"<Pyinson Data Over Head> Passing over to AspectJ It is blowing up whilst processing the shadow for a constructor call - is thereanyway we can have the rest of the iajc output?  At the top of the input itlooks it was truncated so you just added the exception trace to the bug report -but if you include the earlier stuff (where the ""| method-call"" stuff is), I maybe able to see what went wrong.  Is it at all possible that you could attach the AdminUserMB class and the aspectyou used on it? Created attachment 27178Class that is failing to compile Created attachment 27179Aspect Looks like a compiler bug, not an ant task bug.  Let me know if I can help. We have recently added extra diagnostics to AspectJ that will give us morecontext about a failure when the compiler goes bang.  Can you possibly downloadthe latest dev build and recreate this? Hopefully the exception produced will bemore informative. moving to P2 I've been trying to recreate this.  I can use the aspect just about as is - but the AdminUserDB class just has too many dependencies.  I created a cut down version but can't get a failure.Is it still failing for you?Please can you try it with the most recent compiler version and include *all* the output here so I can see exactly which constructor-call shadow is causing the problem?  I really want to fix this for 1.5 - but if I can't recreate it, theres nothing I can do.What would also be helpful is to try trimming down the code in the AdminUserDB class and see when the error suddenly disappears.or if you could supply me all the dependencies for that class (the orbitz stuff) then I can try harder to recreate it here. I've recreated this (woohoo) using the comment on bug 93489. I'll work on it tmrw. Fix for this is checked in. fix available. "	2005-09-15 09:57:46	1126790000.0	resolved fixed	94159f9	1134040000.0	tests/bugs150/pr109614.java tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java weaver/src/org/aspectj/weaver/bcel/BcelShadow.java
119352	AjType.getSupertype breaks for null	"I ran into this while using reflection proxies with LTW... See attached patches for these test cases and my fix:	public void testObjectSupertype() {		AjType<?> objectSuper = AjTypeSystem.getAjType(Object.class).getSupertype();		assertNull(objectSuper);			}	public void testInterfaceSupertype() {		AjType<?> serializableSuper = AjTypeSystem.getAjType(Serializable.class).getSupertype();		assertNull(serializableSuper);			}		public AjType<? super T> getSupertype() {		Class<? super T> superclass = clazz.getSuperclass();		return superclass==null ? null : (AjType<? super T>) new AjTypeImpl(superclass);	} Created attachment 31169Module patch for aspectj5rt I'll let Adrian take a look. patch applied, thanks :)waiting on build... fix available. "	2005-12-05 23:04:42	1133840000.0	resolved fixed	6e8bf52	1133880000.0	aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/AjTypeImpl.java aspectj5rt/java5-testsrc/org/aspectj/internal/lang/reflect/AjTypeTests.java
118715	Load Time Weaving wipes out Xlint files if no Xlint values	"In ClassLoaderWeavingAdaptor if weaverOption.lint is null, then a loaded Xlint properties file gets overwritten by the default Xlint properties. See attached patch to fix this problem. Created attachment 30903Only parse default Xlint properties if an explicit Xlint properties file hasn't been loaded. Still allows Xlint options to override the values in a property file. Created attachment 30959New Xlint configuration for LTW1. New xlint LTW tests2. New <run class=""Test"" xlintfile=""mylint.properties""/> attribute3. New ordering for configurationThis patch includes the previous one. Created attachment 31016New Xlint configuration for LTW1. Modified xlint file copy so that it's not renamed2. Fixed small bug in WeavingAdaptor Created attachment 31020New Xlint configuration for LTW2nd try From email:To test this, I need to copy a resource file (an Xlint.properties file) over to the sandbox directory to be accessible from the classloader at runtime. Is there any means already defined for copying resources over to the sandbox? Ron There is no mechanism for resource copying and there is no test (that I can find) for ""-Xlintfile"" in aop.xml. In fact there are no explicit Xlint LTW tests. I will add the necessary logic to the harness to copy an Xlint.properties file because I have already done it for aop.xml. However I don't think the current implementation is correct nor do I think your patch completely fixes it. I believe it should work like this:1. Load XlintDefault.properties (otherwise all lint messages are WARNING)2. Overlay LTW defaults i.e. ignore ""adviceDidNotMatch"" (see bug 117854)3. Overlay user ""-Xlintfile"" (so they only have to specify the messages they want to tailor)4. Override with user ""-Xlint"" optionMatthewI agree: your proposed design sounds right: the user’s Xlintfile should be able to just partially override the defaults. And thanks for adding the logic to copy Xlint.properties files.Ron all checked in. fixes available. "	2005-11-30 16:53:40	1133390000.0	resolved fixed	1e1bbb3	1133870000.0	loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java testing/newsrc/org/aspectj/testing/OutputSpec.java testing/newsrc/org/aspectj/testing/RunSpec.java testing/newsrc/org/aspectj/testing/XMLBasedAjcTestCase.java tests/src/org/aspectj/systemtest/ajc150/ltw/LTWTests.java weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java
118149	AspectJ compiler crahses possibly due to poincut context binding issue	<Pyinson Data Over Head> Ramnivas, to investigate this further we need to know the complete pointcuts you are using,  what are the definitions of pc1() and pc2() (and any other required pointcuts)?We know the shadow that is causing the problem:constructor-execution(voidcom.aspectivity.mgmt.web.entity.ManageEntity.<init>(com.aspectivity.mgmt.model.Entity,boolean, java.lang.String, java.lang.String, java.lang.String,java.lang.String, java.lang.String))so that + the pointcuts should be enough to progress. Andy,Here is the pointcut along with relevant parts of base and derived aspect.public abstract aspect AbstractEntityManagementAspect {    public abstract pointcut entityAccessor(CommonEntity entity);    ... advice to the pointcut...}public aspect UIDEntityManagementAspect extends AbstractEntityManagementAspect {    public pointcut entityAccessor1(CommonEntity entity)        : (execution(* CommonEntity+.add*(CommonEntity+))           || (execution(* CommonEntity+.remove*(CommonEntity+))))          && within(CommonEntity+)          && args(entity) && if(entity != null);       public pointcut entityAccessor2(CommonEntity entity)        : execution(ManageEntity.new(CommonEntity+, ..))           && within(ManageEntity)          && args(entity, ..)           && if(entity != null);        public pointcut entityAccessor(CommonEntity entity)        : entityAccessor1(entity) || entityAccessor2(entity);    declare parents: Entity implements CommonEntity;} Created attachment 31107testcase patchApply the patch to the tests project.With the given information in the previous comment I've recreated the problem and created an AJ testcase.Note everything compiles fine (no NPE) ifpublic pointcut entityAccessor2(CommonEntity entity)    : execution(ManageEntity.new(CommonEntity+, ..))       && within(ManageEntity)      && args(entity, ..)                          <-------------      && if(entity != null);is changed to:public pointcut entityAccessor2(CommonEntity entity)    : execution(ManageEntity.new(CommonEntity+, ..))       && within(ManageEntity)      && args(entity)                               <--------------      && if(entity != null); Another note...it also doesn't fail (no NPE) if the two if pointcuts are removed ie. if we have:    public pointcut entityAccessor1(CommonEntity entity)        : (execution(* CommonEntity+.add*(CommonEntity+))           || (execution(* CommonEntity+.remove*(CommonEntity+))))          && within(CommonEntity+)          && args(entity);    public pointcut entityAccessor2(CommonEntity entity)        : execution(ManageEntity.new(CommonEntity+, ..))           && within(ManageEntity)          && args(entity, ..) ;    public pointcut entityAccessor(CommonEntity entity)        : entityAccessor1(entity) || entityAccessor2(entity);    declare parents: Entity implements CommonEntity;Then the tests pass. Created attachment 31118simplified testcaseApply patch to the tests project.This patch contains a simplified testcase to the one previously attached. It contains the three things needed to recreate this bug:* An OR pointcut* if pointcut* args(something,..) Thanks for the test case - that helped a lot. I've followed the code paths through, and found the cause of the bug. At the join point for the constructor taking (String, boolean), the side of the pointcut that matches using args(String) can never match, and so does not bind any variable. The other side of the pointcut does of course match in this case. Because there is no binding in that branch (legitimately) the Var can be null when we come to look at it. After much careful investigation, the fix is a simple one-line change to IfPointcut.findResidue to cope with this case.Fix committed in tree, waiting on build. fix available. 	2005-11-27 01:01:55	1133070000.0	resolved fixed	d43e74b	1133840000.0	tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java weaver/src/org/aspectj/weaver/patterns/IfPointcut.java
118698	Not Allowing Access to Private ITD inside Nested Type	"AspectJ is failing to allow access to a private ITD field from a type nested inside the aspect, which is inconsistent with Java's access rules.Here is the source. See also the follow up patch to tests that integrates it into the ajc150 test suite.public aspect prUnknown {    private static interface Marker {}       private class Foo implements Marker {		public Foo() {            bar = null; // allowed            listener = null; // should also be allowed            this.listener = null; // so should this            Marker.this.listener = null; // and this            ((Marker)this).listener = null; // and this        }    }    private Object Marker.listener;    private Object bar;} Created attachment 30893Patch to tests module that integrates this test case into the ajc150 test suite. I have a fix for most of the cases.  All except 1 and I'm not sure if its a bug or not:public aspect pr118698 {    private static interface Marker {}       private class Foo implements Marker {		public Foo() {            bar = null; // works            listener = null; // works            this.listener = null; // works            Marker.this.listener = null; // FAILS            ((Marker)this).listener = null; // works        }    }    private Object Marker.listener;    private Object bar;}you can see above which case fails - with a message:No enclosing instance of the type pr118698.Marker is accessible in scopeSo I mocked up a Java equivalent (kind of...):public class A {    private static class Marker { private Object listener; }    private class Foo extends Marker {      public Foo() {        Marker.this.listener = null; // FAILS        ((Marker)this).listener = null; // works      }    }}The failure message in this case is the same (javac flavour message):A.java:7: not an enclosing class: A.Marker        Marker.this.listener = null;              ^1 errorSo ... I'm not currently sure if the failing case with my fix in is supposed to be possible. That sounds great: thanks for fixing the bug so quickly. You are right, I was trying different forms but the one that's failing should be failing:Marker.this.listener = null;is an error, since Marker.this is only valid in a nested type just checked in the test program and fix for this. fix available "	2005-11-30 15:18:31	1133380000.0	resolved fixed	6d94d09	1133520000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeFieldBinding.java tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java
118781	[waiting-on-build]VerifyError in AspectJ	"I'm fairly new to AspectJ, so this is probably not going to be well explained. I've started working on a project that was working fine. Then I added methods to classes that take a 2-dimensional string array parameter and suddenly I'm getting a VerifyError exception.java.lang.VerifyError: (class: com/drkw/cpds/obligor/facades/version_1_00/ObligorDetailFacade_1_00, method: searchForObligorSummariesByGroup_aroundBody24 signature: (Lcom/drkw/cpds/obligor/facades/version_1_00/ObligorDetailFacade_1_00;[[[Ljava/lang/String;Ljava/lang/String;LjavaÀ(&#130;	at com.drkw.cpds.obligor.facades.version_1_00.obligor.ObligorManager.<clinit>(ObligorManager.java:48)	at com.drkw.cpds.obligor.integration.version_1_00.obligor.GetObligorDetailsGroupingTest.testGetObligorDetailsUsingGroups(GetObligorDetailsGroupingTest.java:45)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) Are you able to attach any of the code that leads to this problem?  perhaps at least the ITD statements you are using?Are you working with Java5 constructs (generics?) or just regular 1.4 java?What level of the compiler are you on, the latest? I'm using:Java 1.4.2_07Eclipse 3.1.1AspectJ dev tools 1.3.0 build 20051130095036Sorry - dont know what you mean by ITD.I think the method I've added that's causing the problem is public ObligorDetail[] searchForObligorDetailsByGroup(String[][] mistralId, String name, String country, String legalEntity, Integer startPosition, Integer pageSize, SortKey[] sortKeys) throws BusinessException;We have a similar method that takes a single-dimension array as the first parameter instead of this 2-dimension array but is the same otherwise. That's been working fine for ages. Oh, I see from the code, you have advised the method with around advice.  I initially assumed when you said 'added a method to a class' that you had made an inter-type declaration ITD, something like:public void SomeClass.newMethod() {}Can you tell me the signature for the around advice (and the pointcut) that you are using to match this?public ObligorDetail[] searchForObligorDetailsByGroup(String[][] mistralId,String name, String country, String legalEntity, Integer startPosition, IntegerpageSize, SortKey[] sortKeys) throws BusinessException;In the meantime, I'll try a similar method with two dimensional params. I said I wouldnt explain it well, didnt I ;-)Hope this makes sense. I'm also trying to start with a simplest case of a class and an aspect to try to isolate this, but at the moment I'm getting other exceptions.The java method is:public ObligorSummary[] searchForObligorSummariesByGroup(String[][] mistralId, String name, String country, String legalEntity, Integer startPosition, Integer pageSize, SortKey[] keys) throws BusinessException;The classname is ObligorDetailFacade_1_00 which extends abstract class ObligorManagerThere are 2 around advices:a) Object around() throws AspectException : no_transaction_required_calls()with pointcutpointcut no_transaction_required_calls(): all_1_00_Calls() && !transaction_required_calls();b) Object around() throws AspectException, SystemException : all_1_00_Calls();pointcut all_1_00_Calls is defined as:pointcut all_1_00_Calls(): !callGetInstance() && (callXref_1_00() || callObligor_1_00() || callVerify_1_00());where the callObligor_1_00 is the one that matches here...pointcut callObligor_1_00(): execution(public * com.drkw.cpds.obligor.facades.version_1_00.obligor.ObligorManager+.*(..)); I've now reproduced this with a simple class...--- Class ---package blah;import java.util.Random;public class MyClass {	public Integer[] getRandomInt(String[][] param)	{		for (int i = 0; i < param.length; i++)		{			System.out.print(""["" + i + ""] = ["");			for (int j = 0; j < param[i].length; j++)			{				System.out.print(param[i][j]);				if (j != param[i].length-1)					System.out.print(',');			}			System.out.println(']');		}		return new Integer[] { new Integer(new Random().nextInt())};	}}--- Aspect ---package blah;public aspect MyAspect {	pointcut callPointCut(): call(public * blah.MyClass+.*(..));		Object around() : callPointCut() {		System.out.println(""start of around"");		Object result = proceed();		System.out.println(""end of around"");		return result;	}}--- Main class ---package blah;/** */public class MyMain {	/**	 * @param args	 */	public static void main(String[] args)	{		MyClass mc = new MyClass();		mc.getRandomInt(new String[][]{{ ""a"", ""b"", ""c""},{""x"",""y"",""z""}});	}}--- Exception --- java.lang.VerifyError: (class: blah/MyMain$AjcClosure3, method: run signature: ([Ljava/lang/Object;)Ljava/lang/Object;) Incompatible argument to function	at blah.MyMain.main(MyMain.java:15)Exception in thread ""main""  thanks for the simple testcase Ian ... but ... I still can't get it to fail for me :(I've tried in AJDT and from the command line, I've switched to a 1.4.2 vm from my usual 1.5 (although I'm on an earlier version of 1.4.2 than you).  Do you have any   options configured in the AspectJ pages for the project?  I'm just trying to work out the difference between your environment and mine...my ajdt is a little older than yours - i'll try updating that now to see if it makes a difference. Progress - sort of.I have Advanced/No Inline switched on. As soon as I turn it off and recompile, my simple case works.However it appears to make no difference to my main project. I'm still investigating. thats it!!  I can recreate it with -XnoInline turned on :) Good, that's pinpointed it. However I'm still not able to get past it in my real application, so all I've done is invalidate my simple test case.Any other suggestions welcome! Fix checked in ... we incorrectly handled multi-dimensional array signatures.  In fact String[][] was turning into String[][][] !!Fix will be in next aspectj dev build and in AJDT in a couple of days. fix available in latest AspectJ dev build - will probably be in AJDT on Monday. *** Bug 119408 has been marked as a duplicate of this bug. *** "	2005-12-01 03:43:53	1133430000.0	resolved fixed	a75b7fa	1133450000.0	tests/bugs150/pr118781/MyAspect.java tests/bugs150/pr118781/MyClass.java tests/bugs150/pr118781/MyMain.java tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java weaver/src/org/aspectj/weaver/World.java
117209	Runtime error - Stack size too large, Bug#69706 related.	"AspectJ compiler version: 1.5M5AJDT plugin version: 1.3.0This is the same error as reported by Bug#69706, even the bug is resolved I'm still experiencing problem by using the classes attached at the bottom.// RUNTIME ERROR MESSAGE========================Exception in thread ""main"" java.lang.VerifyError: (class: DefaultInterfaceImplementationRecipe, method: <clinit> signature: ()V) Stack size too large	at MyClass_ch16.main(MyClass_ch16.java:15)// MyClass_ch16.java====================public class MyClass_ch16{        public void foo(int number, String name)	{		System.out.println(""Inside foo (int, String) with args: "" + number + "":"" + name);	}	public static void main(String[] args)	{		// Create an instance of MyClass		MyInterface_ch16 myObject = (MyInterface_ch16)new MyClass_ch16();				// Make the call to foo		myObject.bar(""Russ"");	}}//MyInterface_ch16.java=======================public interface MyInterface_ch16{	public void bar(String name);}// DefaultInterfaceImplementationRecipe.aj==========================================public aspect DefaultInterfaceImplementationRecipe{	declare parents : MyClass_ch16 implements MyInterface_ch16;		// Declare the default implementation of the bar method	public void MyInterface_ch16.bar(String name)	{		System.out.println(""bar(String) called on "" + this);	}} *** Bug 117210 has been marked as a duplicate of this bug. *** Passing over to AspectJ Bug 69706 was related to using -XnoWeave.  I assume you aren't using -XnoWeave here?I tried M5 and the latest dev build on the command line - compiled those 3 files and they run OK, producing:C:\pr117209>java MyClass_ch16bar(String) called on MyClass_ch16@111a3acI've tried with -emacssym on too - I'll now try again in AJDT to see if that makes a difference. I use AJDT with the default setting - without checking any checkbox option in the Preferences/AspectJ/Compiler/Advanced tab, and check all checkbox options in the Other tab.I've tried with the latest M5 (1.3.0.20051121083802) and found the problem still exist.ThanksDavid(In reply to comment #3)> Bug 69706 was related to using -XnoWeave.  I assume you aren't using -XnoWeave> here?> > I tried M5 and the latest dev build on the command line - compiled those 3> files and they run OK, producing:> > C:\pr117209>java MyClass_ch16> bar(String) called on MyClass_ch16@111a3ac> > I've tried with -emacssym on too - I'll now try again in AJDT to see if that> makes a difference.>  Can I ask what JVM you are running your eclipse on? Sun/IBM/JRockit 1.3/1.4/1.5?I tried it in AJDT myself and those 3 files just compiled fine :(Can you possibly attach the .class files that are broken after the compilation has occurred? And I'll take a look straightaway.thanks. Created attachment 30450MyClass_ch16.class Created attachment 30451MyInterface-ch16.class Created attachment 30452DefaultInterfaceImplementationRecipe.class I use Sun JDk 1.5.0_05 and I've attached 3 classes files for your reference.But by looking at the class files decompiled by JODE, there is a missing method in MyInterface_ch16 and error in DefaultInterfaceImplementationReceipe.It's weird since in Eclipse there is no error message indicated any compilation error after I clicked on the Build AspectJ Project button.// decompiled DefaultInterfaceImplementationRecipe===================================================Exception while decompiling:java.lang.ArrayIndexOutOfBoundsException: 0	at jode.jvm.CodeVerifier.doVerify(CodeVerifier.java:1068)	at jode.jvm.CodeVerifier.verify(CodeVerifier.java:1102)	at jode.decompiler.MethodAnalyzer.analyze(MethodAnalyzer.java:610)	at jode.decompiler.ClassAnalyzer.analyze(ClassAnalyzer.java:325)	at jode.decompiler.ClassAnalyzer.dumpJavaFile(ClassAnalyzer.java:624)	at jode.decompiler.Decompiler.decompile(Decompiler.java:192)	at jode.swingui.Main.run(Main.java:204)	at java.lang.Thread.run(Unknown Source)// decompiled MyClass_ch16==========================/* MyClass_ch16 - Decompiled by JODE * Visit http://jode.sourceforge.net/ */public class MyClass_ch16{    public void foo(int number, String name) {	System.out.println(new StringBuilder			       (""Inside foo (int, String) with args: "").append			       (number).append			       ("":"").append			       (name).toString());    }        public static void main(String[] args) {	MyClass_ch16 myclass_ch16 = new MyClass_ch16();	DefaultInterfaceImplementationRecipe	    .ajc$interMethodDispatch1$DefaultInterfaceImplementationRecipe$MyInterface_ch16$bar	    (/*TYPE_ERROR*/ myclass_ch16, ""Russ"");    }}// decompiled MyInterface_ch16==============================/* MyInterface_ch16 - Decompiled by JODE * Visit http://jode.sourceforge.net/ */public interface MyInterface_ch16{}ThnaksDavid Findings for pr117209...When it works, the 3 classes look like this:public class MyClass_ch16 extends java.lang.Object implements MyInterface_ch16{    public MyClass_ch16();    public void foo(int, java.lang.String);    public static void main(java.lang.String[]);    public void bar(java.lang.String);}public interface MyInterface_ch16{    public abstract void bar(java.lang.String);}public class DefaultInterfaceImplementationRecipe extends java.lang.Object{    private static java.lang.Throwable ajc$initFailureCause;    public static final DefaultInterfaceImplementationRecipe ajc$perSingletonInstance;    static {};    public DefaultInterfaceImplementationRecipe();    void ajc$declare_parents_1();    public static void ajc$interMethod$DefaultInterfaceImplementationRecipe$MyInterface_ch16$bar(MyInterface_ch16, java.lang.String);    public static void ajc$interMethodDispatch1$DefaultInterfaceImplementationRecipe$MyInterface_ch16$bar(MyInterface_ch16, java.lang.String);    public static DefaultInterfaceImplementationRecipe aspectOf();    public static boolean hasAspect();    private static void ajc$postClinit();}In the failing code I've been sent:public class MyClass_ch16 extends java.lang.Object{    public MyClass_ch16();    public void foo(int, java.lang.String);    public static void main(java.lang.String[]);}public interface MyInterface_ch16{}public class DefaultInterfaceImplementationRecipe extends java.lang.Object{    private static java.lang.Throwable ajc$initFailureCause;    public static final DefaultInterfaceImplementationRecipe ajc$perSingletonInstance;    static {};    public DefaultInterfaceImplementationRecipe();    void ajc$declare_parents_1();    public static void ajc$interMethod$DefaultInterfaceImplementationRecipe$MyInterface_ch16$bar(MyInterface_ch16, java.lang.String);    public static void ajc$interMethodDispatch1$DefaultInterfaceImplementationRecipe$MyInterface_ch16$bar(MyInterface_ch16, java.lang.String);    public static DefaultInterfaceImplementationRecipe aspectOf();    public static boolean hasAspect();    private static void ajc$postClinit();}Differences:MyClass_ch16 is missing the method    public void bar(java.lang.String);MyInterface_ch16 is missing the method     public abstract void bar(java.lang.String);In the failing case, the clinit for DefaultInterfaceImplementationRecipe is:static {};  Code:   Stack=0, Locals=1, Args_size=0   0:   invokestatic    #14; //Method ajc$postClinit:()V   3:   goto    11   6:   astore_0   7:   aload_0   8:   putstatic       #16; //Field ajc$initFailureCause:Ljava/lang/Throwable;   11:  return  Exception table:   from   to  target type     0     3     6   Class java/lang/ThrowableIn the working case, the clinit for DefaultInterfaceImplementationRecipe is:static {};  Code:   Stack=1, Locals=1, Args_size=0   0:   invokestatic    #14; //Method ajc$postClinit:()V   3:   goto    11   6:   astore_0   7:   aload_0   8:   putstatic       #16; //Field ajc$initFailureCause:Ljava/lang/Throwable;   11:  return  Exception table:   from   to  target type     0     3     6   Class java/lang/ThrowableNotice the 'stack is 0 in the failing case and 1 in the working case'.The missing meethods and incorrect stack are exactly what I saw for 69706 (see comment 4 in that bug).You mentioned that you turn on all the options in the 'Others' page for compiler options.  Do you see weaving messages in the problems view for the declare parents and ITD actually occurring then?Can you check that the project properties aren't overriding the workbench preferences.Can you try turning *on* 'no weave', doing a build, then turning it off again and rebuilding - just in case its a problem in how options are persisted? My project properties do override the workbench preferences. But doesn't matter how I change the properties, for instance uncheck ""Enable project specific settings"" or uncheck all opetions under Other tab, the result is still the same.Below are messages shown on the ""AJDT Event Trace"" view (not sure if this is the one you mentioned as problem view)## Build ourput while ""no weave"" is turned on22:41:16	 Build kind = FULLBUILD22:41:16	 build: No structure model to be built for project: AspectJ cookbook22:41:16	 Project=AspectJ cookbook         kind of build requested =Full AspectJ compilation22:41:17	 Builder: Tidied output folder, deleted 267 .class files from C:\codes\aspectjcookbook_examples\bin22:41:19	 Timer event: 1963ms: Time to first compiled message22:41:22	 Timer event: 5838ms: Total time spent in AJDE22:41:23	 Timer event: 70ms: Create element map (338 rels in project: AspectJ cookbook)22:41:23	 Types affected during build = 38022:41:23	 Timer event: 10ms: Add markers (83 markers)22:41:23	 Timer event: 6740ms: Total time spent in AJBuilder.build()## Build ourput while ""no weave"" is turned off22:41:52	 Build kind = FULLBUILD22:41:52	 build: No structure model to be built for project: AspectJ cookbook22:41:52	 Project=AspectJ cookbook         kind of build requested =Full AspectJ compilation22:41:52	 Builder: Tidied output folder, deleted 267 .class files from C:\codes\aspectjcookbook_examples\bin22:41:53	 Timer event: 1442ms: Time to first compiled message22:41:57	 Timer event: 5368ms: Total time spent in AJDE22:41:58	 Timer event: 60ms: Create element map (338 rels in project: AspectJ cookbook)22:41:58	 Types affected during build = 38022:41:58	 Timer event: 10ms: Add markers (83 markers)22:41:58	 Timer event: 6280ms: Total time spent in AJBuilder.build()22:42:10	 AJDTContentProvider.selectionChanged(): Marking visualiser content as out of date22:44:19	 AJDTContentProvider.selectionChanged(): Marking visualiser content as out of date By problems view I actually meant the standard Eclipse problems view - if you have the option 'Output weaving messages to problems view' then you should get entries in the problems view indicating that weaving is occurring - that would tell me whether weaving was occurring properly.  this entry in the event trace when no weave is turned 'off' worries me:22:41:52         build: No structure model to be built for project: AspectJ cookbookAfter the build has finished, do you normally see gutter markers etc in the editor and cross references view suggesting that weaving has occurred as you expect? My answer inline(In reply to comment #12)> By problems view I actually meant the standard Eclipse problems view - if you> have the option 'Output weaving messages to problems view' then you should get> entries in the problems view indicating that weaving is occurring - that would> tell me whether weaving was occurring properly.  Just checked ""Output weaving info message to problems view"" and rebuilt the project, but found no any error/warning message in the problem view.> > this entry in the event trace when no weave is turned 'off' worries me:> > 22:41:52         build: No structure model to be built for project: AspectJ> cookbook> When I checked ""Create a structure model during compilation"", the message you mentioned above disappeared. Below is the output message with ""Create a structure model during compilation"" checked.But if it's unchecked the message you mentioned will always show up.17:11:37	 Build kind = INCREMENTALBUILD17:11:37	 Project=AspectJ cookbook         kind of build requested =Full AspectJ compilation17:11:37	 build: Examined delta - no source file changes for project AspectJ cookbook17:11:37	 Timer event: 10ms: Add markers (83 markers)17:11:37	 Timer event: 20ms: Total time spent in AJBuilder.build()> After the build has finished, do you normally see gutter markers etc in the> editor and cross references view suggesting that weaving has occurred as you> expect?> Yes, and when I right-clicked it, a popup menu will show either ""Declared on"" (on DefaultInterfaceImplementationRecipe.aj) or  ""Aspect Declarations"" (on MyClass_ch16.java)to bring me to the right source code. <Pyinson Data Over Head> This bug gets stranger and stranger...> Just checked ""Output weaving info message to problems view"" and rebuilt the> project, but found no any error/warning message in the problem view.Weaving messages that come out will be info messages that go into that view - it's very strange that you get *none* and yet have gutter annotations for navigating the end result of the compilation, since the structure model gets built at exactly the same time as the info message comes out...hmmm.> When I checked ""Create a structure model during compilation"", the message > you mentioned above disappeared. Ok, at least this is behaving itself, you should always have the option 'create a structure model' checked.> Yes, and when I right-clicked it, a popup menu will show either ""Declared on""> (on DefaultInterfaceImplementationRecipe.aj) or  ""Aspect Declarations"" (on> MyClass_ch16.java)to bring me to the right source code.I just (at the moment) dont understand how you can get this correct output and yet end up with broken stuff on the disk.  Maybe we need to wipe the project properties for this project in some way.  I don't suppose you can try it in a completely different eclipse workspace can you?Can you check in the eclipse error log (its one of the views like the problem view that you can choose to show) - are there any errors in it that look like they might be related to this?Have you left all the standard compiler options as default?  Since all the Java base options are inherited by the ajc compiler.thanks.  sorry I don't seem to be able to solve this ... It looks like if I create a new AspectJ project and copy those 3 files from the problematic project to this new project, then the problem is gone.But the problematic project is created based on the examples downloaded from the book AspectJ cookbook. And what I did is to rename the 2 classes - MyClass.java and MyInterface.java in AspectJ cookbook ""chapter_16/Provide a default implementation of an interface"" to MyClass_ch16.java and MyInterface_ch16.java, the problem view/Error Lob view will show errors for other chapters due to the duplication of class name but there is no error warning for the chapter16.Even I have the same setting between new created project (which works fine) and old problematic project, the latter one always spit out error as I mentioned before.I am wondering if you can download the examples and rename class files in chapter16 and try for yourself ...ThanksDavid Hi.  I've downloaded all the code for the book. How precisely do you create AspectJ projects for it?  I see the prefix for all the code is 'aspectjcookbook_examples/chapter_XX' - did you create one AspectJ project for all the code in 'aspectjcookbook_examples' or do you create one project per 'aspectjcookbook_examples/chaper_XX' - i.e. one per chapter?  I'm basically interested in exactly what files you have in the failing project, is it just the 3 or is it everything from the book?cheers. My answer inline(In reply to comment #17)> Hi.  I've downloaded all the code for the book. How precisely do you create> AspectJ projects for it?  I see the prefix for all the code is> 'aspectjcookbook_examples/chapter_XX' - did you create one AspectJ project for> all the code in 'aspectjcookbook_examples' or do you create one project per> 'aspectjcookbook_examples/chaper_XX' - i.e. one per chapter?  I'm basicallyI just created one project for all chapters, and appended ""_ch16"" to all java files for chapter 16, which means only chapter 16 will compile and all the other chapters will get errors such as duplicated class name ...> interested in exactly what files you have in the failing project, is it just> the 3 or is it everything from the book?> > cheers.> The project has everything from the book (from chapter 2 to 22), but only chapter 16 compiles and run since I renamed them to the following names:MyClass_ch16.javaMyInterface_ch16.java Oh ......If you have errors during compilation, we don't weave - we assume the result will be invalid if we tried ... that's why this is happening.If you want to weave what might be broken code, you need to specify '-proceedOnError' - put it in the non-standard compiler options entry on the AspectJ preferences page for the project.  I believe there is a way to set it in the UI but I can't find it at the moment. (In reply to comment #19)> Oh ......> If you have errors during compilation, we don't weave - we assume the result> will be invalid if we tried ... that's why this is happening.> If you want to weave what might be broken code, you need to specify> '-proceedOnError' - put it in the non-standard compiler options entry on the> AspectJ preferences page for the project.  I believe there is a way to set it> in the UI but I can't find it at the moment.Looks like it's been fixed in Bug#74245 but unfortunately even with the flag ""-proceedOnError"" set on the ""Non standard compiler options"" I still get the same run-time error as shown below.p.s. I'm using Eclipse Version: 3.1.1 Build id: M20050929-0840 and AJDT Version 1.3.0.20051130095036***********************************************************Exception in thread ""main"" java.lang.VerifyError: (class: DefaultInterfaceImplementationRecipe, method: <clinit> signature: ()V) Stack size too large	at MyClass_ch16.main(MyClass_ch16.java:15)*********************************************************** I'm just working on another options related bug where what is specified in the 'extra options' panel doesn't get through to the compiler.  I'm putting a similar fix in for this.  I suspect we have a lot of compiler tests that check -proceedOnError works but no AJDE based tests that verify the path from AJDT is working correctly. fix checked in for ensuring '-proceedOnError' makes it across from AJDT to AJ. Thanks Andy, I will give it a try whenever I get a new DEV build tomorrow. it might take a day or so to appear in an AJDT build - i'll let you know through this bug report. Looks like the AJDT Version 1.3.0.20051201090854 still generates the same error. I'll try another new build tomorrow to see if your fix is in.Thanks I marked the abstract such that I'll comment in here when an AJDT build includes the fix - given the current number of AJ bugs I'm working on, I suspect AJDT won't get refreshed until Monday.I'll attach a patch you can apply yourself if you want to sort it out sooner. Created attachment 31015Patch to allow -proceedOnError to pass throughApply as follows.  Put this patch.zip in the org.aspectj.ajde plugin directory (somewhere under eclipse/plugins).  Choose the ajde plugin dated correctly as you may have several installed and you want to patch the latest.Then backup the ajde.jar file in that directory:copy ajde.jar ajde.jar.backupnow apply the patchjar -xvf patch.zipjar -uvf ajde.jar orgnow restart eclipse. Hi AndyJust did what you told me to do in the latest ajde directory (actually there is only one there since I uninstall all the old ajde plugins), below is the output of the jar command (sorry for the Chinese fonts, I set my locale to China) and I believe it successfully patch everything.I double-checked the the Non Standard Compiler Options was set to -proceedOnError and then rebuilt everything but found the result was still the same. Are you able to run it with the patch by yourself ?ThanksDavidC:\Eclipse\3.11\eclipse\plugins\org.aspectj.ajde_1.5.0.20051202173447>jar -xvf patch.zip&#23637;&#24320;:org/aspectj/ajdt/internal/core/builder/AjBuildConfig$1.class&#23637;&#24320;:org/aspectj/ajdt/internal/core/builder/AjBuildConfig$BinarySourceFile.class&#23637;&#24320;:org/aspectj/ajdt/internal/core/builder/AjBuildConfig.classC:\Eclipse\3.11\eclipse\plugins\org.aspectj.ajde_1.5.0.20051202173447>jar -uvf ajde.jar org&#22686;&#21152;:org/(&#35835;&#20837;= 0) (&#20889;&#20986;= 0)(&#23384;&#20648;&#20102; 0%)&#22686;&#21152;:org/aspectj/(&#35835;&#20837;= 0) (&#20889;&#20986;= 0)(&#23384;&#20648;&#20102; 0%)&#22686;&#21152;:org/aspectj/ajdt/(&#35835;&#20837;= 0) (&#20889;&#20986;= 0)(&#23384;&#20648;&#20102; 0%)&#22686;&#21152;:org/aspectj/ajdt/internal/(&#35835;&#20837;= 0) (&#20889;&#20986;= 0)(&#23384;&#20648;&#20102; 0%)&#22686;&#21152;:org/aspectj/ajdt/internal/core/(&#35835;&#20837;= 0) (&#20889;&#20986;= 0)(&#23384;&#20648;&#20102; 0%)&#22686;&#21152;:org/aspectj/ajdt/internal/core/builder/(&#35835;&#20837;= 0) (&#20889;&#20986;= 0)(&#23384;&#20648;&#20102; 0%)&#22686;&#21152;:org/aspectj/ajdt/internal/core/builder/AjBuildConfig$1.class(&#35835;&#20837;= 847) (&#20889;&#20986;= 461)(&#21387;&#32553;&#20102; 45%)&#22686;&#21152;:org/aspectj/ajdt/internal/core/builder/AjBuildConfig$BinarySourceFile.class(&#35835;&#20837;= 976) (&#20889;&#20986;= 545)(&#21387;&#32553;&#20102; 44%)&#22686;&#21152;:org/aspectj/ajdt/internal/core/builder/AjBuildConfig.class(&#35835;&#20837;= 13079) (&#20889;&#20986;= 4955)(&#21387;&#32553;&#20102; 62%)C:\Eclipse\3.11\eclipse\plugins\org.aspectj.ajde_1.5.0.20051202173447>=============================================================== The decompiled MyInterface_ch16.class still looks like below:==============================================================// Decompiled by DJ v3.7.7.81 Copyright 2004 Atanas Neshkov  Date: 12/2/2005 11:33:45 PM// Home Page : http://members.fortunecity.com/neshkov/dj.html  - Check often for new version!// Decompiler options: packimports(3) // Source File Name:   MyInterface_ch16.javapublic interface MyInterface_ch16{} Hmmm... just found that the same error message (ava.lang.VerifyError) can be reproduced easilly by the following steps.1. Create a new AspectJ project (says ""AspectJ in Action"")2. Import Java/Aspect source from ""AspectJ in Action\ch03\section3.3.1"" (Ramniva Laddad's book) - the java/aspect codes will be imported to the default package.2. Create a new class (says TestAccount.java) as below:    public class TestAccount {	public static void main(String[] args) {		Account act = new SavingsAccount(567);		act.credit(36.0f);		System.out.println(act.getAvailableBalance());	}    }3. Build and run the TestAccount - should be no problem till now.4. Create a new package named ""chapter3"".5. Move all java/aspect code to under the package ""chapter3"" by selecting all and then using Refactor->Move.6. Sometime the aspect file (MinimumBalanceRuleAspect) will disappear, if this is the case for you then just re-import it from the same directory. And manually add the package name to it.7. Try to rename the aspect file (MinimumBalanceRuleAspect) to .aj extension by using ""AspectJ Tools->Convert File Extension to .aj"".8. Rebuild the project and then run it.(*** Notice that the gutter markers are gone in the aspect file. And the java.lang.VerifyError will be shown ***) Looks like the problem I mentioned above is caused by the aspect file not being moved to the package directory. There are 2 exactly the same aspect file in 2 different directories and the project seems somehow still make use of the old aspect file (which remain in the default package directory).I have to manually remove the aspect file to make it run correctly. But this workaround doesn't apply to the bug that I opened(117209). I still have problem to run it with your patch :-( There are known problems with eclipse refactorings (like move...) when working with aspects and .aj files.  So i'm not surprised that didn't behave as expected -  I think we typically say use the navigator view to move files around, rather than the eclipse options in the package explorer.I've fully recreated your problem with my patch applied - I think the aspectjcookbook_examples project is just *too* broken with all those errors in it, so the weaver can't get on and do its job (so you get a verify error) - I believe -proceedOnError isn't helping because of how broken the project is.  What if you simply modify the set of source folders in the project (through project properties > Java Build Path) to remove all the source folders apart from the one you are working on?  I removed all but the ""chapter_16/Provide a default implementation"" then it compiled (much faster than the broken variant of the project) and ran happily. Thanks Andy for pointing out the existing issues with Eclipse. And I believe the workaround you proposed should work just fine.Thanks again. sorry it took so long to get to a solution that works for you! I should have thought of it earlier. "	2005-11-20 01:07:23	1132470000.0	resolved fixed	551b9ca	1133380000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java tests/multiIncremental/pr117209/base/src/Aspect.java tests/multiIncremental/pr117209/base/src/Broken.java tests/multiIncremental/pr117209/base/src/DefaultInterfaceImplementationRecipe.java tests/multiIncremental/pr117209/base/src/MyClass_ch16.java tests/multiIncremental/pr117209/base/src/MyInterface_ch16.java tests/multiIncremental/pr117209/base/src/P.java tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.java tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java
111667	Produce a compile warning when default advice precedence is applied	"I propose that the compiler spit out a warning anytime that it has to apply the default advice precedence.  Also, it should spit out the recommendation that default ordering is not guaranteed from release to release of the compiler.You can see the thread on aspectj-dev titled ""change in runtime execution order"" and the one on aspectj-users titled ""AJDT 1.3 and aspectj"" for the reasoning behind why this is a good thing. I'm considering adding a lint warning for this which will identify when multiplepieces of advice are hitting a join point.My problem is whether this should be on by default.  I don't think it shouldsince it will be massively annoying - but how would a user know to turn it on?hmmm...if you want to know the order of precedence that occurred, I really think youcan get that from -showWeaveInfo - for any join point you should see themessages in a particular order indicating the order in which the advice applied. its possibly not ideal but does it help in your case? Andy, I personally am in favor of having it on all the time as I view it as standard compiler type warning that is telling you that are doing something that may/may not be the right way to go.  I think of it in a similiar fashion to the C/C++ cast warnings I used to get all the time.  Now, I can understand why having it on all of the time might be annoying to some.  So I guess the -lint or -showWeaverInfo options are good approaches, but I still have the same reservations that you express.  I am not sure I would turn them on and this may come back to bite me.Now of course, having been burned by this I will definitely turn it.  Shall we propose this to the community for responses and discussions? andy says this will take him 5 seconds ;) Created attachment 30697The rewriter and testcase Damn - that was attached to the wrong bug, ignore it. err.. didnt quite take me 5 seconds.  But I now have a system that reports information like this:Unexpected warning messages:	warning at p1.move(1, 2);^^^^^^^^^^^^^^C:\temp\ajcSandbox\ajcTest1381.tmp\Driver.java:16:0::0 at this shadow method-call(void Pos.move(int, int)) no precedence is specified between advice applying from aspect Foo and aspect Bar [Xlint:unorderedAdviceAtShadow]	warning at Tester.checkEqual(p1.getX(), 1, ""p1.x"");^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^C:\temp\ajcSandbox\ajcTest1381.tmp\Driver.java:17:0::0 at this shadow method-call(int Pos.getX()) no precedence is specified between advice applying from aspect Foo and aspect Bar [Xlint:unorderedAdviceAtShadow]Seems to work ok in my minimal testing.  If I set its default level to 'warning' for the whole test suite it gives me 33 failures, all seem to be reasonable occurrences of this message.  I will set its default to 'ignore' though for what I check in as calculating what goes in the message is *not* cheap.The xlint is called 'unorderedAdviceAtShadow'just waiting on a test run to complete before checking it in... feature available in latest aspectj - will be in AJDT in a few days. "	2005-10-05 14:34:46	1128540000.0	resolved fixed	2c81907	1133370000.0	tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java weaver/src/org/aspectj/weaver/Lint.java weaver/src/org/aspectj/weaver/Shadow.java weaver/src/org/aspectj/weaver/World.java
118337	Use weaver's ClassLoader not the usingClassLoader in 1.5 factory	"In ReflectionBasedReferenceTypeDelegateFactory this line (44) of code is breaking my use of the weaver for looking up bootstrap classes (where the classloader is null and the AspectJ weaver isn't accessible to the bootstrap loader). The commented out code works just fine for me. Is there a real need to resolve the AspectJ runtime from a different classloader than the one that was already used to load this class from the AspectJ runtime?			Class delegateClass = Class.forName(""org.aspectj.weaver.reflect.Java15ReflectionBasedReferenceTypeDelegate"",false,usingClassLoader);//ReflectionBasedReferenceTypeDelegate.class.getClassLoader()); I've had this every which way in the last few days. In each variant something fails.... but I agree that it should assume that weaver5 types are coming from the same place that other weaver types came from. I'm going to put this back again and take another look at the failures it caused to see if there is something else still missing... fix commited back in tree again... "	2005-11-28 20:24:36	1133230000.0	resolved fixed	d1a295c	1133290000.0	weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java
11280	[View Mgmt] Switching perspectives loses view maximized state	1. Open the CVS repository view in the Java perspective.2. Double click the title bar to maximize it3. Switch to the resource perspective.4. Come back to the Java perspective. The CVS repository view is no longermaximized.A view that is maximized should stay maximized. We considered that when implementing it but we concluded that the user could get confused if the perspective was not activated for a long time. 	2002-03-13 12:40:54	1016040000.0	resolved wontfix	508dbcb	1133180000.0	tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java
117614	ajc crashes on common-logging-1.0.4.jar	"--- Dump Properties ---Dump file: ajcore.20051122.152749.326.txtDump reason: org.aspectj.weaver.BCExceptionDump on exception: trueDump at exit condition: abort---- Exception Information ---org.aspectj.weaver.BCException: bad resolve of void org.apache.log4j.Category.log(java.lang.String, org.apache.log4j.Level, java.lang.Object, java.lang.Throwable)	at org.aspectj.weaver.World.getModifiers(World.java:216)	at org.aspectj.weaver.Member.getModifiers(Member.java:406)	at org.aspectj.weaver.patterns.KindedPointcut.warnOnConfusingSig(KindedPointcut.java:109)	at org.aspectj.weaver.patterns.KindedPointcut.match(KindedPointcut.java:69)	at org.aspectj.weaver.patterns.OrPointcut.match(OrPointcut.java:44)	at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:43)	at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:43)	at org.aspectj.weaver.ShadowMunger.match(ShadowMunger.java:62)	at org.aspectj.weaver.Advice.match(Advice.java:91)	at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:1126)	at org.aspectj.weaver.bcel.BcelClassWeaver.matchInvokeInstruction(BcelClassWeaver.java:1115)	at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:987)	at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:827)	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:348)	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:83)	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:742)	at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:707)	at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:634)	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:577)	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:243)	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:118)	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:383)	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:680)	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:168)	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:102)	at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:109)	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)	at org.aspectj.tools.ajc.Main.run(Main.java:291) Could you provide some details of the aspect that you were weaving with at the time please?The compiler was trying to put out a message of the form ""Did not match at join point <blah> because declaring type is XXX, use this(YYY) if match desired"" if that helps you pin it down any.Thanks, Adrian. I couldn't find the compiler message, ""Did not match join point, ....""  It's not in the core dump or the message I get when I run ajc.I also attached my common logging jar.My point cut basically looking at log4J logging method and does something with it.Thanks. pointcut actionLog4j(Object message):	        (call(void org.apache.log4j.Logger.warn(Object))  ||	        call(void org.apache.log4j.Logger.debug(Object)) ||	        call (void org.apache.log4j.Logger.info(Object)) ||	        call (void org.apache.log4j.Logger.error(Object))  ||	        call (void org.apache.log4j.Logger.fatal(Object)))	        && args(message);	void around(Object message) : actionLog4j(message) {//do something hereproceed(message);} Created attachment 30497jar that causes compiler crash I didn't reproduce exactly the same failure as you are seeing, but I did get one very similar at the same point in the code. The problem (that I am seeing) was caused by a commons-logging.jar containing code compiled against a version of log4j.jar that doesn't exactly match the one on my classpath. In particular, part of the commons-logging code (that obviously never gets executed at runtime) calls a method on a Log4j type that doesn't exist. The compiler fell over when trying to put out an error message. It now copes with the missing method. When a build comes through with this fix in I'll ask you to try again if that's ok and make sure that it solves the problem in your environment too.As an added bonus, the ""cantFindType"" messages that come out when you weave into commons-logging.jar (for reasons such as those described above) are by default error messages that stops you in your tracks even though in this case you could safely ignore them. I've made them into lint messages so that you can control the severity (in this case using e.g. -Xlint:ignore) and thus still get useful results in the absence of missing types. build now available from the aspectj downloads page - please could you test out this fix in your environment and let me know what happens? Thanks, A. I'm moving this to ""fixed"" as I'm pretty confident that the changes we put in should have resolved this issue. However, if you do find that there is still an issue in the latest builds please reopen this report.Thanks, Adrian. "	2005-11-22 20:57:51	1132710000.0	resolved fixed	6eb77c5	1132840000.0	tests/src/org/aspectj/systemtest/ajc150/GenericsTests.java weaver/src/org/aspectj/weaver/Lint.java weaver/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java weaver/src/org/aspectj/weaver/World.java weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java weaver/src/org/aspectj/weaver/bcel/BcelShadow.java weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.java weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java weaver/src/org/aspectj/weaver/patterns/WithinAnnotationPointcut.java weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java
116899	Using -verbose in aop.xml does not yield info messages	The interpretation of the -verbose option for LTW is not consistent with other uses in AspectJ e.g. ajc, iajc. It should allow info as well as warining and error messages to be output. The option parser and testcase need to be updated. Created attachment 30193Fix and modified testcasesChange LTW options parsing and change LTWLog testcase to use harness matthew - does this patch clash with another one? since I've applied it just now and some LTW related tests are failing for me. committed - will be in next build. fixes available 	2005-11-17 12:31:22	1132250000.0	resolved fixed	76d7e83	1132820000.0	loadtime/src/org/aspectj/weaver/loadtime/Options.java tests/java5/ataspectj/ataspectj/ltwlog/Main.java tests/java5/ataspectj/ataspectj/ltwlog/MessageHolder.java tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java
114495	unqualified superaspect<T> pointcut sortafunny in subaspect	"Advice not applied in subaspect using parameterized superaspect pointcut withoutqualifying with type parameter.  Declare error using same locution works.  Doc ambiguous:  ""All references to a pointcut declared in a generic type fromoutside of that type must be via a parameterized type reference, and not a rawtype reference.""  I get no compiler error in either case, so perhaps ""outside ofthat type or subtypes.""  But can't interfaces can be parameterized and pointcutsdeclared on interfaces?  Eek!This was disconcerting because the declare warning showed the pointcut wascorrect, but still the advice was not being applied.  (My initial aspect was aperthis(), so I thought that was the problem.)Not sure if this is treated by bug 112105 or any other generics bugs (is there atag for them?)-------------------------------------------------------package bugs;public class ParameterizedTypeInPointcut {	public static void main(String[] args) {		C.go();	}	static class C {		static void go() {}	}}abstract aspect AA_ParameterizedTypeInPointcut<Target> {	pointcut going() :call(void Target.go()) ;	before() : going() {		System.out.println(""AA.going()"");	}}aspect A_ParameterizedTypeInPointcut extends AA_ParameterizedTypeInPointcut<ParameterizedTypeInPointcut.C>{	declare warning : going() : ""going()""; // works fine	before() : going() { // advice not applied		System.out.println(""A.going()"");	}} I should add my original case is more likeabstract aspect A1 {  abstract pointcut pc();  before() : pc() {}}abstract aspect A2<T> {  abstract pointcut foo();  pointcut pc() : call(void T.go()) && foo();}aspect A extends A2<C> {  pointcut foo() : if(true);} Just a quick note.  Bug 112105 is really for ITDs rather than pointcuts.  Idon't know of another bug open relating just to generic pointcut problems. The logic that collected advice members from aspects was missing the code to walk up the hierarchy looking for parameterized supertypes when deciding whether or not parameterization was necessary (the declare collecting logic *did* have this fix in). Solution was to look up the hierarchy when collecting advice too. Bug would have affected any advice in a concrete sub-aspect using a pointcut declared in a parameterized super-aspect where the pointcut used a type parameter. fix checked in, waiting on build... fix now available "	2005-11-01 05:43:00	1130840000.0	resolved fixed	86880f7	1132770000.0	tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java weaver/src/org/aspectj/weaver/ReferenceType.java weaver/src/org/aspectj/weaver/ResolvedType.java weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java
114054	NPE in CContentOutlinePage.createContentProvider()	CUIPlugin.getActiveWorkbenchWindow().getActivePage() can return null. Using different way to obtain page, checking for NullPointer on activePart. *** Bug 149360 has been marked as a duplicate of this bug. *** 	2005-10-27 23:03:41	1130470000.0	resolved fixed	a4caeb9	1132760000.0	tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java weaver/src/org/aspectj/weaver/patterns/PerThisOrTargetPointcutVisitor.java
116254	AjTypeSystem interface cannot be used in LTW environment	"This API uses unqualified calls to Class.forName(). See bug 116229 for more details. The attached patches better simulate a run-time environment and a fix that uses the class loader associated with the type provided by the user. Created attachment 29872Testcase1. <run ltw=""""> to similuate realistic runtime environment2. Use -outxml to generate aop.xml Created attachment 29873FixUse class loader of user supplied type for resolution. patches integrated, thanks :) fix now available "	2005-11-14 11:16:55	1131990000.0	resolved fixed	81e6b60	1132750000.0	aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/DeclareSoftImpl.java aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/StringToType.java
117681	VerifyError when using annotations to define inter-type annotation	"Using Sun JDK1.5.0_04Audit.javapublic interface Audit {   public String getLastUpdatedBy();   public void   setLastUpdatedBy(String un);}AuditImpl.javapublic class AuditImpl implements Audit {   private String lastUpdatedBy;   public String getLastUpdatedBy() {       return lastUpdatedBy;   }   public void setLastUpdatedBy(String un) {       lastUpdatedBy = un;   }}TestAspect.javaimport org.aspectj.lang.annotation.*;Test.java@Aspectpublic class TestAspect {      @DeclareParents(""Test"")      public static Audit introduced = new AuditImpl();}public class Test {    public static void main(String[] args) {        Test t = new Test();        Audit a = (Audit)t;	    a.setLastUpdatedBy(""username"");		System.out.println(""Username =""+a.getLastUpdatedBy());    }}files.lstAudit.javaAuditImpl.javaTestAspect.javaTest.javaCompiled using the following commandd:\aspectj1.5\bin\ajc -classpath ""d:\aspectj1.5\lib\aspectjrt.jar"" -argfile files.lst -1.5d:\aspectj1.5\bin\aj5 TestException in thread ""main"" java.lang.VerifyError: (class: Test, method: setLastUpdatedBy signature: (Ljava/lang/String;)V) Incompatible argument to functiond:\aspectj1.5\bin\aj5 -noverify TestUsername= just my findings: this works fine if you use code style.Any reason why you use 'aj5' to run the program, rather than just 'java Test' - since there is no LTW?? The code style version is public aspect TestAspect {  declare parents: Test extends AuditImpl;}After compilation, Test looks like this:public class Test extends AuditImpl{    public Test();    public static void main(java.lang.String[]);}If I compile the annotation style, then Test looks like this:public class Test extends java.lang.Object implements Audit{    public Test();    public static void main(java.lang.String[]);    public java.lang.String getLastUpdatedBy();    public void setLastUpdatedBy(java.lang.String);}Looking in 'setLastUpdatedBy' we can see:public void setLastUpdatedBy(java.lang.String);  Code:   Stack=2, Locals=2, Args_size=2   0:   getstatic       #64; //Field TestAspect.introduced:LAudit;   3:   aload_0   4:   invokeinterface #25,  2; //InterfaceMethod Audit.setLastUpdatedBy:                                   (Ljava/lang/String;)V   9:   returnThis is not a static method so aload_0 gets 'this' and attempts to pass it as a String parameter to setLastUpdatedBy().  BANG.The solution is to know whether you are dealing with static methods - and skip 'this' if necessary.  Fix checked in, waiting on build. fix available in AspectJ dev build. As 'Java -noverify Test' is resulting in jvm crash, I tried with 'aj5'.(In reply to comment #1)> just my findings: this works fine if you use code style.> Any reason why you use 'aj5' to run the program, rather than just 'java Test' -> since there is no LTW?? "	2005-11-23 04:27:13	1132740000.0	resolved fixed	11ab99f	1132750000.0	tests/bugs150/pr117681/Audit.java tests/bugs150/pr117681/AuditImpl.java tests/bugs150/pr117681/MoodIndicator.java tests/bugs150/pr117681/Test.java tests/bugs150/pr117681/TestAspect.java tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java
103157	"after returning should not bind ""null"" as return value"	"Today I found out the following. When writing an advice as...    after() returning(Object o): staticinitialization(*) {        System.out.println(o);    }This advice is indeed executed every time a type returns from staticinitialization. However, since there is no returned object, o is bound to ""null"".I think this is inconsistent with the fact where we have something like:    after() returning(T o): call(Object Foo.bar()) {        System.out.println(o);    }Here, AFAIK the advice would not execute in cases where the returned object is not an instance of T.Thus, I would propose that the first advice should only execute at joinpoints where a return value is available. I've fixed this in the tree. If a join point kind has no return value, the returning(XXXXxxx) form no longer matches against it. Thusafter() returning(Object obj) : no longermatches at the following join point kinds:* Constructor execution* preinitialization*initialization* staticinitialization* set* handler (but this was disallowed anyway)Thischange can only affect programs using returning(Object xx) since no other form would havematched at these join points anyway.Will close the report once fix is available in apublished build. fix now available "	2005-07-08 09:13:23	1120830000.0	resolved fixed	8b294d9	1132750000.0	tests/new/AfterReturningParam.java tests/new/ConstructorExecInit.java tests/new/OddConstructors.java tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java weaver/src/org/aspectj/weaver/Advice.java weaver/src/org/aspectj/weaver/Shadow.java
117189	Contribution: reduce overhead when no aspects define	"This patch to the ClassLoaderWeavingAdaptor adds two optimizations when enabled is false for the adaptor: it immediately returns false for accept and it also avoids the overhead of constructing a weaver or world.It also contains commented out code that was letting me improve performance by loading reflective proxies instead of creating BCEL objects for a resolution loader (which is currently broken since reflective proxies now require a ReflectionWorld...) Created attachment 30279patch as described Created attachment 30364Fixed patchNice fix. Unfortunately it crashed and burned in the harness because the test on the ""enabled"" flag needs to be made in WeavingAdaptor.weaveClass(). I have made the necessary changes and all the tests now pass. patch checked in. waiting on build. available in latest dev build. "	2005-11-19 13:05:59	1132420000.0	resolved fixed	a5ac5af	1132740000.0	loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java
103051	Declare Soft not Affecting Explicit Adviceexecution	"The following aspect should compile successfully:import java.io.IOException;public aspect SoftenAdvice {    declare soft: IOException: within(SoftenAdvice) && adviceexecution();    before() : execution(* main(..)) {        throw new IOException(""test"");    }    public static void main(String args[]) {    }}But both 1.5.0M2 and HEAD (from 2 days ago) give this output:C:\devel\scratch\err>ajc SoftenAdvice.ajC:\devel\scratch\err\SoftenAdvice.aj:7 [error] Unhandled exception type IOExceptionthrow new IOException(""test"");^^^^^^^^^^^^^^^^^^^^1 errorHowever if you change the declare soft to be the following, it correctly softens at the advice execution join point.    declare soft: IOException: within(SoftenAdvice) && !withincode(* *(..)); Created attachment 28224patch that makes performance acceptable on my test app ok that BCException was from having an old version of the library jar in a web app. It's gone now I removed it. I am now able to start up without deadline when weaving the container. That performance patch is critical though. The patch & comments here are due to Bugzilla's weird habit of prompting you to edit a different bug after you submit something for one. They don't apply to this bug.However, this should be a P1 or P2 bug in my mind: declare soft should work properly in 1.5.0 final!! The problem was that EclipseShadow was building a method-execution shadow for the adviceexecution member, which then was not correctly matched by AjProblemReporter when determining whether or not to suppress unhandledException warnings.Now fixed in tree... waiting for build. fix now available "	2005-07-07 14:03:58	1120760000.0	resolved fixed	554e733	1132650000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseShadow.java tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java
114332	Reflection API not detecting ITD method correctly in all circumstances	"As reported on the aspectj mailing list:Hi,I'm using the 'getDeclaredITDMethods' method (available in thereflection api) to find all ITD methods in the Billing aspect (fromthe aspectj examples).The Billing aspect contains 4 ITD methods (Connection.callRate,LongDistance.callRate, Local.callRate and Customer.addCharge), but Igot only 3 of them using this method.The 'Connection.callRate' is not returned by the'getDeclaredITDMethods' method (maybe because it is abstract). In theimplementation of method 'getDeclaredITDMethods' in'org.aspectj.internal.lang.reflect.AjTypeImpl' there is the followingcondition:if (!m.getName().contains(""ajc$interMethod$"")) continue;Looking the names in the debbuger, I could not find a:public static longtelecom.Billing.ajc$interMethod$telecom_Billing$telecom_Connection$callRate(telecom.Connection)But only:public static longtelecom.Billing.ajc$interMethodDispatch1$telecom_Billing$telecom_Connection$callRate(telecom.Connection)if a take a concrete method, I get two objects, named:public static longtelecom.Billing.ajc$interMethod$telecom_Billing$telecom_LongDistance$callRate(telecom.LongDistance)public static longtelecom.Billing.ajc$interMethodDispatch1$telecom_Billing$telecom_LongDistance$callRate(telecom.LongDistance)One of them satisfies the predicate !m.getName().contains(""ajc$interMethod$"").Is this behavior correct?ps.: I'm using the example bellow.----------------------------------------------------------------public aspect Billing {   ...   public abstract long Connection.callRate();   public long LongDistance.callRate() { return LONG_DISTANCE_RATE; }   public long Local.callRate() { return LOCAL_RATE; }   public void Customer.addCharge(long charge){       totalCharge += charge;   }   ...}----------------------------------------------------------------------------------------import org.aspectj.lang.reflect.AjType;import org.aspectj.lang.reflect.AjTypeSystem;import org.aspectj.lang.reflect.InterTypeMethodDeclaration;import telecom.Billing;public class Test {       public static void main(String args[]) throws ClassNotFoundException{               AjType c = AjTypeSystem.getAjType(Billing.class);               InterTypeMethodDeclaration[] itdmethods = c.getDeclaredITDMethods();               for (int i = 0; i < itdmethods.length; i++) {                       System.out.println(""ITD Method:"" +itdmethods[i].getTargetType().getName()+"".""+itdmethods[i].getName());               }       }}----------------------------------------------------------------Output: ITD Method:telecom.LongDistance.callRate ITD Method:telecom.Local.callRate ITD Method:telecom.Customer.addChargeExpected Output: ITD Method:telecom.Connection.callRate ITD Method:telecom.LongDistance.callRate ITD Method:telecom.Local.callRate ITD Method:telecom.Customer.addChargeI'm using ajde 1.5.0.20051014142856.Regards,Eduardo Pivetahttp://www.inf.ufrgs.br/~epiveta marking for resolution by RC1 The interMethod method is not generated for abstract methods, as you summised. I've now fixed this in the tree, and provided a much more useful version of toString for InterTypeXXXDeclarations too.Will close report once fix availble in a published build. fix now available... "	2005-10-31 03:42:57	1130750000.0	resolved fixed	735d94f	1132610000.0	aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/AjTypeImpl.java aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/InterTypeConstructorDeclarationImpl.java aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/InterTypeDeclarationImpl.java aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/InterTypeFieldDeclarationImpl.java aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/InterTypeMethodDeclarationImpl.java tests/java5/reflection/ReflectBilling.java tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java
115607	Incorrect structure model for simple declare @type program?	This program:---8<-----@interface I {}class Simple {}public aspect C {  declare @type: Simple : @I;}---8<-----(all in a file called C.java, open with the AJ editor) when built showsincorrect gutter markers, it shows a double headed arrow on Simple implying thatit annotates itself - rather than something outgoing from the declare statementand something incoming on the Simple type. Converting the given program to an AJ testcase and printing out the structure model gives:=== MODEL STATUS REPORT ========= After a batch build<root>  [java source file]   pr115607.java  [java source file] C:\temp\ajcSandbox\ajcTest20582.tmp\pr115607.java:1::0    import declarations  [import reference]     I  [annotation] C:\temp\ajcSandbox\ajcTest20582.tmp\pr115607.java:1::11    Simple  [class] C:\temp\ajcSandbox\ajcTest20582.tmp\pr115607.java:3::25    pr115607  [aspect] C:\temp\ajcSandbox\ajcTest20582.tmp\pr115607.java:5::52      declare @type: Simple : @I  [declare @type] C:\temp\ajcSandbox\ajcTest20582.tmp\pr115607.java:6::66=== END OF MODEL REPORT ============ RELATIONSHIPS REPORT ========= After a batch buildHid:1:(targets=1) C:\temp\ajcSandbox\ajcTest20582.tmp\pr115607.java|3|0|25 (annotated by) C:\temp\ajcSandbox\ajcTest20582.tmp\pr115607.java|6|-1|66Hid:2:(targets=1) C:\temp\ajcSandbox\ajcTest20582.tmp\pr115607.java|6|-1|66 (annotates) C:\temp\ajcSandbox\ajcTest20582.tmp\pr115607.java|3|0|25=== END OF RELATIONSHIPS REPORT ===== Properties of the model and relationships map =====annotation=1FileMapSize=1aspect=1RelationshipMapSize=2java source file=2declare @type=1import reference=1class=1The problem is coming from the -1 in the column i.e.C:\temp\ajcSandbox\ajcTest20582.tmp\pr115607.java|6|-1|66In this case the actual IProgramElement corresponding to the 'declare @type: Simple : @I' doesn't have any relationships (since it's ISourceLocation is C:\temp\ajcSandbox\ajcTest20582.tmp\pr115607.java|6|0|66)If the test program is changed to:---8<-----@interface I {}class Simple {}public aspect C {  declare @type: Simple : @I;                              <------- Add an extra empty line here}---8<-----Then the entry in the relationship map becomes C:\temp\ajcSandbox\ajcTest20582.tmp\pr115607.java|6|0|66which is the IProgramElement for 'declare @type: Simple : @I'.   Following on from comment #1....The reason adding another line to the test program works is due to the logic in EclipseSourceLocation.getColumn(). When we enter the method, if the column is currently -1 (which is it because that's the value it's created with), we get the line number, which in the above example is 6. We then check whether this value is greater than zero and less than the number of line separator positions in the file. In the reported testcase this is also 6 so we return with the column still being set to -1. In the case when we add an extra line the number of line separator positions becomes 8 so we pass through this check and set the column to be 0.The fix is to add another check, namely if the line number is equal to the number of line separator positions then we set the column to be zero. Created attachment 30312testcaseApply this patch to the tests project.This patch contains the given testcase converted to a test for the AJ test harness. Created attachment 30314patch containing proposed fixPatch containing fixed proposed in comment #2.Apply patch to org.aspectj.ajdt.core project. patch checked in (thanks Helen). fix available. 	2005-11-09 04:35:59	1131530000.0	resolved fixed	9ed75a1	1132590000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceLocation.java tests/bugs150/pr115607.java tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java
116755	PointcutParser is not configurable	"I'm testing the reflection and weaver tools APIs. When I using following code:PointcutParser parse = new PointcutParser();String expr = ""call(public * main.hello(..)"";PointcutExpression pex = parse.parsePointcutExpression(expr);Whenever I use a full qualified class name in pointcut expression, an exception is throwed out:java.lang.IllegalArgumentException: warning no match for this type name: obj [Xlint:invalidAbsoluteTypeName]I try to turn off this Lint exception. But it seems I must access to world field of PointcutParser. This is inconvenient because world field is not exposed by PointcutParser. The existing PointcutParser interface implicitly creates a World and does not allow any configuration including classpath or lint. But developers may need this kind of control. look at for RC1. See also Bug 116229. I've extended the PointcutParser to support public void setLintProperties(Properties p)andpublic void setLintProperties(String lintPropertiesResourceFileOnClasspath)The following extract shows how to turn of the warning you are seeing:Properties props = new Properties();props.add(""invalidAbsoluteType"",""ignore"");parser.setLintProperties(props);Will close this bug report when fix available in a published build. While this is a nice workaround it is a little cumbersome. Lint already loads XlintDefault.properties as a resource why not allow the user to define ""META-INF/Xlint.properties"" which would contain overrides. This would work well in both a batch and LTW environment. For the second case, you can always do:parser.setLintProperties(""META-INF/Xlint.properties"");A ""magic  location"" would have to work in all modes, and we'd have to figure out it's interaction with the existing command-line options etc.. That's more work than I want to get into right now. If we get lots of user angst about having to add the above call we could consider defaulting post 1.5.0...Fix now available in published build. "	2005-11-16 20:19:54	1132190000.0	resolved fixed	522911e	1132420000.0	tests/java5/ataspectj/annotationGen/RuntimePointcuts.java tests/java5/reflection/ReflectOnAjcCompiledPointcuts.java tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java weaver/src/org/aspectj/weaver/bcel/BcelWorld.java weaver/src/org/aspectj/weaver/internal/tools/TypePatternMatcherImpl.java weaver/src/org/aspectj/weaver/ltw/LTWWorld.java weaver/src/org/aspectj/weaver/ltw/LTWeaver.java weaver/src/org/aspectj/weaver/reflect/AnnotationFinder.java weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegate.java weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java weaver/src/org/aspectj/weaver/reflect/ReflectionBasedResolvedMemberImpl.java weaver/src/org/aspectj/weaver/reflect/ReflectionShadow.java weaver/src/org/aspectj/weaver/reflect/ReflectionVar.java weaver/src/org/aspectj/weaver/reflect/ReflectionWorld.java weaver/src/org/aspectj/weaver/tools/PointcutParser.java weaver/src/org/aspectj/weaver/tools/TypePatternMatcher.java weaver/testsrc/org/aspectj/weaver/tools/PointcutParserTest.java weaver/testsrc/org/aspectj/weaver/tools/ToolsTests.java weaver/testsrc/org/aspectj/weaver/tools/TypePatternMatcherTest.java weaver5/java5-src/org/aspectj/weaver/reflect/Java15AnnotationFinder.java weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java
115204	WildAnnotationTypePattern.java:61 NPE after renaming method-annotation class	"<Pyinson Data Over Head> for investigation prior to RC1 fix checked in. waiting on build. fix available.  Wes, if you remember and still have the environment, can you tryit out when AJDT gets updated (probably Monday?). I'm unable to reproduce in AJDT 20051122132809.There is the usual incremental issue that after code has been invalidated by something like rename, not all dependent code is wiped, so an illegal class seems to be constructed.  In this case, when running the class I get a VerifyError:----------------------------------Exception in thread ""main"" java.lang.VerifyError: (class: bugs/Bug115204, method: <clinit> signature: ()V) Stack size too large	at bugs.Bug115204Class.main(Bug115204Class.java)----------------------------------I don't think it's related and I think it's already a bug.  But just in case, here's the procedure and the code:- define all classes/aspects- rename the annotation class  from Annot to AnnotRenamed- run the main classRESULT: VerifyError aboveThe code:------------------------------------package bugs;public aspect Bug115204 {    before() : execution(@Annot void Bug115204Class.*(..)) {        System.out.println(""before "" + thisJoinPoint);    }}------------------------------------package bugs;public class Bug115204Class {    @Annot()    public static void main(String[] args) {        System.out.println(""Bug115204Class.main(String[])"");    }}------------------------------------package bugs;public @interface Annot {}------------------------------------ becomespackage bugs;public @interface AnnotRenamed {} "	2005-11-05 06:03:26	1131190000.0	resolved fixed	557f5b4	1132310000.0	weaver/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java
116949	[waitingOnAJDTdrop]Exception thrown from AspectJ compiler	<Pyinson Data Over Head> Seems the code is expecting a BcelTypeMunger but is encountering anEclipseTypeMunger.  I've put in a guard - this will fix the ClassCastException. Fix checked in - waiting on build. fix available in latest AspectJ dev build - it will be in AJDT early next week. It seems that the new version dated 20051122132809 didn't fix the problem. After having installed the new version (and after having restarted Eclipse) I got exactly the same behavior (exception). Or was the fix not yet included in this AJDT build ?I tried to reproduce the problem on a simple example, but with no effect. The original code where the problem was observed is a part of a relatively large system, so I did not send it. I'm going to continue trying to find a simplified example.  Important observation: it happens only when incremental compilation is turned on.  The fix is not in AJDT yet. Fix is in the latest 1.3 version of AJDT. Great, with this version (1.3.0.20051125115230) it is fixed ! 	2005-11-17 17:09:48	1132270000.0	verified fixed	dd9a9b2	1132310000.0	weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java
116626	Load-time weaving - exception from the weaver	"Hi again :-)I'm trying to use loadtime weaving and getting an exception. Please look at the testcase:Java code:==========public class Test<T> {	Set<T> intsSet;	public Test() {		this.intsSet = new HashSet<T>();	}	public <T> T[] getObjs(T[] a) {		return intsSet.toArray(a);	}	public static void main(String[] args) {		System.out.println(""AAA :-)"");		new TTT().foo();	}}class TTT {	public void foo() {		Test<Object> mt = new Test<Object>();		Object[] arr = mt.getObjs(new Object[]{});	}}Aspect:=======public privileged aspect TestAspect {      pointcut TestToArray(Test mt) :                target(mt) &&                !within(TestAspect);    Object[] around(Test mt, Object[] objs) :            TestToArray(mt) &&            args(objs) &&            execution(Object[] com.mprv.secsph.Test.getObjs(Object[])) {        objs = proceed(mt, objs);        System.out.println(""GO Aspects!"");        return objs;    }}aop.xml=======<aspectj>	<aspects>		<aspect name=""com.mprv.secsph.TestAspect""/>	</aspects>	<weaver options=""-verbose -XlazyTjp -showWeaveInfo"">		<include within=""com.mprv.*""/>	</weaver></aspectj>Program output:==============AAA :-)info weaving 'com/mprv/secsph/TestAspect'java.lang.NullPointerException	at org.aspectj.weaver.tools.WeavingAdaptor$WeavingClassFileProvider.getBytes(WeavingAdaptor.java:390)	at org.aspectj.weaver.tools.WeavingAdaptor.getAtAspectJAspectBytes(WeavingAdaptor.java:259)	at org.aspectj.weaver.tools.WeavingAdaptor.weaveClass(WeavingAdaptor.java:181)	at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:66)	at org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter.transform(ClassPreProcessorAgentAdapter.java:52)	at sun.instrument.TransformerManager.transform(TransformerManager.java:122)	at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:155)	at java.lang.ClassLoader.defineClass1(Native Method)	at java.lang.ClassLoader.defineClass(ClassLoader.java:620)	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:124)	at java.net.URLClassLoader.defineClass(URLClassLoader.java:260)	at java.net.URLClassLoader.access$100(URLClassLoader.java:56)	at java.net.URLClassLoader$1.run(URLClassLoader.java:195)	at java.security.AccessController.doPrivileged(Native Method)	at java.net.URLClassLoader.findClass(URLClassLoader.java:188)	at java.lang.ClassLoader.loadClass(ClassLoader.java:306)	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:268)	at java.lang.ClassLoader.loadClass(ClassLoader.java:251)	at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:319)	at com.mprv.secsph.Test.getObjs(Test.java:1)	at com.mprv.secsph.TTT.foo(Test.java:34)	at com.mprv.secsph.Test.main(Test.java:27)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)	at java.lang.reflect.Method.invoke(Method.java:585)	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:86)GO Aspects!====This exception doesn't happen all the time ... but if you will try a few times, you will probably get it. May you can understand what is the problem event without running the test case. Anyway, I took a look at your code, and have a guess (but it's only the guess) -My aspect is in the application classpath. Actually it's in the same package, so may be you are trying to weave the aspect with itself somehow ...Thanks!Misha. Matthew, can you take a look at recreating this? This bug is a result of the “fix” to bug 113587. When an aspect is not included in the weave it now gets a second chance if it is an @AspectJ aspect (see WeavingAdaptor.weaveClass()). However the test in BcelWorld.isAnnotationStyleAspect() called from shouldWeaveAnnotationStyleAspect() is unreliable because it only looks for the org/aspectj/lang/annotation/Aspect annotation which for Java 5 is also added to code-style aspects. The trouble happens later in BcelWeaver.weaver() where we use the right test so the aspect is not “munged”. This means no new bytes are generated and WeavingClassFileProvider.getBytes() throws an NPE. The solution is to return the unwoven bytes if there are no woven bytes.Here are some things I spotted:1.	The aop.xml is wrong and the TestAspect is no included. It should be <include within=""com.mprv..*""/> (two dots).2.	The aspect is loaded and weaving is attempted despite its exclusion.3.	The application and aspect run correctly.What is missing from the testcase is how it was built. It has already been woven. If it had not been of the aspect had been included correctly the bug would not have occurred. Created attachment 30073TestcaseFailing user testcase integrated into harness. Created attachment 30080FixWeavingClassFileProvider.getBytes() returns original unwoven bytes if noweaving takes place. While this change solves the user's problem I am not happy with the fix. In fact I don't think any changes should have been made for bug 113587 in the first place. When using annotation-style aspects the Aspects.aspectOf() interface should be used not try to fix it up in the run-time.I have a couple issues with the current implementation:1. The BcelWorld.isAnnotationStyleAspect() seems to be bogus on Java 5.2. More seriously the else clause in WeavingAdaptor.weaveClass() ignores the ""enabled"" flag used in shouldWeave() thereby partially invalidating the performance improvement in Bug 113511: we create and parse a BCEL JavaClass for _every_ excluded class.I will raise a separate bug to deal with this. fix integrated, waiting on build.  thanks Matthew.  Oh, and to the originalraiser: you dont need to specify XlazyTjp - its the default now. Fix available for the NPE. *** Bug 117160 has been marked as a duplicate of this bug. *** "	2005-11-16 03:54:11	1132130000.0	resolved fixed	c760895	1132300000.0	tests/bugs150/pr116626/com/foo/bar/Test.java tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java
116255	XML Linkage Error with LTW	"<Pyinson Data Over Head> This is no doubt related to our change in DocumentParser to now useSAXParserFactory.newInstance().newSAXParser().getXMLReader() when reading aop.xml.Although I can't see how we are doing anything wrong - we are just using thatclass from the VM ... <Pyinson Data Over Head> It turns out the application libraries are a red herring. I am again seeing this error when I restart Tomcat even when the application doesn't have these libraries: I think it's caused by trying to read in the previous session (which is why it doesn't occur when an app is first deployed).I think this bug is important to fix or to work around. Is it important to use JAXP in the load-time weaver? It definitely opens up a can of worms... Bug 112914 changed XMLReader creation from      XMLReaderFactory.createXMLReader()to    SAXParserFactory.newInstance().newSAXParser().getXMLReader();so that LTW would work under JDK 1.4, both in AJDT and at the command line using ""aj"" without AspectJ having to ship an XML parser. The problem was a SAXException rather than anything more serious. I suggest a hybrid approach where we try the old way and if we get a SAXException we try the new way. Created attachment 29965PatchTry 2 different ways to create an XMLReader Although we (AJ) aren't doing anything wrong... I have integrated Matthews patchafter talking it over with him - this will try the old way (which will keep Ronscode happy) and if that fails it will use the new way (keeping AJDT happy).waiting on build. fix available - please reopen if it doesnt fix your problem Ron. This is now working for me: thanks! "	2005-11-14 11:17:02	1131990000.0	verified fixed	fabf159	1132070000.0	loadtime/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java
116305	Unexpected error: can't determine implemented interfaces of missing type	<Pyinson Data Over Head> If I use call(public * javax..xml.rpc.Call.invoke*(..)) then the errors all disappear. That's an ugly workaround though...Interestingly, I seem to only get the linkage error from bug # 116255 when this bug happens, although I believe that has to do with changing the execution path of the system (i.e., it's correlated without causation). Actually the only correlation between the two issues was that I had forgotten I was using the Nov. 9 development build which didn't have the sax parser factory code in it. However, this bug is present in HEAD and the ugly workaround also works in HEAD. just one quick comment to myself, from this line in the stack trace: KindedPointcut.warnOnConfusingSigI can tell its only going down this code path in order to work out whether togive you a lint warning. Hmmm... it would be nice to isolate this kind of exception from breaking the weave (sounds like a great use for aspects). I think I put code in before to stop this going wrong if the hierarchy couldn'tbe determined - but that was before 'Missing' was introduced as a real type asopposed to just a broken signature.  I'll take a look tomorrow. As I thought... the missing logic I put in ages and ages ago is broken by thenew MissingResolvedTypeWithKnownSignatureI'm about to put in a fix for this case fix checked in - waiting on build Fix available.  Can you try it Ron as I can't recreate easily here? I'm closing as the fix is available - (just to get the bug numbers down!!) -please reopen if you still have problems with this Ron. 	2005-11-14 14:16:01	1132000000.0	resolved fixed	676aa08	1132050000.0	weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java
115235	StackOverflowError on circular pointcut iff aspect parameterized	"The code below overflows when concretizing a circular pointcut from aparameterized aspect.  Not true when the aspect is not parameterized.---------------------------------------------public class SelfPC {	public static void main(String[] args) {		new C().foo();	}	static class C { 		pointcut doit() : C.doit(); // CE expected		void foo() {} 	}		// ------------ pertarget<T>	static abstract aspect PT_PARM<T> pertarget(pc()) {		abstract protected pointcut pc();		before() : pc() {}	}	static aspect CPT_PARM extends PT_PARM<C> {		protected pointcut pc() : C.doit();	}	//	// ------------ issingleton<T>//	static abstract aspect IS_PARM<T> {//		abstract protected pointcut pc();//		before() : pc() {}//	}//	static aspect CIS_PARM extends IS_PARM<C> {//		protected pointcut pc() : C.doit();//	}//	// ------------ pertarget//	static abstract aspect PT pertarget(pc()) {//		abstract protected pointcut pc();//		before() : pc() {}//	}//	static aspect CPT extends PT{//		protected pointcut pc() : C.doit();//	}//	// ------------ issingleton//	static abstract aspect SIS {//		abstract protected pointcut pc();//		before() : pc() {}//	}//	static aspect CSIS extends SIS {//		protected pointcut pc() : C.doit();//	}}---------------------------------------------java.lang.StackOverflowErrorat java.lang.StringBuffer.append(StringBuffer.java:225)at org.aspectj.weaver.UnresolvedType.nameToSignature(UnresolvedType.java:734)at org.aspectj.weaver.UnresolvedType.forName(UnresolvedType.java:308)atorg.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBinding(EclipseFactory.java:302)atorg.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromEclipse(EclipseFactory.java:129)atorg.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.getSuperclass(EclipseSourceType.java:119)at org.aspectj.weaver.ReferenceType.getSuperclass(ReferenceType.java:481)at org.aspectj.weaver.ResolvedType.getDirectSupertypes(ResolvedType.java:65)at org.aspectj.weaver.ResolvedType$6.get(ResolvedType.java:447)at org.aspectj.weaver.Iterators$4.next(Iterators.java:148)at org.aspectj.weaver.Iterators$3$1.hasNext(Iterators.java:117)at org.aspectj.weaver.Iterators$3.hasNext(Iterators.java:128)at org.aspectj.weaver.ResolvedType.findPointcut(ResolvedType.java:466)atorg.aspectj.weaver.patterns.ReferencePointcut.concretize1(ReferencePointcut.java:269)at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:229)atorg.aspectj.weaver.patterns.ReferencePointcut.concretize1(ReferencePointcut.java:326)at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:229)...--------------------------------------------- I've managed to recreate the problem with the following simplified testcase:abstract aspect ParameterizedAbstractAspect<T>{	abstract protected pointcut pc();	before() : pc() {}}aspect ParameterizedConcrete extendsParameterizedAbstractAspect<ParameterizedConcrete> {	protected pointcut pc() : pc();}The reason the StackOverflowError is occuring is inReferencePointcut.concretize1(...). In this method, there is a flag called""concretizing"" which is initially false but is set to true when concretizing istaking place. The method begins with a check on whether or not ""concretizing"" istrue and if it is then the expected error message is produced - 'circularpointcut declaration involving: pc()' type message. If it's false, then we goahead and try to concretize. The part of the method which is causing the problems is:Pointcut ret = pointcutDec.getPointcut();if (typeVariableMap != null) ret = ret.parameterizeWith(typeVariableMap);return ret.concretize(searchStart, declaringType, newBindings);(note that the implementation of concretize calls the concretize1 method).If the aspect is not parameterized then typeVariableMap == null. However, if itis parameterized then typeVariableMap is non-null. In this case, ret becomes anew object (due to the implementation ofReferencePointcut.parameterizeWith(..)). So, for example, if we're looking atnon-parameterized aspects, we get the following info at the trouble spot inconcretize1:first pass in concretize1:  this: id = 144 concretizing is set to true,                             ret : id = 176 concretizing is still falsesecond pass in concretize1: this: id = 176 concretizing is set to true                            ret : id = 176 concretizing is still truethird pass in concretize1:  this: id = 176 concretizing is true so get compiler                                            warning as expectedHowever, if we're looking at parameterized aspects, we get the following:first pass in concretize1:    this                                     : id = 47 concretizing is set to true  ret (before call to parameterizeWith(..) : id = 92 concretizing is false  ret (after call to parameterizeWith(..)  : id = 95 concretizing is false second pass in concretize1:    this                                     : id = 95 concretizing is set to true  ret (before call to parameterizeWith(..) : id = 92 concretizing is false  ret (after call to parameterizeWith(..)  : id = 135 concretizing is falsethird pass in concretize1:    this                                     : id = 135 concretizing set to true  ret (before call to parameterizeWith(..) : id = 92 concretizing is false  ret (after call to parameterizeWith(..)  : id = 147 concretizing is falsethis goes on and on..... and hence the StackOverflowError. The fix is to add a protected boolean field hasBeenParameterized to the abstractclass Pointcut. Then add an extra check in the problem code mentioned in comment#1, changing it from if (typeVariableMap != null) ret = ret.parameterizeWith(typeVariableMap);toif (typeVariableMap != null && !hasBeenParameterized) {					    ret = ret.parameterizeWith(typeVariableMap);    ret.hasBeenParameterized=true;}It is necessary to update the field here rather than in theReferencePointcut.parameterizeWith(...) method, because parameterizeWith iscalled several times from different places whereas you only concretize once. Created attachment 29852patch containing fixApply the patch to the weaver project.The patch contains the fix described in the previous comment. Created attachment 29853patch containing testcasesApply this patch to the tests project.This patch contains the original failing testcase in file pr115325.aj. I'vealso included another testcase in file pr115325b.aj which came about from meinvestigating difference scenarios. I'm not sure whether it should be includedin the suite, however, I thought I would include it in the patch just in case:-) fix available. "	2005-11-06 07:26:57	1131280000.0	resolved fixed	4b8bed7	1131960000.0	tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java weaver/src/org/aspectj/weaver/patterns/Pointcut.java weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java
113118	ClassFormatException with tracing aspect	"<Pyinson Data Over Head> i'll take a look ... Slight correction; the static initializer block should have as its first line:prefixStr = new StringBuffer(1024);It doesn't remove the bug, however. The weaving succeeds for some modules, but not all. Most Junit tests fail to runwhen invoked ('An internal error occurred during ""Launching""'). I simplified the pointcuts:	public pointcut exclusions(): within(CallTrace) || within(*Tracer);		public pointcut traceIntf(): 		execution(* com.adteractive..Traced+.*(..)) || 		execution(com.adteractive..Traced+.new(..));		public pointcut traceAnno(): 		execution(* @TracedAnno com.adteractive..*.*(..)) || 		execution(@TracedAnno com.adteractive..*.new(..));	public pointcut trace(): !exclusions() && (traceIntf() || traceAnno());		Object around(): trace() {		// same as before	}The exception dialog doesn't appear anymore, but I'm still having problemsgetting some, but not all, junit tests to run. Unfortunately, the ""failed tolaunch"" dialog provides no information. The log indicates an array index out ofbound exception (value = -1). The only connection to AJ is that this problemdidn't occur until I started using the aspect. I restarted eclipse, that wasn'tenough. What finally got the tests to work again, with the tracing aspect, wasto remove the AJ nature, rebuild, then add the AJ nature back and rebuild. Hmm, looking at this code:org.aspectj.apache.bcel.classfile.ClassFormatExceptionat org.aspectj.apache.bcel.classfile.Utility.typeOfSignature(Utility.java:1293)at org.aspectj.apache.bcel.generic.Type.getTypeInternal(Type.java:166)at org.aspectj.apache.bcel.generic.Type.getTypeInternal(Type.java:174)it seems when the exception is thrown it should include the signature it washaving trouble with - I guess that got lost somewhere in the error reporting? In fact, here is the whole of 'typeOfSignature':public static final byte typeOfSignature(String signature) throwsClassFormatException {    try {      switch(signature.charAt(0)) {          case 'B' : return Constants.T_BYTE;          case 'C' : return Constants.T_CHAR;          case 'D' : return Constants.T_DOUBLE;	      case 'F' : return Constants.T_FLOAT;	      case 'I' : return Constants.T_INT;	      case 'J' : return Constants.T_LONG;	      case 'L' : return Constants.T_REFERENCE;	      case '[' : return Constants.T_ARRAY;	      case 'V' : return Constants.T_VOID;	      case 'Z' : return Constants.T_BOOLEAN;	      case 'S' : return Constants.T_SHORT;          default:  	        throw new ClassFormatException(""Invalid method signature: "" +signature); // << this is line 1293      }    } catch(StringIndexOutOfBoundsException e) {      throw new ClassFormatException(""Invalid method signature: "" + signature);    }  }We are probably leaking a 'P' signature out of the compile stage, P being like'L' but its how we choose to identify parameterized types likePjava/util/List<Ljava/lang/String;>;Wish I knew what the signature was... Created attachment 28477Eclipse log file with stack tracesThis is the segment of the eclipse "".log"" file that contains the ""session"" datawhere the problem occurred. Specifically, I think the signature you want is probably ...!STACK 0org.aspectj.apache.bcel.classfile.ClassFormatException: Invalid methodsignature: Pcom/adteractive/framework/Filter<TI;TO;>;...(Near the end of the file.) Filter is an interface. Curiously, it is not advisedby the aspect in question. Sorry i've taken so long to get to this Dean :(However, I think I've fixed this.  I found a bug in the code that createsgeneric signatures.  There are two ways to grab a signature for a type:getSignature()getSignatureForAttribute()the first may return ""PSomeType<LSomeOtherType;>;"" whilse the second has toreturn something in the standard Java form 'LSomeType<LSomeOtherType;>;"" - wewere incorrectly using the first form when building the signature attribute fora file.  Is it easy for you to recreate Dean? So you can try my fix when its available? the latest dev build includes what I think might fix it... I'm closing this as I believe its fixed.  Dean, please reopen if you encounterthis again. "	2005-10-19 14:01:25	1129740000.0	resolved fixed	d7d5947	1131720000.0	weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java
112756	ajdt compiler generate false warnings	"I was working on aspect that should raise an error for junit test methods that didn'tuse any assertions. Apparently I had to use pointcut like ""call(void Assert+.assert*(..))""on which ajdt compiler complained about using ""assert"" keyword. I don't think such warningshould be shown in such case.Anyway, here is the complete aspect code.importjunit.framework.Test;import junit.framework.Assert;import junit.framework.AssertionFailedError;publicaspect AssertionCounter {  private ThreadLocal counts = new ThreadLocal();  publicpointcut testMethodExecution() :     execution(void Test+.test*());  public pointcutassertCall() :     cflow(testMethodExecution()) && call(void Assert+.assert*(..));     void around() : testMethodExecution() {    counts.set( new Counter());   proceed();    if(((Counter) counts.get()).getCount()==0) {      throw new AssertionFailedError(""Noassertions had been called"");    }  }  before() : assertCall() {    ((Counter)counts.get()).inc();  }  } The code to generate the warning was deep in the JDT parser. This issue (and a related one of using ""enum"" inside a pointcut expression in a similar way) is now fixed... by an aspect that suppresses the warning if made whilst processing a pseudo-token stream.Fix will be available in next published build from AspectJ downloads page, and incorporated into AJDT on Monday of next week (21st). "	2005-10-16 23:56:55	1129520000.0	resolved fixed	7a1002a	1131530000.0	tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java
112830	"Warning ""couldn't find aspectjrt.jar on classpath"""	"The compiler makes this warning if ""aspectrt.jar"" file has a different name like""aspectrt-1.3.jar"", which is the case when compiling with maven. I thought we fixed this last year.  Has no one been using AspectJ with Maven?AjBuildManager.checkRtJar(..) is looking for ""aspectjrt.jar"", not    if (p.isFile() && p.getName().startsWith(""aspectjrt"")       && p.getName().toLowerCase().endsWith("".jar"")) {AjcTask.findAspectjtoolsJar(..) has more specific logic to find versioned jars. Neither would select the correct version from a classpath. Wes,This warning occurs if I am compiling with ajc command line, ant or maven, thethree of them.It does not seem that either classes (AjBuildManager and AjcTask) is giving thewarning.AjBuildManager has to do with ajdt, and not with command line/ant/maven.AjcTask is used by ant and maven, but not with the command line, right? Eitherway, AjcTask.findAspectjtoolsJar(..) find aspectjtools.jar, and notaspecjrt.jar, which is the source of this issue. needs resolving for RC1 I've just commited a fix for this to tolerate variations on aspectjrt.jar as proposed by Wes. Will be available in next published developer build on aspectj downloads page. Let me know how this works out with Maven... should be ok for you now I hope. It's OK for aspectj-DEVELOPMENT-20051110113650.jar. Ok, I'm seeing this using aspectj-maven-plugin 1.4 with aspectjrt & aspectjtools 1.6.12 & maven 3.0.3:[INFO] --- aspectj-maven-plugin:1.4:compile (default) @ configuration ---[WARNING] couldn't find aspectjrt.jar on classpath, checked: C:\dev\jdks\...Parent pom <pluginManagement> contains:                <plugin>                    <groupId>org.codehaus.mojo</groupId>                    <artifactId>aspectj-maven-plugin</artifactId>                    <version>1.4</version>                    <dependencies>                        <!-- Avoids ""bad version"" warning -->                        <dependency>                            <groupId>org.aspectj</groupId>                            <artifactId>aspectjrt</artifactId>                            <version>1.6.12</version>                        </dependency>                        <dependency>                            <groupId>org.aspectj</groupId>                            <artifactId>aspectjtools</artifactId>                            <version>1.6.12</version>                        </dependency>                    </dependencies>                </plugin>Parent pom <plugins> contains:            <plugin>                <groupId>org.codehaus.mojo</groupId>                <artifactId>aspectj-maven-plugin</artifactId>                <configuration>                    <source>${java.version}</source>                    <target>${java.version}</target>                    <encoding>UTF-8</encoding>                    <complianceLevel>${java.version}</complianceLevel>                    <preserveAllLocals>true</preserveAllLocals>                    <showWeaveInfo>false</showWeaveInfo>                    <aspectLibraries>                    	<aspectLibrary>                    		<groupId>org.springframework</groupId>                    		<artifactId>spring-aspects</artifactId>                    	</aspectLibrary>                    </aspectLibraries>                </configuration>                <executions>                    <execution>                        <goals>                            <goal>compile</goal>                            <goal>test-compile</goal>                        </goals>                    </execution>                </executions>            </plugin>Any ideas? We're compiling with ant task and see the same error even though the jar is present in the classpath[aspectj:iajc] warning couldn't find aspectjrt.jar on classpath, checked: D:\cc_tools\tools\tpv\was\7.0\java\jre\lib\vm.jar;D:\cc_tools\tools\tpv\was\7.0\java\jre\lib\annotation.jar;D:\cc_tools\tools\tpv\was\7.0\java\jre\lib\beans.jar;D:\cc_tools\tools\tpv\was\7.0\java\jre\lib\java.util.jar;.......Z:\my_module\module\dependencies\lib\main\SUI_Common_UI.jar;Z:\my_module\module\dependencies\lib\main\com.springsource.org.aspectj.runtime-1.6.6.RELEASE.jar;Z:\my_module\module\dependencies\lib\main\com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar;Z:\my_module\module\dependencies\lib\main\com.springsource.org.aspectj.tools-1.6.6.RELEASE.jar;Is there any way/place to define the name of this jar? How do i get around this? We're using aspectj jars rebundled by spring.I also see the same issue when i use the 1.7.0 version. the code was fixed to allow for 'org.aspectj.runtime' anywhere in the jar name - that was changed years ago but you need to update to a version with the fix in.I notice you are on 1.6.8 weaver and 1.6.6 tools.  You should stick to just one version - and I *think* if you update to 1.6.8 tools you will pickup the change that will avoid this message. (Or you could jump to 1.6.12, the most recent 1.6 fix level). Created attachment 271540aspectj error error when executing this in cmd linemvn clean test jacoco:report -DskipITs=trueerror is as attached The error in that picture says it cant find the JoinPoint class which does come from the runtime module. On the classpath it shows in the error I don't see the runtime module (I don't think it is saying it must be called aspectjrt.jar but the runtime needs to be there somewhere so the classes can be found). "	2005-10-17 14:01:44	1129570000.0	resolved fixed	1f51499	1131470000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
114005	annotated ITD fields on interfaces have no annotation	"As stated in the notebook it is allowed to annotate field ITDs.This seems not to work properly with interfaces.public interface TestInterface {}@Retention(RetentionPolicy.RUNTIME)public @interface SampleAnnotation {}public aspect Declaration {	declare parents: (@SampleAnnotation *) implements TestInterface;	        // this is fine	@SampleAnnotation 	public transient String Test.firstProperty;	        / this does not work	@SampleAnnotation	public transient String TestInterface.secondProperty;	        // this also does not work	declare @field: * TestInterface+.*: @SampleAnnotation;}secondProperty has no Annotation as one can see with:public class Test implements TestInterface {	public static void main(String[] args) {		for (Field field: Test.class.getFields()) {			System.err.println(field.toString().concat("" "").concat(String.valueOf(field.isAnnotationPresent(SampleAnnotation.class))));		}	}}I did not try whether this is also the case for method ITS on interfaces.Secondly the field name is ajc$interField$test_Declaration$test_TestInterface$secondProperty instead ofsimply secondProperty. Is this what is meant with bug 73507?What is with private and package protected ITD of fields and runtime reflection? Because the field name is mangled (Test.class.getField(""firstProperty"") raises a NoSuchFieldException when declared private or package protected). Also ""declare @field: * Test+.*: @SampleAnnotation;"" is not applied for private or package protected declarations. So should one onlyannotate public field IDTs (supported by compiler warnings) to have useful runtime behaviour (with runtime RetentionPolicy annotations)?So it is strange that the introductory example on annotations shows annotated private field ITDs on interfaces :-)Thank you very much for your help,Vincenz Have you tried pointcut matching to see if that recognizes that certain elementshave annotations, rather than poking around in the bytecode?We fixed a bug a while ago about copying the annotations specified on ITDs ontothe public members (bug 98901), I thought that covered the ITD on interface casebut possibly not.Yes, bug 73507 is to do with creating mangled member names for public fields.For non public fields, the members introduced on the target type are mangled topreserve the visibility rules.  You specify the field is 'private' to the aspectso no-one outside the aspect should be able to see it - we can't put a privatefield with the unmangled name on the target as then the methods in the targetcould see it.  Similar story with package protected. This works as expected:====import java.lang.annotation.*;@interface Annotation {}class C implements I {}interface I {}aspect X {  public static void main(String[] argv) {    C c = new C();    System.err.println(c.i);  }  @Annotation  public int I.i;  before(): get(@Annotation * *) {  }}====i.e. pointcut matching works for ITD'd fields.  Here is the output with-showWeaveInfo:C:\>ajc -1.5 -showWeaveInfo A.javaJoin point 'field-get(int I.i)' in Type 'X' (A.java:16) advised by before advice from 'X' (A.java:22)Type 'I' (A.java) has intertyped field from 'X' (A.java:'int I.i')Type 'C' (A.java) has intertyped field from 'X' (A.java:'int I.i')===So the developers notebook isn't incorrect - it doesn't say you'll find theannotations on the members introduced into the types, it is the ITD that isannotated.However, under that other bug we tried to allow for the case of public ITDs asits possible you may be running other tools off the output and need them to beannotated.  So to be complete we should copy them across in the case you raisedhere. Thanks to both of you for your quick replies. I should marked thisas a request for clarification. I am confused about the semantics ofan annotated ITD. I see two distinct possibilities:1. Only the ITD is annotated. No copy semantic. No matchingof get(@Annotation * *) as in aspect X of your example. To annotatedeclared members one would have to use declare @method @field etc. orannotate the annotation with e.g. a @Copy (makes (@Annotation * *) matching).With runtime retention policy these annotations would be present in the aspects bytecode annotating only the ITD. The annotations would be of no use for types that have declarations. Is there a use for only annotating the ITD?2. The semantic states: declare an annotated inter type field or method etc. With runtime retention policy the annotation is copied to the declared membersin the type regardless off scope. Matching of get(@Annotation * *) as in aspect X of your example. One would not have to use declare @method or @field for the declaration. The annotation is present when using reflection.The current implementation seems to be a mixture and in my opinion makes some problems:1. the semantic is not clear (either use @Copy or declar @field, @method etc.)   -- at least for me at the moment :-)2. annotations should be present regardless of scope3. even annotations of public field ITD to interfaces are not present at    runtime via reflection.    Do the 29 use cases of 98901 cover public ITD field declarations on    interfaces?Especially point 3 is important.Here is a use case. I have a EJB3 @Entity with FIELD AccessType. Makinga entity bean a bound bean like in the bean example I declared a private PropertyChangeSupport in an aspect. I would like to annotate this declared field with@Transient so it gets not persisted. (Declaring it transient would besufficient in this use case. But Hibernate has a bug depending on using annotation with @Transient.) There may be other tools using reflection and annotations to filter important members. And other use cases where it makessense to copy annotations regardless of scope.Thank you very much for your patience,Vincenz needs sorting out for RC1. Right - I have addressed the bug described in point (3) in the above comment:> 3. even annotations of public field ITD to interfaces are not present at >    runtime via reflection. >    Do the 29 use cases of 98901 cover public ITD field declarations on >    interfaces?Annotations on public field ITDs that target interfaces are copied to the fieldsthat are placed in the types implementing the interface.  This was a case notcovered by 98901.  The field name is still mangled, but the annotation is there.There should be no difference between directly annotating a field@SomeAnnotationint I.f;and using declare @field:int I.f;declare @field: int I.f: @SomeAnnotation;if they behave at all differently, its a bug.Addressing other points:> 1. the semantic is not clear (either use @Copy or declar @field, @method etc.)>    -- at least for me at the moment :-)The semantic is that for public ITDs the annotations are copied - because sometool may be driving off them (e.g. hibernate).> 2. The semantic states: declare an annotated inter type field or method etc. > With runtime retention policy the annotation is copied to the declared members> in the type regardless off scope. Matching of get(@Annotation * *) as in > aspect X of your example. One would not have to use declare @method or @field > for the declaration. The annotation is present when using reflection.As I mentioned above, there should be no difference between declaring theannotation on a member and specifying it directly against the member. the fixes are available in the latest build.  Does it now go some way towardsaddressing your use case?  I'm now looking at whether to mangle public fieldITDs on interfaces in bug 73507. closing. Thank you very much. For me it is important that allannotations are copied regardless of scope. What are thereasons to constrain it to public ITDs only?For me:@SomeAnnotationint I.f;and using declare @field:int I.f;declare @field: int I.f: @SomeAnnotation;behave the same. Is this last update also available via Eclipse AJDT Update Site? Possibly I was hasty in thinking of fields and methods as the same.  You willfind whatever visibility you declare the field ITD on an interface, you will geta public member in the implementors of the interface that has the annotations.I only copy the annotations because tools can drive off them at a later time -my intention is not to make java reflection work where users write programs thattrawl through the ajc$ fields making assumptions about the fields (i.e. someonenotices an ajc$interField$X$I$field1, that must be a field really called'field1' from aspect 'X' and then to find annotations on it they ask the itd'dfield) - anyone that writes code like that is writing very fragile code sincethe implementation could change at any moment (for example if 73507 goes ahead).    If someone wants to reflect on an AspectJ program, they should use the AspectJmeta aspect protocol interface which understands all about the constructs - andif you did ask an ITD field through the MAP for its annotations, it could easilyquery the ITD definition in the aspect to retrieve them, it doesnt need them toexist on the target mangled field inserted into a type.I dont think this fix will be in AJDT until Monday. "	2005-10-27 13:23:19	1130430000.0	resolved fixed	d9757d7	1131450000.0	tests/bugs150/pr114005/Declaration1.java tests/bugs150/pr114005/Declaration2.java tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java
90143	[itds] Problem with an ITD on an interface	"If an ITD method is declared on an interface with an anonymous inner class returned as the result, the compiler generates an error for any ""super.xxx"" calls in the anonymous inner class.  The example project shows this with a nested inner interface, but the same problem occurs with an ITD of this kind on any interface.  The error does not occur if the ITD is declared on an inner class (as shown in the example) or a normal class. Created attachment 19507Test projectTest case attached take a look for M3 Collapsed into one test program: class MyClass {  protected Object method() {    return null;  }}abstract aspect A {  interface C2 { }  public void C2.hello() {    new MyClass() {      protected Object methodX() {        return super.method();      }    };  }  // ok  class C { }  public void C.hello() {    new MyClass() {      protected Object methodX() {        return super.method();      }    };  }} putting on my todo list, testcase added to CVS. When we fail, at the top of MessageSend.resolveType(BlockScope) we attemptreceiverType.resolveType() and the receiverType is an InterSuperReference.  Whenwe succeed it is simply a normal SuperReference.When the ITD is on an interface we run a 'InterSuperFixerVisitor' over the bodyof the ITD.  (see InterTypeDeclaration.fixSuperCallsForInterfaceContext). Unfortunately it doesn't seem to realise when we've moved into an inneranonymous class (blurgh).  I modified the visitor to keep a stack counter whenit goes into local types - if its >0 we don't mess with the super calls.fix checked in, waiting on build. fix available. "	2005-04-04 06:46:08	1112610000.0	resolved fixed	21cf37d	1131120000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterSuperFixerVisitor.java tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java
112476	"""declare parents"" does not work with bytecode weaving"	"1. download and unpack http://www.fuurou.org/downloads/aspectjtest.zip (I couldn't find a way of attaching it) 2. copy the aspectj jars into the lib directory 3. run ant  The ant file executes both source code and byte code weaving and then it veryfies that the class hierarchy was changed. As you can see from the output in case of source weaving the test is:  [java] Is [class lib.C] subcass of [class weaved.SuperC]? true  while when weaving bytecode:  [java] Is [class lib.C] subcass of [class weaved.SuperC]? false Created attachment 28234test caseSame as http://www.fuurou.org/downloads/aspectjtest.zip, I did	not see theattachment option before fix available. i think I put that comment in the wrong bug - let me double check. something funny is going on.There is a bug, and I've fixed it - but I couldnt recreate it with the ANTbuild.xml as-is.  When I run the ant script, I get the same output as you:[java] Is [class lib.C] subcass of [class weaved.SuperC]? falseHowever, the reason it says 'false' is that this command:<java classname=""weaved.SuperC"">        <classpath>                <path refid=""aspectj.classpath""/>                <pathelement path=""${classes.dir}""/>                <pathelement location=""${dist.dir}/weaved-lib.jar""/>        </classpath></java>puts classes ahead of weaved-lib in order to find weaved.SuperC - and for somereason 'classes' still contains lib/A.class lib/B.class and lib/C.class - whenthey should have been deleted earlier.  When the old version of lib/C.class isloaded from classes, it reports that its new parent isnt SuperC.  The bug was incorrectly modifying super calls - we omitted the package name ifthe new parent was in a package which caused a hideous verifyerror.  If you wantto see the verifyerror, change the order in the task above to:        <classpath>                <path refid=""aspectj.classpath""/>                <pathelement location=""${dist.dir}/weaved-lib.jar""/>                <pathelement path=""${classes.dir}""/>        </classpath>I've put tests in the suite for this - but I'm not going to spend time debuggingthe ant any further.  I've no idea why the javac task that is told to compilesrc/weaved/* also compiles src/lib/*...fix checked in. fix is available. "	2005-10-13 09:44:09	1129210000.0	resolved fixed	a7e13f1	1131100000.0	tests/bugs150/pr112476/case1/lib/A.java tests/bugs150/pr112476/case1/lib/B.java tests/bugs150/pr112476/case1/lib/C.java tests/bugs150/pr112476/case1/weaved/SuperC.java tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java
114744	NPE at CaptureBinding.java on wildcard in intertype field type	"When compiling this program with ajc -1.5public aspect Wildcard {    Class<? extends Wildcard> Wildcard.cl;    void foo() throws Exception {	Wildcard ci = cl.newInstance();    }}ajc throws this exceptionjava.lang.NullPointerException        atorg.aspectj.org.eclipse.jdt.internal.compiler.lookup.CaptureBinding.initializeBounds(CaptureBinding.java:75)        atorg.aspectj.org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.capture(ParameterizedTypeBinding.java:105)        atorg.aspectj.org.eclipse.jdt.internal.compiler.ast.SingleNameReference.resolveType(SingleNameReference.java:772)        atorg.aspectj.org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:293)        atorg.aspectj.org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:199)        atorg.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:422)        atorg.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:178)        atorg.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:400)        atorg.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1076)        atorg.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.resolve(AspectDeclaration.java:114)        atorg.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1125)        atorg.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:305)        atorg.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:514)        atorg.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)        atorg.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:759)        atorg.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:225)        atorg.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:151)        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)        at org.aspectj.tools.ajc.Main.run(Main.java:326)        at org.aspectj.tools.ajc.Main.runMain(Main.java:240)        at org.aspectj.tools.ajc.Main.main(Main.java:83) thanks for the clear bug report - don't think you could write a much smallertestcase ;) Fix checked in.  The problem was in the conversion process between eclipse typesand aj types.  If it is not an ITD then no conversion takes place but if it isan ITD then the conversion process was losing some information about the typevariable behind '? extends Wildcard'  (which is 'T extends Object' from thegeneric type Class).I worry there are a few other bugs lurking in that conversion process :(fix checked in, waiting on build. fix available. "	2005-11-02 07:56:02	1130940000.0	resolved fixed	ade32bc	1130950000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java
113510	readAspect	"clearly define what the goal for readAspect isold byte per byte reading cause NPE in some test casecurrent impl is hashcode for aspect name + classloader - ie unstable acrossstartups. for resolution by rc1... This mechanism was added to support byte-code caching in a PoC OSGi environment. Actual aspect byte-code was use to determine when an aspect implementation had changed as well as the set of aspects affecting a particular class loader. However this approach is not sufficient to determine all the situations when a byte-code cache should be invalidated so I will change the implemtation to one that uses a sorted list of aspect names. Created attachment 29081FixRemove ""readAspect()"" method and use names instead. Have tested against my PoCthat needs it. patch integrated, thanks Matthew. "	2005-10-24 05:36:56	1130150000.0	resolved fixed	62d16d5	1130930000.0	loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java
108892	Load Time Weaving problem with Aspect Definition at 2 Levels of Hierarchy	"I am trying to weave into Tomcat with a system-level aspect (META-INF/aop.xml is found in a jar on the system classpath), and also have a Web application with an aop.xml properly deployed. When I try to run them both together, only the system-level aspects work. If I remove the system-level aspect jar from the classpath, the application-level aspects work. What would be a reasonable way to isolate this into a test case? If I could package up a simple system.jar and app.war file for Tomcat 5.5.9, would that be useful for you to use in debugging it? I tried making a simple standalone version with 2 aop.xml files in the same app classloader but that works just fine. tagging with M4... I'm not quite sure I understand the problem:1. When you say ""weav into Tomcat"" do you mean you are weaving Tomcat classes?2. When you say ""system classpath"" do you you java.class.path or sun.boot.class.path3. When you day ""only the system-level aspects work"" do you mean only the Tomcat classes are woven?4. Could you send the aop.xml files? Are you explicity including/excluding classes or aspects?5. Could you use weaver options ""-verbose"" and/or ""-showWeavInfo"" and append the resulting logs. Hi Matthew,1) I have added a jar to the CLASSPATH used on start-up of Tomcat (but not the bootclasspath). This jar includes a META-INF/aop.xml file. So the aspects in the jar will weave into everything loaded from the AppClassLoader down.2) java.class.path3) The jar in the CLASSPATH weaves properly into everything in the system. Debug information shows that both it and the Web application-level jar are being recognized for the Web app, but that only it is affecting the Web app.4) Here are the aop.xml files below5) I will post in a follow-upclasspath agent's aop.xml<!-- FIXME fails when DTD here and call from Ant--><!--<!DOCTYPE aspectj PUBLIC--><!--    ""-//AspectJ//DTD//EN""--><!--    ""http://www.aspectj.org/dtd/aspectj_1_5_0.dtd"">--><aspectj>    <weaver options=""-proceedOnError""> <!-- -showWeaveInfo -verbose -->         <exclude within=""com.crankj..*""/>        <exclude within=""org.eclipse..*""/>        <exclude within=""org.apache.struts.util..*""/>        <exclude within=""org.apache.catalina.core..*""/>        <exclude within=""org.apache.catalina.cluster..*""/>        <exclude within=""org.apache.commons..*""/>        <exclude within=""org.apache.xerces..*""/>        <exclude within=""org.apache.jasper..*""/>        <exclude within=""org.apache.tomcat.util..*""/>        <exclude within=""org.apache.catalina.util..*""/>        <exclude within=""edu.emory..*""/>        <exclude within=""org.apache.juli..*""/>        <exclude within=""org.apache.naming..*""/>        <exclude within=""org.apache.coyote..*""/>        <exclude within=""org.apache.catalina.storeconfig..*""/>        <exclude within=""org.apache.jk..*""/>        <exclude within=""org.apache.webapp..*""/>        <exclude within=""org.apache.log4j..*""/>        <exclude within=""org.springframework..*""/>        <!-- <exclude within=""*..*CGLIB$*""/>        <exclude within=""$Proxy**""/>        <exclude within=""sun.reflect.Generated*""/>        <exclude within=""com.sun.jmx..*""/> -->    </weaver>    <aspects>        <!-- see here nested class with ""."", ""$"" is accepted as well -->        <aspect name=""com.crankj.monitor.ui.ServletRequestMonitor""/>        <aspect name=""com.crankj.monitor.ui.StrutsRequestMonitor""/>        <aspect name=""com.crankj.monitor.resource.JdbcMonitor""/>        <aspect name=""com.crankj.config.CrankjSystemInitializer""/>    </aspects></aspectj>Web Application aop.xml file:<aspectj>	<!--  <weaver options=""-proceedOnError -showWeaveInfo -verbose""> -->	<weaver options=""-proceedOnError"">          <exclude within=""com.crankj..*""/>        <exclude within=""org.eclipse..*""/>        <exclude within=""org.apache.commons..*""/>        <exclude within=""org.apache.xerces..*""/>        <exclude within=""org.apache.naming..*""/>        <exclude within=""org.apache.catalina.storeconfig..*""/>        <exclude within=""org.apache.jk..*""/>        <exclude within=""org.apache.webapp..*""/>        <exclude within=""org.apache.log4j..*""/>        <exclude within=""org.springframework..*""/>	</weaver>    <aspects>        <aspect name=""com.crankj.aspects.BadSysInfluence""/>        <aspect name=""com.crankj.aspects.BadAppInfluence""/>    </aspects></aspectj> You may be encountering a bug with class loaders that I have experienced under OSGi (now fixed). Like that environment I presume Tomcat defines it's own. The problem lies with ClassLoader.getResources() which the AspectJ weaving adaptor uses to find all the available aop.xml files; in your case 2. The bug is that it only finds the first one. You can confirm this using the lastest AspectJ 5 M3, which has lot's of new diagnostic messages, and use ""-Daj.weaving.verbose=true"". I found that both the aop.xml files were being found, so the issue in my case occurred later... Could you append the log (or at least the relevant parts)? Do you get weaving messages for the required classes (indicating they are being processed) but no weaveInfo messages (indicating there are no matches)? I assume the classes are not in com.crankj which is excluded or org.aspectj, java or javax which are also exluded automatically.Have you looked at stderr? If an exception occurs during weaving it will be caught in the adaptor and logged but class loading will continue. Ron, can you update the status of this one?Does it still stands or? This is still a bug. I just tried with a recent dev build (Oct. 21) and I see the same behavior: I have a simple trace aspect in my Web application that works with load-time weaving (it is compiled in but there's also an aop.xml file that is showing as weaving when I deploy just the app).When I add a jar with load-time weaving to the parent classloader's classpath (i.e., Tomcat's shared lib directory), the Web application's LTW aspect no longer has an affect. I cranked up verbose weave information and you can see that the weaver is loading the aop.xml definitions, but it is not applying the advice from the child classloaders'...info using aspectpath: []info zipfile classpath entry does not exist: C:\java\jrockit-jdk1.5.0_03\jre\lib\i18n.jarinfo zipfile classpath entry does not exist: C:\java\jrockit-jdk1.5.0_03\jre\lib\sunrsasign.jarinfo directory classpath entry does not exist: C:\java\jrockit-jdk1.5.0_03\jre\classesinfo register classloader org.apache.jasper.servlet.JasperLoader@5075224info using file:/C:/jakarta-tomcat-5.5.9/shared/lib/crankjAgent.jar!/META-INF/aop.xmlinfo using /C:/jakarta-tomcat-5.5.9/webapps/jpetstore/WEB-INF/classes/META-INF/aop.xml cannot reproducesee test AtAjLtwTests.testAppContainer()look for AppContainerTest.java in tests/ modulesee the sandbox to get an hint on how the rather complex test case works(simulates on container with 2 deployed apps, sharing same classname inside likecompiled jsp can, with a global aspect, and one local aspect in only one of thedeployed app) just moved to P2 to make sure we close this out one way or another before RC1 Ron, can you provide a test case for that one ?I could not reproduce it. Fixed in recent builds. "	2005-09-06 22:05:34	1126060000.0	resolved fixed	794f9b5	1130500000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java tests/java5/ataspectj/ataspectj/hierarchy/AppContainerTest.java tests/java5/ataspectj/ataspectj/hierarchy/app/SubApp.java tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java
113861	[generics] field-get problems when generic field is used.	"Hi, When i'm compiling the following example, i'm getting this errors:TestAspect.aj:21 [error] incompatible return type applying to field-get(java.util.Set com.mprv.secsph.Test.intsSet)Test.java:18 [error] incompatible return type applying to field-get(java.util.Set com.mprv.secsph.Test.intsSet)Here is the example-------------------Java Code:package com;public class Test {	Set<Integer> intsSet;	public Set<Integer> foo() {18:         return intsSet;	}}Aspect:public privileged aspect TestAspect {    pointcut gettingMember(Test t) :                target(t) &&                get(!public Set<Integer> com.*.*) &&                !within(TestAspect);21: Set<Integer> around(Test t) : gettingMemberCollection(t)  {        Set s =  proceed(t);        return s;    }}I've tried many kinds of workarounds, and the only thing which worked, is defining the member field without using generics (regular Set) ... One more disturbing is, that this fiture worked(!) in M2 release. This is an example of the functionality that worked in my project (with M2), but now, also reports the same error:Java code is the same, Aspect is:public privileged aspect TestAspect {    pointcut gettingMember(Test t) :                target(t) &&                get(!public Set com.*.*) &&                !within(TestAspect);    Set around(Test t) : gettingMemberCollection(t)  {        Set s =  proceed(t);        return s;    }}Is it a bug? Or am i doing something wrong?Thanks!Misha. Doesnt look like you are doing anything wrong.  And I am not surprised it workedin M2 and fails now, M2 was not generics aware and it would have been working'by accident'.  Now the whole compiler/weaver is much more aware of generics andthis kind of thing is going to happen whilst we get it right. I can see why this is failing, fix almost ready. Fix checked in, waiting on build before closing.  As suspected it was that thesystem was more generics aware ... apart from in one place ;) (In reply to comment #3)> Fix checked in, waiting on build before closing.  As suspected it was that the> system was more generics aware ... apart from in one place ;)Thanks!I'll download the build as soon as it will be there ...  fix available in the latest dev build from the AJ download page. "	2005-10-26 14:01:17	1130350000.0	resolved fixed	8cea30f	1130440000.0	tests/bugs150/pr113861/Test.java tests/bugs150/pr113861/TestAspect.java tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java weaver/src/org/aspectj/weaver/Advice.java weaver/src/org/aspectj/weaver/Member.java weaver/src/org/aspectj/weaver/MemberImpl.java
99191	declare @field allowed for non existent fields	"///// in this code@interface anInterface{}aspect B {	  declare @field : int B.noSuchField : @anInterface; // should be an error}//////////////////I don't get an error, even though B.noSuchField doesn't exist.If I try declare @field on NoSuchCLass.noSuchField I do get an error though. it's the same for @method too, and probably @constructor etc. as well A clue for anyone who might be looking at this bug, I'd say look atDeclareAnnotation.resolve() which attempts to resolve a signature pattern. Based on whether that signature pattern correctly resolves (and if it is for@field/@method/@ctor) I might put out the error message, and if I didnt know howto put out a message, I might use something like:scope.getWorld().getMessageHandler().handleMessage(new Message(<somestuff>));... Created attachment 28431zip containing patch for @field part of fix and corresponding testsThis zip contains two patches:pr99191-tests-patch1.txt - to be applied to the tests projectpr99191-weaver-patch1.txt - to be applied to the weaver projectThe @field fix was to add extra logic toBcelClassWeaver.weaveDeclareAtField(..) to record which declare @fields matchand to report an error for each of those that don't.Running the test suite of 2502 tests, I recorded the following performancetimes:With fix: 648.202 s, 645.879 s, 647.972 sWithout fix: 650.816 s, 649.103 s, 646.519 s Created attachment 28512zip file containing tests and fixThe attached zip file contains two patches:- pr99191-tests-patch.txt - this should be applied to the tests project andcontains the tests for this bug- pr99191-weaver-patch.txt - this should be applied to the weaver project andcontains the fixThis is the fix and tests for all three cases: declare @field, declare @methodand declare @constructor. The scenarios which are covered in the tests for declare @field:- the specified field doesn't exist - this should give an error- the specified field is an ITD field - this should compile with no error- the specified field isn't an exact pattern - this should compile with noerror- the specified field already has the annontation on it - this should not givean errorCorresponding tests are also there for @method and @constructor.Running the 2516 tests with my fix took the following times:668.571s, 658.487s, 631.438. patch integrated. fix available. "	2005-06-09 12:08:17	1118330000.0	resolved fixed	2da9b31	1130430000.0	tests/bugs150/pr99191/pr99191_1.java tests/bugs150/pr99191/pr99191_2.java tests/bugs150/pr99191/pr99191_3.java tests/bugs150/pr99191/pr99191_4.java tests/bugs150/pr99191/pr99191_5.java tests/bugs150/pr99191/pr99191_6.java tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java
112615	-XhasMember is not processed correctly when passed from AJDT	"To test this in AJDT install the bean example, add a new interface called I and then add the following line to BoundPoint.aj:declare parents: hasmethod(* set*(..)) implements I;Now open the AspectJ Compiler preference page and select ""Has Member"" on the advanced tab.  Click OK, rebuild and if the option was working the project would build correctly.  As it stands there is an error:the type pattern hasmethod(* set*(..)) can only be used when the -XhasMember option is set Some hints perhaps ...I would follow through another option that you know gets through, when the pathis identified, do the same for hasMember.  It is the kind of option that is seton the world and then accessed throughout the weaver - I think possiblynotReweavable or lazyTjp might behave in a similar way, so try tracing those.You *could* create a testcase for this - it probably won't look like a normalone though because the option needs passing in the same way AJDT passes it,since if you pass it in the standard testcase way it works (see entries inajc150.xml).  As a base for the testcase you could do something likeMultiProjectIncrementalTests.testPr92837() - but you'll need to puzzle throughhow to get the option passed.  Or look at some of the subtypes of AjdeTestcase -which are also confusing ;) A simplified testcase is the following:--------------------------------------------------------------------public class PR102479 {	public void myMethod1() {	}	}interface I {	}aspect A {	declare parents: hasmethod(* myMethod*(..)) implements I;}-----------------------------------------------------------------The fix is to set -XhasMember in the AjBuildConfig.installGlobals(..) method inthe same way that -XlazyTjp is set. Currently writing a testcase to fit in with the aspectj testsuite beforeattaching a patch. Created attachment 28738patch containing fixThis is a patch containing the fix and should be applied to theorg.aspectj.ajdt.core project Created attachment 28739patch containing testThis is a patch containing the test and should be applied to the ajde project. fix committed waiting on build. fix available "	2005-10-14 08:26:11	1129290000.0	resolved fixed	cc6862f	1130240000.0	ajde/testsrc/org/aspectj/ajde/BuildConfigurationTests.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java
113511	LTW enhancements	"Alex, here is the basic patch that is working well before you leave for theweekend ;-) I'll let Matthew post it officially to bugzilla since it was hisidea. The earlier return from !enabled is a small addition I made that seemsto help further. It would be great to have this in HEAD so I can reportperformance numbers based on it in part 2 of my article on developerworks;-)Hope you are enjoying your new addition!Thanks!Index: ClassLoaderWeavingAdaptor.java===================================================================RCS file:/home/technology/org.aspectj/modules/loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java,vretrieving revision 1.18diff -u -r1.18 ClassLoaderWeavingAdaptor.java--- ClassLoaderWeavingAdaptor.java      19 Oct 2005 13:11:36 -0000      1.18+++ ClassLoaderWeavingAdaptor.java      21 Oct 2005 16:04:41 -0000@@ -107,8 +107,13 @@        // register the definitions        registerDefinitions(weaver, loader);+        if (!enabled) {+               return;+        }        messageHandler = bcelWorld.getMessageHandler();+bcelWorld.setResolutionLoader((ClassLoader)null);//loader.getParent());+        // after adding aspects        weaver.prepareForWeave();    }@@ -148,7 +153,11 @@                           definitions.add(DocumentParser.parse(xml));                       }               }-+               if (definitions.isEmpty()) {+                       enabled = false;+                       return;+               }+            // still go thru if definitions is empty since we willconfigure            // the default message handler in there            registerOptions(weaver, loader, definitions); commited this one (TomcatGlassBox startup 28s -> 21s)please attach next for World sharing on java.* things RC1 *** Bug 112817 has been marked as a duplicate of this bug. *** using P2 to track things for RC1 (P3 or below will not make the cut...) The reflection delegates code is now requiring a special type of world, a ReflectionWorld, which causes my previously working optimization that used reflection delegates when loading bootstrap classes to fail. This will also cause problems with any attempt to use reflection-based proxies to optimize instead of using BCEL proxies...In ReflectionBasedReferenceTypeDelegate this method fails now:	protected ReflectionWorld getReflectionWorld() {		return (ReflectionWorld) this.world;	}My changed code that supported this is in BcelWorld. I think Matthew's right that it is going to be better to replace BCEL delegates with reflection-based proxies by weaving into classloaders. However, either way, I think it's going to be important to support reflection-based proxies for load-time weaving.	protected ReferenceTypeDelegate resolveDelegate(ReferenceType ty) {        String name = ty.getName();        JavaClass jc = null;        if (hasResolutionLoader) {			try {					String asRes = name.replace('.', '/').concat("".class"");					// will I resolve this by delegating to my parent?					java.net.URL parentURL = parent.getResource(asRes);					if (parentURL != null && parentURL.equals(resolutionLoader.getResource(asRes))) {						Class resultBoot = Class.forName(name, false, parent);						if (resultBoot != null) {		        			return new ReflectionBasedReferenceTypeDelegate(resultBoot, this, ty);											}					}										Class resultBoot = Class.forName(name, false, null);					if (resultBoot != null) {	        			return new ReflectionBasedReferenceTypeDelegate(resultBoot, this, ty);										}							} catch (Throwable e) {				// proceed with normal			}        } Notes from a conversation with Adrian 10/11/05We need to reduce startup time and latent foot print. There are 3 things we can do:1.	Only weave when we need to. We have already identified the “enbled” flag as a way to avoid using a weaver when no aop.xml is present. This could be extended to include situations where no aspects are actually declared or defined.2.	Use reflection instead of byte-code when it is safe to do so. We can introduce a new LTW World & Weaver which is constructed with a class loader and uses both BCEL/byte-code as well as reflection to resolve types.3.	Replace byte-code when we are certain that a class has been successfully defined. Woven byte-code must be retained in memory because it is difficult and expensive to recreate. However once a class has been defined the byte-code can be replaced by the Class object. There are 3 levels of optimization possible:a.	Intercept successful calls to defineClass(), either though custom class loaders or weaving, and call back into the weaver.b.	Cascade define events from parent loaders for types used in resolution but not defined locallyc.	Use weak references to allow the ResolvedMembers associated with a delegate to be dropped and further reduce latent footprint.Certain environments make these optimizations difficult. It is not possible to share resources reliably between weaver worlds because the relationship between the class loaders with which they are associated cannot always be determined e.g. OSGi. Using reflection may only be safe when using the boot loader due to non-delegating web application class loaders. Byte-code must continue to be used for aspects as their meta-data is not available through reflection pre-Java 5. However they will represent a small proportion of types in the system and a hybrid delegate could be introduced used where reflection is used for Java meta-data and byte-code for AspectJ meta-data.Many of these enhancements will be targeted post 1.5.0 therefore I suggest closing this bug as resolved because it addresses the simple enhancement to use the enabled flag. We should raise a separate enhancement for each possible optimization (I have already opened bug 114083 to cover an LTWWorld) to help stage their introduction and wider testing. Using this bug as a long running “bucket” will just be confusing. Closing as per matthew's last comment. Ron :- note that the reflection world issue has been fixed under a separate bug report and your optimization should hopefully be working again now. I updated bug #114083 with an improved optimization. Unfortunately, it isn't so simple to integrate even just the bootstrap loader performance improvement because it results in ClassCastExceptions from code like this:	public static ResolvedMember createResolvedMethod(Method aMethod, World inWorld) {		ReflectionBasedResolvedMemberImpl ret = new ReflectionBasedResolvedMemberImpl(org.aspectj.weaver.Member.METHOD,				toResolvedType(aMethod.getDeclaringClass(),(ReflectionWorld)inWorld),				aMethod.getModifiers(),				toResolvedType(aMethod.getReturnType(),(ReflectionWorld)inWorld),Sample stack trace (from the debugger the method being resolved is public native int java.lang.Object.hashCode()):java.lang.ClassCastException: org.aspectj.weaver.ltw.LTWWorld	at org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegateFactory.createResolvedMethod(ReflectionBasedReferenceTypeDelegateFactory.java:83)	at org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegateFactory.createResolvedMember(ReflectionBasedReferenceTypeDelegateFactory.java:73)	at org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegate.getDeclaredMethods(ReflectionBasedReferenceTypeDelegate.java:232)	at org.aspectj.weaver.ReferenceType.getDeclaredMethods(ReferenceType.java:412)	at org.aspectj.weaver.ResolvedType.getDeclaredAdvice(ResolvedType.java:682)	at org.aspectj.weaver.ResolvedType.getDeclaredShadowMungers(ResolvedType.java:719)	at org.aspectj.weaver.ResolvedType.collectShadowMungers(ResolvedType.java:559)	at org.aspectj.weaver.ResolvedType.collectCrosscuttingMembers(ResolvedType.java:488)	at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect(CrosscuttingMembersSet.java:58)	at org.aspectj.weaver.bcel.BcelWeaver.addLibraryAspect(BcelWeaver.java:172)	at org.aspectj.weaver.loadtime.ClassLoaderWeavingAdaptor.registerAspects(ClassLoaderWeavingAdaptor.java:330)	at org.aspectj.weaver.loadtime.ClassLoaderWeavingAdaptor.registerDefinitions(ClassLoaderWeavingAdaptor.java:188)	at org.aspectj.weaver.loadtime.ClassLoaderWeavingAdaptor.initialize(ClassLoaderWeavingAdaptor.java:125)	at org.aspectj.weaver.loadtime.Aj$ExplicitlyInitializedClassLoaderWeavingAdaptor.initialize(Aj.java:130)	at org.aspectj.weaver.loadtime.Aj$ExplicitlyInitializedClassLoaderWeavingAdaptor.getWeavingAdaptor(Aj.java:135)	at org.aspectj.weaver.loadtime.Aj$WeaverContainer.getWeaver(Aj.java:101)	at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:65) "	2005-10-24 05:39:33	1130150000.0	resolved fixed	70888dd	1130150000.0	loadtime/src/org/aspectj/weaver/loadtime/Aj.java loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java
111915	illegal change to pointcut declaration	"org.aspectj.weaver.BCExceptionatorg.aspectj.weaver.patterns.ReferencePointcut.concretize1(ReferencePointcut.java:306)at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:229)atorg.aspectj.weaver.patterns.ReferencePointcut.concretize1(ReferencePointcut.java:331)at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:229)at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:216)at org.aspectj.weaver.Advice.concretize(Advice.java:273)at org.aspectj.weaver.bcel.BcelAdvice.concretize(BcelAdvice.java:83)atorg.aspectj.weaver.CrosscuttingMembers.addShadowMunger(CrosscuttingMembers.java:84)atorg.aspectj.weaver.CrosscuttingMembers.addShadowMungers(CrosscuttingMembers.java:78)at org.aspectj.weaver.ResolvedType.collectCrosscuttingMembers(ResolvedType.java:462)atorg.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect(CrosscuttingMembersSet.java:62)at org.aspectj.weaver.bcel.BcelWeaver.prepareForWeave(BcelWeaver.java:426)atorg.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:283)atorg.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:178)atorg.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367)atorg.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:760)atorg.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:225)atorg.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:151)at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)atorg.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)BCException thrown: illegal change to pointcut declaration:spike.np.CommandCase.handleCommand(BindingTypePattern(spike.np.OtherHandler$MyWorld,0))when batch buildingBuildConfig[/home/guido/workspace/.metadata/.plugins/org.eclipse.ajdt.core/np.generated.lst]#Files=11 Can you provide more information about what you were doing when you saw this?The aspect you're writing etc. Here is a minimal sample:package aj;public class SomeClass {    public void doSomething() {    }    public static void main(String... args) {        new SomeClass().doSomething();    }}package aj;public aspect MyAspect {    public interface MyWorld {    }    declare parents : SomeClass implements MyWorld;    pointcut doSomethingInMyWorld(MyWorld myWorld) :            execution(void SomeClass.doSomething()) &&            this(myWorld);    void around(MyWorld myWorld) : doSomethingInMyWorld(myWorld) {        System.out.println(""this works"");    }}package aj;public aspect DoesntCompile {    public interface MyWorld {    }    declare parents : SomeClass implements MyWorld;    pointcut doSomething(SomeClass someClass) :            execution(void SomeClass.doSomething()) &&            this(someClass);    pointcut doSomethingInMyWorld(MyWorld myWorld) : doSomething(myWorld);    void around(MyWorld myWorld) : doSomethingInMyWorld(myWorld) {    }} Thanks for the simplified testcase - I have been able to recreate the problem.This is a compiler bug so reassigning to aspectj. Created attachment 28111patch containing supplied testcaseThis patch is a patch to be applied to the tests project and contains thesupplied testcase written to fit in with the aspectj testcase structure. I've applied Helens patch then worked on reducing the test program as much aspossible, this fails:class SomeClass  {    public void doSomething() { }}aspect DoesntCompile {    declare parents : SomeClass implements Serializable;    pointcut doSomething(SomeClass someClass) :            execution(void SomeClass.doSomething()) &&            this(someClass);    void around(Serializable myWorld) : doSomething(myWorld) { }}If I directly apply Serializable (i.e. not use declare parents) then it works.If I change the around advice to take a 'SomeClass' then it works. Ok ... the problem here is the shadow munger is being concretized before thetype munger that adds the parent has had a chance to take effect.The message 'illegal change to pointcut' is hopeless.Before producing the message it is actually looking at the pointcut and checkingthat what you are binding 'Serializable' is the same or a supertype of the valuein the pointcut 'SomeClass'.  What you are doing is allowed because allSomeClass' are Serializable - however, because the declare parents hasntoccurred yet, we don't know SomeClass is Serializable.Thats why it works if you either:a) hardcode SomeClass implements Serializable and dont use declare parents.b) change the advice to 'void around(SomeClass myWorld)'what on earth I can do about it ...  hmmmmmmmmm The actual problem of using the wrong type in the pointcut is checked in two places.1. ReferencePointcut.resolveBindings   produces something vaguely helpful like the message:      incompatible type, expected SomeClass foundBindingTypePattern(java.io.Serializable, 0)2. ReferencePointcut.concretize1   produces the BCException:   ""illegal change to pointcut declaration:doSomething(BindingTypePattern(java.io.Serializable, 0))""I propose to remove the check for illegal change to pointcut decl as it:1. is done too early2. is duplicating something checked later3. is an exception for something that should be an error4. is extremely unhelpful Fix checked in - waiting on build. fix available. "	2005-10-07 11:14:18	1128700000.0	resolved fixed	3021284	1129880000.0	tests/bugs150/pr111915.java tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java
113073	weaveinfo messages not reported if applying declare @method on an ITD'd method	"Given the following class:@interface Annotation{}aspect B {		declare @method : public * C.anotherMethod(..) : @Annotation;}class C {}aspect D {	public void C.anotherMethod(String s) {	}	public void C.anotherMethod() {	}}I would expect a two weaveinfo messages of the form:weaveinfo 'public void C.anotherMethod()' (pr99191_4.java) is annotated with@Annotation method annotation from 'B' (pr99191_4.java:3)weaveinfo 'public void C.anotherMethod(String)' (pr99191_4.java) is annotatedwith @Annotation method annotation from 'B' (pr99191_4.java:3)However, only the two ""intertyped"" messages are coming out. The problem is that the BcelClassWeaver.reportMethodCtorWeavingMessage(..) isbeing called from within BcelClassWeaver.weaveDeclareAtMethodCtor(..) if themethod matches. However, the possible methods to match against don't include theintertype methods. The reason this is only showing up for 'declare @method' and not 'declare@field' is that the list of possible fields does include the interype fields. Created attachment 28442patch containing testcaseApply this patch to the tests project. Created attachment 28443patch containing fixApply this patch to the weaver project Created attachment 28502patch containing Improved testcaseThis patch should be applied to the tests project.It includes an improved testcase which also tests the weaveinfo messages from adeclare @contructor where the constructor is declared through an ITD. The fixdoesn't need to be changed because declare @constructor uses the same logic asthe declare @method. Created attachment 28509patch containing fix test and variant of patch committed. thanks helen.will close bug when build available. build available. "	2005-10-19 09:24:26	1129730000.0	resolved fixed	f06df41	1129820000.0	tests/bugs150/pr113073.java tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java
112027	unexpected error unboundFormalInPC	"In 1.5.0M4, I get error ""the parameter tis is not bound in [all branches of]pointcut"".  Not true of 1.2.1.  Untested in other development versions of 1.5.0.  No branches (all &&) but duplicate specification of this(..).------------------------------------------package demo;/** * PerThis */public class PerThis {    public static void main(String[] args) {        new This().test();    }}aspect PerThisTest perthis(pc()) {    // TutIndex example-basic-perthis    pointcut pc() : this(This) && !within(PerThisTest) && call(void run());    before(This tis) : pc() && this(tis){        System.out.println(""bef "" + this + "" <-- "" + tis);    }}class This {    int i;    void test() {        run();    }    void run() {        System.out.println(""run "" + this);    }} sort out for 1.5.0 Heres the smallest program with the problem:public aspect pr112027 {  pointcut pc() : this(pr112027);  before(pr112027 tis) : pc() && this(tis) { }}If we turn on pointcut rewriter debugging we can see whats happening:Initial pointcut is        ==>   (persingleton(pr112027) && (this(pr112027) &&this(BindingTypePattern(pr112027, 0))))Distributing NOT gives     ==>   (persingleton(pr112027) && (this(pr112027) &&this(BindingTypePattern(pr112027, 0))))Pull up disjunctions gives ==>   (persingleton(pr112027) && (this(pr112027) &&this(BindingTypePattern(pr112027, 0))))Simplifying ANDs gives     ==>   (this(pr112027) && persingleton(pr112027))Sorting ORs gives          ==>   (this(pr112027) && persingleton(pr112027))Notice at the simplifying ands stage we have ditched the important bindingpointcut designator!  This happens because we collect all designators into a setduring rewrite processing and this(pr112027) is considered equal tothis(BindingTypePattern(pr112027, 0)) when of course they are a little different...the fix is to change the equals code to realise the difference.  fix checked in(also tested it on Wes' larger program). waiting on build. fix available. "	2005-10-08 02:49:49	1128750000.0	resolved fixed	ae612d9	1129650000.0	tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java weaver/src/org/aspectj/weaver/patterns/BindingTypePattern.java weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java
107299	-aspectpath -inpath arguments fail without drive letter	"ajc doesn't recognize Windows absolute file paths that don't start with a drive letter, e.g., run:ajc -inpath \test.jar[error] build config error: bad inpath component: \test.jarbutajc -inpath c:\test.jarworksajc -aspectpath \test.jar Test.aj[error] build config error: bad aspectpath: \test.jarajc -aspectpath c:\test.jar Test.aj(works) Close as fixed?Interesting that no one has ever reported this!Java thinks new File(""\home"").isAbsolute() is false.  SoConfigParser.makeFile(..) was prepending directory to the ""relative"" path.  Tohandle absolute paths that look relative (!isAbsolute()),  I changedConfigParser(1.8).makeFile(..)  to take paths as absolute (and skip the prefixdir) if isAbsolute() is false but the path starts with File.separator and thefile exists (without the startsWith test, .lst-file-relative entries would pickup existing ${user.dir}-local resources of the same name).  Tested locally, butno portable test possible. Sounds great. I think Java's technically right that \foo isn't an absolute path since it is relative to the current drive in use (c:\foo vs d:\foo). But the fix sounds good. I will test when I next build/download... moving to fixed, please reopen if not working as expected. "	2005-08-18 01:41:22	1124340000.0	resolved fixed	332a5df	1129350000.0	util/src/org/aspectj/util/ConfigParser.java
112514	ajc compile crash, not giving information which class file cause it	<Pyinson Data Over Head> I've modified the code that throws the ClassFormatException to include context(the filename!) if knows it.  This will be in the next dev build. dev build available with improved diagnostics in - see AJ download page. fix available. 	2005-10-13 13:24:15	1129220000.0	resolved fixed	999d9b0	1129280000.0	bcel-builder/src/org/aspectj/apache/bcel/classfile/ClassParser.java
112243	Compiler Core Dump with Apparent Fix	"I am seeing this exception when using ajc to do binary weaving:     [iajc] Exception thrown from AspectJ 1.5.0M4     [iajc] This might be logged as a bug already -- find current bugs at     [iajc]   http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&component=Compiler     [iajc] Bugs for exceptions thrown have titles File:line from the top stack,     [iajc] e.g., ""SomeFile.java:243""     [iajc] If you don't find the exception below in a bug, please add a new bug     [iajc] at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ     [iajc] To make the bug a priority, please include a test program     [iajc] that can reproduce this exception.     [iajc] org.aspectj.weaver.MissingResolvedTypeWithKnownSignature     [iajc] when batch building with classpath: ...     [iajc] org.aspectj.weaver.MissingResolvedTypeWithKnownSignature     [iajc] java.lang.ClassCastException: org.aspectj.weaver.MissingResolvedTypeWithKnownSignature     [iajc]     at org.aspectj.weaver.bcel.BcelWorld.addSourceObjectType(BcelWorld.java:277)     [iajc]     at org.aspectj.weaver.bcel.BcelWeaver.addClassFile(BcelWeaver.java:373)     [iajc]     at org.aspectj.weaver.bcel.BcelWeaver.addJarFile(BcelWeaver.java:306)     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.initBcelWorld(AjBuildManager.java:598)     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:204)     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:151)     [iajc]     at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)     [iajc]     at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)     [iajc]     at org.aspectj.tools.ajc.Main.run(Main.java:326)     [iajc]     at org.aspectj.tools.ajc.Main.runMain(Main.java:240)     [iajc]     at org.aspectj.tools.ajc.Main.main(Main.java:83)     [iajc] 1 fail|abortI see this also in HEAD and used the debugger to determine it is trying to resolve the type that it's trying to load!I am able to get it to finish the weave with no errors by changing BcelWorld as follows:	public BcelObjectType addSourceObjectType(JavaClass jc) {		BcelObjectType ret = null;		String signature = UnresolvedType.forName(jc.getClassName()).getSignature();		ReferenceType nameTypeX = null;		Object lookup = typeMap.get(signature);		if (lookup instanceof ReferenceType) {			nameTypeX = (ReferenceType)lookup;		}Instead of just casting. Then the result is null and it falls through to the usual lookup unresolved type logic. Is this fix correct?I suspect it would take a few hours to narrow down a test case for this one. Bug 84572 is the same problem.  And as I mentioned in that bug, I would rathersee what has accidentally made it into the type map.  Ron - as you are workingon it, can you change your logic a little to print out what *was* in the typemap which is preventing the cast from working?  Something like:public BcelObjectType addSourceObjectType(JavaClass jc) {  BcelObjectType ret = null;  String signature = UnresolvedType.forName(jc.getClassName()).getSignature();  ReferenceType nameTypeX = null;  Object lookup = typeMap.get(signature);  if (lookup instanceof ReferenceType) {     nameTypeX = (ReferenceType)lookup;  } else {    System.err.println(""Signature: ""+signature);    System.err.println(""lookup: ""+lookup+"" ""+lookup.getClass());  }and let me know what it says?  I can then hopefully determine if just 'ignoring'the entry in the map is safe. adding} else if (lookup != null){	System.err.println(""DEBUG typeref: Signature: "" + signature);	System.err.println(""lookup: "" + lookup + "" "" + lookup.getClass());producesDEBUG typeref: Signature: Lcom/sample/service/ejb/BungeApplicationServiceBean;lookup: com.sample.service.ejb.BungeApplicationServiceBean class org.aspectj.weaver.MissingResolvedTypeWithKnownSignatureUp the stack trace I can see that this is the very type being loaded from the inpath. I think it's because there's a reference to it in an entry in the aspectpath. thanks for doing that so quickly Ron - I'll mull it over on my lunchtime run :) Ron,Can you try applying this patch to World.java (not BcelWorld):========================== snip below here =======================Index: World.java===================================================================RCS file:/home/technology/org.aspectj/modules/weaver/src/org/aspectj/weaver/World.java,vretrieving revision 1.58diff -u -r1.58 World.java--- World.java	11 Oct 2005 08:25:09 -0000	1.58+++ World.java	12 Oct 2005 14:17:23 -0000@@ -684,6 +684,11 @@ 					System.err.println(""Not putting a bounded reference type into the typemap:key=""+key+"" type=""+type); 				return type; 			}+			if (type instanceof MissingResolvedTypeWithKnownSignature) {+				if (debug) +					System.err.println(""Not putting a missing type into the typemap:key=""+key+"" type=""+type);+				return type;+			} 						 			if (isExpendable(type))  { 				return (ResolvedType) expendableMap.put(key,type);========================== snip above here =======================I'm not surprised to see the problematic entry being theMissingResolvedTypeWithKnownSignature.  And of course this fails because it is asubtype of ResolvedType and not a subtype of ReferenceType.I'd rather keep that entry out of the type map in the first place ... I think. Can you try it? That fixes it too, and more elegantly ;-) If I enable the print-lines I see this:Not putting a missing type into the typemap: key=Lcom/sample/service/ejb/BungeApplicationServiceBean; type=com.sample.service.ejb.BungeApplicationServiceBeanNot putting a missing type into the typemap: key=Lcom/sample/service/ejb/BungeApplicationServiceBean; type=com.sample.service.ejb.BungeApplicationServiceBeanSo that solves the problem for me. Thanks. thanks for testing it Ron - i'll put in a variant of my fix and your fix - as ifit ever happens again I'd like to know what was accidentally in the type map. Working on it right now... fix committed - waiting on build. fix available. "	2005-10-11 14:27:35	1129060000.0	resolved fixed	04e8dca	1129200000.0	weaver/src/org/aspectj/weaver/World.java weaver/src/org/aspectj/weaver/bcel/BcelWorld.java
56779	[ajdoc] add ajdoc support for inter-type declarations and other declare forms	"Currently ajdoc only exposes the ""Advises"" and ""Advised by"" relationships from the structure model.  It needs to support inter-type field and member declarations using a UI similar to how Javadoc presents inherited members.It also needs to support the other declare forms: error, warning, soft, parents, and precedence. Also add ""pointcut used by"" relationship (Ron's request). Also support @see javadoc tag for pointcut definitions. I haven't tried this with advice, but it should also be supported there. Ajdoc should show advised by relationships for interface static initialization (like the IDE browser does). Both Ajdoc and the IDE support should show advised by relationships for interface members too!  We're going to need this for ajdoc'ing the AspectJ 5 library, raising priority. not generics, moving to M4 Lower priority than core ajdoc on Java 5 support. Done.  All declare forms including inter-type fields and methods now show up in the documentation,and have an ""Affects"" section of links to any elements that the ASM determines they affect. "	2004-03-30 12:31:51	1080670000.0	resolved fixed	ab6c7a5	1128530000.0	ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java ajdoc/src/org/aspectj/tools/ajdoc/StructureUtil.java ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java ajdoc/testdata/declareForms/DeclareCoverage.java ajdoc/testsrc/org/aspectj/tools/ajdoc/AjdocTests.java ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java ajdoc/testsrc/org/aspectj/tools/ajdoc/DeclareFormsTest.java ajdoc/testsrc/org/aspectj/tools/ajdoc/ExecutionTestCase.java ajdoc/testsrc/org/aspectj/tools/ajdoc/PatternsTestCase.java ajdoc/testsrc/org/aspectj/tools/ajdoc/PointcutVisibilityTest.java ajdoc/testsrc/org/aspectj/tools/ajdoc/SpacewarTestCase.java asm/src/org/aspectj/asm/IRelationship.java
92837	[inc-compilation] Incremental Compilation Fails for ITD's on Aspects	"On my project, when I save an aspect that calls an inter-type declaration defined on itself, the incremental compiler gives a message like this:The method logError(String, Exception) is undefined for the type Foo Foo.javaRunning a full build clears the error.This might be a compiler bug, or it might be AJDT (I never run command-line incremental compilation, so I don't know :-)).Unfortunately, simple test cases or extracts of just the 2 aspects aren't reproducing the issue, so let me know if you need me to spend some time trying to create a small isolated version of the issue. Hi Ron - it is an AspectJ bug and I'm really keen to resolve errors in thisspace - based on your description I tried to recreate the problem but I can'tseem to get it to fail.  If you have time to look into it, I will fix it...In my attempt, I created two aspects:X.aj----public aspect X {  before(): call(* *(..)) && !within(X) {    Y.log();  }}Y.aj----public aspect Y {  public void X.log() {}}---------initially that advice doesn't exist in X and I build the system, then I change Xto include it and do an incremental build - it doesn't fail :(  But it'ssomething very similar to that scenario that does fail.I think it only happens if you perform a sequence of saves and I believe ITDshave to be in the mix - but that's all I've managed to work out so far :( Any other constructs in your aspects?  inlinable around advice? declares? Andy, I was able to create the following small test case. Each of these types lives in its own source file. If you incrementally compile AbstractDerived, it fails. If you do a full rebuild it works...package sample;public abstract aspect AbstractBase {	protected Holder member;}package sample;public abstract aspect AbstractDerived extends AbstractBase {    Object x = getLogger();}package sample;public interface Holder {}package sample;public aspect Logging {	declare parents: sample.* && !Logging implements Loggable;	public interface Loggable {}	public Object Loggable.getLogger() { return null; }}Another interesting problem I ran into while weaving the same logging aspect using the AJ5 load-time weaving support was:java.lang.NegativeArraySizeException	at org.aspectj.weaver.patterns.TypePatternList.read(TypePatternList.java:476)	at org.aspectj.weaver.patterns.DeclareParents.read(DeclareParents.java:90)	at org.aspectj.weaver.patterns.Declare.read(Declare.java:35)	at org.aspectj.weaver.AjAttribute.read(AjAttribute.java:107)	at org.aspectj.weaver.bcel.BcelAttributes.readAjAttributes(BcelAttributes.java:42)	at org.aspectj.weaver.bcel.BcelObjectType.unpackAspectAttributes(BcelObjectType.java:191)	at org.aspectj.weaver.bcel.BcelObjectType.<init>(BcelObjectType.java:98)	at org.aspectj.weaver.bcel.BcelWorld.makeBcelObjectType(BcelWorld.java:239)	at org.aspectj.weaver.bcel.BcelWorld.resolveObjectType(BcelWorld.java:234)	at org.aspectj.weaver.World.resolveObjectType(World.java:151)	at org.aspectj.weaver.World.resolve(World.java:130)	at org.aspectj.weaver.World.resolve(World.java:109)	at org.aspectj.weaver.World.resolve(World.java:147)	at org.aspectj.weaver.tools.WeavingAdaptor.shouldWeaveAspect(WeavingAdaptor.java:206)	at org.aspectj.weaver.tools.WeavingAdaptor.shouldWeave(WeavingAdaptor.java:185)	at org.aspectj.weaver.tools.WeavingAdaptor.weaveClass(WeavingAdaptor.java:176)	at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:74)	at org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter.transform(ClassPreProcessorAgentAdapter.java:54)	at sun.instrument.TransformerManager.transform(TransformerManager.java:122)...This might have something to do with incompatibility between the loadtime5 branch and the AJDT milestone build that I'm using, but they are from the same epoch and generally work together, so it might not. Any idea why in the debugger it shows a length of -768? <Pyinson Data Over Head> Thanks for the example program Ron, I'll try that.  I'm a little nervous aboutyou working off the branch as that is very old now - as you are so keen on theLTW changes in it, we could think about moving them down into the base soonerrather than later.  hmmm.  Some of your problems really could be related tousing a new AJDT and the branch for LTWing.   investigate for M3 Reached crunch time, now concentrating on just getting generics going for M3.Incremental problems are moving post M3 I have also encountered this problem (the incremental compilation part).Here is a minimal case to reproduce it. The interface and aspect each live intheir own file. Each time I save the aspect file, the error appears and a cleanis required to get rid of it.public interface Foo {}import java.util.ArrayList;import java.util.List;public aspect Bar {    private List<String> Foo.l;    private void Foo.foo() {        l = new ArrayList<String>();    }} From Ron DiFrango on the mailing list, here is another case of the sameincremental bug, or a related one:Matt,As you point out, these are hard to re-produce.  Maybe the steps [which is acombination of my previous two posts] that I used is as follows:Created the following aspect:package com.tascon.tim.sofia.aop;import com.salmonllc.jsp.JspTableRow;public aspect SofiaJspTableRow {   pointcut generateHtml(JspTableRow row) :       execution(public void JspTableRow.generateHTML(..))       && target(row);   void around(JspTableRow row) throws java.io.IOException :generateHtml(row)   {       System.out.println(""Executing my aspect now."");       proceed(row);   }}Performed an incremental compile [and deploy it to my App Server], then Imodified that same aspect so that it resulted in the following;package com.tascon.tim.sofia.aop;public aspect SofiaJspTableRow {private DataStoreEvaluator JspTableRow._dsEval = null;/*** Use this method to bind this component to an expression in aDataStore* @param ds The DataStore to bind to.* @param expression The expression to bind to.* @see DataStoreEvaluator*/public void JspTableRow.setExpression(DataStoreBuffer ds,DataStoreExpression expression) throws Exception {// RRD: Error on this line because it can not see _dsEvalthis._dsEval = new DataStoreEvaluator(ds, expression);// RRD: Error on this line because it can not see _dsEval}pointcut generateHtml(JspTableRow row) :execution(public void JspTableRow.generateHTML(..))&& target(row);void around(JspTableRow row) throws java.io.IOException :generateHtml(row){// RRD: Error on this line because it can not see _dsEvalif (row._dsEval != null){System.out.println(""row._dsEval is NOT NULL."");}else{System.out.println(""row._dsEval is null."");}proceed(row);}}Then, I attempted to perform another incremental compile with a call to this newmethod from another class and I got an error and could not compile until I didthe full re-build.Also, this maybe of important note, these aspects affect only classes in abinary jar that I am weaving into.Ron I think this is related to a bug I raised of my own, bug 108099.  I plan tostart work on it tomorrow... using all the nice examples in here as testcases :) I hate incremental bugs.I managed to get Ron Bodkins scenario from comment #2 failing reliably in the AJtest harness.  After some effort debugging it turns out to be exactly the sameproblem as I covered in bug 85132.  The problem is that when AbstractDerived issaved for the second time, we have lost the declare parents information thatAbstractBase implements Loggable - so we never discover the ITD on Loggable -and compilation fails.I'm trying to decide how much of a leap it is to conclude that incrementalcompilation of ITDs only goes wrong when used with declare parents...  doeseveryone use declare parents with ITDs?  This might certainly explain why I'vehad so much trouble recreating the problem.  Ron DiFrangos program below doesn'tappear to include any declare parents - but he is binary weaving ITDs into a jarwhich I think could be something else.Considering that we didn't have a problem for a while and that it suddenly gotworse, I wonder if that coincided with the binary weaving declare parents work Idid.  Until I'd implemented binary decp we always modified the parentspermanently - so in the example above, AbstractBase will always implementLoggable, even on the 2nd compile.  I've been talking about the fix for thisproblem under bug 85132. Fixed!  See bug 85132.  I'm raising comment #7 as a new bug since its genericsrelated (bug 111779). waiting on build before closing.  Ron (Bodkin), thanks somuch for your test program! fixed as per andy's last comment "	2005-04-26 17:48:55	1114550000.0	resolved fixed	727b0f5	1128520000.0	tests/multiIncremental/PR92837/base/sample/AbstractDerived.java tests/multiIncremental/PR92837/base/sample/Holder.java tests/multiIncremental/PR92837/inc1/sample/AbstractDerived.java tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java
91417	-Xreweavable should be the default	"In order to facilitate widespread use of LTW we need to ensure code is compiled with –Xreweavable. However we cannot rely on developers to use this flag so it must be the default. Unfortunately the current code bloat is unacceptable for large projects. Should try and look at this prior to 1.5.0 shipping.  Currently we have normalreweavable which keeps a copy of the pre-woven class file, orreweavable:compress which keeps a zipped (using ZipStream) copy of the pre-wovenclass file.  We need to look at some binary diff tools, and either:- Just do a diff between the class bytes pre and post weave.- Use more knowledge that we are diffing class files and perhaps processdifferent areas (constant pool, code attributes) differently. See WeaverStateInfo.readAnyReweavableData andWeaverStateInfo.writeAnyReweavableData.  That's where the improvements should go- toughest bit will be getting hold of the bytes representing the finally wovenclass as that must include everything *except* the WeaverStateInfo attributewhere the delta will be stored. Numbers and stuff=================I've made two additional versions of -Xreweavable:compress,one which stores the DIFF of the unwoven fileand one which stores the COMPRESSED DIFF of the unwoven file.SIZE ON DISK============				PROJECT SIZE	ZIPPED JAR SIZEWOVEN				100%		48%REWEAVABLE			152%		58%REWEAVABLE:COMPRESSED		125%		75%REWEAVABLE:COMPRESSED DIFF	110%		59%REWEAVABLE:DIFF			115%		56%These show some interesting results: compiling using reweavable:compressedactually _increases_ the size of the outjar considerably! This is because thesecond compression can't see that the zipped part of reweavable files is verysimilar when unzipped to the non-zipped part of the reweavable files.This means that reweavable:diff is the best overall, as people who care aboutdisk space usage will (should) be compiling to an outjar.So overall:From woven (not reweavable) to woven:reweavable using an outjar, the increase insize was 120%And now, from woven (not reweavable) to woven:reweavable (using diff) using anoutjar, the increase in size is 117%So, I'm going to clean up my code a bit, add some unit tests and then perhapsmake ""uncompressed diff"" the default. Note, the project I used to get this data on consisted of 77 source files, 72 ofwhich were touched by aspects. If I'm going to make the uncompressed diff thing the default,then -Xreweavable and -Xreweavable:compress will become depricated..and perhaps a couple of extra -X options should be added:-Xreweavable:noDiffand-XnoReweavable What is the performance impact to the build time for the different modes? reweavable took 8.54 secondsreweavable:compress took 8.69 secondsand reweavable with the diff took 9.68 secondsgiven that the test-project had 77 files,diffing it would be 13.68 seconds longer than just doing it reweavable on a 1000file project.Thats too long, isn't it? How long does it take to compile that program (77 files) with *no* reweavableoption specified?  It's not necessarily a problem that building 1000 fileproject takes 13 seconds longer, since we will hopefully normally be doingincremental compiles for single file changes, and as long as that remains nearinstant (<1second) then we may be OK.I'm just trying to decide the right conditions under which to make reweavablethe default.  Alex has already changed AJ so that aspects are always builtreweavable - the question is over what to do for normal classes... I've just made a new way of diffing the file, which I'm calling ""DumDiff""SIZE ON DISK============				PROJECT SIZE	ZIPPED JAR SIZEWOVEN				100%		48%REWEAVABLE			152%		58%REWEAVABLE:DIFF			115%		56%REWEAVABLE:DUMDIFF		122%		55%DumDiff is incredibly fast(at least ten times as fast as diff)and it produces the smallest zipped-jar size...so now I think DumDiff should become the default. the dumdiff reweavable method makes the project 114% of the size it would benon-reweavable. We should also remove -noweave at the same time because it is evil and will no longer be necessary. Created attachment 27338partly complete patch Alright, having found that months ago I accidentally deleted the wrongworkspace, I've had to rewrite the diff thing I had. The good news is the newversion works and is better than the old one was :)I'm including a patch here of what I've got so far just incase my computerexplodes..it currently works the same as normal, but when -Xreweavable:compress isspecified it uses my diff thing....I'll put another patch here soonish which will be back compatible with filesmade with the old -Xreweavable:compress, and which will have all the optionswired up correctly, the new options will be:(nothing)		the default makes classfiles reweavable using my diff			  thing-Xreweavable		the same as the default, but outputs a warning-Xreweavable:compress	the same as the default, but outputs a warning-Xnoweave		gives an error-XnotReweavable 	makes non-reweavable classfilespeople should tell me now if they want the options to do different things! dont change -Xnoweave!!  I know we don't like it but I use it all the time fortesting. acknowledged Created attachment 27436complete patchThis zipped patch is synchronised and passes all therun-these-before-you-commit tests. assigning to andy... reminding myself that this is likely to break incremental compilation, watch out! Andrew, I can't apply the entire patch (bloody linux).  I need you to sync andrecreate the patches *only* for the org.aspectj.ajdt.core module and theloadtime module.  The others went on OK. Created attachment 27560loadtime and org.aspectj.ajdt.core againdon't know if this'll work any better :-/ hmmmmm - did you sync before making those new diffs? they don't seem to takeaccount of -Xdev:pinpoint which is in the argument parsing logic now....  i'mtrying to hack them in regardless but it may go wrong. Created attachment 27614one more timedamn whitespace! This feature is about to go in.  I've been tweaking it a bit today and had tochange some option handling slightly so that it worked with some of the otherrecent changes that have gone into CVS.I thought I'd try it out building the biggest AJ project we have, Shadows.           -XnotReweavable                               (default reweavable)time tobuild         ~41s                                           ~41sSize ofbin directoryafter build            8532463bytes                                    9198561bytesZipped bindirectoryafter build            3760391bytes                                    3949184bytesThere are >1200 files in shadows.  Average impact is about 500bytes on each7000byte class file, which is <10%Comparing this with the old reweavable implementation:Xreweavable: 9960142 bin dir, 4036844 zipped.Xreweavable:compress: 9107662 bin dir, 4358636 zipped.I am going to tag the tree before checking it in ... just in case ;) well ... i've done it, this feature is now integrated into CVS.  it will beinteresting to see how well it behaves with AJDT. reweavable is default *gulp* I strongly suspect we should make -XnotReweavable  the default for LTW as is no doubt more expensive and redundant in that mode. "	2005-04-14 11:16:09	1113490000.0	resolved fixed	12e6334	1128520000.0	loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java loadtime/src/org/aspectj/weaver/loadtime/Options.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/core/AspectJCore.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AspectJBuilder.java org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BinaryFormsTestCase.java org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AjCompilerOptionsTest.java taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java testing/newsrc/org/aspectj/testing/WeaveSpec.java testing/src/org/aspectj/testing/harness/bridge/CompilerRun.java tests/java5/ataspectj/ataspectj/ltwlog/MainVerboseAndShow.java tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java weaver/src/org/aspectj/weaver/WeaverStateInfo.java weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java
108117	Complete implementation of abstract generic aspects	this requires1/ completion of the parameterizeWith implementation in the pointcut AST nodes2/ a much more exhaustive test suite around it. for M4 raising to P2 My part of this is now complete - all shadow mungers and all declare based type mungers are now working. Just leaves ITDs to be finished off, and that's for Andy... over to you! I've done as much as I plan to do, generic ITDs are working pretty well.  Bug112105 covers the gory (really gory) details and I'm continuing work under that bug. 	2005-08-26 10:35:57	1125070000.0	resolved fixed	451fea8	1128510000.0	weaver/src/org/aspectj/weaver/patterns/AnnotationPatternList.java weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.java weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java weaver/src/org/aspectj/weaver/patterns/ConcreteCflowPointcut.java weaver/src/org/aspectj/weaver/patterns/DeclareAnnotation.java weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java weaver/src/org/aspectj/weaver/patterns/HandlerPointcut.java weaver/src/org/aspectj/weaver/patterns/PerCflow.java weaver/src/org/aspectj/weaver/patterns/PerFromSuper.java weaver/src/org/aspectj/weaver/patterns/PerObject.java weaver/src/org/aspectj/weaver/patterns/PerSingleton.java weaver/src/org/aspectj/weaver/patterns/PerTypeWithin.java weaver/src/org/aspectj/weaver/patterns/Pointcut.java weaver/src/org/aspectj/weaver/patterns/ThisOrTargetAnnotationPointcut.java weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java weaver/src/org/aspectj/weaver/patterns/TypePattern.java weaver/src/org/aspectj/weaver/patterns/WithinAnnotationPointcut.java weaver/src/org/aspectj/weaver/patterns/WithinCodeAnnotationPointcut.java weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java
111481	varargs doesn't work for ITD'd constructors	"The following program doesn't compile:class MyClass {  public static void main(String []argv) {    new MyClass(new Object[]{""a"",""b"",""c""});    new MyClass(""a"",""b"",""c"");  }}aspect A {    public MyClass.new(Object... names) {    	System.out.println(names[0]);    }}(this is similar to bug 110906) One for Helen :) Created attachment 27849zip file containing test and fix patchesThe zip file contains two patches:- pr111481-org-aspectj-ajdt-core-patch.txt to be applied to theorg.aspectj.ajdt.core project- pr111481-tests-patch.txt to be pplied to the tests projectThe fix involved porting the changes made to the build method in.../asm/InterTypeMethodDeclaration.java for the fix for bug 110906 to the buildmethod in .../asm/InterTypeConstructorDeclaration.java. patch integrated, waiting on build. fix available. "	2005-10-04 12:25:10	1128440000.0	resolved fixed	2b0e675	1128500000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeConstructorDeclaration.java tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java
77269	Advice on inner classes not show in Outline view or gutter	"Advice associated with pointcuts that match join points in inner classes are not shown. Declare warning/error are shown however. See attached screenshot for example below. Notice WEAVEINFO messages indicate problem is in AJDT not AspectJ. Also notice phantom entry in Outline view ""injar aspectL Test.java"".package bug_nnnnn;public class Test {	public void test () {		new Runnable() {			public void run() {				try {					throw new Exception();				}				catch (Exception ex) {					handleException(ex);				}			}		};	}		public static void handleException (Throwable th) {			}		public static void main(String[] args) {		try {			throw new Exception();		}		catch (Exception ex) {			handleException(ex);		}	}}aspect Aspect {		declare warning : call(void handleException(..)) && !within(Aspect) :		""Only Aspect should handle exceptions"";		pointcut caughtExceptions (Throwable th) :		handler(Throwable+) && args(th);		before (Throwable th) : caughtExceptions(th) {		Test.handleException(th);	}} Created attachment 15474Eclipse screenshot Upon investigation this looks like a structure model bug as the relationships do not seem to be appearing in the relationships map maintained by the ASM.  Transferring to AspectJ project Note:  This bug only affects anonymous inner classes fix as part of the structure model overhaul & incremental work etc. in aj5m3timeframe?? Is this related to the $Local$ problems on 1.5.0M3? retest when $local$ is fixed. won't hold m3 for this... This bug has several parts to it:(1) The advice associated with pointcuts that match join points in inner classesare not shown - this is true both for anonymous and named inner classes. Thereason this is happening is the processing for classes of the form Test$1 (whichthe new Runnable() {..} is compiled to) is wrong. With named inner classes,we're looking for classes of the form Test$1$C. Again, the existing logicdoesn't handle this correctly. It says it can't find the corresponding class andconsequently doesn't generate any entries in the relationship map since itdoesn't have both ends of the relationship (source and target). (2) The declare warning is slightly different in that the relationship isappearing in one direction in the structure model (i.e that the declare warningis matched by the new Runnable() {..} run() method), however, it's not appearingin the other direction (i.e. that the new Runnable(){..} run() method matchesthe declare warning). This is why there's the misleading entry ""injar aspectTest.java"". At the time this bug was raised, if AJDT couldn't find bothdirections then it put out this spurious message. In the latest AJDT, you wontsee the injar aspect message, but you wont see the correct one either. Again, Ibelieve it's all down to the processing of class names of the form Test$1. Created attachment 27755zip file of 3 patches containing fix for first part of this bugThe zip file contains three patches:- pr77269-asm-patch.txt to be applied to the asm project- pr77269-org-aspectj-ajdt-core-patch.txt to be applied to theorg.aspectj.ajdt.core project- pr77269-tests-patch.txt to be applied to the tests projectwhich together include the fix and tests for the first part of this bug, namelythe advice affecting inner classes not appearing in the relationship map. The fix involves adding extra logic to the processing of IProgramElements inthe AspectJElementHeirarchy to take into account names of the form Test$1 andadding the type name (i.e. Test$1) as the byteCodeSignature for types of theform Test$1 so this can be used in the processing of IProgramElements. Created attachment 27764zip containing patches and testsThe zip file contains three patches:- pr77269-asm-patch.txt to be applied to the asm project- pr77269-org-aspectj-ajdt-core-patch.txt to be applied to theorg.aspectj.ajdt.core project- pr77269-tests-patch.txt to be applied to the tests projectwhich together include the fix and tests for this bug (both the problem of theadvice not being in the relationship map and the declare warning not showing upeither).The difference between this patch and the previous is that this patch has atest where the class is in a package rather than the default package, plus atest for the declare warning part of this bug. There is also extra logic inAsmHierarchyBuilder when adding the type name as the byteCodeSignature to takeinto account the fact that classes can be in packages. patch integrated (thanks!) - waiting on build. fix available. "	2004-10-29 06:25:28	1099050000.0	resolved fixed	4573068	1128410000.0	asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java
108118	Complete implementation of @SuppressAjWarnings	ensure that @SuppressAJWarnings are indeed suppressed during pointcutoperations. This requires wrapping major pointcut operations with calls to Lintfrom the associated advice. for M4 raising to P2 Calls now wrapped appropriately in BcelAdvice (Advice supertype has no knowledgeof the annotations, this could be refactored better if we had multipleimplementations of Advice, but since we don't it's plenty good enough for thetime being). 	2005-08-26 10:37:42	1125070000.0	resolved fixed	81a0790	1128010000.0	tests/src/org/aspectj/systemtest/ajc150/SuppressedWarnings.java weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java weaver/src/org/aspectj/weaver/bcel/Utility.java
101047	Weaver produces wrong local variable table bytecode	"AspectJ version: DEVELOPMENT (also observed in 1.2.1)When weaving with a before or after advice, the generated local variable table will, on branch instructions, offset the ""length"" field of a local variable wrongly by one instruction. Also, the weaver will mix up local variables with the same name, thus violating the java VM specification:// Test.ajaspect Test {	before() : ( execution(* Foo.foo(..) ) ) {		System.out.println(""before"");			}// Foo.javapublic class Foo {    private String myString = ""A String"";    public static void main(String[] args) {        new Foo().foo();      }    private void foo() {         String myLocal = myString;        if (myLocal.endsWith(""X"")) {      	   String local1 = ""local1"";             System.out.println(local1);        } else if (myLocal.endsWith(""Y"")) {             String local2 = ""local2"";             System.out.println(local2);        } else {      	  String local1 = ""local3"";            System.out.println(local1);        }      }}---We compilw with ajc -sourceroots . and dumps Foo with javap:javap -c -l -s -private Foo........private void foo();  Signature: ()V  Code:   0:   invokestatic    #65; //Method Test.aspectOf:()LTest;   3:   invokevirtual   #68; //Method Test.ajc$before$Test$1$f0485e90:()V   6:   aload_0   7:   getfield        #15; //Field myString:Ljava/lang/String;   10:  astore_1   11:  aload_1   12:  ldc     #30; //String X   14:  invokevirtual   #36; //Method java/lang/String.endsWith:(Ljava/lang/String;)Z   17:  ifeq    33   20:  ldc     #38; //String local1   22:  astore_2   23:  getstatic       #44; //Field java/lang/System.out:Ljava/io/PrintStream;   26:  aload_2   27:  invokevirtual   #50; //Method java/io/PrintStream.println:(Ljava/lang/String;)V   30:  goto    65   33:  aload_1   34:  ldc     #52; //String Y   36:  invokevirtual   #36; //Method java/lang/String.endsWith:(Ljava/lang/String;)Z   39:  ifeq    55   42:  ldc     #54; //String local2   44:  astore_2   45:  getstatic       #44; //Field java/lang/System.out:Ljava/io/PrintStream;   48:  aload_2   49:  invokevirtual   #50; //Method java/io/PrintStream.println:(Ljava/lang/String;)V   52:  goto    65   55:  ldc     #56; //String local3   57:  astore_2   58:  getstatic       #44; //Field java/lang/System.out:Ljava/io/PrintStream;   61:  aload_2   62:  invokevirtual   #50; //Method java/io/PrintStream.println:(Ljava/lang/String;)V   65:  return  LineNumberTable:    line 7: 6   line 8: 11   line 9: 20   line 10: 23   line 11: 33   line 12: 42   line 13: 45   line 15: 55   line 16: 58   line 18: 65  LocalVariableTable:    Start  Length  Slot  Name   Signature   6      60      0    this       LFoo;   11      55      1    myLocal       Ljava/lang/String;   45      12      2    local2       Ljava/lang/String;   23      43      2    local1       Ljava/lang/String;We see that the two occurences of the ""local1"" variable erroneously have been combined into one entry, starting at byte 23 and ending at byte 66. This is obviously wrong, since ""local1"" has no value in the ""local2"" block. Secondly, the ""local2"" variable end is wrongly offset by one instruction offset. I started looking into this in conjunction with https://bugs.eclipse.org/bugs/show_bug.cgi?id=100195.The reason why the weaver combines distinct local variables with the same name into one table entry is probably due to a wrong ""equal"" method implementation in the org.aspectj.weaver.bcel.LocalVariableTag class. It only considers the variable name and slot nuumber when comparing.The reason for the wrong offset is probably that org.aspectj.apache.bcel.generic.LocalVariableGen.getLocalVariable() increases the length by one instruction, and this is not compansated for by the weaver when writing back the woven classfiles. shame not to take advantage of all the good detective work done by Per Hustad,so marking for investigation in M4 This was indeed a comination of two problems. Firstly the the comparison on LocalVariableTags was insufficient as you suggested. I've changed the implementation to record not just name and slot but also the start position. Whilst two distinct local variables can have the same name and occupy the same slot, they cannot also have the same start position! Secondly, BCEL had an off-by-one error in the LocalVariableGen.getLocalVariable routine. The spec says that the range of the variable is from start-pos to start-pos + length INCLUSIVE, but BCEL was giving a length that included the first byte of the following instruction after the range. This is now fixed.Note that I discovered on investigating this that the JDT compiler and javac disagree on where local2 etc. go out of scope. javac says that local2 goes out of scope at the end of the invokevirtual instruction, whereas the JDT says it is the end of the goto instruction. I don't think this will make any practical difference to debuggers - the important thing is that we now have a valid length that ends on an instruction boundary.Fix commited in tree, will be available in first published dev build with date >= 28th Sept. 2005 I'm reopening this. On thinking about the ""off-by-one"" situation some more, I think it was me who was off-by-one, and the orignal BCEL routine was correct. I'm going to think some more on this before fully closing. <Pyinson Data Over Head> "	2005-06-21 10:13:24	1119360000.0	resolved fixed	85a4b0a	1127940000.0	bcel-builder/src/org/aspectj/apache/bcel/generic/MethodGen.java
101407	NullPointerException when selecting Save As in top menu	<Pyinson Data Over Head> That can be a bug when we shift to new selection framework. Fixed already. Verified the bug in BIRT build number of 20050706 Test it in Engine Smoke Test 	2005-06-23 02:44:44	1119510000.0	closed fixed	97520cf	1127860000.0	bcel-builder/src/org/aspectj/apache/bcel/generic/LocalVariableGen.java weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java weaver/src/org/aspectj/weaver/bcel/LocalVariableTag.java
102933	problem with Object arrays and clone() with 1.4 .class compatibility	"environment- eclipse AspectJ project using jdk 1.42_0- JDK 'generated .class compatibility' set to 1.4 (under JDK->compiler->Compliance and class files).  I did this because I wanted to use JDK 1.4 assertions.sample project includes one class:package com.test;public class Foo {    public void test() {        Foo[] array = new Foo[0];        Foo[] arrayClone = (Foo[])array.clone();    }}and one aspect:package com.test;aspect MyAspect {    declare warning: call(* *(..)) :	       ""a call within foo"";}When I build this project, I get an error on the Foo java file telling me that it 'can't find com.test.Foo type' with no line numbers.When I change the JDK 'generated .class compatibility' set to 1.3 everything compiles fine.. clone on an array has special treatment in bytecode, marking for investigation in M4 This is fixed in the current aspectj builds. I've added tests at the -1.3, -1.4,and -1.5 levels and we compile as expected in all cases. "	2005-07-06 16:20:01	1120680000.0	resolved fixed	fb428d0	1127830000.0	tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java
88900	Unnecessary warning for ITDs	Consider the following aspect:public aspect RunnableDefaultImpl {    public void Runnable.run() {    }}(Note that it makes little sense to have a default implementation for Runnable. However, I am using it to allow easy reproduction of the bug.)Compiling this aspect leads to the following warning:...\test\RunnableDefaultImpl.aj:9 [warning] this affected type is not exposed to the weaver: java.lang.Runnable [Xlint:typeNotExposedToWeaver]public void Runnable.run() {                     ^^^This warning isn't really necessary as weaver doesn't (and shouldn't) needto have Runnable exposed. In fact, everything works as expected already.Now it will be a good warning (or even error), if I was trying to introduce anew method, such as in the following aspect:public aspect RunnableDefaultImpl {    public void Runnable.walk() {    }} for investigation during M3... fix commited in tree. no longer warns when the target type is an interface ANDthe interface already defines the member (hence this is a default impl kind of adeal only). 	2005-03-23 13:37:57	1111600000.0	resolved fixed	e76b370	1127830000.0	tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java weaver/src/org/aspectj/weaver/ResolvedTypeMunger.java
77076	Weaving into jar fails if some of the referred classes are unavailable	"<Pyinson Data Over Head> In order to fully identify some join points and determine if there is a match,ajc effectively needs the classpath when weaving that was used when the code wascompiled.  Without it, things like full hierarchy analysis can't be done.However, I take your point and have been thinking about what we can do.  It ispossible that in the case where we can't do full static analysis because youhaven't supplied all the types, we might be able to simply insert more dynamictests (of course, we'll tell you that we are doing it because you didn't supplyall the types).In the short term, we could even at least tell you what we were trying to dowhen we couldn't resolve the type, so you could then decide whether to worryabout it or simply ignore it. this is a common problem. scheduling for investigation in m4. the wished behavior (important for LTW as well) is:- type resolution must be as lazy as possible (f.e. getMethod called on a bcelclass mirror should not trigger new type resolution, unless method params andreturned values are actually queried etc, same with annotation, same with fieldsetc) Actually it is usually possible to have a string mirror for a methodsignature: void foo(bar.Baz) => method name = ""foo"", parameter[0] =mirror.getName = ""bar.Baz"", mirror.get() => trigger type resolutionas a consequence of that:- if pointcut can be match without loading further types mirror, then it shouldnot warn- if a pointcut does not further types mirror to do the match and those cannotbe found, then its better to have a warning (and the pointcut expression /location) so that the user can narrow its pointcut(mainly: ""+"" in type patterns, method argument, method return value, annotation, field type, exception throwned) I've made a big dent in this long-standing problem. The only message that the compiler produces now when compiling your example against spring.jar is XLint:adviceDidNotApply. I also tested with a similar example against struts.jar that weaved into the Action class (which refers to javax.servlet types not on the classpath). This now works too - though in that case the compiler puts out warning messages indicating that certain types could not be found and that this may have affected pointcut matching at the call / execution join point in question. The example in question is before() : execution(* Action.*(..))when the supertypes of some struts types can't be found, we don't know for certain that those missing types don't themselves descend from Action (and hence might cause some methods in the type being analysed to match). But it's a likely bet that they don't, hence the warning rather than an error.For those interested in such things, the solution involves the following:* a new subtype of ResolvedType, MissingResolvedTypeWithKnownSignature. We create one of these when we can't resolve a type for which we know the signature. Instead of putting out the ""can't find type"" error straight away, we now only do so if a question is asked of the missing type that can't be answered solely based on signature.* In join point signature matching, switching to using a lazy iterator that only creates join point signatures when absolutely needed, rather than building all the signatures of a join point up front.* Every time we created a LazyClassGen, we looked to see if it implemented Serializable (so that lint warnings could be issued on operations affecting serializability). This requires chasing all supertypes of any given type looking for Serializable - which always caused a type not found if any parent type was not present. Now we tolerate a missing type in this situation and just assume that it did not implement Serializable - the only side effect is that some serializability warnings will not be issued that may have been had the type been present and it implemented Serializable and we performed some munging that affected it's serializability. * A similar parent-chasing scenario happens during preparation for weaving when we try to work out if a type exposed to the weaver and implementing an interface is the topmost implementor of that interface. This logic also now tolerates missing types, and assumes in this case that the sub-type in question is the topmost (it is certainly the topmost exposed to the weaver, which is all that matters here).* Finally, the can't find type messages themselves are much improved to give more information about why we were trying to find the type in the first place.Fix commited in tree and should be available for download in next published aspectj build. Wonderful! Thank you very much. "	2004-10-26 23:43:59	1098850000.0	resolved fixed	a4a9090	1127550000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/OutjarTest.java weaver/src/org/aspectj/weaver/JoinPointSignature.java weaver/src/org/aspectj/weaver/JoinPointSignatureIterator.java weaver/src/org/aspectj/weaver/Member.java weaver/src/org/aspectj/weaver/MemberImpl.java weaver/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java weaver/src/org/aspectj/weaver/ReferenceType.java weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java weaver/src/org/aspectj/weaver/ResolvedType.java weaver/src/org/aspectj/weaver/WeaverMessages.java weaver/src/org/aspectj/weaver/World.java weaver/src/org/aspectj/weaver/bcel/BcelAccessForInlineMunger.java weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java weaver/src/org/aspectj/weaver/patterns/TypePatternList.java weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java
109173	Weaving Adaptor enhancements for performance, configuration and diagnosis	"Patch successfully applied, thanks :) Here are some suggested enhancements as a result of exhaustive testing in the Eclipse/OSGi environment.1.	If no aspects are declared for a particular class loader, either because there are no visible aop.xml files or they contain no aspect definitions, then we should short-circuit the implementation of weaveClass() so that byte-code is not unnecessarily passed to the weaver. This is especially important under OSGi where there may be hundreds of class bundles, each with their own class loader only some of which are being woven. We can use the existing “enabled” flag.2.	As previously discussed on aspectj-dev the META-INF directory is considered private in OSGi and is therefore an inappropriate location for aop.xml files declaring shared aspects. I therefore propose a System property to set the a resource names for finding aop.xml files which would default to “META-INF/aop.xml” e.g. -Dorg.aspectj.weaver.loadtime.configuration=META-INF/aop.xml;org/aspectj/aop.xml.3.	We should not be catching Throwable  in Aj. Instead we should catch known exceptions e.g. BCException and issue messages while letting other runtime exceptions pass back to the class loader. A user provided IMessageHandler implementation can decide under what circumstances to abort. Alternatively if Aj is considered to be a “safe” interface for weaving agents e.g. JVMTI then the dump logic it contains should be moved to the WeavingAdaptor so that it can be used directly from a class loader. Created attachment 27212ClassLoaderWeavingAdaptor Patch for multiple aop.xml locationsApply this patch to to the ClassLoaderWeavingAdaptor.java file in the loadtimemodule of aspectj. It will enable the class to load up aop.xml files fromlocations specified in the org.aspectj.weaver.loadtime.configuration systemproperty, or from the default location (META-INF/aop.xml) if this property isnot set. So for instance you could run with-Dorg.aspectj.weaver.loadtime.configuration=META-INF/aop.xml;foo/bar/aop.xml Under OSGi, we have a problem with LTW in that the ClassLoader.getResources() call (used to load aop.xml files) may return results from more bundles than we want. Say you have three bundles, a, b and c. Each declares (and exports) an aop.xml file from some location (the same location within each bundle). Suppose also that bundle b requires a, and c requires b. Now we find that the aop.xml file from a is given to c by the ClassLoader.getResources() call, but as c has no dependancy on a, the aspects named in that file will not be visible to c, resulting in Runtime Exception(""Cannot register non aspect @missing@"").One solution to this is to use a WeavingContext object, passed from OSGi world to AspectJ world, to perform some filtering on the results of ClassLoader.getResources(). In a standard (non-OSGi) environment, this can simply return the (unaltered) result of ClassLoader.getResources(). This would be done via a new interface in the loadtime module (so no dependency from AspectJ on OSGi).I have a working implementation of this and will post a patch shortly.This approach may also help us to define multiple aop.xml files to each weaver... Created attachment 27305Patch to enable extra support for OSGisee previous comment for explanation Created attachment 27437Patch for the loadtime module to support AOSGiThis patch replaces both the patches above. It contains everything that theycontain, along with some additional code needed in order to allow a cachingservice. "	2005-09-09 12:49:04	1126280000.0	resolved fixed	03b20bc	1127490000.0	loadtime/src/org/aspectj/weaver/loadtime/Aj.java loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java loadtime/src/org/aspectj/weaver/loadtime/DefaultWeavingContext.java loadtime/src/org/aspectj/weaver/loadtime/IWeavingContext.java
109283	"Invalid ""indirect static access"" warning on EnumSet.noneOf"	"When compiling AspectJ enabled projects in Java 5.0 source mode with ""Indirectaccess to static modifier"" warnings on, the following code incorrectly gives acompiler warning (this doesn't occur in non-AspectJ enabled projects):public class Test {    enum Foo {        Wibble,        Wobble,        Woo;    }    public static void main(String[] args) {        EnumSet<Foo> set = EnumSet.noneOf(Foo.class);    }} Passing over to compiler this is a regression it seems, with AJDT 1.2.1.20050704111033 we don't reportthe problem, but with the latest 1.3.0.20050912161038 - we do... stillinvestigating. The error is produced at this line of code in MessageSend.java:if (!receiver.isImplicitThis() && binding.declaringClass != actualReceiverType) {  scope.problemReporter().indirectAccessToStaticMethod(this, binding);}	It comes out if binding.declaringClass != actualReceiverType.At the point it comes out:actualReceiverType is a RawTypeBinding (id 211) for EnumSet#RAWbinding is a ParameterizedGenericMethodBinding (id 218) containing:  declaringClass BinaryTypeBinding (id 234) for EnumSet  originalMethod ParameterizedMethodBinding containing:    declaringClass RawTypeBinding (id 211) EnumSet#RAWSo, if we had compared originalMethod.declaringClass with actualReceiverType -the warning wouldn't be produced.  But we compared actualReceiverType (id211)with binding.declaringClass (id234) and they don't match.We also have an aspect in affect for references to declaringClass that is neededfor working with ITDs - however the advice doesn't do anything in this case asits not an ITD.I think when the original method is on a raw type theParameterizedGenericMethodBinding should also have the raw as its declaringclass - but debugging this is darn tricky. Ok... the complexity here is due to the nesting of:ParameterizedGenericMethodBinding having an originalMethod that is aParameterizedMethodBinding that has an originalMethod that is a MethodBinding.Excluding ITDs, the time when the declaringClass for aParameterizedMethodBinding is different to that for its containingoriginalMethod seems to be when the parameterized method is being created for a'raw type' - see RawTypeBinding.getMethodsBase().  Effectively theoriginalMethod remains with a declaring class that is the generic type, whilstthe parameterizedMethodBinding has a declaring class that is the raw type.  Whenworking with these methods, our aspect for managing declaring class referencesbreaks.Basically the aspect currently says 'whenever someone accesses the declaringclass for a ParameterizedMethodBinding, return the declaring class for theoriginal', in the case in this bug we end up retrieving the generic type when wereally wanted the raw type. Hmmmmm.... these changes to the aspect appear to fix the problem:instead of:pointcut redirectedDeclaringClassAccesses(MethodBinding aBinding) :  accessingDeclaringTypeOfAMethodBinding(aBinding) &&   !within(OwningClassSupportForMethodBindings) &&  !withincode(* MethodBinding.canBeSeenBy(..)) && // must be based on aspecttype here  !withincode(MethodBinding.new(..));             // allow binding to initialiseproperlywe now have:pointcut redirectedDeclaringClassAccesses(MethodBinding aBinding) :  accessingDeclaringTypeOfAMethodBinding(aBinding) &&   !within(OwningClassSupportForMethodBindings) &&  !withincode(* MethodBinding.canBeSeenBy(..)) && // must be based on aspecttype here  !withincode(MethodBinding.new(..))&&             // allow binding toinitialise properly  !within(ParameterizedGenericMethodBinding) &&  !target(ParameterizedGenericMethodBinding);with the two extra conditions on the end ... it effectively says if working witha ParameterizedGenericMethodBinding, assume the fiddling to set the rightdeclaring class has already been done when we built theParameterizedMethodBinding, so we don't need to fiddle again...I can't build the org.eclipse.jdt.core shadows project right now so I've had tohack up a way to test it - until I've thought about it a little more, discussedit with Adrian and checked what it does in the real shadows module - I won'tcheck it in... Fixed by changing the ITD'd method we make on ParameterizedMethodBinding to takeaccount of the situation where the declaringClass in the PMB is different to thedeclaringClass in this.original(). We no longer give back the ITD owningClass inthat this situation. Will close bug once fix is available in build on download page. fix now available. "	2005-09-12 08:37:45	1126530000.0	resolved fixed	8a0f59a	1127400000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java weaver/src/org/aspectj/weaver/AjcMemberMaker.java weaver/src/org/aspectj/weaver/bcel/BcelPerClauseAspectAdder.java
76374	Problem with declare parents when using non-public classes	"Non-public classes, when explicitly named, do not get woven.The test case below exhibits this problem when the package declaration isuncommented.If the package declaration is commented out, the class is woven correctly.If the package declaration is uncommented, a compilation failure occurs withAspectJ 1.2.  According to Andrew Clement, AspectJ 1.2.1 compiles, but does notweave.If the ""MyInnerClass"" is changed to be public [regardless of the packagedeclaration status], the class is woven correctly.Also:When the ""MyInnerClass"" is moved out of ""MyClass"", but kept in the MyClass.javafile, then the following behavior is exhibited:If the package declaration is commented out, the class is woven correctly.If the package declaration is uncommented out, a compilation failure occurs withAspectJ 1.2.Note, in this case, MyInnerClass cannot be declared as public.It also appears that if the RunnableAspect is placed in the same package as""MyClass"", weaving occurs correctly, regardless of any class access modifiers<MyClass.java>// package mypackage;public class MyClass { public MyClass() {   MyInnerClass mic = new MyInnerClass();   if (mic instanceof Runnable)     mic.run(); } class MyInnerClass {   public void run() {     System.out.println(""In MyInnerClass.run()!!"");   } } public static void main(String args[]) {   new MyClass(); }}</MyClass.java><RunnableAspect.aj>public aspect RunnableAspect { declare parents: MyClass$MyInnerClass implements Runnable; // declare parents: mypackage.MyClass$MyInnerClass implements Runnable;}</RunnableAspect.aj> There is a bug here, but its not what I expected it to be.When referring to inner classes in type patterns like this, you should use the'.' notation rather than the $ notation.  So to refer to MyInnerClass, either:// this works if you import mypackage.*declare parents: MyClass.MyInnerClass implements Runnable;// this just works//declare parents: mypackage.MyClass.MyInnerClass implements Runnable;What actually causes the confusion is that this works:declare parents: MyClass$MyInnerClass implements Runnable;when MyClass is not in a package.  It makes you think that:declare parents: mypackage.MyClass$MyInnerClass implements Runnable;should work when you put MyClass into a package.Actually 'MyClass$MyInnerClass' doesn't refer to an inner class, it refers to aclass called 'MyClass$MyInnerClass' as $ is valid in a class name.  So the bugis that we should have put out an error indicating no type match for:declare parents: MyClass$MyInnerClass implements Runnable;which would have led you to try MyClass.MyInnerClass which is correct. scheduled for aj5m4 Correctly produces xlint message ""no type match for: blah blah"" with the latestcompiler builds. "	2004-10-15 13:23:09	1097860000.0	resolved fixed	ca9c1f7	1127320000.0	tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java
104957	NullPointerException when running ajc on gij	<Pyinson Data Over Head> for resolution in M4 Fix checked into AspectJ version of BCEL library, will be available in nextpublished AspectJ build from the download page.Will close out bug report once build is available. fix now available. 	2005-07-24 20:01:39	1122250000.0	resolved fixed	0e1bb19	1127320000.0	bcel-builder/src/org/aspectj/apache/bcel/generic/InstructionComparator.java
108120	Complete implemenation of runtime pointcut parsing and matching	The weaver API for runtime pointcut parsing and matching needs extending for allof the new pointcuts we have added in AJ5. Recommended approach is to implementJavaLangReflectObjectType as a new ReferenceTypeDelegate, and aJavaLangReflectWorld in place of BcelWorld. for M4, this is required for the Spring integration support Work completed. See javadoc in org.aspectj.weaver.tools API for usage.Implementation uses an alternate world (org.aspectj.weaver.reflect) that answersquestions based on Java reflection from the runtime type system. The onlyexception to this is for discovering annotations on types and members in Java 15where we need to get annotations with class file retention as well as runtimeretention. This is done by going to Bcel briefly, remembering the annotations,and throwing the Bcel repository away.Supports reference pointcuts (can even refer to named pointcuts in compiledaspects etc. and parameter binding). Known limitations are that cflow,cflowbelow, and if pcds cannot be supported at runtime.  All other pcds can beused (including all of those introduced in AJ 5). 	2005-08-26 10:39:53	1125070000.0	resolved fixed	a39f595	1127310000.0	aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/AjTypeImpl.java aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/PointcutImpl.java aspectj5rt/java5-src/org/aspectj/lang/annotation/Pointcut.java aspectj5rt/java5-src/org/aspectj/lang/reflect/Pointcut.java bcel-builder/src/org/aspectj/apache/bcel/classfile/JavaClass.java bcel-builder/src/org/aspectj/apache/bcel/generic/Type.java bcel-builder/testsrc/org/aspectj/apache/bcel/classfile/tests/GetReflectMembersTest.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AtAspectJAnnotationFactory.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PointcutDeclaration.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PointcutDesignator.java tests/java5/ataspectj/annotationGen/RuntimePointcuts.java tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjAnnotationGenTests.java weaver/java5-src/org/aspectj/weaver/reflect/Java15AnnotationFinder.java weaver/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java weaver/java5-testsrc/org/aspectj/weaver/tools/Java15PointcutExpressionTest.java weaver/src/org/aspectj/weaver/Shadow.java weaver/src/org/aspectj/weaver/UnresolvedType.java weaver/src/org/aspectj/weaver/World.java weaver/src/org/aspectj/weaver/internal/tools/PointcutExpressionImpl.java weaver/src/org/aspectj/weaver/patterns/AndPointcut.java weaver/src/org/aspectj/weaver/patterns/AndTypePattern.java weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.java weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java weaver/src/org/aspectj/weaver/patterns/ConcreteCflowPointcut.java weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java weaver/src/org/aspectj/weaver/patterns/HandlerPointcut.java weaver/src/org/aspectj/weaver/patterns/HasMemberTypePattern.java weaver/src/org/aspectj/weaver/patterns/IfPointcut.java weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java weaver/src/org/aspectj/weaver/patterns/NotPointcut.java weaver/src/org/aspectj/weaver/patterns/NotTypePattern.java weaver/src/org/aspectj/weaver/patterns/OrPointcut.java weaver/src/org/aspectj/weaver/patterns/OrTypePattern.java weaver/src/org/aspectj/weaver/patterns/PerCflow.java weaver/src/org/aspectj/weaver/patterns/PerClause.java weaver/src/org/aspectj/weaver/patterns/PerFromSuper.java weaver/src/org/aspectj/weaver/patterns/PerObject.java weaver/src/org/aspectj/weaver/patterns/PerSingleton.java weaver/src/org/aspectj/weaver/patterns/PerTypeWithin.java weaver/src/org/aspectj/weaver/patterns/Pointcut.java weaver/src/org/aspectj/weaver/patterns/PointcutExpressionMatching.java weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java weaver/src/org/aspectj/weaver/patterns/ThisOrTargetAnnotationPointcut.java weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java weaver/src/org/aspectj/weaver/patterns/ThrowsPattern.java weaver/src/org/aspectj/weaver/patterns/TypePattern.java weaver/src/org/aspectj/weaver/patterns/TypePatternList.java weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java weaver/src/org/aspectj/weaver/patterns/WithinAnnotationPointcut.java weaver/src/org/aspectj/weaver/patterns/WithinCodeAnnotationPointcut.java weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java weaver/src/org/aspectj/weaver/reflect/AnnotationFinder.java weaver/src/org/aspectj/weaver/reflect/JoinPointMatchImpl.java weaver/src/org/aspectj/weaver/reflect/PointcutParameterImpl.java weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegate.java weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java weaver/src/org/aspectj/weaver/reflect/ReflectionBasedResolvedMemberImpl.java weaver/src/org/aspectj/weaver/reflect/ReflectionShadow.java weaver/src/org/aspectj/weaver/reflect/ReflectionVar.java weaver/src/org/aspectj/weaver/reflect/ReflectionWorld.java weaver/src/org/aspectj/weaver/reflect/ShadowMatchImpl.java weaver/src/org/aspectj/weaver/tools/JoinPointMatch.java weaver/src/org/aspectj/weaver/tools/PointcutExpression.java weaver/src/org/aspectj/weaver/tools/PointcutParameter.java weaver/src/org/aspectj/weaver/tools/PointcutParser.java weaver/src/org/aspectj/weaver/tools/PointcutPrimitive.java weaver/src/org/aspectj/weaver/tools/ShadowMatch.java weaver/testsrc/BcweaverModuleTests15.java weaver/testsrc/org/aspectj/weaver/patterns/AndOrNotTestCase.java weaver/testsrc/org/aspectj/weaver/patterns/ArgsTestCase.java weaver/testsrc/org/aspectj/weaver/patterns/HandlerTestCase.java weaver/testsrc/org/aspectj/weaver/patterns/KindedTestCase.java weaver/testsrc/org/aspectj/weaver/patterns/PatternsTests.java weaver/testsrc/org/aspectj/weaver/patterns/PointcutTestCase.java weaver/testsrc/org/aspectj/weaver/patterns/ThisOrTargetTestCase.java weaver/testsrc/org/aspectj/weaver/patterns/WithinCodeTestCase.java weaver/testsrc/org/aspectj/weaver/patterns/WithinTestCase.java weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java weaver/testsrc/org/aspectj/weaver/reflect/ReflectionWorldTest.java weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java weaver/testsrc/org/aspectj/weaver/tools/PointcutParserTest.java weaver/testsrc/reflect/tests/C.java
109486	Internal compiler error (ClassParser.java:242)	"Testcase: A.aj containing:final abstract aspect A {}This causes the compiler to abort with an internal compiler error:C:\Documents and Settings\mchapman\A.aj [error] Internal compiler errororg.aspectj.apache.bcel.classfile.ClassFormatException: Class can't be bothfinal and abstract        at org.aspectj.apache.bcel.classfile.ClassParser.readClassInfo(ClassParser.java:242)        at org.aspectj.apache.bcel.classfile.ClassParser.parse(ClassParser.java:165)        at org.aspectj.weaver.bcel.Utility.makeJavaClass(Utility.java:489)        at org.aspectj.weaver.bcel.UnwovenClassFile.getJavaClass(UnwovenClassFile.java:63)        at org.aspectj.weaver.bcel.UnwovenClassFile.getClassName(UnwovenClassFile.java:147)        at org.aspectj.ajdt.internal.core.builder.AjState.noteResult(AjState.java:497)        at org.aspectj.ajdt.internal.core.builder.AjBuildManager$3.acceptResult(AjBuildManager.java:748)        at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterProcessing(AjCompilerAdapter.java:186)        at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$4$6b855184(CompilerAdapter.aj:89)        at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:528)        at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329)        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:728)        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:206)        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:140)        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:112)        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)        at org.aspectj.tools.ajc.Main.run(Main.java:324)        at org.aspectj.tools.ajc.Main.runMain(Main.java:238)        at org.aspectj.tools.ajc.Main.main(Main.java:82)(no source information available)C:\Documents and Settings\mchapman\A.aj:1 [error] The class A can be either abstract or final, not bothfinal abstract aspect A {}ABORTException thrown from AspectJ DEVELOPMENTC:\Documents and Settings\mchapman>ajc -versionAspectJ Compiler DEVELOPMENT built on Tuesday Sep 13, 2005 at 22:31:40 GMTThe expected behaviour is naturally just to get a regular compiler errror saying""The aspect A can be either abstract or final, not both"". Fix checked in - will be in next build.  will close this bug when its available. fix available. "	2005-09-14 06:06:29	1126690000.0	resolved fixed	87e5c2e	1126700000.0	bcel-builder/src/org/aspectj/apache/bcel/classfile/ClassParser.java tests/bugs150/PR109486.java tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java
103740	Compiler failure on @annotation	"I'm using the ajc embedded in the latest dev build of AJDT (build 20050713163417)This small example illustrates the problem:public abstract aspect AbstractRequestMonitor {    public pointcut requestExecution(RequestContext requestContext) :        execution(* RequestContext.execute(..)) && this(requestContext);    public abstract class RequestContext {        public abstract Object execute();    }        after(RequestContext requestContext) throwing (Throwable t) : requestExecution(requestContext) {    }    }import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;@Retention(RetentionPolicy.RUNTIME)public @interface AroundAdvice {}public aspect ErrorHandling {    declare soft: Exception: !@annotation(AroundAdvice) && !withincode(* *(..));        Object around() : adviceexecution() && !@annotation(AroundAdvice) {        try {            return proceed();        } catch (Exception e) {            return null;        }    }}Here's the stack trace I get:org.aspectj.weaver.BCException: bad	at org.aspectj.weaver.bcel.BcelRenderer.visit(BcelRenderer.java:228)	at org.aspectj.weaver.ast.Literal.accept(Literal.java:29)	at org.aspectj.weaver.bcel.BcelRenderer.recur(BcelRenderer.java:151)	at org.aspectj.weaver.bcel.BcelRenderer.renderTest(BcelRenderer.java:117)	at org.aspectj.weaver.bcel.BcelAdvice.getTestInstructions(BcelAdvice.java:445)	at org.aspectj.weaver.bcel.BcelShadow.weaveAroundClosure(BcelShadow.java:2585)	at org.aspectj.weaver.bcel.BcelAdvice.implementOn(BcelAdvice.java:182)	at org.aspectj.weaver.Shadow.implementMungers(Shadow.java:480)	at org.aspectj.weaver.Shadow.implement(Shadow.java:358)	at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:1703)	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:389)	at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:94)	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1362)	at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1327)	at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1106)	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:981)	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:286)	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:165)	at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:368)	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:727)	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:206)	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:140)	at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:121)	at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191) One for Andy... ;) for M4 Heres my reduced program that also fails:import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;@Retention(RetentionPolicy.RUNTIME)public @interface AroundAdvice { }aspect ErrorHandling {  before(): !@annotation(AroundAdvice) { }}the '!' is causing the problem. Fix checked in.  We were always returning 'Literal.TRUE' fromfindResidueInternal for the annotation pointcut type which became a'Literal.FALSE' due to the NOT.  We always blow up if attempting to visit(generate) a test that is Literal.FALSE (since we shouldn't have gotten to thispoint claiming it was ever a match).  The fix is to make findResidueInternal() return either TRUE or FALSE dependingon whether the shadow actually matched the pointcut.  In the case where a joinpoint does *not* have the annotation, it will now return FALSE, which willbecome TRUE due to the ! and this is a valid test.waiting on build before closing bug. Fix available now. "	2005-07-13 19:09:31	1121300000.0	resolved fixed	2ae4f53	1126530000.0	tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java
108826	AJDT Error: Can't find type	"In Eclipse 3.1, using the latest AspectJ build (1.5.0_M3a compiler and 1.3.0plugin) I get an error ""can't find type test.T"" , using the following code:===============package test;public class CantFindType {    public <T> T[] method(T[] array) {        return null;    }}================The error occurs, if the return type, or the parameter is an array of a generictype.The code compiles fine, but Eclipse shows the error, but doesn't show the folderor the location for the error. tagging with M4... I tried to reproduce this tonight but couldn't create the failure. Is a single project with just this one type defined in it sufficient to trigger the bug, or do you have any aspects present in the system that are advising this type (and in particular the method ""method""?). ""can't find type"" messages normally come out of the weaver, which leads me to suspect there is some other aspect involved that is necessary to trigger the bug... Created attachment 26980AspectJ project showing the bug ... (In reply to comment #2)> I tried to reproduce this tonight but couldn't create the failure. Is a singleproject with just this one type > defined in it sufficient to trigger the bug, or do you have any aspectspresent in the system that are > advising this type (and in particular the method ""method""?). ""can't find type""messages normally come out > of the weaver, which leads me to suspect there is some other aspect involvedthat is necessary to trigger > the bug...I have attached a project which triggers the ""can't find type"" message in myenvironment. There are no aspects in this project, just the single class. I am running Eclipse 3.1, Java 1.5.0 on Mandrake Linux 10.1. bingo! thank you. I can reproduce this now. The problem only occurs when AspectJ is generating thecrosscutting structure model used by AJDT (hence why I couldn't reproduce it onthe command-line). Passing the -emacssym option enables reproduction outside ofAJDT. fix available in latest AspectJ build on downloads page, and will be incorporated into AJDT on Monday 12th. (In reply to comment #6)Excellent. I will try it as soon as it comes available. "	2005-09-06 08:13:03	1126010000.0	resolved fixed	2942ca0	1126280000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java
109124	VerifyError with inner classes	"This bug apparently occurs only when compiling with the -1.5 option (AdrianColyer managed to reproduce it).Considering the code below, when I set a 'set' pointcut on the fields of innerclass Node, I get an error from the class verifier:	Exception in thread ""main"" java.lang.VerifyError: (class: test/List$Node,method: <init> signature: (Ltest/List;I)V) Expecting to find object/array on stackWhen the Node class is moved out of the List class, it works fine. Thedecompiled code for the inner class is included below for reference.//////////////////////////////////////////////////////////////////////// List.javapackage test;public class List {	class Node {		int value;		Node next;		Node(int v)		{			value = v;		}	}	private Node head;	public List()	{		head = null;	}	public void add(int v)	{		Node n = new Node(v);		n.next = head;		head = n;	}	public void print()	{		Node n = head;		while (n != null) {			System.out.print("" "" + n.value);			n = n.next;		}		System.out.println();	}	public static void main(String[] args) {		List l = new List();		for (int i = 0; i < 10; i++)			l.add(i);		l.print();	}}//////////////////////////////////////////////////////////////////////// ListAspect.ajpackage test;public aspect ListAspect {	pointcut setField(Object t) : target(t) && set(* List.Node+.*);	before(Object t) : setField(t) {		System.out.println(""WRITE"");		// Do something with t...	}}//////////////////////////////////////////////////////////////////////// List@Node.jadpackage test;// Referenced classes of package test://            List, ListAspectclass List$Node{    int value;    List$Node next;    final List this$0;    List$Node(int v)    {    //*   0    0:aload_0                 List list1 = List.this;    //    1    1:aload_1             //    2    2:astore_3                List$Node list$node = this;    //    3    3:astore          4        ListAspect.aspectOf().ajc$before$test_ListAspect$1$3f3247a5(list$node);    //    4    5:invokestatic    #37  <Method test.ListAspecttest.ListAspect.aspectOf()>    //    5    8:aload           4    //    6   10:invokevirtual   #41  <Method voidtest.ListAspect.ajc$before$test_ListAspect$1$3f3247a5(java.lang.Object)>        list$node.this$0 = list1;    //    7   13:aload           4    //    8   15:aload_3             //    9   16:putfield        #16  <Field test.List test.List$Node.this$0>        super();    //   10   19:aload_0             //   11   20:invokespecial   #19  <Method void Object()>    //*  12   23:aload_0                 int i = v;    //   13   24:iload_2             //   14   25:istore          5        List$Node list$node1 = this;    //   15   27:astore          6        ListAspect.aspectOf().ajc$before$test_ListAspect$1$3f3247a5(list$node1);    //   16   29:invokestatic    #37  <Method test.ListAspecttest.ListAspect.aspectOf()>    //   17   32:aload           6    //   18   34:invokevirtual   #41  <Method voidtest.ListAspect.ajc$before$test_ListAspect$1$3f3247a5(java.lang.Object)>        list$node1.value = i;    //   19   37:aload           6    //   20   39:iload           5    //   21   41:putfield        #21  <Field int test.List$Node.value>    //   22   44:return              }} ok, getting close on this one. The JDT compiler uses a different code generationstrategy across 1.4 and 1.5 for the constructor of Node. The bug arises due tothe following conditions:* Node is a non-static inner class (and so has a reference to its enclosinginstance)* The set pointcut is broad enough to match any set join point for Node* In 1.4, the JDT compiler correctly marks the enclosing instance field (this$0)as synthetic, which means we correctly treat as NOT being a join point* But... in 1.5 compliance mode the JDT compiler is failing to mark the field(this$0) as synthetic, which causes us to think it is a genuine join point whenin fact it isn't, and after that it's all downhill...So now I'm off hunting for the JDT bug so that I can fix that... ah... no, it's not a JDT bug - prior to 1.5 synthetic was an attribute, but in1.5, it's a modifier. That's why we don't see the synthetic attribute. Need toupdate our isSynthetic test to do the right thing in 1.5... *** Bug 106874 has been marked as a duplicate of this bug. *** fixed in tree, will be available in next published AspectJ build. "	2005-09-09 05:44:14	1126260000.0	resolved fixed	a9ca915	1126260000.0	tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java weaver/src/org/aspectj/weaver/bcel/BcelField.java
109016	NullPointerException when building configuration	"The exception below seems to be happening with any .lst file:Message: NullPointerException thrown: nullStack trace: java.lang.NullPointerException	atorg.aspectj.ajde.internal.CompilerAdapter.configureBuildOptions(CompilerAdapter.java:296)	atorg.aspectj.ajde.internal.CompilerAdapter.genBuildConfig(CompilerAdapter.java:170)	at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:95)	atorg.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191) we have many tests in the suite that use lst files, and AJDT uses lst files todrive the compiler too - could you give a few more details about the commandline or ant options you are using to kick off the compiler please? sounds likeyou could easily create a small self-contained test to reproduce this? If so,adding that as an attachment to this bug report would be very helpful.thks, Adrian. As Adrian points out it would be very useful to know what options you are using,because it seems that no source compliance option is being set.  Since it'sok to fall back to a default compliance I have added the following guard toprevent this NPE:if (optionsToSet.containsKey(CompilerOptions.OPTION_Compliance)){...} I followed the following steps:1. Ran ""java -jar aspectjtools.jar"" 2. Selected a build configuration and supplied a .lst file with one test classin it.3. Attempted to build a configuration. This step failed with AJDE error windowdisplaying the NPE. Roman, this should be resolved now and I was able to successfully compiletypical .lst files with the browser.  If the browser still doesn't workfor you on the next release please reopen the report and post the first few lines of the .lst file that you are building. "	2005-09-07 21:09:51	1126140000.0	resolved fixed	5187437	1126210000.0	ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java
108886	Getting Exception during compilation :  java.lang.RuntimeException: Internal Compiler Error: Unexpected null source location passed as 'see also' location.	"Am attaching a small test case to reproduce the error (Not sure how to attach it - hopefully should be feasible to do so after I logthe bug). Created attachment 26873Jar containg sources, build.xml and compiler dump fileAttached file contains the sources, ant file (poorly hacked version of the onein examples - expects all jars in a ""lib"" directory which is a peer to ""src"")and the compiler core dump file. There is a good likelihood what I am attempting to do is not feasible - howevereven in that case there should be a reasonable error message rather than aninternal error. tagging with M4... this was caused by trying to issue a message saying that the type User mustimplement the methods from Identifiable (in the aspect DomainIntroduction, youhave declared two local methods getId and setId, whereas I suspect you meantthese to be ITDs on Domain?). The source location for the parameterized versionsof the methods was null which lead to the crash. This has now been fixed in the tree. Thanks for the easy to reproduce bug report.Regards, Adrian. "	2005-09-06 19:02:23	1126050000.0	resolved fixed	2d21db0	1126200000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java weaver/src/org/aspectj/weaver/ResolvedType.java
109042	parameter ajc_aroundclosure is never read	"Similar to [http://dev.eclipse.org/newslists/news.eclipse.technology.ajdt/msg00691.html] I get the following warning in the attached test project:Severity	Description	Resource	In Folder	Location	Creation Time1	The parameter ajc_aroundClosure is never read	PlaylistAspect.aj	Jukebox/src/playlist	line 1	8. September 2005 14:10:12 Created attachment 26944testcase (ZIP) this should be a little light-relief after some heavy duty ITD work... taggingfor M4 now fixed in tree. "	2005-09-08 08:13:40	1126180000.0	resolved fixed	08d6a5d	1126190000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java
108902	Type mismatch: cannot convert from Collection to Collection	(From aspectj-users)The program below produces the erroneous message:    [iajc] D:\workdir\DPsample\main\src\com\designpattern\observer\ObserverProtocol.aj:39 [error] Type mismatch: cannot convert from Collection to Collection    [iajc] return observers;    [iajc]        ^^^^^//Subject.javainterface Subject { public void addObserver(Observer observer); public void removeObserver(Observer observer); public Collection getObservers();}//Observer.javainterface Observer{ public void update();}//ObserverProtocolpublic abstract aspect ObserverProtocol{ abstract pointcut stateChange(Subject subject); after(Subject subject):stateChange(subject){   Iterator it=subject.getObservers().iterator();   while(it.hasNext()){        Observer observer=(Observer)it.next();        observer.update();   } } private Collection Subject.observers=new ArrayList(); public void Subject.addObserver(Observer observer){        observers.add(observer); } public void Subject.removeObserver(Observer observer){       observers.remove(observer); } public Collection Subject.getObservers() {  return observers; }} I'm out of the office most of today, will take another look at this tonight... Regards, Adrian. ok, I made some progress on this on the train. The first piece of good news isthat I can reliably reproduce it, and have a failing test case in the suite. Ialso know what the cause of the bug is :- the inter-type field has been giventhe (correct) type of Collection#RAW, but the return type of the inter-typemethod has the type Collection (the generic base type). The compiler comparesthe two types by identity and says that they are not the same, resulting in theconfusing error message. Now all I need to do is find out why the itd method does not also present itsreturn type as raw.... fix now committed in tree. 	2005-09-07 02:53:36	1126080000.0	resolved fixed	2505485	1126190000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java tests/bugs150/pr108902/Observer.java tests/bugs150/pr108902/Subject.java tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java
108816	AspectJ 1.5.0 Development Compiler Chokes on Advice with Cflow	"<Pyinson Data Over Head> ugh. I'm not looking forward to diagnosing this one! At least you've veryhelpfully been able to narrow it down to one of the 33 bug ""fixes"" I've put inover the last week. I'm suspicious of the changes made for bug 59196, will lookinto this later on today. ok, I can confirm that this bug is related to the fix for 59196 - it only occurswhen the cflow uses args. found it! the extra "".."" in the args pattern was also needed to reproduce thebug, which was due to an inconsistency in determining the length of the argsarray to be used for matching when calculating the number of positions that ""..""should eat. We were ignoring synthetic args everywhere but there. So the actualbug was triggered by args binding at least one formal, at a join point withsynthetic args, with "".."" used in the type pattern.Just running all the suite and then I'll commit the fix. Fantastic; thank you! Glad you were able to find and fix it so quickly! The revised AspectJ version builds my code correctly. fix available and verified... "	2005-09-06 03:18:39	1125990000.0	resolved fixed	71771ab	1126010000.0	tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java
99125	Repetitive method name/signature in class file	This is what the VM sais:java.lang.ClassFormatError: Repetitive method name/signature in class file com/netvisor/metadata_view/ComponentFactory        at java.lang.ClassLoader.defineClass1(Native Method)        at java.lang.ClassLoader.defineClass(ClassLoader.java:620)        at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:124)        at java.net.URLClassLoader.defineClass(URLClassLoader.java:260)        at java.net.URLClassLoader.access$100(URLClassLoader.java:56)        at java.net.URLClassLoader$1.run(URLClassLoader.java:195)        at java.security.AccessController.doPrivileged(Native Method)        at java.net.URLClassLoader.findClass(URLClassLoader.java:188)        at java.lang.ClassLoader.loadClass(ClassLoader.java:306)        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:268)        at java.lang.ClassLoader.loadClass(ClassLoader.java:251)        at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:319)And this is why: I've got an interface (ComponentFactory) and an aspect that adds various ITD methods trough that interface. I've added some methods to both the interface and the aspect, some other methods are only added trough the aspect. (The situation is a bit more complex, I've got a base interface/aspect with these two methods and the subaspects implement the problematic two methods.)And those methods that are both in the interface and the aspect are the ones that get duplicated in the interface class file.This is working fine in the old CVS branch (1.2.*).Hope it helps, good luck! needs investigating for M4 now that we're over the generics hump I finally managed to reproduce this, by using binary weaving rather than source (the failure does not occur when compiling from source).Fix commited in tree, will be available in next published build. 	2005-06-09 06:25:43	1118310000.0	resolved fixed	df46c6f	1125680000.0	tests/bugs150/pr99125/p/I.java tests/bugs150/pr99125/p/J.java tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java
101606	AspectJ compiler does not process unused code compiler options properly for aspects	In Eclipse (3.0) click 'Window' > 'Preferences' > 'Java' > 'Compiler'.  Select the 'Unused Code' tab on the compiler preference page.  Change 'Unused or unread private members' to Warning or Error.  Create a project that contains an aspect with some private pointcuts.  You will see warnings or errors for these pointcuts saying that they are unused. should be a quick fix. Away you unwanted warnings, away! 	2005-06-24 05:17:53	1119600000.0	resolved fixed	2c88c59	1125670000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java
102212	[itds] abstract synchronized: compile error expected	"when using intertype declaration, the compiler doesn't check for illegalmodifier combinations such as ""abstract synchronized"".another manifestation of this problem is when using intertype declaration to adda synchronized method to an interface. the problem is more severe in this casebecause conceptually, this method is not abstract at all.interface Interface {}abstract class Parent {}class Child extends Parent implements Interface {}aspect Bug {  // illegal modifier combination not caught by ajc  public abstract synchronized void Parent._abstract();  public synchronized void Child._abstract() {}  // the following has the same effect, but is easier to miss  public /* implicit abstract */ synchronized void Interface._interface() {}  // use Child to make java complain: ""illegal modifiers: 0x421""  // (this corresponds to ""public abstract synchronized"")  public static void main(String[] args) {    new Child();  }} when making an automated test out of this code, notice that the failure onlyoccurs at runtime. it appears that the test case passes using the latest build. oops, it isn't fixed after all (fails at runtime). my bad! now fixed in tree. The abstract synchronized declaration on Parent is correctly disallowed.The synchronized declaration on the interface *is* allowed - it's both the declaration of an interface member and the declaration of the default implementation of that member. The types that receive the default member get a synchronized method, but the interface type of course should not (have the synchronized modifier on its method). And now it doesn't :). "	2005-06-29 17:07:44	1120080000.0	resolved fixed	b17ff4e	1125670000.0	tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java
99136	xlint advice not applied appears twice with cflows	"////////////// in the following codeaspect A{  before(): call(* *(..)) && cflow(execution(* *(..))) {}}////////////////////////////////////two ""advice not appied"" xlint messages are produced, one for the before adviceand one for the cflow within the before advice. Created attachment 22682fix thisAttatched is a patch to fix this by only printing out ""advice not applied""messages at most once per line.this does though mean that for something like this only one ""advice notapplied"" message would be produced:aspect A{  pointcut empty();  before(): empty(){}; before(): empty(){};} Created attachment 22683test thispatch to add a unit test that checks that the above patch is working integrate patch in M4... a slight variation on the patch is now checked into the tree and the test passes.Thanks Andrew :) "	2005-06-09 08:36:06	1118320000.0	resolved fixed	047173e	1125660000.0	tests/bugs150/pr105479/Driver.java tests/bugs150/pr105479/ReturnTypeTester.java tests/harness/XLintcflow.java tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java tests/src/org/aspectj/systemtest/xlint/XLintTests.java weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java
108062	NPE when opening resources from CVS resources history	<Pyinson Data Over Head> I just had this happen to me too.  Fixed. 	2005-08-25 17:47:23	1125010000.0	resolved fixed	ad753aa	1125650000.0	bcel-builder/src/org/aspectj/apache/bcel/classfile/GenericSignatureParser.java tests/bugs150/pr108602.java tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java
98290	"no ""matches declare"" entry in structure model for single declare warning statement"	"A project containing one class and one aspect:-----------------------------------------------------package pack;public class C {	public static void main(String[] args) {		new C().sayHello();	}		public void sayHello() {		System.out.println(""HELLO"");	}}----------------------------------------------------package pack;public aspect A {			declare warning : 		execution(* C.sayHello(..)) :			""blah blah"";			}-----------------------------------------------------has the ""matched by"" entry for A.aj, but doesn't have the ""matches declare""entry for C.java.This means that in AJDT, C.sayHello isn't added to our map and consequently wedon't get any relationships showing in the Cross Reference view for A.aj. Do you get them for other declares? Since I know we have done some work in AJ tosupport them - maybe the AJDE is out of date that is in AJDT, hmmm. The related bug was bug 91090 - but that was only to do with thestaticinitialization PCD.  Worth seeing if this problem occurs if the declarewarning is all on one line rather than split across multiple lines. Yes, this problem still happens when the declare statement is on one line. Italso happens with declare error. Dumping out the structure model contents using the usual API call gives us thishelpful output:=== MODEL STATUS REPORT ========= After a batch buildA.generated.lst  [build configuration file]  pack  [package]    A.java  [java source file]K:\eclipse31m7\eclipse\runtime-workspace\A\A.java:1::0      import declarations  [import reference]      A  [aspect] K:\eclipse31m7\eclipse\runtime-workspace\A\A.java:3::31        declare warning: ""blah blah""  [declare warning]K:\eclipse31m7\eclipse\runtime-workspace\A\A.java:5::42    C.java  [java source file]K:\eclipse31m7\eclipse\runtime-workspace\A\C.java:1::0      import declarations  [import reference]      C  [class] K:\eclipse31m7\eclipse\runtime-workspace\A\C.java:3::31        main(String[])  [method]K:\eclipse31m7\eclipse\runtime-workspace\A\C.java:5::58        sayHello()  [method]K:\eclipse31m7\eclipse\runtime-workspace\A\C.java:9::124=== END OF MODEL REPORT ============ RELATIONSHIPS REPORT ========= After a batch buildHid:1:(targets=1) K:\eclipse31m7\eclipse\runtime-workspace\A\A.java|5|0|42 (matched by) K:\eclipse31m7\eclipse\runtime-workspace\A\C.java|9|0|0Hid:2:(targets=1) K:\eclipse31m7\eclipse\runtime-workspace\A\C.java|9|0|0 (matches declare) K:\eclipse31m7\eclipse\runtime-workspace\A\A.java|5|0|42=== END OF RELATIONSHIPS REPORT ===== Properties of the model and relationships map =====method=2import reference=2aspect=1declare warning=1class=1RelationshipMapSize=2build configuration file=1FileMapSize=2package=1java source file=2which says that the relationships do exist in both directions.  The problem iswith one of the endpoints.The problem is the ASM records line 9 like this:sayHello()  [method] K:\eclipse31m7\eclipse\runtime-workspace\A\C.java:9::124whilst the relationship map records it with handle:K:\eclipse31m7\eclipse\runtime-workspace\A\C.java|9|0|0since the offsets don't match (one is 0, one is 124) then they aren't consideredequivalent.  The fix is to make sure the offset isn't lost.b offset is now correctly preserved and ""matches declare"" relationship created in the case that the source is compiled by ajc (needs our MethodDeclarationLineNumber attribute). This is of course the case for AJDT which is the primary client of this feature. "	2005-06-03 10:57:01	1117810000.0	resolved fixed	619f8bc	1125600000.0	weaver/src/org/aspectj/weaver/bcel/BcelShadow.java weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java
102459	provide more detail in -showWeaveInfo messages	When advice is executed, the object you have to work with is the joinpoint. Thiscan then be queried to get various information out of it. It would be nice, ifas part of the weaving you could get hold of the same information. This is particularly useful in the case of writing a coverage tool. In order tomeasure where you've been, you have to know all the places you could possiblygo. The introduction of the -showWeaveInfo option means that we can record theseplaces, however, this would be greatly enhanced by providing similar informationas to that which is collected as the program is running.The information which would be good is the same as that obtained fromJoinPoint.StaticPart.getSignature().toLongString(). try and look at this for 1.5.0 weave info messages for advice execution now have the form:Join point 'method-execution(void Simple.method())' in Type 'Simple' (Simple.java:17) advised by afterThrowing advice from aspect 'AspectAdvice' (AspectAdvice.aj:20)etc.The new part is the prefix containing the join point information. I didn't change the tail end of the message because it would have upset too many test cases.I actually prefer this new message since it makes the primary abstraction one of join points being advised, and not source locations. 	2005-07-01 06:48:04	1120210000.0	resolved fixed	c6bc7a2	1125600000.0	bridge/src/org/aspectj/bridge/WeaveMessage.java tests/java5/ataspectj/ataspectj/ltwlog/MainVerboseAndShow.java weaver/src/org/aspectj/weaver/Shadow.java
59076	Reduce footprint of JoinPoint.StaticPart objects	Tests show that each object consumes 180+ bytes. For a large project (1000+ classes) where an aspect is used to implement a pervasive cross-cutting concern e.g. exception logging this can lead to >1MB of additional heap space. Two possible approaches could be:1. Break literal String used by Factory.makeXXXSig() methods into component parts e.g. package, class, method. ... names. These could then be shared automatically by the JVM as interned Strings.2. Lazy instantiation of handler static JPs in the catch block.Any enhancements could be enabled by a compiler option similar to -XlazyTjp. Adding Noel CC Created attachment 10392Patch to implement option (1) I am appending the attachment from Noel Markham that implements option (1) ofthe two strategies proposed for addressing this problem.Noel says:---Please find attached two patches: LazyClassGen.java and Factory.java, forreducing the footprint of JoinPoint.StaticPart objects. Currently, only themethods makeMethodSig() and makeCatchClauseSig() in Factory.java take abroken-up set of parameters.Since the generated code is enclosed in a static block, it is only run once andshoudn't affect the performance too much. Using my FFDC Simulation tests, thefree heap size (on a 4Meg heap) has been increased from ~600k to ~1.6M.On the test, 1000 classes are produced, each with four catch blocks. The classnames(fully qualified with package name) are approx 60 chars, and the methodnames are approx 40 chars.----My only concern with the approach is using makeClass() which callsClass.forName() - I wonder if that is necessary - but I haven't become anexpert on this area of code like Noel has so I can't say yet ! Created attachment 10445New version of patch to implement (1)This patch creates overriding methods for makeMethodSig(),makeConstructorSig(), makeFieldSig(), makeAdviceSig(), makeInitializerSig() andmakeCatchClauseSig() in Factory.java The code to use these methods instead ofthe one-String parameter methods is in the second file, a patch forLazyClassGen.javaThis patch supersedes the previous submission. This could reduce memory usage in AJ programs and it is worth looking atintegrating this patch in AJ5 M4. Note that tjpsp currently provides a stableand unique hashCode for use in Maps etc.. Any change to the implementation mustpreserve this property. patch updated and applied. 	2004-04-19 10:52:41	1082390000.0	resolved fixed	a5e645f	1125580000.0	runtime/src/org/aspectj/runtime/reflect/Factory.java runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java
74048	AJDT reports unnecessary compile time warnings for private static aspects	"When using private static aspects inside a class (e.g. using the Participant pattern as described in Laddad: AspectJ in Action), the compiler reports a warning about the type never being used, e.g.:The private type RowSet.ConstructorCallControlAspect is never used locally  This, of course, only happens when the setting ""Window-->Preferences-->Java-->Compiler-->Unused code-->Unused or unread private members"" is set to Warning.  These warnings should not be generated as aspects are (almost) never referred to anywhere else in the code, so they are not really unused even if references do not exist. The warning comes from the compiler, so passing over to AspectJ. The warning isgiven when using ""ajc -warn:unusedPrivate"" from the command line. this would be a nice thing to tidy up in aj5m4 now fixed in tree, and will be available in next published AspectJ developmentbuild on the AspectJ download page. "	2004-09-16 05:30:58	1095330000.0	resolved fixed	16512b2	1125570000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java
59196	"""adviceexecution() && args()"" pcd does not pick up around advice execution because args() does not match the AroundClosure parameter."	"In the following sample, the advice defined in ""other_aspect"" does not pick up the execution of around advice defined in ""some_aspect"". It matches only against the before advice defined in ""some_aspect"".The implicit AroundClosure parameter of an around advice seems to come in the way of args() matching. ------------------------------------------------------ aspect some_aspect {   pointcut call_m(int a, int b) :               call(int test.m(..)) && args(a, b);    before(int x, int y) : call_m(x, y) { ...  }   int around(int x, int y) : call_m(x, y) { ... }} aspect other_aspect {   before(int x, int y) :        adviceexecution() && within(some_aspect) &&                                        args(x, y){          ...       }}--------------------------------------------------------AspectJ doc has to state this explicitly. This is a bug, not a misdocumentation.  I've moved this back to compiler and cc'd myself on it in case I get enough time to fix the bug.  I've verifiedthat this is still a bug in 1.2 with the following test that I should checkin as a test case:public class Test {    public static void main(String[] args) {	m(3, 4);    }    static void m(int x, int y) {    }}aspect some_aspect {   pointcut call_m(int a, int b) :               call(void Test.m(..)) && args(a, b);    before(int x, int y) : call_m(x, y) { System.err.println(""b4"");  }   void around(int x, int y) : call_m(x, y) { System.err.println(""arn""); }} aspect other_aspect {   before(int x, int y) :        adviceexecution() && within(some_aspect) &&                                        args(x, y){        System.err.println(""exec"");       }}The args of an around advice should be the formal arguments listed, notincluding the magic closure argument.I've P4d the bug since I think it unlikely in the extreme that peoplein the wild are using adviceexecution at all, much less with args. marked as target AJ5 M4 fixed in tree, fix will be available in next published build on AspectJ download page later on today. "	2004-04-20 03:42:16	1082450000.0	resolved fixed	a66e0a2	1125560000.0	tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java
71159	pointcut call(MethodPattern) matches non-visible methods in parent class	"aspectjtools.jar / ajc v1.2We believe that the call(methodpattern) pointcut has matching behaviour that isinconsistent with what we expect from Java in relation to invocations of methodson subclasses and superclasses.Background: Our goal is to use an aspect to declare ajc compiler warnings on any invocationto a target method, where the space of targets is defined as any visible methodof any class in a specified package P or its subpackages.As well as straight invocations from types in packages oustide P and itssubpackages, we wish to match method invocations on P where the methods invokedare inherited from P -- that is , they are obtained in a type that directlyextends a type in P or its subpackages.  The fragment of the aspect we are using is:public aspect Aspect1{  pointcut methodCalls() :     !within(Aspect1) &&    call(* P..*.*(..)) ;         // 'P' is the target package space  declare warning : methodCalls() : ""invoking"";  //...}Consider these cases:Case 1 method inheritance: Superclass A in package P declares and implements a public method M.  A directsubclass B (in a package outside P) directly extends A and inherits this method. Now, any calls inside B to M or this.M() are matched by the call() join pointabove which seeks to match calls to P..*.*() This is as we would expect sincethe implementation in package space P is actually being called.Case 2 method overriding: Superclass A in package P declares and implements a public method M.  Directsubclass B (in a package outside P) overrides A.M with its own implementationM'. M' does not invoke M.  Now, calls inside B to M' or this.M'() are stillmatched by the call() join point above which seeks to match calls to P..*.*()even though M' does not invoke or depend on M.  We do not expect this resultsince we do not think M is actually called.Case 3 redeclaration of non-visible method with the same name:  Superclass A in package P declares and implements a private method M.  Directsubclass B (in a package outside P) introduces its own method M having the samesignature as A.M.  Now, calls in B to M or this.M() are still matched by thecall() join point above which seeks to match calls to P..*.*() even though A.Mis not visible to B and is never called by it. We do not expect this resultsince we do not think A.M is ever called.The only way we can explain this apparent behaviour is by reasoning that thecompiler is treating the subclass B ""as a type of"" its parent A and somehowconcluding that method calls on B can be equated with calls to methods ofidentical signature on A.  However this seems at odds with the rules for Javavisibility and with our expectations for when the call(...) joinpoint should match.We have experimented with execution(...) join points to perform this matchingbut that has turned up a different set of problems which we are still analyzing.Please can you shed any light on what the call joinpoint is doing here?regards, Dave marked as target 1.2.1 Case(1) - we all agree its right :)===Case(2) is 'working as designed'.  According to the new eclipse AspectJ book:For the call() pcd: ""If a declared type pattern is specified, then the pointcut will only matchcalls made to methods that are declared in a type matched by the pattern, *orone of its super-types.*""So here we are talking about where things are *declared*, not whether thesubclass is calling the superclass.  Your subclass logic calls B().m() andalthough the m() in the subclass runs, it is declared in the superclass (thefull signature for the declaration in the superclass matches your pointcut).===Case (3) is similar to case (2) but we are still thinking about it.  It may beworking as designed but it is unhelpful.  Although you aren't overriding m() inthe subclass, from the JVM spec (8.4.2):""The signature of a method consists of the name of the method and the number andtypes of formal parameters.""It doesn't include the visibility modifier.  So, if we ignore the visibilitymodifier then this is the same as case (2).Our AspectJ language guru, Erik Hilsdale is off back packing this week thinkingthrough the semantic issues... more to follow ... we should take note of visibility in ResolvedMemberImpl.getJoinPointSignatures Fixed!!Given the program below, the ""should match"" warning does match, and the ""shouldnot match"" warning does not.class A {		private void foo() {}	}class B extends A {		protected void foo() {}	}class C extends B {}class D extends C {		public void foo() {}	}aspect X {		void bar() {		D d = new D();		d.foo();	}		declare warning : call(* B.foo()) : ""should match"";	declare warning : call(* A.foo()) : ""should not match"";	}Will be available in next published build on AspectJ download page. "	2004-07-30 10:36:22	1091200000.0	resolved fixed	7e0c3cd	1125500000.0	tests/bugs150/pr71159/pkg1/A.java tests/bugs150/pr71159/pkg1/B.java tests/bugs150/pr71159/pkg1/C.java tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java
107858	illegal argument to proceed crashes the parser	in a context where proceed requires zero arguments, calling it with an extraargument crashes the compiler, but only if that argument is a field access:class Foo {  Foo field;  void test() {}}public aspect Bug {  void around() : call(void Foo.test()) {    Foo foo = new Foo().field;    proceed(foo); // caught at compile time    proceed(new Foo().field); // crashes  }}/home/user/sgelin3/dev/java/ajc/new_bug/Bug.java [error] Internal compiler errorjava.lang.NullPointerException        atorg.aspectj.ajdt.internal.compiler.ast.AccessForInlineVisitor.getAccessibleField(AccessForInlineVisitor.java:145)        atorg.aspectj.ajdt.internal.compiler.ast.AccessForInlineVisitor.endVisit(AccessForInlineVisitor.java:108)        atorg.aspectj.org.eclipse.jdt.internal.compiler.ast.FieldReference.traverse(FieldReference.java:609)        atorg.aspectj.org.eclipse.jdt.internal.compiler.ast.MessageSend.traverse(MessageSend.java:467)        atorg.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:212) for M4 now fixed in tree, will be available in published build from AspectJ downloadpage later on today. now available in published build 	2005-08-24 10:53:45	1124900000.0	resolved fixed	6c8747b	1125500000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java
104024	combining varargs and inner classes crashes the parser	class Outer {  public class Inner {}}public class Bug {  public void varargs(Object... varargs) {}  public void test() {    Outer.Inner inner = new Outer().new Inner();    varargs(inner); // works    varargs(new Outer().new Inner()); // crashes  }} for M4 This is fixed with the latest builds of the compiler (and quite probably in M3 too). 	2005-07-15 11:16:07	1121440000.0	resolved fixed	f2af562	1125500000.0	tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java
95992	Problems resolving type name inside generic class	"ajc reports an error when compiling the following code:interface Base<T> {    static interface Inner {    }}class Test<T extends Test.InnerTest> implements Base<T> {    static class InnerTest implements Inner {    }}$ ajc -1.5 Test.javaTest.java:14 [error] Inner cannot be resolved to a typestatic class InnerTest implements Inner {Sun's javac compiles it without any error.The error can be avoided by simply writing ""Base.Inner"" instead of just ""Inner"".Also, it compiles fine if the constraint ""extends Test.InnerTest"" is left away. this program also fails in the regular Eclipse JDT compiler (3.1m7) This program also fails to compile using the Java compiler in Eclipse 3.1 RC1. (same error) Eclipse + JDT 3.1.0 (final) does compile it. Another example of a similar bug, which causes error while trying to resolve classes:public interface ExampleInterface<T> {}public class ExampleClass {    private static class MyClass implements ExampleInterface<String> {    }}But if the inner class is defined without the generic, everything works:public class ExampleClass {    private static class MyClass implements ExampleInterface {    }} This program: public interface ExampleInterface<T> {}public class ExampleClass {    private static class MyClass implements ExampleInterface<String> {    }}works with the latest dev build of the compiler (20050824100440), however the first program mentioned in this bug seems to have changed from failing because of JDT to failing because of AJ.  Compiling it now gives:[error] can't find type Test$InnerTest This bug had the same root cause as bug 108454, and is now fixed in tree. Themost recent published build on the AspectJ downloads page contains the fix. "	2005-05-19 14:12:24	1116530000.0	resolved fixed	b953c03	1125500000.0	tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java
108448	IllegalStateException: Undeclared type variable when hiding	"ISE thrown compiling http://sourceforge.net/projects/collections 4.0beta3 source.javac issues two warnings, but Eclipse 3.1 (JDT) issues *many* for typeparameter hiding types (perhaps bug 103783).  I haven't isolated a test case ortried it on earlier releases - sorry. Created attachment 26684ajcore text file I recognise that stack trace :)The collections project looks like a good way of hammering our generics support.I'll download it and give it a spin... I've improved the error handling inside ajc so that we get much betterdiagnostics on errors like this in the future. The compiler now fails with anIllegalStateException that says:""While determing the generic superinterfaces oforg.apache.commons.collections15.list.FastArrayList$SubList$SubListIter withgeneric signature Ljava/lang/Object;Ljava/util/ListIterator<TE;>; the followingerror was detected: Undeclared type variable in signature: E""Much more like it :)Now I can go ahead and make the fix (not chasing up *all* the outer types tofind type variables, we are only looking at immediate enclosing types at themoment), and if we encounter similar situations in the future we should be ableto debug much more directly from the error report. Put in place a straightforward fix to walk *all* outer types while looking fortype variables in scope. ajc now compiles the collections project without error.Just running the full suite before commiting... fix now available in latest published build on the downloads page. "	2005-08-31 02:35:46	1125470000.0	resolved fixed	2c9ea11	1125490000.0	weaver/src/org/aspectj/weaver/bcel/BcelField.java weaver/src/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXConverter.java weaver/src/org/aspectj/weaver/bcel/BcelMethod.java weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java weaver/testsrc/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXTestCase.java
108377	Verify Error on intertype field indirection in intertype method	"When I run this program:public class A {    public static void main(String[] args) {	System.out.println(new A().foo());    }}aspect Aspect1 {    public A A.a;    public String A.value;    public String A.foo() {	return a.value;    }}I get the error:Exception in thread ""main"" java.lang.VerifyError: (class: Aspect1, method:ajc$interMethod$Aspect1$A$foo signature: (LA;)Ljava/lang/String;) Incompatibletype for getting or setting field        at A.<init>(A.java:1)        at A.main(A.java:3)Javap reveals that the field name is missing the class name part:   1:   getfield        #50; //Field a:LA;   4:   getfield        #46; //Field A.value:Ljava/lang/String;If I replace a.value by this.a.value, the correct code is generated:   1:   getfield        #37; //Field A.a:LA;   4:   getfield        #46; //Field A.value:Ljava/lang/String; this looks serious. tagging M4 and P1 The bug occurs when the JDT compiler tries to update the codegenBinding for thefield in the case that the actual receiver type != the declaring class of thefield (to preserve the receiver type in the bytecode, as per 1.4 onwards). Withan ITD, the receiver type was set to the Aspect type, and updating thecodegenBinding with the aspect as the new declaring type causes the problem. Nowlooking into the cleanest fix for this in the codebase... fix now available in latest published build on the download page. "	2005-08-30 11:01:24	1125410000.0	resolved fixed	be750d5	1125480000.0	tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java
108050	Execution not matching override in doubly derived method	"The following sample code fails because the compiler isn't matching theexecution of doPost in MockServlet4. The declare warning for ""servlet request""doesn't match  in that case, nor does advice on the join point actually run atruntime (though this simplified code only shows the problem with declarewarning). This was working until fairly recently (certainly in M2, even in AJDTfrom August 11).public abstract class MockServlet extends HttpServlet {        protected void doPost() {    }    private static aspect FindMatches {        declare warning: execution(* HttpServlet.do*(..)): ""servlet request"";        declare warning: execution(* HttpServlet+.do*(..)): ""servlet request2"";    	    }}class HttpServlet {    protected void doPost() {    }    }public class MockDelayingServlet extends MockServlet {    private static final long serialVersionUID = 1; }public class MockServlet4 extends MockDelayingServlet {    protected void doPost()    {    } }compiler output (should have 6 warnings, including two for MockServlet4):C:\devel\workspace\test\src\MockServlet.java:16 [warning] servlet requestprotected void doPost() {^^^^^^^^^^^^^^^^^^^^^^^^^        method-execution(void MockServlet.doPost())        see also: C:\devel\workspace\test\src\MockServlet.java:20::0C:\devel\workspace\test\src\MockServlet.java:16 [warning] servlet request2protected void doPost() {^^^^^^^^^^^^^^^^^^^^^^^^^        method-execution(void MockServlet.doPost())        see also: C:\devel\workspace\test\src\MockServlet.java:21::0C:\devel\workspace\test\src\MockServlet.java:26 [warning] servlet requestprotected void doPost() {^^^^^^^^^^^^^^^^^^^^^^^^^        method-execution(void HttpServlet.doPost())        see also: C:\devel\workspace\test\src\MockServlet.java:20::0C:\devel\workspace\test\src\MockServlet.java:26 [warning] servlet request2protected void doPost() {^^^^^^^^^^^^^^^^^^^^^^^^^        method-execution(void HttpServlet.doPost())        see also: C:\devel\workspace\test\src\MockServlet.java:21::0C:\devel\workspace\test\src\MockServlet4.java:9 [warning] servlet request2protected void doPost()^^^^^^^^^^^^^^^^^^^^^^^        method-execution(void MockServlet4.doPost())        see also: C:\devel\workspace\test\src\MockServlet.java:21::05 warnings bloody hell!  (excuse my language)over 2300 tests in the suite now (any many of those make multiple discreteassertions) - up by 1,100 from AspectJ 1.2.1, and not one of them caught this bug. It's fixed now in the tree, and serious enough to warrant 1.5.0 M3aThanks for the quick catch and the easy to reproduce bug report. "	2005-08-25 16:22:28	1125000000.0	resolved fixed	27e68f3	1125060000.0	tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java weaver/src/org/aspectj/weaver/JoinPointSignature.java weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java
107713	ClassCastException popup	"<Pyinson Data Over Head> Hi,Please could you add your Eclipse and AJDT versions.Thanks. AJDT version: 1.2.1 for Eclipse 3.1> Hi,> Please could you add your Eclipse and AJDT versions.> Thanks. I didn't see the ClassCastException popup, but I could reproduce the compilererror for the referenced line (b.support cannot be resolved). This compilationerror only appears after an incremental build, not after a full build. Passingover to AspectJ. Shame we don't have the stack trace for the classcastexception :(Depending on where some type originated from it will be represented as anEclipseSourceType (if it came from source) or a BcelObjectType (if it came froma .class file on disk).  The classcast occurs when someone is makingassumptions.  They shouldn't really need to make assumptions as they bothimplement the same interface.Anyway - I might have some insights on the problem where the member is missingpost incremental compile.  I came across a similar situation when working onbinary weaving of generic ITDs.If we look at AjLookupEnvironment.weaveIntertypeDeclarations - it is passed aset of type mungers.  The first thing the method does is look for a weaver stateinfo - if it finds one then it retrieves the set of type mungers from the infoobject and reapplies them to the type ... THEN it returns.  It never seems toapply the set of them that was passed in - if you just comment out the return soit continues through the method applying the new ones too, that causes anexisting test or two to fail.  In the incremental case we are likely toencounter the state info attributes, if doing a full build then we don't.I haven't had time to resolve this descrepancy but I think its where I'd startlooking for all incremental ITD related problems we are having... I picked up this trace from the old log entries. This could be the one you are looking for.java.lang.ClassCastException: org.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType cannot be cast to org.aspectj.weaver.bcel.BcelObjectType	at org.aspectj.weaver.bcel.BcelWorld.getBcelObjectType(BcelWorld.java:414)	at org.aspectj.weaver.bcel.BcelWeaver.getClassType(BcelWeaver.java:1121)	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:946)	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:286)	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:165)	at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70)	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:368)	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:727)	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:229)	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:147)	at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:116)	at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191) Ok ...  It happens when we go to retrieve any reweavable state for a file - nowgiven that if the delegate is really an EclipseSourceType then it *cant* haveany reweavable state, i've put in the guards to allow for this case(getBcelObjectType() returns NULL if the delegate is an EclipseSourceType, andit says so in its new javadoc - so its up to the caller to handle).Maybe removing the classcastexception will affect the missing member problem.fix checked in. Can you confirm whether this is fixed in the recent AJDT builds? This particular code is working fine. thanks for verifying! "	2005-08-23 06:56:58	1124790000.0	resolved fixed	100d9e0	1125050000.0	weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java weaver/src/org/aspectj/weaver/bcel/BcelWorld.java
104720	VerifyError after weaving around trivial switch statement	"After compiling the attached source file and class file withajc -inpath . -outjar t.jar Tracer.aj(on any of 1.2.1, 1.5.0M2 or the June 2005 snapshot) and then attempting to runit withgij -classpath ./t.jar:$CLASSPATH Testthe following error is obtained:Exception in thread ""main"" java.lang.VerifyError: verification failed at PC 1 inTest:newTest_aroundBody2((I)LTest;): branch out of range   at java.lang.VMClassLoader.resolveClass(java.lang.Class)(/usr/lib/libgcj.so.6.0.0)   at java.lang.Class.initializeClass() (/usr/lib/libgcj.so.6.0.0)   at java.lang.Class.forName(java.lang.String, boolean, java.lang.ClassLoader)(/usr/lib/libgcj.so.6.0.0)   at gnu.java.lang.MainThread.run() (/usr/lib/libgcj.so.6.0.0)An excerpt from the output ofjavap -private -classpath t.jar -c Testshows that the generated switch is indeed bogus:private static final Test newTest_aroundBody2(int);  Code:   0:   iload_0   1:   tableswitch{ //0 to 0                0: -1157627302;                default: 16 }   20:  invokespecial   #3; //Method ""<init>"":()V   23:  areturn Created attachment 25148Class file to be weaved Created attachment 25149Aspect Moving to P1 as any verify error is bad... Sorry its taken a while to get to this ... darn generics has slowed us down so much.I assume you used javac or something to build Test.java before using ajc tobinary weave it?What I'm doing to recreate is:javac -d outputfolder Test.javaajc -inpath outputfolder Tracer.ajjava Testand I get:Exception in thread ""main"" java.lang.VerifyError: (class: Test, method:newTest_aroundBody2 signature: (I)LTest;) Illegal default target in switchdisassembling that method:private static final Test newTest_aroundBody2(int);  Code:   Stack=2, Locals=1, Args_size=1   0:	iload_0   1:	tableswitch{ //0 to 0		0: -1157627302;		default: 16 }   20:	invokespecial	#3; //Method ""<init>"":()V   23:	areturn  LineNumberTable:    line 16: 0   line 19: 16before any advice got tangled up in things, the newTest() method looked like this:public static Test newTest(int);  Code:   Stack=2, Locals=1, Args_size=1   0:	iload_0   1:	lookupswitch{ //0		default: 12 }   12:	new	#2; //class Test   15:	dup   16:	invokespecial	#3; //Method ""<init>"":()V   19:	areturn  LineNumberTable:    line 16: 0   line 19: 12If I compile it all together with ajc:ajc Test.java Tracer.aj then the result works - it seems that the switch statement is optimized awaybecause it only has a default entry.  I will take a quick look at tableswitchbut I don't think this will be fixed for M3. I've reduced the testcase to something simpler.  Here is the test class:public class Test {    public static Test newTest(int i) {        switch(i) {          default: return null;        }    }}and here is the aspect:aspect Tracer {  Object around (): execution(* newTest(..)) { return proceed();}}If you follow the steps I outlined earlier, this also blows up.  I triedmodifying the switch to include an entry:    public static Test newTest(int i) {        switch(i) {          case 1:  return null;          default: return null;        }    }so that I could just compile entirely with ajc but that works fine, thearoundbody in the result looks like:private static final Test newTest_aroundBody0(int);  Code:   Stack=1, Locals=1, Args_size=1   0:   iload_0   1:   tableswitch{ //1 to 1                1: 20;                default: 22 }   20:  aconst_null   21:  areturn   22:  aconst_null   23:  areturn  LineNumberTable:   line 10: 0   line 11: 20   line 12: 22starting to suspect BCEL more and more... Ok... BCEL bug.  The problem occurs when we perform 'extractInstructions' forcreating the body of the around advice.  In order to do that we use a routinecalled 'copyInstruction'.If you look in the code generated by the javac run, it looks like this:public static Test newTest(int);  Code:   Stack=1, Locals=1, Args_size=1   0:   iload_0   1:   lookupswitch{ //0                default: 12 }   12:  aconst_null   13:  areturn  LineNumberTable:   line 4: 0   line 5: 12Notice that a lookupswitch has been used.  The copyinstruction() routine copiesa select (like lookupswitch) by just building a new 'SELECT' object and lettingBCEL work out the best way to represent the select based on the number oftargets in the select.  BCEL thinks its better to represent a select with notargets (the case we have here) with a TABLESWITCH rather than LOOKUPSWITCH.However, thats wrong - and there are two bugs lurking.  My first fix is to sayif there are no targets then use a LOOKUPSWITCH - my around body now looks likethis:private static final Test newTest_aroundBody0(int);  Code:   Stack=1, Locals=1, Args_size=1   0:   iload_0   1:   lookupswitch{ //0                default: 12 }   12:  aconst_null   13:  areturn  LineNumberTable:   line 4: 0   line 5: 12perfect!The other lurking problem is that a TABLESWITCH is defined as:TABLESWITCH (0xaa)<0-3> padding bytesdefaultbytes1-4lowbyte1-4highbyte1-4jumpoffsets...So in our case we create a TABLESWITCH where lowbyte=0 and highbyte=0 but thedefinition of the instruction says that the number of jumpoffsets must be(high-low+1).  BCEL doesnt write out any entries in the case where there are notargets when it should write out at least *one* - if it doesnt then decompilersand verifiers will choke.However... I haven't fixed this problem as there seems to be more issues lurkingin TABLESWITCH - if we write out those 4 missing bytes, we'll need to ensure the'length' of the instruction is managed correctly too.  Given that so far theonly way I've seen a damaged TABLESWITCH is when its been incorrectly createdinstead of a LOOKUPSWITCH (and that can no longer happen) I won't fixTABLESWITCH until I see a bug that shows the problem.fix checked in, waiting on build. fix available in latest dev build, see download page. "	2005-07-21 15:16:55	1121970000.0	resolved fixed	bf767a9	1124970000.0	bcel-builder/src/org/aspectj/apache/bcel/generic/SWITCH.java bcel-builder/src/org/aspectj/apache/bcel/generic/TABLESWITCH.java
82989	Compiler error due to a wrong exception check in try blocks	Compiler error on correct code when an aspect performs a method introdiction.The method introduction contains an invocation to a method from the class andsuch an invocation is inside an appropriate try block.The ajc compiler performs a wrong check on the exception types.To understand better, please see the attached example Created attachment 17204The class Created attachment 17205the aspect Created attachment 17206the exception for investigation in aj5m3 Here is the program that fails directly in the bug report:class A {  public A(){}  private void m1() throws E {    throw new E();  }}privileged aspect B {  void A.m2() {    try {      m1();    } catch(E e) {    }  }}class E extends Exception{  public E(){}}On compiling (with up to date AJ) you get:C:\pr82989\poo\A.java:15 [error] Unreachable catch block for E. This exception is never thrown from the try statement body} catch(E e) {If you change m1() in A to be public rather than private, the program compilesfine.  This suggests the accessor methods created for m1() in the A class don'thave the exception throws clauses correctly copied across. Ok, I looked at AjcMemberMaker.privilegedAccessMethodForMethod() and found thisXXX comment: //XXX needs thrown exceptions to be correct(so it appears I was right in my previous comment).I rewrote the code to generate a correct accessor, now the program compilesfine, and the accessor method looks like this in A:public void ajc$privMethod$B$A$m1() throws E;I need to test whether the fix affects any other tests - but it looks good. fix checked in - waiting on build fix available, see AJ downloads page. 	2005-01-17 12:07:27	1105980000.0	resolved fixed	cc6e681	1124910000.0	tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java tests/src/org/aspectj/systemtest/ajc150/GenericsTests.java weaver/src/org/aspectj/weaver/AjcMemberMaker.java
79523	BCException: illegal change to pointcut declaration: calls(<nothing>)	<Pyinson Data Over Head> this needs to be fixed in aj5m3. The bug arises when calls(str) is used in thedeow (rather than calls(String) which produces the correct error message). compiler now handles this gracefully and emits the appropriate error messages. 	2004-11-25 16:31:26	1101420000.0	resolved fixed	93fdce1	1124480000.0	tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java
104529	"@SuppressWarnings( ""unchecked"" ) is not ignoring type safety checks"	"AJDT is ignoring the @SuppressWarnings( ""unchecked"" ) annotation.  It is giving me a type safety warning when I don't specify the type when declaring a generic even though I have the @SuppressWarnings( ""unchecked"" ) annotation specified. Passing over to compiler We should just be picking up this functionality from the underlying JDTcompiler. I'll check it out as part of the M3 release... Fixed by upgrade to latest JDT compiler level. This program: import java.util.*;public class pr104529 {		void unsuppressed() {		List<String> l = new ArrayList();	}		@SuppressWarnings(""unchecked"")	void suppressed() {		List<Double> l = new ArrayList();	}	}compiled with:ajc -1.5 -warn:+unchecked pr104529.ajgives an unchecked error for the assignment in unsuppressed() and not for theassignment in suppressed() "	2005-07-20 12:46:55	1121880000.0	resolved fixed	7b32570	1124480000.0	tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java
86057	expect error when overriding final pointcuts	"I get no compiler error when I ""override""/redefine a final pointcut:------------public class Main {    static void walk() {}    static void run() {}    public static void main(String[] args) {        walk();        run();    }}abstract aspect AA {    public final pointcut publicPointcut() : call(void walk());    before() : publicPointcut() { System.out.print(""here: "" + thisJoinPoint); }}aspect AA1 extends AA {    // expecting error here b/c pointcut is final    public pointcut publicPointcut() : call(void run());}------------When run, it picks out run() rather than walk(). we should tidy this up in aj5m3 fixed in tree. "	2005-02-21 17:25:49	1109020000.0	resolved fixed	86ce1f7	1124470000.0	tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java weaver/src/org/aspectj/weaver/ResolvedType.java weaver/src/org/aspectj/weaver/WeaverMessages.java
78261	"field pattern with ""void"" type should be compile-time error"	"We really should barf early on  get(void i)as opposed to just compiling through and treating it as something that'll nevermatch.  I rated this as minor since this is just an error message issue. for aj5m3 whilst we're working in the parser... nice to have an easy bug for a quick moral boost :)We now put out an error, ""fields cannot have a void type"".Fix committed in tree. "	2004-11-10 01:58:38	1100070000.0	resolved fixed	2b23e91	1124460000.0	tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java
91114	"[jdt-parser] Parser error on System.out.printf(""..."" + (after-before) + ""..."")"	"Following code fragment:*****************************class Foo {        public void bar () {                long before = 0;                long after = 0;                System.out.println(""... "" + (before - after) + "" ..."");        }}*****************************leads to following parser error*****************************[...].java:25 [error] Syntax error on token ""-"", invalid AssignmentOperatorSystem.out.println(""... "" + (before - after) + "" ..."");*****************************Problems seems to vanish when I rename the before variable. Same applies if    System.out.println(""... "" + (after - before) + "" ..."");again, renaming after solves the problem whilst Adrian has the parser open, he can take a look :) Verified as happening on Windows 2000, PC hardware. I would switch the hardware to All if I had the power. Recommend that this never gets assigned as minor since some legacy/existing code cannot be changed to workaround this bug. The problem is in the way that AspectJ handles its pseudo-keywords. Identifierssuch as ""aspect"", ""pointcut"", ""before"", ""after"" etc. are treated as keywords inthe context in which they may legitimately appear, but as identifiers in othercontexts. This *should* allow you to name your variable before and after in thefragments of code shown in this bug report, but where the grammar has beenextended to cope with the new features of Java5, we clearly haven't yet nailedall of the places where we need to be accomodating. Fix will be to find the grammar production for these expressions and ensure thatany use of 'Identifier' is replaced by 'JavaIdentifier'. Still targetting to fixthis as part of the current milestone (M3) development. turns out a whole family of expressions fail, eg.before * after, before >>>  x, after \ before etc..all of these are now successfully compiled as expected.Fix committed to tree. "	2005-04-12 08:03:15	1113310000.0	resolved fixed	169a488	1124460000.0	tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java
64568	Wildcarding in ITDs needs clearer compiler error message.	"If a user attempts to define an ITD using a type pattern (illegal sinceAspectJ 1.1) they get back a compiler error message of the followingform :-MyAspect.java:4 error Syntax error on token ""*"", around expectedpublic String foo.bar.*.name;A clearer error message informing the user of their use of illegal syntax would help. Created attachment 11277Test caseJust unzip and then run the command ""ajc MyAspect.java foo\bar\A.java"" .Should result in the ""around expected"" error message. A simple thing to look at in M3 whilst we have the parser open for surgery... it now says:syntax error on token ""*"", delete this tokenpublic String foo.bar.*.name;                      ^you wouldn't believe how difficult that was to do! "	2004-05-28 11:21:04	1085760000.0	resolved fixed	5e9aca9	1124460000.0	tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java
106634	regression: argument causes BcelGenericSignatureToTypeXConverter.java:203	"the following reported a compile error usingAspectJ Compiler DEVELOPMENT built on Monday Jun 20, 2005 at 08:14:57 GMTbut now crashes usingAspectJ Compiler DEVELOPMENT built on Wednesday Aug 10, 2005 at 13:12:53 GMTimport java.util.Vector; // works if java.util.* is usedpublic class Bug extends Vector { // works if Vector is not extended  void test(DoesNotExist argument) {} // works without the argument}also, the bug only appears if the -1.5 flag is used. update: also fails if ""java.util.*"" is used after all, and the argument typedoesn't have to be non-existent. so, an updated test case would be:import java.util.*;public class Bug extends Vector {  void test(Object argument) {}}ajc -1.5 Bug.java./Bug.java [error] Internal compiler errorjava.lang.IllegalStateException: Undeclared type variable in signature: E        atorg.aspectj.weaver.bcel.BcelGenericSignatureToTypeXConverter.typeVariableSignature2TypeX(BcelGenericSignatureToTypeXConverter.java:203)        atorg.aspectj.weaver.bcel.BcelGenericSignatureToTypeXConverter.fieldTypeSignature2TypeX(BcelGenericSignatureToTypeXConverter.java:120)        atorg.aspectj.weaver.bcel.BcelGenericSignatureToTypeXConverter.typeArgument2TypeX(BcelGenericSignatureToTypeXConverter.java:163)        atorg.aspectj.weaver.bcel.BcelGenericSignatureToTypeXConverter.classTypeSignature2TypeX(BcelGenericSignatureToTypeXConverter.java:75)        atorg.aspectj.weaver.bcel.BcelGenericSignatureToTypeXConverter.classTypeSignature2TypeX(BcelGenericSignatureToTypeXConverter.java:40)        atorg.aspectj.weaver.bcel.BcelObjectType.unpackGenericSignature(BcelObjectType.java:514) The problem seems to be in unpacking the generic signatures of Vector and itssuper types. In particular, Vector extends ArrayList<E>, which  has a nestedtype Itr<E>. The ""E"" used it ArrayList$Itr<E> comes from the outer type, whichwe are failing to look in when trying to resolve type parameters. Fix commited in tree,  will close when available in a published build. Thanksfor the clear bug report - we're making good headway on the genericsimplementation now and hope to start giving much better service on bug reportsagain soon. Dev build is available with fix in, closing this bug "	2005-08-10 11:04:45	1123690000.0	resolved fixed	477c575	1123760000.0	tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java
106461	org.aspectj.weaver.patterns.WildTypePattern.maybeGetCleanName(WildTypePattern.java:500)	"I want to declare a pointcut to capture invocation of methods on annotatedinterfaces being subtypes of a given interface.here is the full ajcore report:http://veleno.pastebin.com/332842i will attach a test case. Created attachment 25889untar and compile with ajc -source 1.5 -classpath $ASPECTJ1.5/aspectjrt.jar AnnotationTestCase Looks like the root cause of the bug is the pointcut expression:  /* intercept a call to an annotated resource */  pointcut invokingAMonitoredComponent():        call(* Service+(..)) && @annotation(MemberOfMonitoredSet);Notice that the call expression is not well-formed (it should be call(*Service+.*(..)) ), with a missing name pattern. However, this should be detectedduring parsing and resolution, NOT with a RuntimeException. Parser exhibited similar behaviour on missing name patterns in constructor andfield patterns:call(Foo+(..))get(* Foo+)Now produces compilation errors as follows:call(* Foo+(..))-> syntax error on token ""("", ""name pattern"" expectedcall(Foo+(..))-> syntax error on token ""("", ""name pattern"" expectedget(* Foo+)-> syntax error on token "")"", ""name pattern"" expectedFix will be available in next published build. Fix now available in latest build on AspectJ downloads page. "	2005-08-09 08:46:59	1123590000.0	resolved fixed	5735e96	1123670000.0	tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java weaver/src/org/aspectj/weaver/patterns/PatternParser.java weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java
104212	static method call from subclass signature is wrong	"a very bad bug... or ?in the snip below, getMethod() says null and the factory is actually thinkingthat test() is a static method of AspectJBugMain instead of Assert...wondering why we don't catch that in the test suite or what could happenrecently around that. Or is it something I am confused about ? (i doubt ajp.getSignature().getMethod is supposed to return null in some cases though..)@Aspectpublic class Sam {    @Pointcut(""call(* *.*(..))"")            public void methodCalls() {    }    @Around(""methodCalls() && !within(alex.sam.Sam) && within(alex..*)"")            public Object aroundMethodCalls(ProceedingJoinPoint jp) throwsThrowable {        String typeName = jp.getSignature().getDeclaringTypeName();        System.out.println(""declType "" + typeName);        System.out.println(""method "" +((MethodSignature)jp.getSignature()).getMethod());        return jp.proceed();    }}class Assert {    public static void test() {        System.out.println(""RUN Assert.test"");    }}class AspectJBugMain extends Assert {    public static void main(String[] args) {        test();    }//    public static void test() {//        System.out.println(""RUN AspectJBugMain.test"");//    }} don't know why but javap says:invoke static #2const #2 = Method       #3.#19; //  alex/sam/AspectJBugMain.test:()Vwhy is that AspectJBugMain there ?(1.5_3, both Sun  and  Jrockit ) javap shows the same thing under jdk 1.4 too.There was a change from 1.3 to 1.4 in the bytecodes generated for invoke calls.In the 1.3 spec, the spec. said you generate a call to the root defining type ofthe method. In 1.4 compilers were required to preserve the target type of thecall. It looks very odd to see this for static methods too, but that seems to bewhat is happening. The getMethod() method was added to MethodSignature only as part of theannotation work done in M2 (so comparatively recent for the aspectj runtimelibrary). Without looking, my guess is that it is not walking up the hierarchycorrectly to find the method in this case. I don't thinkMethodSignature.getMethod() should ever return null so that's definitely a bug! note that also means toShort/LongString provides a wrong information as well(this even in old version) given what you describe, should the toShort/LongString give the name of the baseclass or not (currently: not, it has the name of the class that is in thebytecode from the compiler)?I think we need to correct class name instead, ie that the issue is not inruntime/ but in the shadow signature creation down in the weaver/thoughts ? i have changed the bcelshadow when it gets createdodd that we were having a match - there might be duplicate logic now somewhere fixedclose when ship was M3 remind was M3 remind "	2005-07-18 09:25:01	1121690000.0	resolved fixed	619a6ad	1122040000.0	tests/java5/ataspectj/ataspectj/Bug104212.java tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjSyntaxTests.java weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java weaver/src/org/aspectj/weaver/bcel/BcelShadow.java weaver/src/org/aspectj/weaver/bcel/BcelWorld.java
103266	NPE on syntax error	"This example program generates an NPE on CVS HEAD and M2. I will attach the ajcore file.public abstract aspect WorkerExample {    after() returning (RequestContext newContext) : call(RequestContext+.new(..)) {                System.out.println(""constructing ""+newContext+"" at ""+thisJoinPoint.toLongString()+"" from ""+thisEnclosingJoinPointStaticPart+"":"");    }    public abstract class RequestContext {        public final Object execute() {            return doExecute();        }                /** template method */        public abstract Object doExecute();    }    public static void main(String args[]) {        new Runnable() {            public void run() {}        }.run();    };}aspect ConcreteAlpha extends WorkerExample {    Object around(final Object runnable) : execution(void Runnable.run()) && this(runnable) {        System.out.println(""monitoring operation: ""+runnable+"" at ""+thisJoinPoint+"", for ""+thisJoinPoint.getThis());        RequestContext requestContext = new RequestContext() {            public Object doExecute() {                return proceed(runnable);            }                    };        return requestContext.execute();    }    }aspect ConcreteBeta extends WorkerExample {        Object around() : call(void awqeyuwqer()) {        RequestContext requestContext = new ConnectionRequestContext() {            public Object doExecute() {                                return proceed();            }                    };        return requestContext.execute();    }    } Created attachment 24515stack trace Created attachment 24516old class file that was still presentThis was caused by having old bytecode for a version of this class file stilllingering on the classpath, which apparently confused the compiler. Comment on attachment 24516old class file that was still presentI cleaned the directory & also tried this in a recent dev AJDT and still seethe NPE. Please disregard attachment. Problem is caused by the visitor that patches up nodes in the AST - it doesn'tallow for a particular thing to be null - which can happen *if* there are syntaxerrors in the code.  A simple guard for the NPE allows us to get the real errormessage out:""ConnectionRequestContext cannot be resolved to a type""testcase (thanks Ron) and fix checked in.  I put guards on all methods in thenew visitor...just in case.Will close when build available. was M3 remind was M3 remind "	2005-07-10 01:40:14	1120970000.0	resolved fixed	bba9c50	1121680000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/MakeDeclsPublicVisitor.java tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java
83935	@AJ and formal binding impl	"Some notes on formal binding impl for @AJIn code style, the advice signature is always looking the same(..bindings.., org.aspectj.lang.Part thisJoinPointStaticPart, JoinPointthisJoinPoint, org.aspectj.lang.Part thisEnclosingJoinPointStaticPart)In @ style, it is user defined.The current impl is handling the formal binding in a way that onlyargs/this/target can be bound.I had to add some conditionals to handles cases like that:void myAdvice(JoinPoint jp, Object target) {..}where target() binding is at index 1, while the index 0 is not an unbound butactually ""virtually"" bound to the joinpoint.Pointcut are thus having a virtuallyBoundedNames String[] that is the list ofarguments for which we don't want any complain if it not bound.This one is populated during  @ extraction, and Pointcut.concretize() make surethe info is not lost when composition occurs (with PerClause f.e.)The only issue is that currently, binding JP/SJP/ESJP themselves is not possiblef.e. ""... && args(jp)"" myAdvice(JoinPoint jp, JoinPoint currentJp)Is that a big issue ?May be impact adviceexecution() and could impact some use cases around mock testing. reviewed and fixed + test, all bindings and arg binding are supported and erroris supposed to be seen when formal binding is missingclose when M3 ships was M3 remind was M3 remind "	2005-01-28 10:29:18	1106930000.0	resolved fixed	639b4fd	1121090000.0	tests/java5/ataspectj/ataspectj/MultipleBindingTest.java tests/java5/ataspectj/ataspectj/SingletonAspectBindingsTest.java tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjSyntaxTests.java weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java
100260	[generics][itds] methods inherited from a generic parent	when using an intertype declaration to add a method to a generic class, themethod is not correctly inherited. the bug doesn't apply to fields.Strangely enough, raw types (generic types instantiated without specifying atype parameter) inherit the methods properly:class Generic_Parent<T> {}class Child extends Generic_Parent<Integer> {}class Generic_Child<T> extends Generic_Parent<Integer> {}aspect Injector {  public void Generic_Parent.inherited_method() {}  public int Generic_Parent.inherited_field;  public void test() {    int inherited_field;    inherited_field = new Generic_Child().inherited_field; // works    inherited_field = new Generic_Child<Integer>().inherited_field; // works    inherited_field = new Child().inherited_field; // works    new Generic_Child().inherited_method(); // works    new Generic_Child<Integer>().inherited_method(); // unresolved    new Child().inherited_method(); // unresolved  }} Related to bug 99228 which fixed this problem for fields - and I also noted inthat bug that I was concerned about methods :)   Similar fix works here - weensure that when asked for methods on a parameterized type binding that wedelegate to a potential itd member finder on the source generic type.fix checked in, waiting on build. Dev build available from the download page: aspectj-DEVELOPMENT-20050620091600.jar 	2005-06-15 14:29:21	1118860000.0	resolved fixed	b54831f	1118920000.0	tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java
100227	[generics][itds] inner class with generic enclosing class	"ajc crashes with a NullPointerException when an intertype declaration tries tomodify an inner class, if the enclosing (outer) class is generic:class Outer {  class Inner {}}class Generic_Outer<T> {  class Inner {}}aspect Injector {  int Outer.outer; // works  int Outer.Inner.inner; // works  int Generic_Outer.outer; // works  int Generic_Outer.Inner.inner; // crashes}/home/user/sgelin3/dev/java/ajc/new_bug/Bug.java [error] Internal compiler errorjava.lang.NullPointerException        atorg.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBinding(EclipseFactory.java:202)        atorg.aspectj.ajdt.internal.compiler.ast.InterTypeFieldDeclaration.build(InterTypeFieldDeclaration.java:173)        atorg.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTypeAndPerClause(AspectDeclaration.java:1020)        atorg.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildInterTypeAndPerClause(AjLookupEnvironment.java:306)        atorg.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:122)        atorg.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:302)        atorg.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:316)... I've sent quite a few bug reports on the interaction of ITD with generics, so bynow I know that they all get ""1.5.0 M3"" as a target. I'd save you the trouble ofsetting that target every time but:""You tried to change the Target Milestone field from --- to 1.5.0 M3, but onlythe owner or submitter of the bug, or a sufficiently empowered user, may changethat field.""strange, since I _am_ the submitter of the bug!anyway, sorry to bother you with so many similar looking bugs (98320, 98592,99168, 99228 and now 100227), I know that I am not supposed to expect genericsto work completely until M3, and keep up the good work! Its great that you are spending time creating these minimal testcases for bugsthat I can work on, keep it up!  You are bound to hit something we've notcreated testcases for yet.In this case it appears there is a special form of ParameterizedTypeBindingknown to the compiler.  It is a PTB whose arguments (type parameters) are null -this doesn't mean it is a raw type as raw type is a subtype ofParameterizedTypeBinding.  From a quick look round the JDT compiler, it *looks*like a PTB with null arguments represents an inner type of a parameterized typethat itself specifies no type parameters.  Presumably it 'inherits' any from theenclosing type.So, the fix is to allow for null type parameters - and ensure we don'tmisintepret the null as a raw type ref. Fix checked in, waiting on build. Dev build available from the download page: aspectj-DEVELOPMENT-20050620091600.jar "	2005-06-15 12:24:09	1118850000.0	resolved fixed	7d5002a	1118910000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java weaver/src/org/aspectj/weaver/TypeX.java
99168	[generics][itds] ITD on generic inner class crashes ajc	inter-type declaration on a generic inner class crashes the compiler:class Outer {  class Inner {}  class Generic_Inner<T> {}}class Generic_Outer<T> {}aspect Injector {  int Outer.outer; // works  int Outer.Inner.inner; // works  int Generic_Outer.outer; // works  int Outer.Generic_Inner.inner; // crashes}/home/user/sgelin3/dev/java/ajc/new_bug/Bug.java [error] Internal compiler errorjava.lang.RuntimeException: can't handle: class Generic_Inner#RAW        extends NULL TYPENULL SUPERINTERFACES        enclosing type : OuterNULL FIELDSNULL METHODS        atorg.aspectj.ajdt.internal.compiler.lookup.InterTypeScope.makeSourceTypeBinding(InterTypeScope.java:35)        atorg.aspectj.ajdt.internal.compiler.lookup.InterTypeScope.<init>(InterTypeScope.java:28)        atorg.aspectj.ajdt.internal.compiler.ast.InterTypeDeclaration.resolve(InterTypeDeclaration.java:101)        atorg.aspectj.ajdt.internal.compiler.ast.InterTypeFieldDeclaration.resolve(InterTypeFieldDeclaration.java:141)        atorg.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1076)        atorg.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.resolve(AspectDeclaration.java:110)        atorg.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1125)... fix for M3. Bug occurs because InterTypeScope.makeSourceTypeBinding() doesn't acknowledgethat it may be passed a ParameterizedTypeBinding or a RawTypeBinding (the latteris a subclass of the former).  Neither of these are SourceTypeBindings *however*both of them contain a field called 'type' that refers to the generic type whichthey are based upon.  The fix is to recognize the PTB hierarchy and if it isbeing used return the type field.  Bit more testing, then I'll check in the fix. Fix checked in, waiting on build before closing. Fix available, see aspectj download page: aspectj-DEVELOPMENT-20050614164300.jar 	2005-06-09 11:21:17	1118330000.0	resolved fixed	588023e	1118760000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeScope.java
84260	import static fails when importing a method	"I got the following error:==============================================MyClass2.java:3 [error] The import MyClass.myMethod cannot be resolvedimport static MyClass.myMethod;==============================================other import static statements (Strings/Enums) appear to work. This bug has ""Product"" set to AspectJ; however, the same occurs without AspectJ in 3.1M4. This is a duplicate of bug 81706. this should be fixed when we pick up the latest JDT compiler in aj5m3... Fixed in CVS, I have added testcases under this bug number for static imports. Fix available, see aspectj download page: aspectj-DEVELOPMENT-20050614164300.jar "	2005-02-02 14:23:31	1107370000.0	resolved fixed	f747b82	1118230000.0	tests/bugs150/pr84260/A.java tests/bugs150/pr84260/I1.java tests/bugs150/pr84260/I2.java tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java
98646	parser cannot parse varargs correctly	"the following cannot be parsed:call(* *(int, Integer...))see in modules/weaver/.../PointcutVisitorTest (uncomment the testTemp())See ""FIXME AV for Adrian"" comments in PatternParser. Half fix but then fails forother tests.Adrian can you have a look at it ?Thanks Fix checked in (and Alex's test uncommented).  Tokenizer for the pattern parsernow spits out tokens for ""..."". fix in next dev build. close with M3 was M3 remind was M3 remind "	2005-06-07 05:55:18	1118140000.0	resolved fixed	743566f	1118150000.0	weaver/src/org/aspectj/weaver/patterns/BasicTokenSource.java weaver/src/org/aspectj/weaver/patterns/PatternParser.java weaver/testsrc/org/aspectj/weaver/patterns/VisitorTestCase.java
94167	NPE in reflect implementation	"Proposed fix (I'd like input on how to best add test cases for this so I can submit a tested patch); I believe this will work because if you uncomment the work-around line, it works):Change line 63 from:				method = declaringType.getDeclaredMethod(getName(),getParameterTypes());to				method = getDeclaringType().getDeclaredMethod(getName(),getParameterTypes());Test source:package reflect;import org.aspectj.lang.*;import org.aspectj.lang.reflect.*;import java.lang.reflect.*;aspect Test {    before() : call(* *(..)) && !within(Test) {       MethodSignature sig = (MethodSignature)thisJoinPoint.getSignature();       //sig.getDeclaringType(); // uncomment to work-around       Method method = sig.getMethod();   }}public class MinimalErr {    public static void main(String args[]) {	try {	    Inner.foo();	} catch (Throwable t) {	    t.printStackTrace();	}    }    public static class Inner {	public static void foo() {}    }} Fix integrated.  Test put in as follows:Test program put into tests/bugs150/PR94167.javaAdded test spec to XML file: tests/src/org/aspectj/systemtest/ajc150/ajc150.xmlJUnit test added to: tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.javaThanks for the simple testcase Ron :)waiting on dev build before closing. Fix available, see aspectj download page: aspectj-DEVELOPMENT-20050614164300.jar "	2005-05-09 13:37:42	1115660000.0	resolved fixed	3824b1c	1118150000.0	runtime/src/org/aspectj/runtime/reflect/AdviceSignatureImpl.java runtime/src/org/aspectj/runtime/reflect/MethodSignatureImpl.java tests/bugs150/PR94167.java tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java
81846	EclipseAdapterUtils.java:83	"it IS connected to the warnings: it tires to issue a warning at an empty line, and while trimming the empty line goes out of the array...i've modified the code like this around the lines where the exception happens:        while ((((c = extract[trimLeftIndex++]) == TAB) || (c == SPACE)) && trimLeftIndex < extract.length) {        };                if (trimLeftIndex >= extract.length)            return new String(extract) + ""\n""; //$NON-NLS-2$ //$NON-NLS-1$unfortunately the warnings are still bugous. i've rearranged the build process to put the jar containing UserMessageCollectorMixin into the aspectpath, but i still get the warnings...  Created attachment 16825UserMessageCollector.java Created attachment 16826UserMessageCollectorMixin.java You could turn off the xlint warnings until I fix the bug, simplest way is:ajc -Xlint:ignore <.....>(that might be xlint=""ignore"" in an ant build.xml).===Those warnings are telling you that ajc couldn't resolve a member, you *may ormay not* be interested in the warning depending on whether the advice you havewritten was intended to capture references to those members.  From some write upI put into bug 59596:===An unresolvable member is a member (method declaration) we have found in some inheritance hierarchy (its on some interface somewhere) that has no implementation within that hierarchy, apparently due to the use of abstract classes that provide no implementation for it.Without the concrete implementation it can't be successfully 'resolved' and so we can't match on it.====I've seen more unresolvablemember issues recently as we have moved to partiallysupporting 1.5.  For example if some piece of code uses an API that only existson 1.5 (maybe Integer.valueOf(int) which was added in 1.5 for autoboxing) andthen AspectJ is asked to weave it, you are likely to get unresolvableMembererrors for calls to those members - I'm not saying this is what is happeninghere but it is one cause of unresolvablemember problems.  Are you relying onautoboxing in your app?The possible solution is to put the rt.jar from a 1.5 JVM on your classpathahead of everything else (effectively running the AspectJ compiler on a 1.5 VM -I can't vouch that this will work as we haven't done much testing of it yet).It may also help to ensure you have 'debug=""yes""' on the javac call to compileyour source code as the default is no and it looks like we are blowing up whilstaccessing some source context to put out a sensible message.However, obviously there is something to fix, so I'll do that soon as I can. thanks for the quick answer, Andy!since then i've compiled an 1.2.1 with my patch in it which avoids a crash, so don't worry about this more then appropiate.an idea: errors in nonessential parts of the system (like messaging the user) should only generate a warning and go on with the execution.about the warning: i don't use 1.5 vm. this warning was lingering around for a long time now, pre 1.5. please note that i use the aspect in question in other projects in similar setups, but the warnings appear only in this project.also note that the aspect is privileged, so it should be woven before the others. well, i have other privileged aspects... so it would be helpful if the warning message contained what aspect is being woven while the method is not found, so i could take a look at declare precedence stuff.thanks, and marry christmas! :) I meant declare precedence, not privileged. Bah, too much work... oops, this patch should have been integrated long ago. scheduling for aj5m3... I'm hit by this bug again as we are moving to java 1.5. Could you please add at least the check not to access the array out of bounds? I've tried xlint=""ignore"" but id didn't help...I know I could compile a locally patched version, but I've already driven mad my collegues with having custom versions of all kind of OSS stuff... :) I've just integrated your patch - it will appear in a dev build shortly.  sorryfor the long delay!!Out of interest, with your patch in place, what kind of strange messages do yousee for these empty lines?  Is there any way you can paste a sample of them intohere? Patch integrated.See latest dev build from http://eclipse.org/aspectj/downloads.php java.lang.ArrayIndexOutOfBoundsException: 3Unfortunately I can't provide much more information, please see the attached compiler dump. Created attachment 16822Compiler dump Created attachment 168231.5.0 M1 dump without recompiling dependant projects Created attachment 168241.5.0 M1 dump after recompiling dependant projects with 1.5.0 M1 btw, the warnings in the first dump like this one:[warning] can not resolve this member: void com.netvisor.ttm.ui.HpsdCSVTask.addUserMessage(java.lang.String, int) [Xlint:unresolvableMember]are false warnings as far as i can understand what's going on. UserMessageCollectorMixin is defined in a jar file which is on the classpath, not aspectpath. therefore i have an aspect in the project like this:public abstract aspect UserMessageCollectorMixin extends com.netvisor.common.UserMessageCollectorMixin{	declare parents: (CSVTaskBase) implements UserMessageCollector;	declare precedence: UserMessageCollectorMixin;}that ""brings in"" the aspect into the waeving. i had these warnings for a long time, so i doubt it's closely related. "	2004-12-23 07:27:36	1103800000.0	resolved fixed	a675b65	1117640000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseAdapterUtils.java
96371	Patch to support loading aop.xml properly	"AspectJ 5 load-time weaving in CVS HEAD isn't loading aop.xml files properly from a jar file without specifying the global -D flag. The following patch fixes the problem for me so I can load aop.xml files from jars on the classpath without a global flag:ClassLoaderWeavingAdaptor.java:109:-             Enumeration xmls = loader.getResources(""/META-INF/aop.xml"");+            Enumeration xmls = loader.getResources(""META-INF/aop.xml"");I.e., getResources doesn't work with a leading separator, at least not on the Sun VM or JRockIt on Windows. Writing a unit test for this would require significant changes to the loadtime module, so I wrote a standalone test of the API:public class TestApi extends TestCase {    public void testLoadResource() throws Exception {        URL urlList[] = { new URL(""file:testsrc/org/aspectj/weaver/loadtime/test/sample.jar"") };        ClassLoader loader = new URLClassLoader(urlList);	                  Enumeration xmls = loader.getResources(""META-INF/aop.xml"");        //this version fails:        //Enumeration xmls = loader.getResources(""/META-INF/aop.xml"");        assertTrue(xmls.hasMoreElements());    }} Created attachment 21605Sample jar to use with sample unit test case Thanks Ron :)I've assigned to Alex since I'm going to be out of contact for the next few daysand Andy is at a conference in Vegas... done "	2005-05-23 17:22:52	1116880000.0	resolved fixed	f14646f	1117450000.0	loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java loadtime5/java5-src/org/aspectj/weaver/loadtime/ClassPreProcessorAgentAdapter.java tests/java5/ataspectj/ataspectj/SingletonAspectBindingsTest.java
94086	Exploding compile time with if() statements in pointcut	"Compile time explodes when adding if(...) statements to pointcuts.This is the same with ajc 1.2.1 and 1.5M2 although 1.5M2 is a little bit faster,but compile time still explodes.Example:    pointcut pc2() :        (execution(* Test.a(..)) && if(sl.isEnabled()) )        || (execution(* Test.a(..)) && if(sl.isEnabled()) )compiled in about 1 second.Up to 7 such conditions , eg.    pointcut Pc7() :        (execution(* Test.a(..)) && if (sl.isEnabled()))        || (execution(* Test.b(..)) && if (sl.isEnabled()))        || (execution(* Test.c(..)) && if (sl.isEnabled()))        || (execution(* Test.d(..)) && if (sl.isEnabled()))        || (execution(* Test.e(..)) && if (sl.isEnabled()))        || (execution(* Test.f(..)) && if (sl.isEnabled()))        || (execution(* Test.g(..)) && if (sl.isEnabled()));are also compiled quite quickly (~ 3 seconds with both ajc 1.2.1 and 1.5M2).Now, adding another condition (8 lines) causes 6 seconds compile time. Addingyet another condition line (= 9 ex. lines) causes ~ 1 min compile time!(10 such lines even more than 8 minutes)Sample source code below------------------------// ########## Aspect.aj ###############public aspect Aspect {    private static final SimpleLogger sl        = new SimpleLogger();    pointcut PC() :        (execution(* Test.a(..)) && if (sl.isEnabled()))        || (execution(* Test.b(..)) && if (sl.isEnabled()))        || (execution(* Test.c(..)) && if (sl.isEnabled()))        || (execution(* Test.d(..)) && if (sl.isEnabled()))        || (execution(* Test.e(..)) && if (sl.isEnabled()))        || (execution(* Test.f(..)) && if (sl.isEnabled()))        || (execution(* Test.g(..)) && if (sl.isEnabled()))        || (execution(* Test.h(..)) && if (sl.isEnabled()))        || (execution(* Test.i(..)) && if (sl.isEnabled()))        || (execution(* Test.j(..)) && if (sl.isEnabled()))        ;    before() : PC() {        sl.log(""Before"");    }    after() : PC() {        sl.log(""After"");    }}// ########## Test.java ############### // ########## Test.java ###############public class Test {        public void a() {}        public void b() {}        public void c() {}        public void d() {}        public void e() {}        public void f() {}        public void g() {}        public void h() {}        public void i() {}        public void j() {}        public void k() {}        public void l() {}        public void m() {}        public void n() {}        public void o() {}        public void p() {}}// ########## SimpleLogger.java ###############public class SimpleLogger {    private boolean enabled;    public SimpleLogger() {        enabled = false;    }    public void disable() {        enabled = false;    }    public void enable() {        enabled = true;    }    public boolean isEnabled() {        return enabled;    }    public void log(String str) {        if (enabled) {            System.out.println(""> Log: "" + str);        }    }} On my machine:Num. ifs	Compile time (seconds)1 		32 		33 		34 		35 		36 		37 		38 		59 		2510 		285 More interesting stuff:Num. ifs	Times IfPointcut.findResidueInternal is called1 		22 		203 		1444 		10405 		81506 		70452 Right, Andrew Clement and I have made a patch to fix this.It makes it run consistently in good speed.With the new patch:Num. ifs	Times IfPointcut.findResidueInternal is called1 		12 		43 		94 		16N		N^2 fix checked in, waiting on build. This bug should have been closed out in May! Has been fixed in tree for severalmonths... "	2005-05-09 04:45:22	1115630000.0	resolved fixed	88d477d	1116240000.0	tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java weaver/src/org/aspectj/weaver/patterns/IfPointcut.java
84312	Finish implementation of *runtime* retention checking	See FIXME in BindingAnnotationTypePattern.resolveBinding() andEclipseSourceType.getAnnotationTypes() aj5m2?? I've made a patch which I think fixes this - and sent it to Andy all fixed - should have closed sooner ;) 	2005-02-03 05:47:10	1107430000.0	resolved fixed	f9eebd4	1115900000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java weaver/src/org/aspectj/weaver/patterns/BindingAnnotationTypePattern.java
86832	Internal compiler error (generics?)	"Attached is project that will generate an ""Internal compiler error"" for a singleclass that extends ""ArrayList<Object>"". If the class extends just ""ArrayList""the compiler error does not occur. Note that the ""extends ArrayList<Object>"" class compiles successuflly withoutthe aspectj nature.--- exception ---Severity	Description	Resource	In Folder	Location	Creation Time2	Internal compiler errorjava.lang.NullPointerException	atorg.aspectj.org.eclipse.jdt.internal.compiler.lookup.ClassScope.detectHierarchyCycle(ClassScope.java:945)	atorg.aspectj.org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.internalResolveType(ParameterizedSingleTypeReference.java:143)	atorg.aspectj.org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.resolveType(ParameterizedSingleTypeReference.java:208)	atorg.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveSuperType(TypeReference.java:112)	atorg.aspectj.org.eclipse.jdt.internal.compiler.lookup.ClassScope.findSupertype(ClassScope.java:1092)	atorg.aspectj.org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectSuperclass(ClassScope.java:747)	atorg.aspectj.org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectTypeHierarchy(ClassScope.java:884)	atorg.aspectj.org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.connectTypeHierarchy(CompilationUnitScope.java:249)	atorg.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:91)	atorg.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:331)	atorg.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:348)	atorg.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:682)	atorg.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:168)	atorg.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:102)	at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122)	atorg.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:165)	FlattenedListExtendsArrayListObject.javaopentrader.infra/src/org/opentrader/infra/springframework		February 28, 20059:59:42 AM Created attachment 18364eclipse project(requires eclipse 3.1M5a and ajdt dev build 1.2.0.20050225125806) should be fixed when we pick up the latest JDT compiler as part of aj5m3... I've fixed this - it is do to with our modification to make BinaryTypeBinding asubclass of SourceTypeBinding.  will close this when build is available with fix in. Fix available for download in latest dev build. I can confirm that this fix works. Thanks! "	2005-02-28 09:59:49	1109600000.0	resolved fixed	0cb826c	1115890000.0	tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java
82755	[ajdoc] update ajdoc to support Java 5 language features	"Java 5 langauge features such as enums and annotations need to be supported by ajdoc. for aj5m3... Found this:in javadoc (java full version ""1.5.0_02-b09"") and hence in ajdocif you javadoc an annotation definition so:/** *  A javadoc comment on @interface anInterface {} */@interface anInterface {}a page is generated for ""anInterface"", but the javadoc comment is not included! looks like if you put an annotation on a class it doesn't show that the class isannotated in javadoc either... think we'll have to wait till (if) javadoc showswhat things are annotated before we can make ajdoc do that Andrew: comment #2 is a result of the current ajdoc not understanding annotations and should be a straightforward fix.  Comment #3 I'll have to take a closer look at and should know something later this week. Created attachment 20644tar.b2 of two patch files to make ajdoc work with enums Excellent!  I'm impressed that you're making progress on ajdoc since the code for it is such a mess (it evolved from a toy program written in a functional style).  This is to say that if you ever want to restructure any of it feel free to do so.Could I ask you to attach this and future patches in Eclipse's standard plain text patch format?  This makes them easier to apply.  Note that if you create a patch from a project or source folder it automatically include patch information for each changed file, so that it can be simply applied to the project and update every file without having to first figure out which files to apply it to.  Once you do that I'll look over this and apply it. Created attachment 20671enums patch Patches look great Andrew.  I've committed them. guess its fixed in the latest dev build as Mik has integrated the patches... :) "	2005-01-13 10:49:15	1105630000.0	resolved fixed	7b7c7b2	1115880000.0	ajdoc/src/org/aspectj/tools/ajdoc/Declaration.java ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java
93345	unresolved joinpoint in cflow causes ClassCastException on BcelWeaver:933	"I'm getting ClassCastException while compiling following code:---- Test.java ----class AClass {//      void method() {}}aspect AnAspect {        pointcut annt() : cflow( execution(* *(..)) );        before() : annt() {                System.out.println(""before annt"");        }}----Here's output of the compiler:--- out ---java.lang.ClassCastException: org.aspectj.weaver.ResolvedMember        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:933)        atorg.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:244)        atorg.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:119)        atorg.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:385)  [cut]------The problem is caused by cflow on unresolved (not existing) jointpoint.When you uncomment the method() in AnClass, the problem disappears.I found this bug when I was introducing an aspect (which haspointcuts based on annotations) to fresh object-oriented systemwithout annotated classes. When I started to annotate the classesproblem disappeared. Following code illustates (simplified) situation:--- Test2.java ---import java.lang.annotation.*;@Target(ElementType.METHOD)@interface Ann {}class AClass {        // @Ann        void method() {}}aspect AnAspect {        pointcut annt() : cflow( execution(@Ann * *(..)) );        before() : annt() {                System.out.println(""before annt"");        }}----I'm attaching those sources and ajcore files.Best regards, Michal Created attachment 20548cflowbug.zip typo: joint -> join :) Andrew, can you look at recreating? Recreated this and made a fix for it...I've sent my patch to Andy Clement who'll hopefully put it in the cvs head sometime. Build available containing fix, see AspectJ downloads page and grab the dev build:http://eclipse.org/aspectj/downloads.phpNotice (as I just said in another bug), you need to mark annotations thatAspectJ will be matching on as having runtime retention with:@Retention(RetentionPolicy.RUNTIME)its a known bug that we are missing an error message for it. I was telling a lie there - and in the other bug I commented on.  Of course youonly need runtime retention if you are binding the annotation value - if you arejust *matching* then the default retention of CLASS is fine.  Stupid me. No... let me change my mind one more time...Because some of the kinds of matching, for example:call(* *(..)) && @args(MyAnnotation)can lead to a runtime test for whether the advised call has the annotation, youmust specify that MyAnnotation has runtime retention.In the binding case:before(MyAnnotation ma): call(* *(..)) && @args(ma) {}you obviously need runtime retention too.The only time we could let you get away with it (i.e. the default of CLASSretention) is:call(* *(@MyAnnotation ma))since that is matched purely based on static information available at compiletime and can't lead to a runtime test being put into the code.hope that gets things straight now... (In reply to comment #7)> No... let me change my mind one more time...:)I understand, now.In fact, I have RUNTIME policy in the original sources,but I've removed it in the test case for simplicity. Thanks! "	2005-04-30 08:49:47	1114870000.0	resolved fixed	f603458	1115640000.0	tests/src/org/aspectj/systemtest/ajc150/AllTestsAspectJ150.java tests/src/org/aspectj/systemtest/ajc150/StaticImports.java tests/src/org/aspectj/systemtest/ajc150/SuppressedWarnings.java weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java
87282	Compilation error on generic member introduction	"The compiler aborts with the following introduction code:aspect introductionToA{   private ArrayList<B> A.m_Array = new ArrayList<B>();    public void A.addB(B tmp){    m_Array.add(tmp);  }}The error message is ""[error] The method add(E) in the type ArrayList<E> is notapplicable for the arguments (B) m_Array.add(tmp)""Compiling with AspectJ Development version (2005/02/18). known limitation in aj5m2, will be fixed in aj5m3... Fixed under bug 91053 - this is the same problem to do with losing parameterizedtype information.Testcase checked in.  Closing when build available. Fix available, see AJ downloads page:http://eclipse.org/aspectj/downloads.php "	2005-03-07 11:27:29	1110210000.0	resolved fixed	51c018d	1115390000.0	tests/src/org/aspectj/systemtest/ajc150/GenericsTests.java
91053	Generics problem with Set - does not compile with AspectJ 5	"I tried different things to remove compiler warnings about generics which youget when you switch to JDK 5 and use collections. At last I fall back to JDK1.4. The following code compiles with AspectJ 5 and JDK compliance level 1.4:public aspect SubjectAspect {        private Set Subject.observers = new HashSet();    public void Subject.addObserver(SubjectObserver observer) {        observers.add(observer);    }    ...}After switching to compliance level 5.0 I get an error message""The method add(E) in the type Set<E> is not applicable for the arguments(SubjectObserver)"".I don't know if it is a similar problem like #87550 but I means for olderprojects which use collections that they can't switch to JDK 1.5 Created attachment 19782the problematic source codesources where the error occurs (about 180 LOC including comments)as compressed tar file (2 KB) I've fixed this - a smaller program that shows the problem is:import java.util.*;aspect X {    private Set PR91053.aSet = new HashSet();    public void PR91053.add(String s) {        aSet.add(s);    }}public class PR91053 {   public static void main(String[]argv) {    new PR91053().add(""hello"");  }}The problem is that when the intertype field declaration is captured we lose thefact that the Set is a raw type binding (i.e. a parameterized type where nobounds have been specified for any of the parameters) - and when we recover thebinding later we create an ordinary type binding for it.Losing that information means later on when resolving the receiver of theMessageSend (Set.add) we end up in BinaryTypeBinding.getExactMethod() ratherthan ParameterizedTypeBinding.getExactMethod().  The former of these doesn'tlook at whether methods are parameterized and so thinks add(E) doesn't matchadd(SubjectObserver).The fix is to preserve that it is a raw type binding.  I have done this bysaying if the typex is parameterized but has no typeparameters then it isconsidered raw.  That seems good enough for now but may break with some case Ihaven't come across yet...fix checked in, waiting on build... Fix available in latest AspectJ Dev build, see AJ downloads page:http://eclipse.org/aspectj/downloads.php "	2005-04-11 17:15:13	1113250000.0	resolved fixed	952dda9	1115390000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java tests/src/org/aspectj/systemtest/ajc150/GenericsTests.java weaver/src/org/aspectj/weaver/TypeX.java weaver/src/org/aspectj/weaver/World.java
91267	NPE at EclipseFactory.java:143 when using generic methods in aspects	"When I compile any of these two aspects with ajc -1.5, an exception is thrown bythe compiler:import java.util.*;public aspect TestBug1 {    static <T> void addToEnv(Map<String,T> env, String key, T value) {	env.put(key, value);    }}import java.util.*;public aspect TestBug2 {    static <T> T lookupEnv(Map<String,T> env, String key) {	return env.get(key);    }}If the methods are placed into classes instead of aspects, all works fine.The exception thrown is the following:java.lang.NullPointerException        atorg.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.getName(EclipseFactory.java:143)        atorg.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBinding(EclipseFactory.java:166)        atorg.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBindings(EclipseFactory.java:176)        atorg.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeResolvedMember(EclipseFactory.java:254)        atorg.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeResolvedMember(EclipseFactory.java:249)        atorg.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.fillDeclaredMembers(EclipseSourceType.java:115)        atorg.aspectj.ajdt.internal.compiler.lookup.EclipseSourceType.getDeclaredPointcuts(EclipseSourceType.java:146)        atorg.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTypeAndPerClause(AspectDeclaration.java:977)        atorg.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildInterTypeAndPerClause(AjLookupEnvironment.java:303)        atorg.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:119)        atorg.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:331)        atorg.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:348)        atorg.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:683)        atorg.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:168)        atorg.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:102)        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:109)        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)        at org.aspectj.tools.ajc.Main.run(Main.java:291)        at org.aspectj.tools.ajc.Main.runMain(Main.java:227)        at org.aspectj.tools.ajc.Main.main(Main.java:80) Full generics support is targetted for M3, so I've set the target for fixingthis appropriately.  thanks for the bug report! Fixed in CVS - will be in next dev build.Problem is us not processing eclipse 'TypeVariableBinding' objects correctly -I've enhanced our support to fix this case but it is not complete, in going froma TVB to a TypeX we are losing information about it being a type variable that Ithink we'll need later.  When I hit a bug that requires it, I'll fully upgradeTypeX. Fix available, see AJ downloads page:http://eclipse.org/aspectj/downloads.php "	2005-04-13 09:29:09	1113400000.0	resolved fixed	7389d9f	1115370000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java tests/src/org/aspectj/systemtest/ajc150/GenericsTests.java weaver/src/org/aspectj/weaver/TypeX.java
91719	Work with Oli B to pull in examples of generating all the LINT messages	"Oli on the dev list has written code examples that generate each type of lintwarning, work with him to pull them into the codebase.  The relevant email isbelow.  Make sure they go via a bugzilla attachment to ensure EPL rules are met.====Hi Andrew,for ""unresolvableMember"" I gave up to find an example. But for the other Xlint warnings you can find my example under		 http://www.javatux.de/aj/as compress tarfile (xlint.tgz) or as directory (for online browsing).BTW - I read the announcement from Adrian. There are new Xlint warnings? Which ones?Happy EasternOliverAndrew Clement wrote:> > Hi Oli,> > If you can come up with examples that produce all of them, I'd be keen to> include them as testcases in AspectJ where appropriate as I know we don't> properly test some of them.  A good place to start would be searching> in the bugzilla database - I'm not sure how accurately that is indexed> by google.  Here's a bit of info I've quickly dug up:> > > * invalidWildcardTypeName> Never signalled anywhere in the codebase! (so ignore this one...)> > > * unresolvableMember,> This one is hard to reproduce, see bug 59596 where I've done a bit> of write up about it.> > > * typeNotExposedToWeaver> Should be recreatable by trying to weave into something that is> actually on the classpath rather than the inpath.> > > * shadowNotInStructure> Signalled if the structure model is broken, probably can't happen> right now as we work hard to ensure it is always correct.> > > * unmatchedSuperTypeInCall> These two covariance problems demonstrate this xlint.  it is related> to specifying the declaring type in a call() type pattern and it> not matching as you expected...> > CovBaseProgram01.java >>>>>> > class Car {}> > class FastCar extends Car {}> > class Super {>   Car getCar() {>     return new Car();>   }> }> > class Sub extends Super {>   FastCar getCar() {>     return new FastCar();>   }> }> > public class CovBaseProgram01 {>   public static void main(String[] argv) {>     new CovBaseProgram01().run();>   }> >   public void run() {>     Super instance_super = new Super();>     Sub   instance_sub   = new Sub();> >     Car c1 = instance_super.getCar();>     Car c2 = instance_sub.getCar();>   }> }> > // FastCar is a subclass of Car.> // Sub is a subclass of Super.> ==============> CovAspect06.aj >>>> > aspect CovAspect06 {>        >   pointcut p(): call(Car Sub.getCar());>  >   @org.aspectj.lang.annotation.SuppressAjWarnings>   before(): p() {>           System.out.println(""[call(Car Sub.getCar()) matched on > '""+thisJoinPoint+"":""+thisJoinPoint.getSourceLocation()+""']"");>   }>  > }> ================> ajc -1.5 CovAspect06.aj CovBaseProgram01.ja> > > * noInterfaceCtorJoinpoint> related to trying to put advice on constructor execution join point for > an interface I think...> > > hope some of that is useful...> > Andy.> > > > *""Oli B."" <boehm@javatux.de>*> Sent by: aspectj-dev-admin@eclipse.org Created attachment 20206tar file with requested sourcestest sources to proof Xlint warnings Integrated into CVS - thanks Oliver! "	2005-04-18 05:21:33	1113820000.0	resolved fixed	70b9ffd	1115220000.0	tests/bugs/seven/lint/Main.java tests/src/org/aspectj/systemtest/xlint/XLintTests.java
92906	showWeaveInfo for declare annotations	declaring annotations (declare @type, @constructor, @method and @field)currently doesn't show a message when the -showWeaveInfo option is set in ajc.Appropriate messages should be displayed. I have a patch from Andrew, will put this in for 1.5.0M3 Created attachment 20630Patches to make showweaveinfo workThis includes the patch to make -showWeaveInfo work for declare @type, field,method, ctor.  But I don't think it copes with null source locations (see thebeautifyLocation() method in the Shadow class) - which can occur when no debuginfo exists for the types being woven. Patch integrated.  I tidied up the code so there wasn't the possibility ofmultiple NPEs occurring per line.  I modified it to cope with duff sourcelocation (i.e. when no debug information is present) and I changed the weavingmessage so that it reports what annotation is being attached to each member/type.Fix will be in next dev build. Fix available, see AspectJ download page:aspectj-DEVELOPMENT-20050506112715.jar 	2005-04-27 09:55:33	1114610000.0	resolved fixed	abc9a58	1115200000.0	ajde/testsrc/org/aspectj/ajde/ShowWeaveMessagesTestCase.java bridge/src/org/aspectj/bridge/WeaveMessage.java weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java weaver/src/org/aspectj/weaver/bcel/Utility.java
92630	Null Pointer Exception thrown by ajc compiler	"<Pyinson Data Over Head> The failure occurs on a line that is processing a list of files, the list isnull.  The list was created by a call to File.listFiles() for a particulardirectory and the code is trying to find <blah>$Ajc<blah> class files thatshould be deleted.  The caller allows for the this method to fail with anIOException - I suspect the difference is in the implementation of listFiles onthe MAC.  The spec for listFiles says it returns:""An array of abstract pathnames denoting the files and directories in thedirectory denoted by this abstract pathname. The array will be empty if thedirectory is empty. Returns null if this abstract pathname does not denote adirectory, or if an I/O error occurs.""It could be that what windows considers an IO error is just returned as a Nullon the MAC.  Due to the caller of the method not minding if it fails I proposeto just guard on null and return from the deleteRealFile() method.The fix will be in an imminent dev build.  I'm hoping the other message in this bug report:""The type EspressoTrace is already defined""is just a symptom of us failing with an NPE.  I suppose a possible workaroundwould be to construct the output directory for the ant task (make sure itexists) before running the task - does that make any difference?  Was it alreadydefined? <Pyinson Data Over Head> <Pyinson Data Over Head> Hi,When i removed the following lines from the Ajx task, the Null Pointer Exception disappeared.<src path=""${src.dir}""/>                    <src path=""${sharedsrc.dir}""/>                    <src path=""${gensrc.dir}""Still, i'm not sure why should it be a NPE?Thanks,Manjula It is interesting that you are using 'src path' as we don't document that it issupported in the AspectJ manuals (however, it does work..).  <iajc destdir=""${build.dir}/classes"" fork=""true""   forkclasspath=""${aspectjtools.jar}""   argfiles=""${list}"">  <src path=""${src.dir}""/>  <src path=""${sharedsrc.dir}""/>  <src path=""${gensrc.dir}""/>  <classpath>    <path refid=""classpath""/>    <path refid=""aspectj.lib""/>  </classpath></iajc>You also seem to be mixing your methods of referring to what you want compiled -you specify a list of files for building from an argfile and then supply threesource paths that will contain files - which want do you want the compiler to use?  I have just recreated a scenario like yours with multiple input src folders andI get the errors I'd expect - if I use a .lst and specify <src path> entries aswell then AspectJ tells me it is seeing duplicates (since the files are beingfound as referenced twice - once in the .lst and once through the <src path>entries).I don't see an NPE and I still believe that is due to what I mentioned incomment #1 where the MAC is interpreting an error differently to Windows.  Thebug is fixed but I am still having problems creating a development buildcontaining the fix. Fix available, see AspectJ download page:aspectj-DEVELOPMENT-20050506112715.jar This was fixed in May as per last comment on this  bug, but we forgot to closeout the report. Tidying that up now... "	2005-04-25 15:26:05	1114460000.0	resolved fixed	02f75ba	1114530000.0	weaver/src/org/aspectj/weaver/bcel/UnwovenClassFile.java
91912	Request for a new type of relationship in the structure model	Declare soft relationships are currently 'advises' and 'advised by' relationships.  Would it be possible to add 'softens' and 'softened by' (or 'softens exception at' and 'exception softened by') relationships to the structure model? Good idea.  Done and committed.  Note that there is now a new IRelationship.Kind.DECLARE_SOFT.  I wasn't sure whether it was better to have this be consistent with the other declares (i.e. declared on / declared by) or to be more explicit (i.e. softens / softened by).  So I went with your choice since the former didn't sound quite right.  But I think that in general it's a good idea to minimize the number of relationships. 	2005-04-19 11:32:29	1113920000.0	resolved fixed	7a61380	1114100000.0	asm/src/org/aspectj/asm/IRelationship.java weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java
92053	@args causes a VerifyError: Unable to pop operand off an empty stack	"I'm getting a VerifyError exception when I try to use @argsin following code:------------------ Test3.java -------------------------import java.lang.annotation.*;@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@interface Ann {}@Annclass AClass{}public class Test3 {        void abc(AClass y) {}        public static void main(String[] args) {                new Test3().abc(new AClass());        }}aspect Annotations {        before(Ann ann) : call(* Test3.*(..)) && @args(ann) {                System.out.println(""Before: "" + thisJoinPoint);        }}----On JRockIt5 jre and AspectJ 1.5.0M2 I get following result:-----------java.lang.VerifyError: (class: Test3, method: main signature:([Ljava/lang/String;)V) Unable to pop operand off an empty stack-----------I'm getting similar error with sun jre and with older versionsof AspectJ5 (20050324155000 and from 10th feb). Created attachment 20114Test3.java I'm currently looking into this one ... Fixed - the bug is due to an 'optimization' in ArgsAnnotationPointcut.  Normallyall annotation binding consists of two generated bits of code:1. a 'hasAnnotation()' call to check if the element has the annotation2. a 'getAnnotation()' call to retrieve the annotation of the elementObviously there are some cases where we can statically determine that an elementwill always have the annotation at runtime, so we could skip generating part (1)and just generate the retrieval code.  Unfortunately we were being a bit tooclever and skipped generating both bits of code in this case.  I've fixed it sothat we only skip the test now and always generate the retrieval code.The exception that occurred indicated that when the advice ran the annotationwasn't on the stack to be passed as a parameter...Fix checked in, waiting on build before closing. Fix available, see AspectJ downloads:BUILD COMPLETE -  build.470Date of build: 04/20/2005 16:29:28Time to build: 142 minutes 34 secondsLast changed: 04/20/2005 15:58:14 "	2005-04-20 07:19:59	1114000000.0	resolved fixed	3f942a4	1114010000.0	tests/java5/annotations/binding/bugs/Test3.java tests/src/org/aspectj/systemtest/ajc150/AnnotationBinding.java weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.java
91858	NullPointerException when declare @type is spelt with capital letter	"I have the following code in an AspectJ project:declare @Type: MainClass : @MyAnnotation;I believe the correct syntax should be:declare @type: MainClass : @MyAnnotation;However when I saved my aspect with the first version I got the following NullPointerException:java.lang.NullPointerException	at org.aspectj.ajdt.internal.compiler.ast.DeclareAnnotationDeclaration.postParse(DeclareAnnotationDeclaration.java:83)	at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.ClassScope.postParse(ClassScope.java:175)	at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.ClassScope.buildFieldsAndMethods(ClassScope.java:154)	at org.aspectj.org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.buildFieldsAndMethods(CompilationUnitScope.java:63)	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:104)	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:331)	at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:348)	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:683)	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:191)	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:109)	at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)	at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:165) actually it's not just if you spell it Type, the following code produces the bugfor any XXX other than a recognised one (type):@interface myInterface {}aspect A{  declare @XXX: A : @myInterface;} patch submitted by Andrew Huff (IBM). Bug will be closed when available in apublished build. forgot to close this out, fix was available a good while ago... "	2005-04-19 05:38:48	1113900000.0	resolved fixed	78abc76	1114000000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/DeclareAnnotationDeclaration.java tests/src/org/aspectj/systemtest/ajc150/DeclareAnnotationTests.java weaver/src/org/aspectj/weaver/patterns/PatternParser.java
82171	enable ASM interoperability with JavaCore via uniform element handles	"Proposal pasted from the following email discussion:http://dev.eclipse.org/mhonarc/lists/ajdt-dev/msg00379.htmlWe finally seem to be both have more support for working directly with theJava Model, and more need to do so.  Here's an idea for a light-weightupdate to our architecture that will give us transparent access for workingwith the relationship map using either the IJavaElements orIProgramElements.The idea is that we change the handle identifiers, used for storing entriesin the map, to be the same those used by the JavaModel, i.e.IJavaElement.getHandleIdentifier().  That will allow us to ask forrelationships for IJavaElements, and get back a list of handles that anadapter can turn into IJavaElements.  Currently our identifiers are a source location including path, line, andcolumn number.  The Java model uses the handles that look like thefollowing, ""=Project-l/src<pkg1{Foo.java[Foo~m1"", which uniquely identifymembers, are stable across builds and Eclipse invocations, but don't gobelow the member signature.  So our adapter will have to extend these byappending either line/column or offset information to reach at ""code""elements (e.g. calls, handlers).  That's doable, and these handles shouldjust get ignored by JavaCore as desired.  But I'm wondering what they shouldcorrespond to in our extended Java Model, perhaps a subtype ofSourceRefElement called ICodeElement?  We should get JDT Core to addsomething like that anyway, but they'll probably want to call itIUnknownElement or IGenericRefElement to provide other projects with thesame sort of extensibility.  Another challenge will be generating theproject part of the handle because our compiler doesn't know aboutworkspaces.  I hope that info can be extracted from the full path and sourcepath information.  Then for other IDEs we can simply use the same relativepath convention. I've addressed this by allowing IDE clients to provide their own mechanism for creating ASM handles.  For AJDT to add a new that handles JavaCore style handles do the following:1) Implement org.aspectj.asm.IElementHandleProvider and provide the four methods that map source location information to handles.2) Somewhere in the plugin initialization call:      AsmManager.getDefault().setHandleProvider(..)Doing (1) depends on being able to map source locations to IJavaElement.getHandleIdentifier() strings.  If that turns out to be a pain to do in a way that performs we can consider changing the AspectJElementHierarchy to not realy on line number information and instead do lookups based on member names. It appears from Mik's comment as of April that this request should be closed out in the AspectJ database. Yes, the ASM part of this is now there.  I'm not sure if AJDT is actually usinga custom handle provider though, or whether it is still doing that translation step. "	2005-01-04 14:13:17	1104870000.0	resolved fixed	df7fff4	1113500000.0	asm/src/org/aspectj/asm/AsmManager.java asm/src/org/aspectj/asm/IElementHandleProvider.java asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java asm/src/org/aspectj/asm/internal/FullPathHandleProvider.java asm/src/org/aspectj/asm/internal/ProgramElement.java docs/sandbox/api-clients/org/aspectj/samples/AsmRelationshipMapExtensionTest.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AsmInterTypeRelationshipProvider.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java weaver/src/org/aspectj/weaver/ShadowMunger.java
90588	compiler verifyerror and an NPE	"2nd email:As a workaround, I created a link from the broker.hibernate project to thesource folder of the broker project. This works except for certain code thatextends a class that uses generics which is in a third project. The attached projects will demonstrate a compiler NPE.-barry=============ask Andy Clement for the attachments as stupid bugzilla won't let me attach themright now  ?!?!??! Reassigning to Andrew to confirm existence of the bug and then fix it :) Attachments already sent via email. I've written a tiny (3 line) test that causes the NPE and sent off a patch withthis in... as the NPE is in jdt I think the current plan is to wait till wechange to the newer version of jdt then see if the test I wrote still fails. Andrew, can you attach your test program here?? I think this was it://///////////////////class AbstractClass<T> {}class ConcreteClass extends AbstractClass<Object> {}/////////////////////This breaks AspectJ 1.5M2, but works on head. Ok, I double checked and Andrews test program does work on HEAD - marking thisas fixed :) Reported via the lists by Barry Kaplan (groups1@memelet.com), emails attached:Email1:===================I've distilled it down to a trivial test case. The problem is only when theweaved class comes from another project via the inpath. Attached are twoprojects with a test case. -barryAndrew Clement wrote:> > Hi Barry,> > I've just taken this off list to see if you could possibly privately > send me the code that is failing?  If the full applications dependencies > are minimal (things like hibernate) then I can recreate it here and > debug it directly.c> 		 > Subject> 		 [NEWSDELIVER] Re: Advice on how to debug VerifyError?> > > I've tried every permutation I can think of in a simple test, and cannot > get it to fail.> > I've tried every permutation I can think of in the application, and > cannot get it succeed. I've even take all member variables out of the > weaved class, then all methods. Then I removed the default constructor > introduced that as well. No joy. "	2005-04-07 06:32:11	1112870000.0	resolved fixed	d697649	1113400000.0	tests/bugs150/pr90588/AbstractClass.java tests/bugs150/pr90588/ConcreteClass.java tests/src/org/aspectj/systemtest/knownfailures/KnownfailuresTests.java
85297	Improvements to incremental compilation	"This bug is to track compiler improvements to incremental compilation.There are multiple scenarios to think about but the first focus is changing onesource file for a class/interface that is affected by an Aspect - it shouldcompile/weave almost instantly.  Recently response times have been reported of>3seconds (and worse...) and this is not reasonable.I've put the following improvements in today:- Caching classpath calculations rather than performing them repeatedly.- Improved logic to detect weaver completion.- Removed unnecessary serialization of the structure model.These are available in dev builds right now:  	ajdt_1.2.0.20050215161840I'd be interested in user feedback on whether they see noticeable improvementsin their particular projects.more improvements to follow shortly. Oh. My. God.The sort of good news: an unscientific average of new incremental compile timesis about 1.8 seconds, which represents a 25% time reduction over the previousaverage of 2.5.The REALLY REALLY good news: My full build times have dropped from aroung 80s.to around 40s. I can't emphasize how huge this is for our team. This level ofspeed increase represents a productivity gain of *hours* per week per developer.You guys are awesome! The structure model was getting serialized so that the crosscutting structure would be visible when you opened an IDE or when you switched projects in the IDE.  I guess that the first case is less important, but the second case does seem important.  Won't it be confusing if people switch projects, and all of the sudden it looks like nothing has advice?Or perhaps you've alreayd mad the obvious update that should would mean both a performance improvement, little memory overhead, and no need for serialization:- keep a HashMap from build config to relationship map in memory- when the active build config (i.e. project) changes swap the active map, or instead wjust do a 2-step lookup of the relationshipI'm guessing that the memory requirements of this would be <5 MB on workspaces with tens of thousands of classes, and under a dozen projects but it might be worth checking.  With workspaces that have dozens of projects we could get into a situation where it's better to purge the least recently used relationship maps. I've changed the timers reported to AJDT Event Trace, you don't get meaninglessweaver metrics now, you get:- total time spent in the AJDT build() method- within that, the time spent in AJDE (i.e. compiling and weaving)- number of types affected by what you just did.  (You change an aspect thiswill be a high number, you change a single class, it should be 1)Difference between those first two times is the time spent fiddling with markersand structure model.(I've also changed some String handling to String buffers - tiny optimization)There is still a lot of scope for bringing times down, but I'm going to focusfor the next little while on inter-project dependencies and ensuring when youchange an AspectJ project we don't force an unnecessary build of any Javaproject depending on it. Created attachment 18149Unusual behavior on 2-17 AJDTI checked out the latest build for the above described better metrics.Unfortunately, it performs a full rebuild every time a file is saved (though itclaims its doing an autobuild). It does this even with non-Java, non-AJ files.The most amusing consequence is gutter annotations for my Tapestry files :) Nicholas, that's very weird! There is a newer build which is worth trying, assoon as I can get it uploaded - the eclipse infrastructure changed over theweekend, and we have to change the way we upload, which wasn't working. I'llappend here when it's available - should be tomorrow. I have just put a new change in CVS that may affect people building in batchmode (i.e. outside of the IBM) - it will be in the next dev build.  I'd beinterested in whether Nick notices any difference at all.  there was a rogue bitof structure model still being generated even from the command line when-emacssym was not specified, I've hopefully now stopped this happening.  Mightreduce memory consumption a bit too. batching up a whole set of incremental things under aj5m4... I've been poking the 2005-03-25 build, and it seems to have discarded theincremental mode completely. In other words, it weaves every type in the systemrather than ever doing a true incremental build, despite CLAIMING that it'sdoing an incremental. Here's an example trace resulting in changing a Java filein a trivial way (changing the value of a local variable):11:35:15 AM	 build: Kind=AUTOBUILD Project=Adbase Mode=Incremental AspectJcompilation11:35:20 AM	 Time to first 'compiled:' message: 5344ms11:35:25 AM	 Time to first 'woven' message: 10656ms11:35:51 AM	 Time spent in ajde = 36030ms11:35:55 AM	 Types affected during build = 845 <--- Nota Bene11:35:57 AM	 Time spent in build() = 42170msThis has been happening consistently all morning, so I'm forced to downgrade tothe last milestone, or face the wrath of my boss. Hmmm.  This could be related to a change Adrian put in just before the easterbreak.  There was a problem in the code to do with determining whether to do afull build or not.  Before the fix there was a crude check to compare theprevious classpath used to build the project with the new classpath being used.The comparison was:- Do the classpaths consist of the same elements in the same order- For a jar or directory, confirm the last mod time is older than the previoustime we built.If either of these tests fail, we do a full build instead of an incremental one.What we didn't do, in the case of a directory on the classpath, is check all theentries in the directory and any subdirectories, to see if anything has changed. It was this check that was added.  If this is affecting Nick then the onlyreason I can imagine is that between incremental builds the contents of adirectory on the project classpath are changing.  However, if building just thatsingle project over and over with only a simple change to a class, then theclasspath contents shouldnt be changing *unless* the output directory for theproject is on the classpath - as each incremental build will then be affectingthe following incremental build.  Is there anyway you can check this Nick? I have recreated this problem using the AJDT plugins themselves as test code -and it is what I thought.  The output location is on the input classpath.  I'veput in a fix, should appear in next AJDT.  Does this mean we have reached1.5.0M2 ... surely not... Glad to hear it's fixed. Sorry I couldn't try anything myself, my bossthreatened to have me professionally killed if I waste another morningdownloading eclipse, ajdt, and trying things out--I'm too busy to try at night.(Stupid AOP evangelism, I should be working on this ! ) _grin_ I just tried the april 7 (i.e. M2 build). The recompile everything bug is gone,but the overall incremental times are still slow. e.g.(s). Keep up the improvements!10:31:54 AM	 build: Kind=AUTOBUILD Project=Adbase Mode=Incremental AspectJcompilation10:31:55 AM	 Time to first 'compiled:' message: 1171ms10:31:56 AM	 Time to first 'woven' message: 1312ms10:31:58 AM	 Time spent in ajde = 4031ms10:32:00 AM	 Types affected during build = 1610:32:01 AM	 Time spent in build() = 6953ms10:32:59 AM	 build: Kind=AUTOBUILD Project=Adbase Mode=Incremental AspectJcompilation10:33:01 AM	 Time to first 'compiled:' message: 1187ms10:33:01 AM	 Time to first 'woven' message: 1296ms10:33:04 AM	 Time spent in ajde = 4828ms10:33:05 AM	 Types affected during build = 1610:33:07 AM	 Time spent in build() = 7187ms10:33:42 AM	 build: Kind=AUTOBUILD Project=Adbase Mode=Incremental AspectJcompilation10:33:44 AM	 Time to first 'compiled:' message: 1187ms10:33:44 AM	 Time to first 'woven' message: 1672ms10:33:44 AM	 Time spent in ajde = 1953ms10:33:46 AM	 Types affected during build = 210:33:47 AM	 Time spent in build() = 4875ms Nick, are those timings from three builds of the same project withoutsignificant changes inbetween? They seem to vary quite a bit. Also, a greaterthan usual amount of time is spent in AJDT, so I will look into that, but weneed to figure out what is different about your project to cause this. Can yougive us an appropriate count of the number of classes and number of aspects inyour project? Yes, I made a change to a different source file for each build. The times _are_fairly variable... Maybe my computer was affected by solar radiation that day.Here are two more changes, both adding a new, unused field to a testcase:2:25:13 PM	 build: Kind=AUTOBUILD Project=Adbase Mode=Incremental AspectJcompilation2:25:14 PM	 Time to first 'compiled:' message: 1296ms2:25:15 PM	 Time to first 'woven' message: 1750ms2:25:15 PM	 Time spent in ajde = 2015ms2:25:16 PM	 Types affected during build = 12:25:18 PM	 Time spent in build() = 4516ms2:28:17 PM	 build: Kind=AUTOBUILD Project=Adbase Mode=Incremental AspectJcompilation2:28:19 PM	 Time to first 'compiled:' message: 1281ms2:28:19 PM	 Time to first 'woven' message: 1578ms2:28:20 PM	 Time spent in ajde = 2109ms2:28:21 PM	 Types affected during build = 22:28:22 PM	 Time spent in build() = 4515msA little more stable...Here's adding a field to a Hibernate object:2:29:37 PM	 build: Kind=AUTOBUILD Project=Adbase Mode=Incremental AspectJcompilation2:29:38 PM	 Time to first 'compiled:' message: 1032ms2:29:38 PM	 Time to first 'woven' message: 1063ms2:29:40 PM	 Time spent in ajde = 2500ms2:29:41 PM	 Types affected during build = 42:29:43 PM	 Time spent in build() = 5344msAs far as my project goes, it has:58 aspects793 Java source filesI will happily answer any other questions if it helps. <Pyinson Data Over Head> all of the enhancements scheduled for 1.5.0 are complete, but there's more we'll look at doing in 1.5.1. For 1.5.3 we tackled pipelining - helping memory usage.  We also improved intelligence for recognizing changes to either dynamic (pointcuts/advice) or static (itd) crosscutting, and will do full builds far less frequently.  We even recognize changes to around advice bodies when advice is inlined - which require a full build.  The jdtlike handle provider we use also us to avoid recompilation on white space changes too.I think i'm going to close this bug and track further changes we make in new bugs. "	2005-02-15 12:31:18	1108490000.0	resolved fixed	e460b1e	1112710000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/IStateListener.java tests/src/org/aspectj/systemtest/incremental/IncrementalTests.java
88862	Declare annotation on ITDs	"I'll use this bug to capture info on the implementation... What a pig of a feature - now checked in...First change is in ResolvedMember.  - I've added the ability for it to manage annotations.  - Also, I've added a flag that can be specified on resolvedmembers whichindicates its' annotations can be found elsewhere. Why did I need the latter option?  This is because for ITDs we create fakeresolvedmembers that look like the original declaration (e.g. ""int A.m()"") buthave no annotations.  Managing the annotations on these fake resolvedmembers aswell as on the real members in the original aspect would be expensive, sosetting this flag can indicate that for a particular member you should lookelsewhere for the annotations - the caller has to do the hunting.  This is usedto support field ITDs.The flag is not serialized (so the binary format isn't affected), it is setcorrectly when the NewFieldTypeMunger is constructed from the attributes in theclass file.Info that will help you understand the rest of the changes:ITDs are represented by 'bunches' of methods, some put in the target type, someput in the aspect.  Annotations are stored against just *one* of these methods,and that being one of those placed in the aspect - if any of the other methodsare encountered we have to go back to the aspect to ask this special method whatthe annotations are.BcelClassWeaver has had the following changes.- Cache introduced from resolvedmembers (from effective signature attributes) toarrays of annotation types.  The cache shouldn't get very large as it is onlypopulated for ITD constructs, not all resolvedmembers.- weaving of dec@ into methods and fields has been extended for ITDs, I've putin quite a few guards and optimizations where I can.- I got rid of field-execution join points- I modified the match logic to discover the annotations for ITD'd methods -this uses the cache I introduced.BcelShadow- initializeKindedAnnotationVars improved to take account of ITD'd members.LazyMethodGen- removed one layer of annotation indirection! (we were caching the set at toomany layers - now there is one less)AnnotationPointcut- For field ITDs this goes back to the aspect to discover the annotation setSignaturePattern- For field ITDs this goes back to the aspect to discover the annotation set Feature available, see download page:aspectj-DEVELOPMENT-20050324155000.jarfully supported in forthcoming AJDT build... "	2005-03-23 09:47:03	1111590000.0	resolved fixed	0d14ccf	1111610000.0	tests/src/org/aspectj/systemtest/ajc150/AnnotationBinding.java tests/src/org/aspectj/systemtest/ajc150/Annotations.java weaver/src/org/aspectj/weaver/NewFieldTypeMunger.java weaver/src/org/aspectj/weaver/ResolvedMember.java weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java weaver/src/org/aspectj/weaver/bcel/BcelShadow.java weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java
84333	BCException: Bad type name: TypeX.nameToSignature(TypeX.java:635)	<Pyinson Data Over Head> a broken sample is NOT good. We should fail release testing without fixing thisin any case... a little more info... this sample fails because we try to make an inter-typedeclaration of Point.compareTo(Object) from the Comparable interface, but inJava 5, Comparable (and the compareTo method) have a generic signature that wedon't understand yet. So really this is an aj5m3 bug, but I'm going to keeplooking for a little bit longer since I don't like a broken sample. now fixed in tree... Fix available, see download page:aspectj-DEVELOPMENT-20050324155000.jar 	2005-02-03 10:14:20	1107440000.0	resolved fixed	fb01cad	1111610000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java tests/src/org/aspectj/systemtest/ajc150/GenericsTests.java
84122	Allow aspectPath to contain directories	The -aspectpath option to the compiler only allows jar/zip files, notdirectories. But inpath and classpath allow directories.This capability would improve the handling of aspects spanning multiple projectsin Eclipse. AJDT can currently only support jar/zip files on the aspect path,which requires one of the projects to create an outjar instead of writing to thebin directory as usual.The iajc ant task could then also be enhanced to support aspectpath directories. I'd like to get this in ASAP. Will try to do it today if i get time... fix committed in tree. moving to AJDT bug for AJDT to support this in projectpreferences... That's great, I'll enable the AJDT support as soon as we get an updated ajdewith the fix.We already have bug 84318 for the AJDT support, so I'll pass this one back foryou to close. Fix available, see download page:aspectj-DEVELOPMENT-20050324155000.jar 	2005-02-01 05:03:27	1107250000.0	resolved fixed	68f6350	1111600000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java tests/options/aspectpath/MyClass.java tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java
76055	Some Pointcut PatternNodes are missing getters to traverse syntax tree	In order to find out which other pointcuts are referenced by a pointcut definition  i need to access the private members of the CflowPointcut, IfPointcut andNotPointcut PatternNodes found in the weaver module.Unlike the OrPointcut and AndPointcut classes, they are missing the appropriategetter methods. Created attachment 15105This is the proposed patch that adds the needed getters Adrian: I don't see a problem with adding these getters, as long as we make it clear that this is not API.  And it would make these classes consistent with the other ones.Let me know if you have concerns about this, otherwise I will add the methods. committed to tree. 	2004-10-12 03:43:52	1097570000.0	resolved fixed	b0f270e	1111590000.0	weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java weaver/src/org/aspectj/weaver/patterns/IfPointcut.java
88652	an array type as the last parameter in a signature does not match on the varargs declared method	"I get this warning in my code, though I actually do not specify an array type.The signature I want to match is the following constructor signature:public Touple(Object formulaHandle, Object... propositions) {...}Touple implements IRelationThe pointcut I use is the following:pointcut p(): call(Touple.new(..));This should actually match the signature, shouldn't it?AspectJ however complains with this warning:an array type as the last parameter in a signature does not match on the varargs declared method: void ltlrv.Touple.<init>(java.lang.Object, java.lang.Object[]) [Xlint:cantMatchArrayTypeOnVarargs]Also, even if I *had* stated an array type, it should match even then IMHO, since arrays and varargs are actually the same in the Java implementation. Fixed in tree. Will close bug once fix is available in a published build.The pcut call(Touple.new(Object,Object[]) does *not* match against a signatureTouple(Object, Object...)because call matches based on signature, and the signatures:Touple(Object, Object...) and Touple(Object, Object[]) are different signatures(try passing an Object[] to both as the second param in the call - the resultsare *not* the same). However, args(Object, Object[]) matches calls made to both signatures since the*run-time type* of the varargs argument is Object[].Even ""simple"" Java 5 features can be quite confusing at times! to update this bug for the record, *I* was the confused one this afternoon (andeven documented contrary to my earlier entry in the notebook:http://dev.eclipse.org/viewcvs/indextech.cgi/~checkout~/aspectj-home/doc/ajdk15notebook/varargs.html#d0e1849). An Object[] can be passed to an Object... signature and acts exactly as ifthe operation were called with each array element passed separately. new(..)should clearly match regardless of my confusion, and now it does :) fix will be available in m2 build Fix available, see download page:aspectj-DEVELOPMENT-20050324155000.jar "	2005-03-21 12:05:42	1111420000.0	resolved fixed	b5f4d09	1111500000.0	tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java weaver/src/org/aspectj/weaver/patterns/TypePattern.java weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java
87376	NPE when unresolved type of a bound var in a pointcut expression (EclipseFactory.java:224)	"see attached mini-project to reproduce Created attachment 18534contents of an AJ project ""Bug"" with 2 source files that reproduce the problem. I'm passing this back over the fence, as it happens from the command line(although only when building the structure model):E:\Bug>ajc -emacssym @.generated.lstE:\Bug\a\b\d\NPE.aj [error] Internal compiler errorjava.lang.NullPointerException        at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeResolvedMember(EclipseFactory.java:224)        at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.getPointcutDeclaration(AsmHierarchyBuilder.java:384)        at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.addUsesPointcutRelationsForNode(AsmHierarchyBuilder.java:369)        at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.visit(AsmHierarchyBuilder.java:343)        at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:167)        at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1133)        at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:314)        at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.internalBuild(AsmHierarchyBuilder.java:141)        at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.buildStructureForCompilationUnit(AsmHierarchyBuilder.java:81)        at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.finishedCompilationUnit(EclipseFactory.java:354)        at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterProcessing(AjCompilerAdapter.java:139)        at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:373)        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:682)        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:168)        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:102)        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:109)        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60)        at org.aspectj.tools.ajc.Main.run(Main.java:291)        at org.aspectj.tools.ajc.Main.runMain(Main.java:227)        at org.aspectj.tools.ajc.Main.main(Main.java:80)(no source information available)E:\Bug\a\b\d\NPE.aj:9 [error] I cannot be resolved to a typepointcut ii(I i) : execution(* I.*(..)) && this(i);E:\Bug\a\b\d\NPE.aj:11 [error] I cannot be resolved to a typeafter(I i) returning : ii(i) {ABORTException thrown from AspectJ DEVELOPMENTE:\Bug>ajc -versionAspectJ Compiler DEVELOPMENT built on Friday Feb 18, 2005 at 17:12:57 GMT *** Bug 86051 has been marked as a duplicate of this bug. *** fix committed in tree, will close bug once available in a published build. this will be in m2 Fix available, see download page:aspectj-DEVELOPMENT-20050324155000.jar "	2005-03-08 10:11:13	1110290000.0	resolved fixed	85aa152	1110460000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java tests/bugs150/pr87376/I.java tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java
86789	"annotations and ""circularity in declare precedence"""	The following example    declare precedence : (@PremiumPartner *), *;results in the error message    circularity in declare precedence, ''*'' occurs more than once   It is the same example (apart form the name) as in the developers notebook.(see also http://dev.eclipse.org/mhonarc/lists/aspectj-dev/msg01326.html) fixed in aj5m2 	2005-02-27 16:24:12	1109540000.0	resolved fixed	f90186c	1110380000.0	weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java
83565	"BCException ""bad type name"" thrown when compiling"	"<Pyinson Data Over Head> This looks like the weaver code that builds the structure model for ajdt ischoking on some generic type name its not expecting to see. I'm reassigning toAndy temporarily as I'm on a plane the next two days... I've recreated from the command line by compiling that type with -emacssym(which generated the ASM).  Adrian is correct that we choke on the genericsignature.Although not all that helpful a temporary workaround is to turn off structuremodel building in the project properties, it should then compile the codesuccessfully (but the xref view will be empty...) I think I know what's going wrong here and will plan on fixing it this week. Andy: the ASM part of this is fixed, but note the following caveat.The problem was that the weaver's TypeX.nameToSignature(String name) can't handle generic return types, for example the ""T"" in:public T elementAt(int i) {  return elements.elementAt(i);}I've made the AsmHierarchyBuilder robust to that problem, which means that when building a signature it will put <undefined> whenever the weaver can't resolve a name.  I committed a minimal test of this to, which now passes (if the single test is uncommented and 1.5 is required)./ajde/testsrc/org/aspectj/ajde/GenericsTest.javaNote that the hierarchy of the structure model is correct, although it would be nice to get the right type name in there for clients that make use the bytecode signature.  I'll leave this open in case you want to use this test case to experiment.  In that case you may also want to inspect the catch catch(BCException) clause in AsmHierarchyBuilder. lets take one more look at this one before closing out m2... the fix for bug 843333 should ensure that TypeX.forName never sees aparameterized type. This is certainly good enough for m2. Moving the bug to m3where we will pass parameterized types through in all probability. <Pyinson Data Over Head> The failing code has now be upgraded to support basic generics - the use ofparameterized types and raw types *should* be ok... so this might be resolved inthe next version of AJDT...  unfortunately without a simple testcase I can'tconfirm that right now... Created attachment 20796AspectJ Eclipse project illustrating the bug (In reply to comment #8)> The failing code has now be upgraded to support basic generics - the use of> parameterized types and raw types *should* be ok... so this might be resolved in> the next version of AJDT...  unfortunately without a simple testcase I can't> confirm that right now...Thank you for looking at this.I created a simple testcase and attached it.  I discovered that the file wherethe error was reported was *not* the file with the problem -- it just had thebad luck of being the last file in the build path.My test case has two java files, a parametized interface and a parametized typeimplementing the interface.  If the parametized type does not implement theinterface, then there the error does not occur. This appears fixed with the work I've done for bug 97763.Without my changes (actually with the dev build 20050510144051), on compilingthe attached test program I was getting:[error] can't find type test.TroubleInterface<java.lang.Object>1 errorNow with my changes, I don't get any errors at all.Waiting on a dev build to be uploaded now... Fixed in latest dev build from http://eclipse.org/aspectj/downloads.php "	2005-01-24 17:13:15	1106600000.0	resolved fixed	5765d53	1106850000.0	ajde/testdata/bug-83565/Bug.java ajde/testsrc/org/aspectj/ajde/AjdeTests.java ajde/testsrc/org/aspectj/ajde/GenericsTest.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java
83626	@AJ	Andy wants a patch format + a bugzilla for @AJ work due to some funny license issue.Here it is as drafted Created attachment 17429@AJdraft @AJ with- non final package names- //ALEX  markers all around to spot hooks- singleton aspect support final (except names etc)- LTW Java 5 drafted- LTW xml drafted- test case not fully integrated in the XML infra. Created attachment 17463full @AJ draft since the patch does not contain new files..per Andy request I've started by taking the modifications to 'runtime' which:1. Introduce EnclosingStaticPart as minimal subtype of StaticPart2. Provides support for proceed() on a join point. (supported by joinpointobjects being aware of an around closure instance)Alex - did you see Adrians notes at: http://dev.eclipse.org/viewcvs/indextech.cgi/~checkout~/aspectj-home/doc/ajdk15notebook/ataspectj-pcadvice.htmlwhich suggest the creation of a new sub-type of JoinPoint calledProceedingJoinPoint that has the proceed method on it? I am not in favor of the ProceedingJoinPoint but more in favor of a NO-OP whenproceed() is used within before / after advices.It makes the advice signatures symetric.The programming model seems simpler as well for the user.Aside the impact on the code is reduced, since code style aspects adviceinvocation are unchanged.On the opposite, we would have to create this proceedingJP as soon as we see wehave an around advice on a shadow no matter if it is a code style or @style advice.That is for sure something to iterate on, as well as the underlyingclosure/joinpoint run/proceed linkage.I just think this is enough for the RC1 we aim at demo at AOSD. bcel-builder module.Change to MethodGen committed (and lib/bcel.jar rebuilt), now returns emptystring array instead of null if no arg names set. 95% of the patch is applied to my private workspace - I've mainly stayed awayfrom changes to LTW related stuff.  I have committed a few minor changes thatare fine standalone.  All the testcases are still passing for me - the nextthing I want to do is get Alex's single testcase to pass.  Once that is passingtoo, I will commit - Alex can do a sync and see what I messed up ;)  There are a few things here and there where I have some questions, I'll try andpull these into a sensible list ... Hi Alex,singleton test is passing and my own two simple tests are also passing.I do have a few questions, and the best way to tackle these is likely to have acall between you and us to talk through them.  But its worth listing thequestions here that we want to discuss...For some of the simpler changes, we probably need to create more tests, eventhings like the addition of EnclosingStaticPart deserve a few unit tests toverify they work ok.JoinPoint is our public interface, it doesn't seem right to haveset$aroundClosure() on it - we need to fix that (but I think you already knowthis isnt quite right).AroundClosure- better to have getter for relevant state than make state public.- What problem does getJoinpoint() solve?  Is it used from theweaveAroundClosure(), I'm just not sure why we haven't needed it before, is thejoinpoint not accessible as a parameter?SingletonAspectBindingsTest is a good test, but it probably needs some simplerones around it, I've added a couple to start with.  It's just for when they gowrong (like the around advice did this morning).Whats stored in an aj$class field - should it be ajc$class as ajc$ is ourrecognized prefix?Aj5Attributes- I'm worried about the performance of making multiple passes over theattributes.  A first way to address it is to have a flag, set or returned by theunpackAjAttributes() method that informs the caller of whether there are anyannotations worth looking at, if not we can avoid making that second pass.  Butthis still leaves us with the problem of pointcut annotations, and going throughall the methods as part of unpacking the annotations on the class in order tofind them - we need to think about the best way to solve this...Need to move the hardcoded strings to constants somewhere...that tripped me up acouple of times.Ought to rename from Aj5Attributes to ATAttributes or something, i'm not sure what.CastExpr/FieldGetOn/StringConstExpr - could do with a bit more doc.  I admit weare lacking in doc in loooooooads of places but we are trying to change that aswe move forward.Commenting out the munger sorting in BcelWeaver may help the @Aj syntax butbreaks some testcases - it would be better to determine an appropriate key forthe sort other than the name.Given the nature of the changes, we've been discussing the best way to sharethis code amongst the team - we think the best way will be a CVS branch in whichthese features can be finished, then we can merge them into HEAD.  One goodreason for this is that the build infrastructure is currently completely unawareof Java5 and it'll take me a little while to ensure aspectjrt.jar is builtappropriately and the 1.5 tests are executed correctly.what do you think?I'll attach my current version of the patch to this bug report - just so it isntonly on my machine ! Created attachment 17506Zip of 4 patches to 4 modules and new 'java5' module.This file contains patches to org.aspectj.ajdt.core/tests/weaver/runtime and azip of the new module 'java5'.The patches were generated in eclipse and do include new files (e.g. the newtests).Its quite amazing to see annotation syntax programs compile and run :)This patch includes the minimum from the first patch to get annotation syntaxto work. Yes a branch is a good idea. Can you do one now, so that we iterate in ittomorrow ? The strategy for the branch will be to reduce the changes in theexisting base to avoid having conflicts during the merge later on.As I said, this patch is a draft (hence all those strings, public access insteadof accessors etc). That was the best way to point f.e. this build issue for Java5 in the current system, recently fixed enum as local variable naming issue ,packaging issues, etc.The around advice closure/jp will be refactored as time goes. The shortexplanation for now is that- for code style, the relation is closure-->jp [closure has jp in its state]- for @ style, the relation is jp-->closure [jp.proceed() must reach closure.run()]The munger sorting cannot be solved. There must be NO ordering since it wouldactually un-order the source code ordering.The source code ordering for code style aspect should rely on the compiler (justas for javac) and not on name ordering - even if so far the advice name whereindeed in the correct order - something that cannnot be controlled with @AJ aspects.I ll add tests and fix those issues in the branch. Optimizations way later aswell. Let me know what's the branch name. Note on joinpoint.proceed()If we plan to have a proceed(Object..) varargs based version, then we will needa ProceedingJoinPoint (extends JoinPoint) since that one will be Java 5 specific.When we then have a 1.4 port, we will have to have proceed(Object[]) and then wed better not tied us to varargs. In 1.4 the user will do the boxing as needed.It thus seems proceed should belong to the 1.4 world. Be it JoinPoint with aNO-OP strategy for before/after or be it ProceedingJoinPoint.Note: @AJ proceed(...) is not yet impl. Only proceed() for now. closingwas a generic @AJ one for several things. We agreed on ProceedingJoinPoint, andthe other things have been handled during the branch to head merge. 	2005-01-25 11:20:09	1106670000.0	resolved fixed	7b4c7d7	1106750000.0	bcel-builder/src/org/aspectj/apache/bcel/generic/MethodGen.java
83563	pertypewithin() handing of inner classes	"It seems that pertypewithin() aspect association does not handle nested classescorrectly. Here is a test class that exhibits the problem:package test;public class Test {    public static void main(String[] args) {        new NestedTest().run();    }	    static class NestedTest implements Runnable {        public void run() {            System.out.println(""Running..."");        }    }} aspect PertypewithinTest pertypewithin(Test) {    before() : execution(* *.*(..)) {        System.out.println(thisJoinPointStaticPart);    }	}> ajc -versionAspectJ Compiler DEVELOPMENT built on Monday Jan 24, 2005 at 17:07:00 GMT> ajc test\Test.java> java test.Testexecution(void test.Test.main(String[]))execution(void test.Test.bar())Exception in thread ""main"" java.lang.NoSuchMethodError: test.Test$1.ajc$test_PertypewithinTest$localAspectOf()Ltest/PertypewithinTest;        at test.Test$1.run(Test.java)        at test.Test.bar(Test.java:9)        at test.Test.main(Test.java:13)The same problem is seen for anonymous inner classes, as well:package test;public class Test {    public void bar() {        new Runnable() {            public void run() {                System.out.println(""Running..."");            }        }.run();    }            public static void main(String[] args) {        new Test().bar();    }} aspect PertypewithinTest pertypewithin(Test) {    before() : execution(* *.*(..)) {        System.out.println(thisJoinPoint);    }    }> ajc test\Test.java> java test.Testexecution(void test.Test.main(String[]))execution(void test.Test.bar())Exception in thread ""main"" java.lang.NoSuchMethodError: test.Test$1.ajc$test_PertypewithinTest$localAspectOf()Ltest/PertypewithinTest;        at test.Test$1.run(Test.java)        at test.Test.bar(Test.java:9)        at test.Test.main(Test.java:13) Bug fixed.  The problem was in two parts, in order to implement pertypewithin we'generate' a special type munger and a special shadow munger.  The special typemunger adds the necessary local methods and state to the target matched type. The special shadow munger ensures the aspect instance in the target matched typeis initialized.  Both of these new mungers have associated generatedpointcuts/matching logic.The shadow munger pointcut was wrong and the special type munger matching logicwas wrong with respect to including nested types.For the shadow munger the pointcut was 'staticinitalization(Test)', when itshould have been 'staticinitialization(*) && within(Test)' - within(Test)correctly matches the nested type. (Fix is in PerTypeWithin.java)For the special type munger (PerTypeWithinTargetTypeMunger.java), the matches()logic was changed to allow for nested types just like the within pointcut.thanks for the testcases ramnivas, both added to the test suite. (and pleasedon't ask me to implement pertype(<pcut>) - that will be a nightmare!!)waiting for build. Fix available:BUILD COMPLETE -  build.449Date of build: 01/25/2005 20:48:44Time to build: 102 minutes 1 secondLast changed: 01/25/2005 20:18:44Last log entry: Fix for Bug 83563: pertypewithin() handling of inner classesLatest good AspectJ jar available at:download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar "	2005-01-24 14:59:36	1106600000.0	resolved fixed	1b01255	1106680000.0	tests/bugs150/PR83563_1.java tests/bugs150/PR83563_2.java tests/src/org/aspectj/systemtest/ajc150/Ajc150TestsNoHarness.java weaver/src/org/aspectj/weaver/PerTypeWithinTargetTypeMunger.java weaver/src/org/aspectj/weaver/patterns/PerTypeWithin.java
83303	complier error when mixing inheritance, overriding and polymorphism	Given this scenario:- class A define method m1 (with proteceted visibility)- class B extends class A and implements interface I and override method m1 (butwith public visibility)- interface I define method m1 (with public  visibility)The code is correct and compile using java 1.4Let's modify the scenario:move the method B.m1 into a method introduction on aspect C, such that- class B extends class A- apsect C intosuces method m1 into B (with public visibility) and makes Bimplemts I (declare parents)- A and I as beforeThe compiler reports this error:B.java:1 [error] The inherited method A.m1() cannot hide the public abstractmethod in Iclass B extends A { Created attachment 17330class A which define protected method m1 Created attachment 17331class B which extends A (and inherits m1) Created attachment 17332interface I which define method m1 Created attachment 17333aspect C which crosscut B Thanks for the test programs.  I've added them as a testcase and checked in thefix.  We intercept the Java compiler error reporting mechanism in a few placesand check if ITDs satisfy what the compiler thinks is an error.  This bughighlights a missing case - I just made the ITD check and the program compiles fine.I will close the bug report when a build with the fix in becomes available(about 3 hours time). Fix available:BUILD COMPLETE -  build.442Date of build: 01/20/2005 19:14:23Time to build: 117 minutes 4 secondsLast changed: 01/20/2005 14:44:46Last log entry: Fix for Bug 83303: complier error when mixing inheritance,overriding and polymorphismLatest good AspectJ jar available at:download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar 	2005-01-20 08:47:23	1106230000.0	resolved fixed	5d281fd	1106230000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java tests/bugs150/PR83303.java tests/src/org/aspectj/systemtest/ajc150/Ajc150TestsNoHarness.java
82340	Visibility selector ignored for pointcuts	"Using ajdoc under AJDT 1.1.12 or AspectJ 1.2.1 at the commandline has the following aspect has problems.public abstract aspect Aspect {	private pointcut privatePointcut ();	protected pointcut protectedPointcut ();	public pointcut publicPointcut ();		private void privateMethod () {			}		public void protectedMethod () {			}		public void publicMethod () {			}}1. Asking for ""protected"" gives all pointcuts (public, protected _and_ private)2. The Aspect entry is wrong: ""public abstract class Aspect""3. The ""Methods inherited ..."" section has a leading comma: "", clone, equals, finalize, ..."" I just committed fixes for all 3 bugs listed here.Please note that I found a new bug, which causes ""-public"" to show documentation for ""protected"" members.  The problem is that the source signatures that the ASM is getting from the compiler indicate protected methods as public (I added bug#82752 for this issue). "	2005-01-06 12:25:09	1105030000.0	resolved fixed	b460597	1105630000.0	ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java ajdoc/testdata/bug82340/Pointcuts.java ajdoc/testdata/coverage/foo/NoMembers.java ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java ajdoc/testsrc/org/aspectj/tools/ajdoc/PointcutVisibilityTest.java
82218	fails to doc spacewar using AJDT 1.2.0M2	"Using AJDT 1.2.0M2 {with Java 5 JRE on XP SP2}, install Spacewar example andgenerate to Spacewar/docs.  Result: output has no cross-references (and displays special AJDT tags), andstderr lists this exception:java.lang.StringIndexOutOfBoundsException: String index out of range: -1	at java.lang.AbstractStringBuilder.insert(AbstractStringBuilder.java:980)	at java.lang.StringBuffer.insert(StringBuffer.java:447)	atorg.aspectj.tools.ajdoc.HtmlDecorator.insertDeclarationsDetails(HtmlDecorator.java:350)	atorg.aspectj.tools.ajdoc.HtmlDecorator.addAspectDocumentation(HtmlDecorator.java:234)	at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFile(HtmlDecorator.java:188)	atorg.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromDecl(HtmlDecorator.java:116)	atorg.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromDecls(HtmlDecorator.java:54)	atorg.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromInputFiles(HtmlDecorator.java:43)	at org.aspectj.tools.ajdoc.Main.main(Main.java:210) Fix committed to CVS.The problem was that ajdoc wasn ot parsing the HTML files generated by Javadoc in the 1.5 JDK properly.  I've updated it to support JDKs up to 1.5, so it's successfully generating all documentation now.  However, there seem to be some classes missing from the ""all classes"" listing when running on 1.5, so I added bug#82730 for that. "	2005-01-05 04:49:41	1104920000.0	resolved fixed	f70b383	1105590000.0	ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java ajdoc/src/org/aspectj/tools/ajdoc/Util.java ajdoc/testdata/coverage/foo/ModelCoverage.java ajdoc/testdata/coverage/foo/NoMembers.java ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java ajdoc/testsrc/org/aspectj/tools/ajdoc/JDKVersionTest.java
78021	Injecting exception into while loop with break statement causes catch block to be ignored	"In order to test exception scenarios in an existing framework, I havecreated an aspect to inject an exception.  The exception is injected intosome code running within a try/catch/finally block.  After the exception isthrown, I am expecting control to pass to the catch block.  However, whatis happening is that the catch block code is not executed, control passesthrough the finally block and the (undeclared) exception is thrown to thecalling method.Here is a distilled test case:public class MainClass {       protected Integer counter;       private int j;       public static void main(String[] args) {               MainClass mh = new MainClass();               try {                       mh.doSomething();               } catch (Exception e) {                       System.out.println(""Exception thrown bydoSomething!!!!!"");                       e.printStackTrace();               }       }       public void doSomething() {               int i = 0;               while (i++ < 1) {                       counter=null;                       try {                               counter = getCounter();                               if (counter == null) {                                       break;                               }                               commit();                       } catch (Throwable e) {                               System.out.println(""Caught exception "" +e);                       } finally {                               System.out.println(""In finally block"");                       }               }       }       protected Integer getCounter() {               return new Integer(j++);       }       protected void commit() throws SQLException {               System.out.println(""Main.commit"");       }}The following aspect injects the exception:public aspect SimpleExceptionThrowingAspect {   pointcut commitOperation() : call (* MainClass+.commit(..));   before() throws SQLException : commitOperation() {        throw new SQLException(""Dummy SQL Exception"", ""55102"");   }}Expected output is:       Caught exception java.sql.SQLException: Dummy SQL Exception       In finally blockActual output is:       In finally block       Exception thrown by doSomething!!!!!       java.sql.SQLException: Dummy SQL Exception        atnz.govt.moh.test.SimpleExceptionThrowingAspect.ajc$before$nz_govt_moh_test_SimpleExceptionThrowingAspect$1$292c82f1(SimpleExceptionThrowingAspect.aj:10)       at nz.govt.moh.test.MainClass.doSomething(MainClass.java:32)       at nz.govt.moh.test.MainClass.main(MainClass.java:14)Removing the ""break;"" statement from MainClass.java causes the expectedoutput to be produced. This is related to bug 79554 - they are both to do with us creating an incorrectexception table for a woven method.  The exception table for the unwoven code is:  Exception table:   from   to  target type     9    38    38   Class java/lang/Throwable     9    29    64   any     32    61    64   any    81    84    64   anyOnce woven, this changes to:  Exception table:   from   to  target type    87    90    70   any    32    67    70   any     9    44    44   Class java/lang/Throwable     9    29    70   anyThe inclusion of 'any' with a range that overlaps the 'Throwable' range iscausing the problem.  When the exception occurs, it is right in the overlaprange and so in the woven code we skip the catch block, do the finally stuff and rethrow the exception. When unpacking, we associate a priority with entries in the exception table. This priority can be used when writing the class out to ensure we don't breakthe ordering carefully constructed by the compiler.  We currently ignore thepriority - leading to situations where sometimes entries for finally blocksobscure entries for real catch blocks.  The implementation of the priority fornewly created exception handlers (created during weaving) doesn't seem quiteright as they are given either super high priority (Integer.MAX) or super lowpriority (-1).  There are comments in the code (aroundLazyMethodGen.insertHandler()) which suggest what the right long termimplementation would be but having spent the last day in the code, it is nottrivial and the simpler immediate fix of using the priorities fixes this bug andthe related 79954.We can do the full implementation of the priority work when (if?) someone findsa situation that the current algorithm doesn't cope with.Fix checked in - waiting for build. Fix available:BUILD COMPLETE -  build.429Date of build: 01/11/2005 11:52:16Time to build: 103 minutes 38 secondsLast changed: 01/11/2005 11:22:16Last log entry: Fixes for 78021, 79554 - both to do with us breaking theexception table for a method on weaving *if* finally blocks are involved.Latest good AspectJ jar available at:download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar "	2004-11-06 13:47:16	1099770000.0	resolved fixed	603b063	1105440000.0	tests/bugs150/PR78021.java tests/bugs150/PR79554.java tests/src/org/aspectj/systemtest/AllTests.java tests/src/org/aspectj/systemtest/ajc150/Ajc150TestsNoHarness.java tests/src/org/aspectj/systemtest/ajc150/AllTestsAspectJ150.java tests/src/org/aspectj/systemtest/ajc150/AllTestsJava5_binaryWeaving.java tests/src/org/aspectj/systemtest/ajc150/TestUtils.java weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java
82134	AspectJ 5 M2 should implement backwards compatibility for binary aspect form	Hi Adrian,thanks for the detailed explanation of the compatibility questions. That explains the problem I observed.> * An AspectJ program should always be run with the aspectjrt.jar runtime > library that accompanies the distribution containing the compiler/weaver > used to build it. Interesting point. Which one? The one that is used to compile it or the one that is used to weave it?> However, instead of some IOException, what you should see is a nice > message saying that the aspect was produced by a more recent version of > AspectJ and cannot be read. Likewise, if you load a pre-aspectj 5 aspect > into the AspectJ 5 weaver right now, you'll also see an IOException > (odds-on). In M2 we'll detect that and use the back-level loaders to read > it in.Okay. Is there a bug to track this? I really would like to update the weaver of my weaving runtime but only if it allows to load/weave asepects that are compiled with any of the AJDT versions that are out right now (AJDT 1.1.x and AJDT 1.2.0Mx). I have just checked in the fix for this.  AspectJ5 will now read in 1.2.1 builtaspects.  I have:1. Updated the version number for the WeaverVersionInfo attribute that exists infiles generated by AspectJ releases since 1.2.1 onwards.  1.2.1 had version 1.0in the attribute.  AspectJ 5 has version 2.02. Rebuilt all the jar files used by testcases so they include the new versionnumber.3. Introduced a VersionedDataInputStream subclass of DataInputStream that knowsthe weaver version that was used to build the contents of the data in the stream.  4. Modified all read() methods in the org.aspectj.weaver.patterns package to use a VersionedDataInputStream rather than a DataInputStream, they are then able tocheck the version before determining what data they should read.5. Fixed the TypePattern and SignaturePattern read methods to allow for the oldversion number (1.0) which wouldn't include varargs info or annotation patterns.6. Added a testcase that takes 1.2.1 generated code as input for a weave byAspectJ 5.Basically, the VersionedDataInputStream defaults to assuming the latest version,and some changes in the attribute unpacking code modify the version if they comeacross a WeaverVersionInfo attribute.  We can't (without a lot of messy messy work) get AspectJ 5 to accept pre-1.2.1built aspects as input.waiting for build ... Build available:BUILD COMPLETE -  build.428Date of build: 01/07/2005 14:46:31Time to build: 100 minutes 19 secondsLast changed: 01/07/2005 14:14:51Last log entry: Fix for Bug 82134: AspectJ 5 M2 should implement backwardscompatibility for binary aspect formLatest good AspectJ jar available at:download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar Should have been closed on Jan. 7th... 	2005-01-04 09:40:55	1104850000.0	resolved fixed	797b6a6	1105110000.0	tests/src/org/aspectj/systemtest/ajc150/AllTestsJava5_binaryWeaving.java tests/src/org/aspectj/systemtest/ajc150/MigrationTests.java weaver/src/org/aspectj/weaver/AdviceKind.java weaver/src/org/aspectj/weaver/AjAttribute.java weaver/src/org/aspectj/weaver/ResolvedPointcutDefinition.java weaver/src/org/aspectj/weaver/VersionedDataInputStream.java weaver/src/org/aspectj/weaver/WeaverStateInfo.java weaver/src/org/aspectj/weaver/bcel/BcelAttributes.java weaver/src/org/aspectj/weaver/bcel/BcelField.java weaver/src/org/aspectj/weaver/bcel/BcelMethod.java weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java weaver/src/org/aspectj/weaver/patterns/AndAnnotationTypePattern.java weaver/src/org/aspectj/weaver/patterns/AndPointcut.java weaver/src/org/aspectj/weaver/patterns/AndTypePattern.java weaver/src/org/aspectj/weaver/patterns/AnnotationPatternList.java weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java weaver/src/org/aspectj/weaver/patterns/AnnotationTypePattern.java weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.java weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java weaver/src/org/aspectj/weaver/patterns/BindingAnnotationTypePattern.java weaver/src/org/aspectj/weaver/patterns/BindingTypePattern.java weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java weaver/src/org/aspectj/weaver/patterns/Declare.java weaver/src/org/aspectj/weaver/patterns/DeclareErrorOrWarning.java weaver/src/org/aspectj/weaver/patterns/DeclareParents.java weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java weaver/src/org/aspectj/weaver/patterns/DeclareSoft.java weaver/src/org/aspectj/weaver/patterns/ExactAnnotationTypePattern.java weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java weaver/src/org/aspectj/weaver/patterns/HandlerPointcut.java weaver/src/org/aspectj/weaver/patterns/IfPointcut.java weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java weaver/src/org/aspectj/weaver/patterns/ModifiersPattern.java weaver/src/org/aspectj/weaver/patterns/NamePattern.java weaver/src/org/aspectj/weaver/patterns/NotAnnotationTypePattern.java weaver/src/org/aspectj/weaver/patterns/NotPointcut.java weaver/src/org/aspectj/weaver/patterns/NotTypePattern.java weaver/src/org/aspectj/weaver/patterns/OrAnnotationTypePattern.java weaver/src/org/aspectj/weaver/patterns/OrPointcut.java weaver/src/org/aspectj/weaver/patterns/OrTypePattern.java weaver/src/org/aspectj/weaver/patterns/PerCflow.java weaver/src/org/aspectj/weaver/patterns/PerClause.java weaver/src/org/aspectj/weaver/patterns/PerFromSuper.java weaver/src/org/aspectj/weaver/patterns/PerObject.java weaver/src/org/aspectj/weaver/patterns/PerSingleton.java weaver/src/org/aspectj/weaver/patterns/Pointcut.java weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java weaver/src/org/aspectj/weaver/patterns/ThisOrTargetAnnotationPointcut.java weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java weaver/src/org/aspectj/weaver/patterns/ThrowsPattern.java weaver/src/org/aspectj/weaver/patterns/TypePattern.java weaver/src/org/aspectj/weaver/patterns/TypePatternList.java weaver/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java weaver/src/org/aspectj/weaver/patterns/WithinAnnotationPointcut.java weaver/src/org/aspectj/weaver/patterns/WithinCodeAnnotationPointcut.java weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java weaver/testsrc/org/aspectj/weaver/bcel/PatternWeaveTestCase.java weaver/testsrc/org/aspectj/weaver/bcel/PointcutResidueTestCase.java weaver/testsrc/org/aspectj/weaver/patterns/AndOrNotTestCase.java weaver/testsrc/org/aspectj/weaver/patterns/DeclareErrorOrWarningTestCase.java weaver/testsrc/org/aspectj/weaver/patterns/ModifiersPatternTestCase.java weaver/testsrc/org/aspectj/weaver/patterns/NamePatternTestCase.java weaver/testsrc/org/aspectj/weaver/patterns/SignaturePatternTestCase.java weaver/testsrc/org/aspectj/weaver/patterns/TypePatternListTestCase.java weaver/testsrc/org/aspectj/weaver/patterns/TypePatternTestCase.java weaver/testsrc/org/aspectj/weaver/patterns/WithinTestCase.java
81863	Annotation matching using within() PCD doesn't appear to be working.	"From discussion on aspectj list:Hi,Well, having just done some testing, I think this even simpler case shows within() is not behaving correctly for annotations:@Entitypublic class myClass1 {...}public class myClass2 {...}public aspect myAspect {  before():call(* *(..)) && within(@Entity *) {  }}The pointcut matches all the method calls in myClass1 and myClass2 (effectively it is parsing but then ignoring the annotation specifiedin the within()).So, what you want to do is valid but AspectJ is misbehaving - you get a stack overflow because the perthis() clause is also matching on your aspect type when obviously that doesnt have the annotation and shouldnt be matched.Andy.---Andy ClementAspectJ DevelopmentRifflard Mickaël <Mickael.Rifflard@atosorigin.com> Sent by: aspectj-users-admin@eclipse.org22/12/2004 16:56Please respond toaspectj-users@eclipse.org	To<aspectj-users@eclipse.org>ccSubject[aspectj-users] Aspect instance on JDK 1.5 annotation		Hi all, I'm currently trying to get an aspect instance for an object instance withspecific JDK 1.5 annotation. Exemple :         Create an aspect instance for all object like that :         @Entity         public class myClass { ... } I try         public aspect myAspect perthis(within(@Entity *)) {...} but this aspect execution lead to a java.lang.StackOverflowError exception. Is it possible ? Thanks.         Mickaël         _______________________________________________ aspectj-users mailing listaspectj-users@eclipse.org http://dev.eclipse.org/mailman/listinfo/aspectj-users Fixed, build available:BUILD COMPLETE -  build.429Date of build: 01/11/2005 11:52:16Time to build: 103 minutes 38 secondsLast changed: 01/11/2005 11:22:16Latest good AspectJ jar available at:download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar "	2004-12-23 10:54:16	1103820000.0	resolved fixed	8a8930f	1104940000.0	tests/java5/annotations/within/PlainWithin.java tests/src/org/aspectj/systemtest/ajc150/AnnotationPointcutsTests.java tests/src/org/aspectj/systemtest/ajc150/AnnotationRuntimeTests.java weaver/src/org/aspectj/weaver/patterns/AnnotationTypePattern.java weaver/src/org/aspectj/weaver/patterns/ExactAnnotationTypePattern.java weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java weaver/src/org/aspectj/weaver/patterns/HandlerPointcut.java weaver/src/org/aspectj/weaver/patterns/TypePattern.java weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java
82062	WeaveMessage should provide more information	It would be wonderful if the WeaveMessage object would provide two additionalthings:- the affected class name- the aspect nameI could use this to determine which aspect is woven into which class duringload-time weaving (need this for dependency management). Created attachment 16883weavemessage-bridge-patchPatch that adds several things to WeaveMessage:- getter for aspectname- getter for affectedtypename- additional static factory method to provide aspectname and affectedtypename- two new parameters for constructor (for aspectname and affectedtypename) Created attachment 16884weavemessage-weaver-patchPatch that makes use of new WeaveMessage factory method to provide additionalinformation via WeaveMessage objects (aspectname and affectedtypename). Both patches implemented - i see the second one also includes your change fromprivate to protected for a method in BcelWorld.(and sorry I hadn't gotten round to improving WeaveMessages earlier - I knowyou've wanted changes like this for a while!!)Waiting for build before closing bug report. Fixes available:BUILD COMPLETE -  build.426Date of build: 01/05/2005 02:54:21Time to build: 100 minutes 4 secondsLast changed: 01/04/2005 21:08:48Latest good AspectJ jar available at:download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar Perfect. I am just waiting for bug 82134 to be fixed before I can check thisout. Thanks again for the quick reaction!!! 	2005-01-01 15:07:54	1104610000.0	resolved fixed	9897659	1104840000.0	bridge/src/org/aspectj/bridge/WeaveMessage.java weaver/src/org/aspectj/weaver/Advice.java weaver/src/org/aspectj/weaver/Shadow.java weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java weaver/src/org/aspectj/weaver/bcel/BcelWorld.java
80916	"In some cases the structure model doesn't contain the ""matches declare"" relationship"	"With a project containing one class and one aspect:public class HelloClass {	public static void main(String[] args) {		new HelloClass().sayHello();	}		public void sayHello() {		System.out.println(""Hello"");	}	}public aspect A1 {	pointcut test() : get(* System.out);		declare warning : test() && !within(A1)		 : ""test warning"";		pointcut anotherTest() : 		execution(void HelloClass.sayHello(..));		after() returning : anotherTest() {		System.out.println(""returning...."");	}		}The following is returned from the structure model:asmRelMap entry: HelloClass.sayHello(), relationship: advised by, target: A1.afterReturning(): anotherTest..asmRelMap entry: A1.afterReturning(): anotherTest.., relationship: uses pointcut, target: A1.anotherTest()asmRelMap entry: A1.afterReturning(): anotherTest.., relationship: advises, target: HelloClass.sayHello()asmRelMap entry: HelloClass.sayHello(), relationship: advised by, target: A1.afterReturning(): anotherTest..asmRelMap entry: A1.anotherTest(), relationship: pointcut used by, target: A1.afterReturning(): anotherTest..asmRelMap entry: A1.declare warning: ""test warning"", relationship: matched by, target: HelloClass.sayHello()In other words, the model is saying that there are two entries the same:asmRelMap entry: HelloClass.sayHello(), relationship: advised by, target: A1.afterReturning(): anotherTest..whereas one of these should be the ""matches declare"" relationship relating to the declare warning.Changing the aspect to be:public aspect A1 {	pointcut test() : get(* System.out);		declare warning : test() && !within(A1)		 : ""test warning"";		pointcut anotherTest() : 		execution(void HelloClass.sayHello(..));		after() returning : anotherTest() {		System.out.println(""returning...."");	}		after() returning : test() {		System.out.println(""returning again!"");	}	}means that the IRelationshipMap does now contain the ""matches declare"" relationship.This is all with AspectJ 5 M1. I'll take a look at fixing this when I do the ""concretizes pointcut"" additions. Just as a note, this may have something to do with the changes Andy put in recently - he added the capability to get at the offset aswell as the line number (we needed this for AJDT). Plus there's the changes which have gone in for AspectJ 5. Yesterday we didn't have declare soft in the model, and that was fixed - it might be something in the same area.Thanks, Helen It could well be related to what I did as I'm not sure how many tests there arein existence around my changes.  Helen, can you tell me what you call to getyour output: (Matt mentioned some API with annotation in the name the other daybut I can't remember what it was)asmRelMap entry: HelloClass.sayHello(), relationship: advised by, target: A1.afterReturning(): anotherTest..asmRelMap entry: A1.afterReturning(): anotherTest.., relationship: uses pointcut, target: A1.anotherTest()asmRelMap entry: A1.afterReturning(): anotherTest.., relationship: advises, target: HelloClass.sayHello()asmRelMap entry: HelloClass.sayHello(), relationship: advised by, target: A1.afterReturning(): anotherTest..asmRelMap entry: A1.anotherTest(), relationship: pointcut used by, target: A1.afterReturning(): anotherTest..asmRelMap entry: A1.declare warning: ""test warning"", relationship: matched by, target: HelloClass.sayHello()I have other ways of looking at the structure model - I'm trying to work out ifthe data structure is incorrect inside AJ or just processed incorrectly by themethod you are calling. The way we get the relationships map is using:AsmManager.getDefault().getRelationshipMap();We then iterate through the entries. This turns out to be a long standing bug.The structure model relationships data is correct.The structure model node tree structure is missing a node.It should look like this:HelloClass.java  [java source file] [C:\temp\ajcSandbox\ajcTest55158.tmp\HelloClass.java|1|0|0]    import declarations  [import reference]    HelloClass  [class]        main(String[])  [method]      sayHello()  [method]          field-get(java.io.PrintStream java.lang.System.out) But the field-get node is missing at the moment.  Without that in there, theprocessRelationships code isn't doing what you think it is:String sourceOfRel = (String) iter.next();IProgramElement sourcePE = AsmManager.getDefault().getHierarchy()				.findElementForHandle(sourceOfRel);			List relationships = asmRelMap.get(sourcePE);In the case of the matched declare, the first call to iter.next() gets hold ofthe handle of the place matching the declare (which is inside the sayHello()method).  Then it calls findElementForHandle() which returns *the nearestmatching node* - so without the field-get node existing in the node structure,it gives you back the sayHello() method node - and then asmRelMap.get()retrieves the relationships for that node.  So twice you will be asking for therelationships on the sayHello() method and getting back the advised_by information.The rewritten aspect works because the 2nd piece of advice on the get(*System.out) method causes the field-get node to be created.I'm just testing the fix.You should be careful looking for the IJavaElement for a code node that you getback as the end of a relationship, like 'field-get(java.io.PrintStreamjava.lang.System.out)' - i'm not sure how you are currently handling them. Looks like you got this one Andy.This reminds me... we seem to be getting onto the golden path of transitioning from the ASM IHierarchy to the JavaModel.  I'll post a note about we might make our life easier with that to ajdt-dev. Fix checked in, waiting on build. fix available. "	2004-12-14 06:01:38	1103020000.0	resolved fixed	427c0d3	1103550000.0	weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java
80249	Order of types passed to compiler determines weaving behavior	Currently, the order in which you specify types when passing them to thecompiler can affect how they are woven:For example, if we have class A and class B extends A - Also, an aspect that'declare parents: A+ implements Serializable' then depending on whether we see Afirst, we may or may not make B serializable.The fix is that when we weave a type, we first weave its supertype then itssuperinterfaces (if they were also passed to the compiler).The problematic construct is declare parents - so we only process the types in aspecial order if there are declare parents around.  Also, because we can'tcurrently do decp when binary weaving, the order processing logic is only beingput into the source weaving pipeline. Fix checked in (see AJLookupEnvironment) - waiting on build. Fix available.BUILD COMPLETE -  build.406Date of build: 12/06/2004 13:43:55Time to build: 135 minutes 21 secondsLast changed: 12/06/2004 10:38:45Last log entry: Fixes for Bug 80249: Order of types passed to compilerdetermines weaving behaviorLatest good AspectJ jar available at:download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar 	2004-12-06 05:20:15	1102330000.0	resolved fixed	9052d5d	1102330000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java tests/decp/A.java tests/decp/AspectX.java tests/decp/B.java tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java
77163	Load time weaver default verbose setting	"The default setting for the load time weaver is (as of 1.2.1rc1) to produceweaving messages rather than ignore them.  I think the default should be changedto ignore them.  Also, I cannot override the default setting with -Daj.weaver.versose=""False"". This is the implied syntax from docs/examples/build.xml.  If this has changedthen build.xml should be updated.  Otherwise, the weaver should be fixed to use it! Correction.  I used -Daj.weaving.verbose=""False"" Created attachment 15623Fix to WeavingAdaptor and new tests1. New message handler which ignores WEAVEINFO messages by default2. New org.aspectj.weaver.showWeaveInfo system property to show WEAVEINFOmessages3. Replace all syserr/sysout with info/warning/error messages4. Improved exception handling5. New tests Patch integrated, waiting for build.... Fix available:BUILD COMPLETE -  build.391Date of build: 11/05/2004 14:19:22Time to build: 132 minutes 36 secondsLast changed: 11/05/2004 11:00:43Last log entry: Matthews fix for Bugzilla Bug 77163: Load time weaver defaultverbose settingLatest good AspectJ jar available at:download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jarAlso available in 1.2.1 final which will be released in about an hour... "	2004-10-27 20:09:52	1098920000.0	resolved fixed	edd6539	1099650000.0	weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java
77799	NullPointerException in StructureSearchManager	Calling Ajde.getDefault().getStructureSearchManager().findMatches(...)for an AspectJ project that has not been built results in a NullPointerExceptionin StructureSearchManager.findMatchesHelper(...) (line 58)Simple patch is attached. Created attachment 15650Simple patch that tests if var is null before accessing it Thanks for the patch Jurgen!  I have applied it and committed to CVS, so you should be able to see it if you update now. 	2004-11-04 01:48:22	1099550000.0	resolved fixed	aab9c2c	1099580000.0	ajde/src/org/aspectj/ajde/ui/StructureSearchManager.java
76798	Add versions to woven class files - enabling better backwards compatibility.	We don't currently include a version in the class files that come out of theweaver.  This can cause problems.  For example, if we add a new attribute to aclass file in a future version of AspectJ, then that attribute will cause olderversions of AspectJ to blow up if they encounter it.  If we include a version inthe class file we can rev the version number when we add attributes (or changethe class file form in another way), and by checking that version number in theweaver we can better determine whether we should fail if we encounter a newattribute (or other change), or if it is safe to continue processing.I will add a new WeaverVersion attribute that includes 2 shorts.  Major and Minor.Encountering a major version in a class file that is greater than the version aparticular weaver is designed to understand will cause compilation to fail.Encountering a minor version in a class file that is greater than the minorversion a particular weaver is designed to understand will not cause compilationto fail - we will assume it is safe to continue. fix checked in - waiting for build. fix available. 	2004-10-22 07:04:41	1098440000.0	resolved fixed	6aa7516	1098440000.0	weaver/src/org/aspectj/weaver/AjAttribute.java weaver/src/org/aspectj/weaver/bcel/BcelAttributes.java weaver/src/org/aspectj/weaver/bcel/BcelField.java weaver/src/org/aspectj/weaver/bcel/BcelMethod.java weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java
73895	unnecessary cast causing problems	"class: org.aspectj.weaver.ResolvedTypeX$Namemethod: isCoerceableFrom(..)I am having trouble with the line:ResolvedMember[] b = ((Name)other).getDeclaredMethods(); //??? is this castalways safeAs the comment suggests this cast is NOT always safe. In my case the cast is notsafe because I have some additional implementations for ResolvedTypeX (someoptimizations).Solution: just remove the cast since the method ""getDeclaredMethods"" is alreadydefined abstract in the type of ""other"" (ResolvedTypeX). So the cast seems to beobsolete anyway. cast removed. Martin's analysis is correct, and removing this cast cannot do anyharm. Fix is in 1.2.1. "	2004-09-14 13:08:41	1095180000.0	resolved fixed	8a64fa2	1098370000.0	weaver/src/org/aspectj/weaver/ResolvedTypeX.java
74952	before,after !(cflow(within(Trace*))) prints nothing	"Reference: ""cflow(within(C)) vs (within(C)||cflowbelow(within(C)) inaspectj-users mailing list.The aspect TraceClass below doesn't print any message when the pointcut isdefined to ""!cflow(within(Trace*))"". The other defintion ""!(within(Trace*) ||cflowbelow(within(Trace*)))"" works fine. Wes Isberg in his reply explained thatcflow should never be used alone but he thought ""there is a bug or two in here""class SomeClass {    static public void main (String [] args) {    }} // SomeClassaspect TraceClass {    // members    static private int level = 0;    static private void offset() {        int i;        for (i = 0; i < level; ++i) {            System.out.print(""  "");        }    } // offset    pointcut pc() :         !cflow(within(Trace*))//        !(within(Trace*) || cflowbelow(within(Trace*)))        ;    before () : pc() {        offset();        System.out.println(""-> "" + thisJoinPoint);        ++level;    }    after  () : pc() {        --level;        offset();        System.out.println(""<- "" + thisJoinPoint);    }} // TraceClassIn order to try to figure out what is happening within TraceClass, I added asecond aspect, TraceTrace, just to trace TraceClass.aspect TraceTrace {    // members    static private int level = 0;    static private void offset() {        int i;        for (i = 0; i < level; ++i) {            System.out.print(""  "");        }    } // offset    pointcut pc() : within(TraceClass);    before () : pc() {        offset();        System.out.println(""=> "" + thisJoinPoint);        ++level;    }    after  () : pc() {        --level;        offset();        System.out.println(""<= "" + thisJoinPoint);    }} // TraceTraceHere is what TraceTrace prints when TraceClass uses ""!cflow(within(Trace*))""=> staticinitialization(TraceClass.<clinit>)  => set(int TraceClass.level)  <= set(int TraceClass.level)  => preinitialization(TraceClass())    => initialization(TraceClass())      => execution(TraceClass())      <= execution(TraceClass())    <= initialization(TraceClass())  <= staticinitialization(TraceClass.<clinit>)The after advice is not executed for preinitialization. I use AspectJ Compiler 1.2 built on Friday May 21, 2004 at 15:06:22 GMTand java version ""1.4.2_01""Java(TM) 2 Runtime Environment, Standard Edition (build 1.4.2_01-b06)Java HotSpot(TM) Client VM (build 1.4.2_01-b06, mixed mode) <Pyinson Data Over Head> Fix available:BUILD COMPLETE -  build.387Date of build: 10/21/2004 21:05:26Time to build: 128 minutes 30 secondsLast changed: 10/21/2004 16:41:04Latest good AspectJ jar available at:download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar "	2004-09-24 11:04:58	1096040000.0	resolved fixed	a303a09	1098360000.0	tests/bugs/WhatsGoingOn.java tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java weaver/src/org/aspectj/weaver/bcel/BcelShadow.java
76096	Anonymous classes unaware of introductions into abstract classes (error can't find type $Local$)	"The example below generates a compiler error, on both Linux and Windows. Theerror occurs for ajdt (eclipse) as well.The compiler error:$ ajc -version> AspectJ Compiler 1.2 built on Friday May 21, 2004 at> 15:06:22 GMT> $ ajc ConcreteClassA.java> error can't find type $Local$> > /home/marin/tests/ConcreteClassA.java:18 error Class> must implement the inherited abstract method> InterfaceA.a2()> InterfaceA a = new AbstractClassA() {>                    ^^^^^^^^^^^^^> > 2 errors> --------> The example (in ConcreteClassA.java):interface InterfaceA { public void a1();  public void a2(); }abstract class AbstractClassA implements InterfaceA { public void a1() {  System.out.println(""AbstractClassA.a()""); } }public class ConcreteClassA extends AbstractClassA { public void someMethod() {  InterfaceA a = new AbstractClassA() {  }; } }aspect IntroAspectA { public void AbstractClassA.a2() {  System.out.println(""AbstractClassA.a2() from IntroAspectA""); }}------------If you comment out the body of someMethod() (the anonymous class), the codecompiles without errors. This was a problem in the AjProblemReporter code.  Before putting out the errorit checks if an ITD exists that would resolve the issue.  It used to attempt toresolve the type for the generated class that represented the anonymous type($Local$) - this obviously fails.  It now allows for anonymous types and checksfor ITDs on the parent of the anonymous type.  Tests added, fixed checked in. Will close when build available. Fix available.BUILD COMPLETE -  build.385Date of build: 10/19/2004 15:08:44Time to build: 230 minutes 55 secondsLast changed: 10/19/2004 11:37:35Last log entry: Fix for Bugzilla Bug 76096: Anonymous classes unaware ofintroductions into abstract classes (error can't find type $Local$)Latest good AspectJ jar available at:download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar Fix released as part of AspectJ 1.2.1 "	2004-10-12 12:17:35	1097600000.0	resolved fixed	6beb43f	1098180000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java tests/bugs/pr76096/ConcreteClassA.java tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java
75568	ajc changes classfile timestamps even if compilation fails (regression)	"It appears that ajc 1.2 updates a classfile timestamps even if the compilation fails. This breaks the integration with the Ant build system. E.g. using the ant ""javac"" task with the Ajc11CompilerAdapter interface, the compilation may fail on the first attempt and succeed on the second attempt, - because ajc has touched the timestamp and Ant hence decides that nothing needs to be recompiled.This did not happen in ajc 1.1.To reproduce:1. In the examples/observer folder, run a build: ajc -sourceroots . 2. Edit the ""Demo.java"" class and insert the line ""DONT COMPILE""3. Run the compilation again. The compiler displays the correct error message but the Demo.class file has been updated with the compile-time timestamp. I do not see this problem using ajc (rather than the Ant task). The behaviour would now seem to be consistent with javac i.e. we compile what we can. The timestamps remain unchanged for the classes that fail to be compiled. It is not peculiar to ""-sourceroots"" e.g. ""ajc observer/*.java"" has the same effect. When the syntax error in Demo.java is corrected everything is rebuilt.It seems the problem may lie in the adapter. I still cannot see that ajc is consistent with javac. E.g. create a standard java class, e.g. class Test {}  and store it in ""Test.java"". Then compile with javac:$ javac Test.java$ ls --full-time Test.class  -rwxrwxrwx    1 t539956  mkpasswd      182 Fri Oct 08 13:25:29 2004 Test.class*Then insert some syntax errors in Test.java and recompile with javac$ javac Test.javaTest.java:2: <identifier> expected  DONT_COMPILE;              ^Test.java:2: cannot resolve symbolsymbol  : class DONT_COMPILE  location: class Test  DONT_COMPILE;  ^2 errors$ ls --full-time Test.class -rwxrwxrwx    1 t539956  mkpasswd      182 Fri Oct 08 13:25:29 2004 Test.class*I.e. javac has not changed the Test.class timestampNow compile with ajc:$ ajc Test.javaC:\aspectj1.2\doc\examples\Test.java:2 [error] Syntax error on token ""DONT_COMPILE"", VariableDeclarator expected after this tokenDONT_COMPILE;^^^^^^^^^1 error$ ls --full-time Test.class  -rwxrwxrwx    1 t539956  mkpasswd      410 Fri Oct 08 13:28:40 2004 Test.class*Summary: ajc has changed the Test.class timestamp while javac has not.  I believe this is due to the lack of support for '-proceedOnError' which isclaimed to be a supported flag.  It seems to be defaulting to *ON* which meanswe write out files even if things go wrong.  I am just adding support for it nowso it will default to OFF unless you specify -proceedOnError. Two bugs:1) -proceedOnError is defaulting to ON regardless of what you pass in.2) -proceedOnError is ignored when deciding whether to do weaving.  We should gointo weaving even if there were compile errors *if* proceedOnError was set (seebug 74245).I have modified the options processing to take account of -proceedOnError - thevalue is stored in the buildconfig object.  I have also changed the decisionabout whether to weave to check the proceedOnError setting. Fix checked in, waiting for build. Fix available.BUILD COMPLETE -  build.383Date of build: 10/18/2004 23:39:49Time to build: 113 minutes 41 secondsLast changed: 10/18/2004 13:04:09Latest good AspectJ jar available at:download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar Fix released as part of AspectJ 1.2.1 "	2004-10-04 10:12:39	1096900000.0	resolved fixed	0a77939	1097760000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AspectJBuilder.java org.aspectj.ajdt.core/testdata/src1/C1.java org.aspectj.ajdt.core/testdata/src1/C2.java org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/AjdtBatchTests.java org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/ProceedOnErrorTestCase.java
74238	Applet which uses cflow pointcut gets AccessControlException	"When I used cflow pointcut for my applet, I couldn't launch the Applet.java.lang.ExceptionInInitializerError        at SandAspect.ajc$preClinit(SandAspect.aj)        at SandAspect.<clinit>(SandAspect.aj)        at SandApplet.init(SandApplet.java)        at sun.applet.AppletPanel.run(AppletPanel.java:353)        at java.lang.Thread.run(Thread.java:534)Caused by: java.security.AccessControlException: access denied (java.util.PropertyPermission aspectj.runtime.cflowstack.usethreadlocal read)        at java.security.AccessControlContext.checkPermission(AccessControlContext.java:269)        at java.security.AccessController.checkPermission(AccessController.java:401)        at java.lang.SecurityManager.checkPermission(SecurityManager.java:524)        at java.lang.SecurityManager.checkPropertyAccess(SecurityManager.java:1276)        at java.lang.System.getProperty(System.java:612)        at org.aspectj.runtime.internal.CFlowStack.selectFactoryForVMVersion(CFlowStack.java:124)        at org.aspectj.runtime.internal.CFlowStack.<clinit>(CFlowStack.java:59)        ... 5 moreIt because CFlowStack uses System.getProperty method with no try..catch block. Applet doesn't have permission to read system property:""aspectj.runtime.cflowstack.usethreadlocal"".workaround:modify CFlowStack.java(1.5) line 123,124 like this-----private static String getSystemPropertyWithNoSecurityException(  String aPropertyName, String aDefaultValue){  try{    return System.getProperty(aPropertyName, aDefaultValue);  } catch(java.lang.SecurityException e){    return aDefaultValue;  }}private static void selectFactoryForVMVersion() {  String override = getSystemPropertyWithNoSecurityException(    ""aspectj.runtime.cflowstack.usethreadlocal""    , ""unspecified""  );-----I think defining getSystemPropertyWithNoSecurityException(or moresimple name :-)) method in some utility class and using it where you callSystem.getProperty are better way. Assigning to Matthew.  The proposed solution looks good.  See related bug 71527. In that bug the raiser wanted a way to switch off the use of threadlocal - butafter reading this bug I think what they really meant in bug 71527 was theywanted a way to use cflow and not hit the security exception.   In the runtime we use 2 other access controlled APIs but do so safely:- Class.forName(): use of String argument version and avoid use of ""null"" class loader (see comment in SigantureImpl.makeClass()).- Class.getClassLoader(): use on self or class defining static join point object (which must be defined by a classloader at or below that used by the runtime which is OK).Should explore option to enclose calls to System.getProperty() in privileged blocks so that full function is availble when correct permissions granted. However must first explore implications for J2ME (which is the reason for the property query in the first place). Created attachment 14938Suggested fix and Ant-based testThe java.class.version property is not protected so only the first getPropertycall is replaced. The test can be replaced with a harness-based version when""fork"" is supported. Fix checked in.  I've added Charles Zhang to the CC list as he was havingproblems with this same bit of property checking code failing on J2ME.  Catchingthe security exception will now allow the code to proceed, it will beinteresting  whether it enables Charles' code to now run successfully on J2ME. I know ThreadLocal isn't available there but the cflow stuff in aspectjrt.jarshould be able to cope with that and fall back on the old non-threadlocalimplementation.Matthew do you want to migrate your test into the new forking harness?waiting for build .... Build available:BUILD COMPLETE -  build.383Date of build: 10/18/2004 23:39:49Time to build: 113 minutes 41 secondsLast changed: 10/18/2004 13:04:09Latest good AspectJ jar available at:download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar Fix released as part of AspectJ 1.2.1 "	2004-09-19 05:51:49	1095590000.0	resolved fixed	6e155a6	1097740000.0	ajde/testdata/SecurityManagerTest/src/HelloWorld.java runtime/src/org/aspectj/runtime/internal/CFlowCounter.java runtime/src/org/aspectj/runtime/internal/CFlowStack.java
72157	declare soft can cause programs with invalid exception behaviour to be generated	"Compiling the program below results in the constructor for the class SCE2throwing Exception, which it is not declared to throw either in the source codeor in the generated bytecode. If the 'declare soft' statement is removed, thenthe super() call in the SCE2 constructor is correctly reported as throwing anundeclared exception; it seems that the 'declare soft' statement turns off theexception checking of the super() call despite there being no join point whichcovers this call that would actually soften the exception.I'm using 'DEVELOPMENT built on Monday Aug 16, 2004 at 13:50:47 GMT'.public class SuperConsExc {    public SuperConsExc() throws Exception {	throw new Exception();    }    public static void main(String[] args) {	new SCE2();    }}class SCE2 extends SuperConsExc {    public SCE2() {	super();    }}aspect SCEAspect {    declare soft: Exception: within(SCE2);} marked as target 1.2.1 This program looks like it is behaving correctly to me?within(SCE2) matches the execution join point for SCE2.new(), and softens exceptions that occur during its execution.Consider the analogous program (which eliminates the super() call confusion):class Foo {  public void foo() throws Exception {    throw new Exception();  }  public void goo() {    foo();  }}This will give an unhandled exception compilation error as is, but if you adddeclare soft : Exception : execution(* goo(..));it will compile happily. In your example, the thrown Exception actually does get softened; but in myexample it doesn't, leading to a checked exception being thrown at runtime by amethod not declared to throw it.The super() call is crucial to my example, because the problem is that theexecution join point for a constructor does not cover the super() call. Got it, thanks. Should have read more carefully. Have re-opened bug.Interesting problem since:class Foo {  Foo() {}}class Boo extends Foo {  Boo() {   try {     super();   } catch(Error e) {}  }}is not a valid program. Therefore the correct behaviour must be to NOT soften the exception, which is consistent with the definition of execution join points as beginning after the super call. Fix in tree. Waiting for development build before closing. Fix now available for download. Fix released as part of AspectJ 1.2.1 "	2004-08-18 06:39:42	1092830000.0	resolved fixed	eca1429	1094650000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java tests/bugs/ConvertToUnchecked.java tests/bugs/PR72157.java tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java
73433	AspectJ does not correctly support -cp	Discovered by Andy Brodie.-cp is a shorthand for -classpath supported by the JDT compiler.  AspectJ doesnot correctly support -cp option.  Look at this example:C:\aspectj1.2>ajc -inpath injar.jar -outjar outjar.jar -cp lib\aspectjrt.jar[error] can't find type org.aspectj.lang.JoinPoint1 errorC:\aspectj1.2>ajc -inpath injar.jar -outjar outjar.jar -classpath lib\aspectjrt.jarThis is due to the arg parser in AspectJ only recognizing -classpath.  Itdoesn't fail when it encounters -cp, it just ignores it and passes it down toJDT for processing.  The fix is to recognize -cp too. Fix checked in - waiting for build. Fix available:BUILD COMPLETE -  build.374Date of build: 09/08/2004 14:21:24Time to build: 105 minutes 21 secondsLast changed: 09/08/2004 13:05:10Latest good AspectJ jar available at:download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar Fix released as part of AspectJ 1.2.1 	2004-09-08 05:46:09	1094640000.0	resolved fixed	8e4d898	1094640000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java
73334	Avoid clashes in the org.eclipse namespace by renaming our duplicates.	We have recently renamed our 'copy' of BCEL to use a different package prefix sothat our version never clashes with another version that might be around on ausers system.This enhancement is to do the same thing for our 'copy' of the org.eclipse.jdtcode (in the shadows project).  As part of packaging the shadows project tocreate the 'jdtcore' jar files (bin and src) we will rename the packages from:org.eclipse.jdt.***toorg.aspectj.org.eclipse.jdt.**This has a really nice side effect that we can make our version of the compileraccessible in the IDE.  It should now be possible for AJDT to work more closelywith it and get features like eager parsing to work.Care will be taken that we don't accidentally make the merge process a nightmare. Implementation checked in.  See build.xml in the shadows for the new targetsthat do the package transforms.  waiting on successful build ... Fix available:BUILD COMPLETE -  build.371Date of build: 09/07/2004 12:33:43Time to build: 101 minutes 39 secondsLast changed: 09/07/2004 11:47:45Latest good AspectJ jar available at:download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jarI have not changed the package names of any eclipse classes that we just dependon.  I've only changed the package names of classes that we have a copy of inour source tree (so org.eclipse.jdt.*) Fix released as part of AspectJ 1.2.1 	2004-09-06 11:41:58	1094490000.0	resolved fixed	b133299	1094490000.0	ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java ajde/testsrc/org/aspectj/ajde/BuildConfigurationTests.java ajde/testsrc/org/aspectj/ajde/ExtensionTests.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/AjdtCommand.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/compiler/IAjTerminalSymbols.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/core/AspectJCore.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjClassFile.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ClassFileBasedByteCodeProvider.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/IOutputClassFileNameProvider.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/InterimCompilationResult.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverAdapter.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverMessageHandler.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AdviceDeclaration.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AjConstructorDeclaration.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AjMethodDeclaration.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectClinit.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AstUtil.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/DeclareDeclaration.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/EclipseAttributeAdapter.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/IfMethodDeclaration.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/IfPseudoToken.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterSuperFixerVisitor.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterSuperReference.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeConstructorDeclaration.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeDeclaration.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeFieldDeclaration.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/KnownFieldReference.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/KnownMessageSend.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/MakeDeclsPublicVisitor.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PointcutDeclaration.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PointcutDesignator.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/Proceed.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ProceedVisitor.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PseudoToken.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PseudoTokens.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/SuperFixerVisitor.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ThisJoinPointVisitor.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjTypeConstants.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseScope.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseShadow.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceLocation.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseTypeMunger.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/HelperInterfaceBinding.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InlineAccessFieldBinding.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeFieldBinding.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeMemberFinder.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeMethodBinding.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeScope.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/PointcutBinding.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/PrivilegedFieldBinding.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/PrivilegedHandler.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/SimpleSyntheticAccessMethodBinding.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/parser/DeclarationFactory.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBatchImageBuilder.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildNotifier.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjIncrementalImageBuilder.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmElementFormatter.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AspectJBuilder.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseAdapterUtils.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseClassPathManager.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseSourceContext.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/StatefulNameEnvironment.java org.aspectj.ajdt.core/testsrc/WeaveTests.java org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/AjdtCommandTestCase.java org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AjCompilerOptionsTest.java org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AsmBuilderTest.java
72671	Bootclasspath specification for compiling is not possible	"I have following bug running  eclipse 3.0 and ajdt 1.1.12I have following class: import java.io.FileNotFoundException;import java.io.FileOutputStream;import org.w3c.dom.DOMConfiguration;import org.w3c.dom.DOMError;import org.w3c.dom.DOMErrorHandler;import org.w3c.dom.Document;import org.w3c.dom.DocumentFragment;import org.w3c.dom.NodeList;import org.w3c.dom.ls.DOMImplementationLS;import org.w3c.dom.ls.LSInput;import org.w3c.dom.ls.LSOutput;import org.w3c.dom.ls.LSParser;import com.dcbank.common.DOMImplementationLSSingleton;public class DOMHelper {   public static final String CLASS_ID = ""%full_filespec:DOMHelper.java~1:java:1 %"";      public static void save(Document document, String filename)   throws ClassNotFoundException, InstantiationException,  IllegalAccessException, FileNotFoundException {         document.normalizeDocument();   }}which compiles very fine with JDK 1.4.2_02 on Windows XP, as soon as the  dom2-xml-apis.jar and dom3-xercesImpl.jar are added at thebeginning of the jre container, or are included inthe jar-library list before the system jar. As soon as I convert this project to an AspectJ project, the code does notcompile anymore. The aspectJ compiler does not find the  normalizeDocument,which is included in the one of the two additional jars.method any more.kind regardsArno Schmidmeier We have reproduced the problem and are investigating further. The conversion toan AspectJ project does appear to be changing the order of entries on theclasspath so that the dom jars end up after the JRE ones. Hello,I do not believe that this is a bug in the conversion of the project, as the same issue seems to appears if I set up the project as an AspectJ-project from the beginning.I expect it is a problem in the bootclasspath handling of Ajdt/AspectJ.I can compile it from the command line directly but not from the ajc batch script.following command do work on NT:C:\j2sdk1.4.2_02\jre\bin\java -Xbootclasspath:%BP% -classpath %ASPECTJ_HOME%\lib\aspectjtools.jar;%JAVA_HOME%\lib\tools.jar;%CLASSPATH% -Xmx64M org.aspectj.tools.ajc.Main DOMHelper.javakind regards  Arno You can pass a bootclasspath option directly to the AspectJ compiler (ajcscript), the flag is -bootclasspath instead of -Xbootclasspath. There is no GUI in AJDT for specifying this bootclasspath option to the AspectJcompiler, but there is at least a textfield you can use: right-click on theproject and select properties, then the ""AspectJ"" tab. You can then use the ""nonstandard compiler options"" field to type in the -bootclasspath settings you need.We'll consider further if there is more we can do in this situation. We believe we've now fixed this. The fix is in two parts: one, which was handledseparately in bug 73035, was to change the build classpath of aspectj projectsso that it matches that of java projects, and the order of entries matches thedefined order in the build properties. The other part of the fix was to changeajde so that a fixed bootclasspath is not passed to the ajc compiler, so thatthe jre jars from the regular classpath are used, in the right order.Either way of putting the dom jars ahead of the jre ones should now work,although I'd recommend changing the project classpath appropriately, inpreference to redefining the contents of the jre itself.The fixes will be available in the next release of AJDT. We are also starting topublish development builds if you want to try it out before then. I'll adddetails here of where to get this from once we have a suitable build. Fixed. A development build containing the fix is now available via the followingupdate site: http://download.eclipse.org/technology/ajdt/30/dev/update/ "	2004-08-26 06:56:09	1093520000.0	resolved fixed	d1551bd	1094480000.0	ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java
72528	around advice throws java.lang.VerifyError at runtime	"I have an aspect that captures around() a pcd and returns an Object[], thoughthe actual methods being instrumented might return any valid POJO array, iunderstand that AspectJ will take care of casting at assignment.I expected the following code to work properly, but at runtime i get ajava.lang.VerifyError as shown below:F:\wd\Hello>ajbrowser HelloWorld.lstjava.lang.VerifyError: (class: de/rohith/PrinterWorld, method: returnArrayWithCloning signature: ()[Ljava/lang/Integer;) Incompatible argument to function        at de.rohith.HelloWorld.main(HelloWorld.java:18)Exception in thread ""main""I suspect the compiler fails to notice the return types of the methods beingcaught at compile time.I have tested this code with both ajbrowser as well as AJDT, both result in thesame error output.-----------HelloWorldAspect.java---------------package de.rohith;import java.lang.Object;public aspect HelloWorldAspect {    	private int callDepth = -1;    public HelloWorldAspect() {    }        pointcut hello(): !within(HelloWorldAspect);        pointcut method(): execution(public (*[]) de..*(..));        pointcut cloning(): call(* java.lang.Object.clone());    declare warning: method() && hello(): ""*[] returning method called"" ;        Object[] around(): cflow(method()) && cloning() && hello() {    	print("""", thisEnclosingJoinPointStaticPart);    	Object[] ret = proceed();     	return (Object[])ret.clone();    }    private void print(String prefix, Object message) {        for (int i = 0, spaces = callDepth * 2; i < spaces; i++) {            System.out.print("" "");        }        System.out.println(prefix + message);    }}-----------PrinterWorld.java------------package de.rohith;public class PrinterWorld {	private Integer[] intArray = new Integer[2];	public PrinterWorld() {			}    public void print() {        System.out.println(""Hello World!"");     }        public Integer returnInt() {    	return new Integer(3);    }        public Integer[] returnArrayWithCloning() {    	for (int i = 0; i < intArray.length; i++) {			intArray[i] = new Integer(i++);		}    	return (Integer[])intArray.clone();    }        public Integer[] returnArrayWithoutCloning() {    	return intArray;    }}-----------HelloWorld.java------------package de.rohith;public class HelloWorld {    public static void main(String[] args) {        PrinterWorld p = new PrinterWorld();        p.print();         Integer i = p.returnInt();        Integer[] intArray = p.returnArrayWithCloning();        Integer[] array2 = p.returnArrayWithoutCloning();    }} Created attachment 14155Contains all the classes to reproduce this bug This is almost certainly related to the bug in the handling of [] in type patterns, as reported in bug 72531. Any verify error is serious and we will fix this in the 1.2.1 release. I'll post to this bug report as soon as a fix is available for download from the AspectJ download page. This turns out to be a really interesting bug. The problem is that in 'marshalling' the parameters to call the around body, ajc gets confused and thinks that the target of the call (the intArray) is a Foo, and generates a line of code of the form:Foo foo = intArray;this is what causes the verify error.This is all wrapped up in the special treatment of array types and of the clone method. Note that clone() is redefined for an array type, to be public (you can't just call clone on an arbitrary Object), and to return a shallow copy of the array. But where does this special redefinition of the clone() method happen (in which type??). It's this unique combination of factors - a redefined method on a 'special' type that is causing the confusion. I'm off to spend some time reading in the JVM and JLS specs to see what they have to say on the topic before deciding on the right fix....  JSL 10.7..... this is not the first time those magical JLS 10.7 array members cause trouble.We're already special casing the length field somewhere (actually, it's more special since it is represented in bytecode by the ARRAYLENGTH bytecodeand not by a field at all).   related to Bug 67665  I understand from JLS 10.7 that it is unclear what type represents an array typeat runtime, but if this bug is related to Bug 67665 then i think the basicassumption that AspectJ supports all the Java types fails. According to JLS10.1, an array is a Java type. Another reason i would assume that arrays aresupported as types is in ""AspectJ 1.1 quick refernce"" among TypePat it clearlymentions that it accepts an array type. when I said it was related to Bug 67665, I meant that I raised_implementation_ issues of treatment of .length and .clone() there, and that there are some cleanup issues witharray syntax there as well.  I don't think 10.7 is at all unclear about what types represent at runtime.Array types are types.  They have some methods and one field.  We need to capture calls to those methods (and accesses and assignments to that field)as join points.  Nobody is talking about language changes here.  We'retalking about fixing a bug, and I noted that array treatment in generalis a place where we've had bugs before. Ok - fix checked in.  What I've done is what we thought we'd have to do.  Whenwe grab the target for a method-call shadow and we recognize it as being one ofthese nasty clone calls on Object, I have a quick look before the shadow to seewhat the 'thing' is on the stack.  There are a number of possibilities (that Ihave captured in the testcase), basically we might encounter:- a load instruction, in which case we ask the instruction what type it isworking with (querying the local variable tag) and this helps us work out thatit is an array.- a field access instruction, in which case we ask the field what type it is.- a anewarray instruction, in which case we *know* its an array (although whyanyone would write '(Integer[])new Integer[5].clone()' I dont know!)- a multianewarray instruction, in which case *know* its an array.I've put a lot of guards in so that we don't do this extra processing unless itmeets the criteria of being this nasty case.  It will also blow up if itencounters an instruction other than those expected when trying to determine thereal type of the target - if we didn't blow up then we would fail later atverify time.its a bit messy but I think it is quite a robust solution. I can't look at the code right now, but two reactions to the solution description:* the localVariable tag won't work at all if someone has stripped off debugginginformation.  Whatever solution we have should perhaps work better if we havedebugging info, but better not generate a bad classfile if we don't.* even if we're lucky enough to have debugging information, ?: can surprise you  ((testA ? exp0 : exp1) (testB ? exp2 : exp3) (testC ? exp4 : exp5)).clone() Hi Erik.  Yes, I hadn't thought about them stripping that debug info off.  I just couldn't think of a nicer solution to this problem (unless we saycompiler restriction).  I believe that at least now we will fail at compile timerather than runtime.  Did you have a nicer fix in mind for this?  My first gowas to try and generate the code that looked like this:public static final Object clone_aroundBody0(X x, Object y) {  if (y instanceof Object[]) {    return ((Object[])y).clone();  } else {    return y.clone();  }}but that still fails verification because 'return y.clone()' exists in the bytecode.I then thought well - is the only time we will ever try and create a method likethis:public static final Object clone_aroundBody0(Object y) {  return y.clone();}when the clone was originally on an array type.  If its true then in this casewe could always produce:public static final Object[] clone_aroundBody0(Object[] y) {  return (Object[])y.clone();}but I wasnt sure if that was one assumption too far? Yeah, I see your point.  The proposed solution we had was worse, too, since  ((Object) new int[3]) instanceof Object[]is false.  I'm still worried about the fragility of this solution withoutdebugging info, but there it is.This is exactly the case where a separate set of people working on the AspectJsemantics might come up with a better solution that we could then steal if thecurrent one turns out to be too fragile in practice *grin*.We should probably close this as fixed. I'm going on holiday at the weekend for two weeks and want to write down my lastminute thoughts on this bug so I don't forget them whilst I'm in the Maldives. I may not get to finishing this bug off before I go.The oxford guys didn't seem to think a 1.4 compiler should still be producingthe 'Object.clone()' bytecode, they seemed to think the one they are using isproducing the right '<arraytype>.clone()' bytecode.  I need to check if this isreally the case.  It could be a bug in the Eclipse compiler so I need to checkit on SUN and IBM 1.4 compilers. (And check the polyglot compiler they use?)I do think my current solution will fail at compile time if we can't determinethe actual type on which clone() is called - but if there is no debuginformation I don't think it will fail in a nice way - it will fail with an NPEas I'm assuming the local variable tag is found.  It should gracefully fail ifthe tag is missing. not useful targetting 1.2.1 not planning to do any more with this for now... basic verifyerror was fixed long ago. "	2004-08-24 14:21:34	1093370000.0	resolved fixed	27d204c	1094220000.0	tests/bugs/ArrayCloning.java tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java weaver/src/org/aspectj/weaver/ResolvedTypeX.java weaver/src/org/aspectj/weaver/bcel/BcelShadow.java
46298	Aspectj generate code does not de-compile cleanly.	"<Pyinson Data Over Head> Created attachment 6699Source to re-produce problem. Created attachment 6700Source to re-prodcue problem. Created attachment 6701Decompiled output. Created attachment 6702Decompiled output. Adding this to 1.2 plan as a placeholder to spend some effort to see what we can do if anything to improve existing decompiler toleration of ajc generated code.The long term solution is to build an AspectJ decompiler. This is not currently in plan (and wouldn't actually help Ron here since I recall from discussion that the reason for decompiling is to understand what ajc is generating, and an AspectJ decompiler should decompile back to AspectJ source). Anywhere we generate handlers, we need the load/store combo to keep the decompilers happy (see the JRocket fix)... Yuck, this is a nasty problem - nastier than the JRockit issue as it isnt really related to *generating* new handlers so much as instrumenting existing ones.  Help, jim, can you tell me what you think about this...Here is what I have found.Here is a simple version of Rons code that shows the problem:class ExceptionCatcher {  RuntimeException re = new RuntimeException();  public void catchException() {    try {      throw re;    } catch (Exception e) { }  }	  public static void main(String[] args) {    new ExceptionCatcher().catchException();  }}aspect ExceptionHandler {  before(): handler(*) {    System.out.println(""Starting before block"");  }}If I compile this, I am basically adding advice to the start of the catch block.  If I jad the resulting ExceptionCatcher then it fails as Ron describes.  A javap -c ExceptionCatcher reports:public void catchException();  Code:   0:   aload_0   1:   getfield        #16; //Field re:Ljava/lang/RuntimeException;   4:   athrow   5:   nop   6:   invokestatic    #38; //Method ExceptionHandler.aspectOf:()LExceptionHandler;   9:   invokevirtual   #41; //Method ExceptionHandler.ajc$before$ExceptionHandler$1$768387dd:()V   12:  pop   13:  return  Exception table:   from   to  target type     0     5     5   Class java/lang/ExceptionNotice where the 'pop' instruction is.Now, if I try and create a piece of Java that simulates what ajc is doing:class ExceptionCatcher {  RuntimeException re = new RuntimeException();  public void catchException() {    try {      throw re;    } catch (Exception e) {       ExceptionHandler.aspectOf().ajc$before$ExceptionHandler$1$768387dd();    }  }	  public static void main(String[] args) {    new ExceptionCatcher().catchException();  }}And then I compile that with ajc (no aspect is included in the compilation step), then I get a new version of ExceptionCatcher that jads successfully.  The bytecode is:public void catchException();  Code:   0:   aload_0   1:   getfield        #16; //Field re:Ljava/lang/RuntimeException;   4:   athrow   5:   pop   6:   invokestatic    #27; //Method ExceptionHandler.aspectOf:()LExceptionHandler;   9:   invokevirtual   #30; //Method ExceptionHandler.ajc$before$ExceptionHandler$1$768387dd:()V   12:  return  Exception table:   from   to  target type     0     5     5   Class java/lang/ExceptionNotice that the pop instruction in this case is before the call to the aspect method.I had originally thought the fix might be to move the shadow start point for the handler by one instruction (over the pop) but that causes a bit of a mess in the harness tests. Right, some progress - I think I can see that the method I'm interested in is BcelShadow.prepareForMungers() which messes with the exception handler code, inserting the NOP amongst other things. After Miks demo earlier today at AOSD, I asked Erik what he thought about this bug.  He said:proposed fix:AspectJ should pattern match between START OF HANDLERpopSTART OF HANDLERpushif we expose the exception, we need to delete the pop if it's thereif we don't, we should just insert code _after_ the pop.=====I *hope* to get this in before 1.2 final. This turns out to be more complicated ... as these things do.prepareForMungers() looks at the shape of the handler and inserts a NOP (I assume to use as the shadow to munge).  I can adjust prepareForMungers() to insert the NOP after the POP (using what Erik described and optionally including the POP instruction when identifying a handler join point).  But if I do that then at the point we do the munging, I need to perhaps delete the POP depending on whether the exception is being used in the advice being woven.  I can determine if the exception is being used, but deleting the POP seems tricky.  At the point we do the munging the start of the shadow is the NOP, and jumping to a previous instruction seems to move me outside of the shadow - and I don't think I want to start affecting code 'surrounding' the shadow ??   I don't have a decompiler to play with, so all of these suggestions are untested.  You should be careful fixing this bug as the last thing we want is to generate truly invalid bytecode just to make broken decompilers happier.The first thing that I'd try is to call initializeArgVars() at the end of the ""else if (getKind() == ExceptionHandler) {"" block in prepareForMungers().  This call will force the use of a frame slot to hold the exception value and the added store instruction will mean that the value isn't kept on the stack during the advice.After doing this, you'll still have an ALOAD/POP combo just outside the shadow for cases where the exception isn't used in the original handler.  If this still bothers the decompiler, you can try to remove it at the end of prepareMungers().  At the end of that method there's a block for ""if (getKind().argsOnStack() && argVars != null) {"".  You could add a special case to the beginning of this block to check for an ExceptionHandler shadow type AND a first instruction outside the shadow that's a POP.  In that case you want to remove the POP and NOT generate the args. Ok - I've implemented a fix based around what Jim was suggesting.  (I must saythis seemed easier to do having 3 months more compiler experience than when Ilast posted on the bug!).  All changes in BcelShadow.prepareForMungers()We currently shove in a 'NOP' when preparing an exception handler for munging. This is to give us an anchor when we insert extra instructions that exposecontext for use in the advice.  This confuses the decompiler as it wants toeither see a POP or an ASTORE as the first instruction in the handler code.  SoI've removed the NOP and made it always do a STORE to stick the stack contentsinto a local variable - which we may or may not use the value of.  Effectivelywhere we were optionally storing the value on the stack (the caught exception),we now always store it but may not use it.Once the STORE is in the right place we rework the exception ranges to includeour new instruction. (They need to point to it rather than to the instructionafter it).The other piece of the fix is to repair the stack as we exit the handler. Normally we stick in an ALOAD after the advice so the stack is ready for use bythe actual code originally written in the catch block.  However, in the case weare looking at here, the first instruction in the real catch block is a POP asthe exception is never used.  It is redundant to generate an ALOAD and thenexecute a POP - and it confuses decompilers.  So in the case where we have donethis clever ASTORE business (i.e. we are a handler shadow), we check if the nextinstruction is a POP.  if it is then we don't generate the ALOAD and splat thePOP with a NOP (easier to replace the POP than remove it with all the targetermanagement that would be involved).If we now compile the sample program:class ExceptionCatcher {  RuntimeException re = new RuntimeException();  public void catchException() {    try {      throw re;    } catch (Exception e) { }  }	  public static void main(String[] args) {    new ExceptionCatcher().catchException();  }}aspect ExceptionHandler {  before(): handler(*) {    System.out.println(""Starting before block"");  }}We get this bytecode:public void catchException();  org.aspectj.weaver.MethodDeclarationLineNumber: length = 0x4   00 00 00 05  Code:   Stack=1, Locals=2, Args_size=1   0:   aload_0   1:   getfield        #16; //Field re:Ljava/lang/RuntimeException;   4:   athrow   5:   astore_1   6:   invokestatic    #39; //Method ExceptionHandler.aspectOf:()LExceptionHandler;   9:   invokevirtual   #42; //MethodExceptionHandler.ajc$before$ExceptionHandler$1$768387dd:()V   12:  nop   13:  return  Exception table:   from   to  target type     0     5     5   Class java/lang/ExceptionAt instruction #5 you can see the new ASTORE_1. At instruction #12 you can see where we replaced the POP with a NOP.In the exception table you can see the target is our new ASTORE_1.And it decompiles just fine.(I also fixed the common singleton version of the aspectOf() method so that itdecompiles cleanly - I haven't investigated decompilation of the variants ofthis method created when using per clauses)I'll close the bug when the fix is available. Fix available:BUILD COMPLETE -  build.371Date of build: 09/07/2004 12:33:43Time to build: 101 minutes 39 secondsLast changed: 09/07/2004 11:47:45Latest good AspectJ jar available at:download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar Fix released as part of AspectJ 1.2.1 "	2003-11-07 14:40:53	1068230000.0	resolved fixed	4921f0c	1094050000.0	weaver/src/org/aspectj/weaver/bcel/BcelShadow.java
49743	performance improvements for runtime library	"I am heavily using the runtime signature information fromthisJoinPoint.getSignature() and the toString() method of it. This causes heavyString operations each time the toString method is called. Would it be possibleto cache the resulting string for example in MethodSignatureImpl and similarclasses for other signatures? We will try to do this change after the benchmark suite is implemented so we will have a better grasp on the runtime performance gain and the static memory usage overhead of the change. Matthew, do we have a suite to understand the possible footprint / performance trade-offs here? If this enhancement makes sense under test, then let's put it in... The ""toString()"" cache will add a new reference to every Signature object. There are concerns about footprint in large systems: bug 59076. Therefore the reference must be shared by each of the toString implementations: short, middle, long. Also the cache must be soft so that GC can collect the String when no need.We should also endeavour to make this feature footprint-neutral by saving some memory elsewhere. Each SJP has a SourceLocation as well as a Signature. The column property is deprecated. Removing it and always returning -1 will save an ""int"". Created attachment 14146toString caching1. For Signature objects the results of to/toShort/toLongString are cachedsoftly.2. Simple testcase3. Performance testcase4. Redundant/deprecated ""col"" field removed from SourceLocation Matthews code integrated.  I will close the bug when it is available in a build. fix available:BUILD COMPLETE -  build.371Date of build: 09/07/2004 12:33:43Time to build: 101 minutes 39 secondsLast changed: 09/07/2004 11:47:45Latest good AspectJ jar available at:download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar Fix released as part of AspectJ 1.2.1 "	2004-01-08 17:37:54	1073600000.0	resolved fixed	438e61c	1094030000.0	runtime/src/org/aspectj/runtime/reflect/AdviceSignatureImpl.java runtime/src/org/aspectj/runtime/reflect/CatchClauseSignatureImpl.java runtime/src/org/aspectj/runtime/reflect/ConstructorSignatureImpl.java runtime/src/org/aspectj/runtime/reflect/Factory.java runtime/src/org/aspectj/runtime/reflect/FieldSignatureImpl.java runtime/src/org/aspectj/runtime/reflect/InitializerSignatureImpl.java runtime/src/org/aspectj/runtime/reflect/MethodSignatureImpl.java runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java runtime/src/org/aspectj/runtime/reflect/SourceLocationImpl.java runtime/src/org/aspectj/runtime/reflect/StringMaker.java runtime/testsrc/RuntimeModuleTests.java runtime/testsrc/org/aspectj/runtime/reflect/RuntimePerformanceTest.java runtime/testsrc/org/aspectj/runtime/reflect/SignatureTest.java
72699	Bogus error message: The abstract method ajc$pointcut$$tracingScope$a2 in type Tracing can only be defined by an abstract class	"When attempting to compile the following aspect the resulting error message should say something like ""The abstract method pointcut tracingScope in type Tracing can only be defined by an abstract aspect""public aspect Tracing {	public abstract pointcut tracingScope();} I have fixed this case and the related case ofpublic class Tracing  public abstract pointcut tracingScope();}Which was also resulting in crap error messages.  I haven't fixed the message asproposed in the bug report, I have fixed it properly to be""The abstract pointcut tracingScope can only be defined in an abstract aspect""This involved:In pointcutdeclaration.postParse() I had to produce the correct error message.In AjProblemReporter I have to override abstractMethodInAbstractClass and makesure we don't report problems on methods arising from pointcut declarations(since postParse is already putting out the right message).Fix checked in, waiting for build. Fix available: BUILD COMPLETE -  build.364Date of build: 08/27/2004 22:17:38Time to build: 95 minutes 15 secondsLast changed: 08/27/2004 17:02:18Latest good AspectJ jar available at:download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar Fix released as part of AspectJ 1.2.1 "	2004-08-26 11:46:30	1093540000.0	resolved fixed	5e08765	1093610000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PointcutDeclaration.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java tests/bugs/BogusMessage.java tests/bugs/BogusMessage2.java tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java
72150	AJC possible bug with static nested classes	"AJC fails to find nested static classes during binary-weaving analysis if the classes have been previously compiled with J2SE5.0 javac compiler with options: -source 1.5/ - target 1.5Note, that the nested static classes are not necessarily subject to bytecode weaving - AJC merely fails to detect them in the JARS for its analysis.This issue disappears when the .java sources are pre-compiled with -source/target 1.4, regardless if the javac compiler comes from the J2SE1.4 or J2SE5.0 distribution.This issue is distinct form Bug #71548, since no 5.0 source code processing is required from AJC ever.Thanks,Hristo Hristo, can you send me a built jar that fails binary weaving?  I will try andrecreate it here too.Andy. Hi,We have just built a version of AspectJ that includes some rudimentary dumpsupport - this allows us to collect diagnostic information when things go wrong. I'd like to try it out for the first time on this bug.  The version of AspectJrequired is available here (the usual place):BUILD COMPLETE -  build.356Date of build: 08/23/2004 16:06:44Time to build: 125 minutes 0 secondsLast changed: 08/23/2004 14:40:33Latest good AspectJ jar available at:download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jarPlease can you retry your failing Java 1.5 scenario with this version.  AND inorder to cause it to dump on error (it normally just dumps on abort), you willneed to set this property:org.aspectj.weaver.Dump.condition=errorIf that works then when the compiler finishes after reporting your 'Cant findtype' message it will produce an ajcore.XXX file on the disk (XXX is a date/timestamp).  Can you send me the ajcore file?  That will enable me to tell whichroute to can't find type is having problems with the 1.5 generated code.many thanks. <Pyinson Data Over Head> Thanks for that ajcore Hristo, it really helped!Some progress.  The problem appears to be the bytecode generated for a call toclone() on an array type.  I notice that you make a call:return (DataStoreFactorySpi.Param[])PARAMS_ARRAY.clone() in PERSTDataStoreFactory.getParametersInfo()The bytecode generated differs between 1.4 and 1.5.  Under 1.4 it becomes aninvokevirtual #50: //Method java/lang/Object.clone():()Ljava/lang/Object;Under 1.5 it becomes:invokevirtual #45: //Method""[Lorg/geotools/data/DataStoreFactorySpi$Param;"".clone:()Ljava/lang/Object; Without suitable documentation available on what the changes are from 1.4/1.5 -we believe this is a bug fix that sun has made.  In 1.4 they were incorrectlymaking the clone call against type Object.  In 1.5 they now make the clone callagainst the array type.The fix is as follows. In TypeX where we convert a name to a signature(nameToSignature()) - we were incorrectly converting ""[LB$D;"" into ""L[LB$D;;"". We weren't checking if it was already valid (in fact there is a comment innameToSignature() that said it ought to be doing more checking).  It now doesnot incorrectly alter the array signature - this fixes the cant find type message.Yesterday, Erik talked about whether getDeclaredMethods() on ResolvedTypeX.Arrayshould return the clone() method (it doesn't at the moment).  I have not neededto change it in order for my testcase to pass. Fix checked in - waiting for build.many thanks to Hristo for using a few development builds to help track down thisbug. Fix available:BUILD COMPLETE -  build.364Date of build: 08/27/2004 22:17:38Time to build: 95 minutes 15 secondsLast changed: 08/27/2004 17:02:18Latest good AspectJ jar available at:download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar Closing bug as fixed - please reopen Hristo if the fix doesn't work for you ... Fix released as part of AspectJ 1.2.1 "	2004-08-18 03:27:01	1092810000.0	resolved fixed	b5e6307	1093600000.0	tests/bugs/java5/arrayCloning/A.java tests/bugs/java5/arrayCloning/C.java tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java weaver/src/org/aspectj/weaver/TypeX.java
72531	declare warning warns at wrong points	"I have a ""declare warning"" declaration that warns on usage of any method thatreturns an array of any POJO type, this should point to the methods that inreality return an array, but i see warnings at points other than these arrayreturning methods, and also those that have void in their signature. In theattached files i get a warning at statements like:>        PrinterWorld p = new PrinterWorld();[in main()method]>        System.out.println(""Hello World!""); >    	 return new Integer(3);and these being the first/only lines in their respective methods. Created attachment 14156Contains all the classes to reproduce this bug With the fix for bug 37020, the declare warning statements at least now report the correct lines (the previous behaviour was to report the line number of the first bytecodes in the body of the method), giving the output below:C:\temp\de\rohith\HelloWorld.java:4 [warning] *[] returning method calledpublic static void main(String[] args) {^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^        method-execution(void de.rohith.HelloWorld.main(java.lang.String[]))        see also: C:\temp\de\rohith\HelloWorldAspect.java:17C:\temp\de\rohith\PrinterWorld.java:7 [warning] *[] returning method calledpublic void print() {^^^^^^^^^^^^^^^^^^^^^        method-execution(void de.rohith.PrinterWorld.print())        see also: C:\temp\de\rohith\HelloWorldAspect.java:17C:\temp\de\rohith\PrinterWorld.java:11 [warning] *[] returning method calledpublic Integer returnInt() {^^^^^^^^^^^^^^^^^^^^^^^^^^^^        method-execution(java.lang.Integer de.rohith.PrinterWorld.returnInt())        see also: C:\temp\de\rohith\HelloWorldAspect.java:17C:\temp\de\rohith\PrinterWorld.java:15 [warning] *[] returning method calledpublic Integer[] returnArrayWithCloning() {^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^        method-execution(java.lang.Integer[] de.rohith.PrinterWorld.returnArrayWithCloning())        see also: C:\temp\de\rohith\HelloWorldAspect.java:17C:\temp\de\rohith\PrinterWorld.java:22 [warning] *[] returning method calledpublic Integer[] returnArrayWithoutCloning() {^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^        method-execution(java.lang.Integer[] de.rohith.PrinterWorld.returnArrayWithoutCloning())        see also: C:\temp\de\rohith\HelloWorldAspect.java:175 warningsThere remains the issue that the pattern (*[]) seems to be matching any type, not any array type. I will look at this tomorrow. Fixed in tree. Will close bug report once this fix is available in a public build. The bug involved the processing of a ""*"" pattern when postfixed with one or more array dimensions. Type patterns other than ""*[]"" were unaffected by this bug. Fix now available from the AspectJ download page. Fix released as part of AspectJ 1.2.1 "	2004-08-24 14:42:12	1093370000.0	resolved fixed	82eae55	1093380000.0	tests/bugs/pr72531/de/rohith/HelloWorld.java tests/bugs/pr72531/de/rohith/HelloWorldAspect.java tests/bugs/pr72531/de/rohith/PrinterWorld.java tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java weaver/testsrc/org/aspectj/weaver/patterns/TypePatternTestCase.java
72154	Support for simple dump file	When the compiler terminates abnormally (exception) or behaves unexpectedly (warning/error/abort) a simple dump of the compiler state should be produced to aid problem diagnosis. The content and conditions under which the dump is produced should be configurable by the user but the facility should be enabled by default for exceptions. Consequently its inclusion should have negligible impact on compiler performance and footprint. The file should be attached to bug reports to give a complete and objective description of the user’s environment and support problem resolution where a testcase cannot be provided.One approach is to write a uniquely name file (using date & time) in the current directory e.g “ajcore.20040818.105200.txt” which should be human readable (it can be zipped if large) to allow the user to potentially diagnose their own problems or remove potentially sensitive data before submission. It should contain basic information such as AspectJ version, system properties and command line as well as failure information such as _full_ exception stack trace, compiler messages and internal compiler state. Created attachment 14077Dump class and testcasesA new Dump facility consisting of a single org.aspectj.weaver.Dump class withstatic methods to generate dump files. Configuration methods and systemproperties determine whether a file is produced. By default the file containsthe AspectJ version, system properties, command line, full classpath andcompiler messages. An extensible visitor mechanism allows classes to provideadditional state information. Matthews code is now fully integrated. Fix released as part of AspectJ 1.2.1 	2004-08-18 06:00:35	1092820000.0	resolved fixed	f503523	1093270000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/AjdtCommand.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java org.aspectj.ajdt.core/testdata/DumpTestCase/src/HelloWorld.java org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/AjdtBatchTests.java org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/CompilerDumpTestCase.java weaver/src/org/aspectj/weaver/Dump.java weaver/src/org/aspectj/weaver/World.java weaver/testsrc/org/aspectj/weaver/BcweaverTests.java weaver/testsrc/org/aspectj/weaver/DumpTestCase.java
71811	AJDoc: should be able to set encoding like javadoc	ajdoc doesn't support the -encoding -docencoding and -charset options of javadoc.Especially, it doesn't pass on the -encoding to ajc.If your project uses a source file encoding (e.g. UTF-8) differing form the platform standard, and some java identifiers use characters byond the standard ASCII range, you won't be able to use ajdoc at all. Fixed.  The following flags now work:  - encoding <name>  - docencoding <name>  - charset <name>  Fix released as part of AspectJ 1.2.1 	2004-08-11 13:40:26	1092250000.0	resolved fixed	5f80c8c	1092960000.0	ajdoc/src/org/aspectj/tools/ajdoc/Main.java ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java
49657	Weaver results in rt error if affected base class not exposed	"I was weaving a 3rd party library and wrote an aspect that should affect both a base class and a derived class, but inadvertently wove only the derived class.  This resulted in the following error. I would like the weaver to catch this kind of error at weave (link) time, rather than creating code that results in a rt error... I get this error in 1.1.1 final and in a fairly recent version from CVS HEAD:java.lang.AbstractMethodError	at ajee.logging.LogManager.ajc$interMethodDispatch1$ajee_logging_LogManager$ajee_logging_Loggable$getLogger(LogManager.java)	at ajee.tracing.ExecutionTracer.ajc$before$ajee_tracing_ExecutionTracer$926(ExecutionTracer.java:62)	at library.Derived.<init>(Derived.java:46)This line is a call to super();I've attached a small example that reproduces another error that I think is related:C:\devel\test\ctors\twoPass>buildC:\devel\test\ctors\twoPass>call ajc -outjar fullBase.jar sample\Base.java sample\Derived.javaException in thread ""main"" java.lang.ExceptionInInitializerError        at sample.Derived.<init>(Derived.java:6)        at sample.Derived.main(Derived.java:13)Caused by: org.aspectj.lang.NoAspectBoundException        at sample.Trace.aspectOf(Trace.aj)        at sample.Trace.<init>(Trace.aj:5)        at sample.Trace.ajc$postClinit(Trace.aj)        at sample.Trace.<clinit>(Trace.aj:5)        ... 2 more Created attachment 7354test case I can reproduce the failure in the testcase however the NoAspectBoundException is because the Trace aspect is advising itself (it is also in the sample package). If a ""!within(Trace)"" is used the testcase runs.We need a more representative testcase. Here's a revised version that replicates the bug by adding in an interface that is woven and that the abstract class implements (which isn't woven). I also excluded the aspect from affecting itself so the real error is visible:Exception in thread ""main"" java.lang.AbstractMethodError: sample.Derived.getLogger()Ljava/util/logging/Logger;        at sample.Trace.ajc$interMethodDispatch1$sample_Trace$sample_Trace$Traced$getLogger(Trace.aj)        at sample.Trace.ajc$before$sample_Trace$d2(Trace.aj:12)        at sample.Derived.<init>(Derived.java:6)        at sample.Derived.main(Derived.java:13) Created attachment 7511revised test case that exposes the actual bug Some notes on this bug ... I think there is something that needs fixing, possibly with a compiler error message. Explaining Rons program:an interface 'Iface' is implemented by an abstract class 'Base' which is then extended with a class 'Derived'.All three are compiled into a jar.  We then take 'Base.class' out of that jar.The resulting jar with just two classes in it is woven against a Trace aspect. (The compiler/weaver can still find Base.class because it is accessible on the CLASSPATH). The 'Trace' aspect includes an inner Traced interface onto which it ITDs a field and a method.  The aspect declares that all the classes apart from itself implement 'Trace'.We then execute the Derived class which blows up trying to find an implementation of the method that was introduced to the interface (getLogger).I *think* that because getLogger is introduced onto an interface, its implementation would normally be introduced into top-most implementors.  During the compilation that involved the aspect, Base.class was on CLASSPATH so not a target for weaving.  This means getLogger() was not introduced onto it, even though the abstract method getLogger was introduced upon the Trace.Traced interface (so at runtime this manifests as an AbstractMethodError).  It seems that in the inheritance hierarchy we considered Base.class to be the top most implementor of Traced - even though it couldn't be woven?Tracing the compile that involved the 2 class jar and the aspect, I see a mungeNewMethod() for the getLogger ITD on the interface Traced and I see a mungeNewField() for the ITDd field on Traced.  I don't see (obviously) the mungeNewMethod() for the getLogger implementation on Base.class.I think we should have thrown an error on this compile when we couldn't introduce the method implementation into the right place?However... it is possibly more subtle than that because if I take the interface Iface entirely out of the frame, so I simply have an abstract class Base and its subclass Derived and I repeat the steps above, it works - in this situation the getLogger() implementation is put into Derived ?!?phew. This bug has strong similarities to #52107.  In this case it seems that the compiler isn't checking that it has access to the top-most implementors of an interface that has a concrete introduction on it.  My guess is that you want to modify the same ResolvedTypeMunger.matches method to also do this check for the top-most implementors when the target type is an interface. updated to milestone 1.2 marked as target 1.2.1 Progress. And it explains my confused comment made a couple of months back.We have interface 'Iface' and implementor of that 'Base' and subclass of Basecalled 'Derived'.  Iface and Derived are accessible for weaving.An aspect makes a non-abstract ITD onto an interface called 'Traced' and also adeclare parents statement for everything (Iface/Base/Derived) to implement 'Traced'.The problem arises due to an ordering issue - our approach is to go through eachtype and for each one apply all type mungers then all shadow mungers.  I thinkthis is still right.  The problem here is that we match the munger for the ITDagainst the 'Derived' class and correctly discover (at that point in time) thatit is indeed the top most implementor of 'Traced' because 'Base' wasn't touchedby the declare parents statement.  However ... just after we discover it is'Derived' we then move on to 'IFace' and apply the declare parents statement toit.  This means IFace implements Traced and therefore Base now implements Tracedeven though we didn't actually touch Base.  What happens later on is that wemake this check:if (onInterface &&                             // The ITD was on an interface     !Modifier.isAbstract(signature.getModifiers()) && // It was not abstract    gen.genType().isTopmostImplementor(onType)) { // we are looking at the                                                  // top most implementor. // Stick the body of the ITD method in.This fails because isTopmostImplementor now returns false for 'Derived' at thepoint we do the weave - in this situation we quietly do nothing and so you don'tget an implementation of the ITD put anywhere!  I have changed this slightly so that if we are processing a type that is nolonger the top most implementor (when it used to be) then report an error thatwe need access to the proper top most implementor for weaving:type sample.Base must be accessible for weaving interface inter type declarationfrom aspect sample.TraceIt is an unusual situation because you are giving some of the top and bottom ofan inheritance hierarchy to AspectJ but not the middle bit. Fix checked in - waiting for build. Fix available:BUILD COMPLETE -  build.349Date of build: 08/20/2004 10:22:41Time to build: 93 minutes 15 secondsLast changed: 08/20/2004 08:18:14Latest good AspectJ jar available at:download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar Fix released as part of AspectJ 1.2.1 "	2004-01-07 17:27:35	1073510000.0	resolved fixed	dbe1024	1092930000.0	org.aspectj.ajdt.core/testdata/partialHierarchy/sample/Base.java org.aspectj.ajdt.core/testdata/partialHierarchy/sample/Derived.java org.aspectj.ajdt.core/testdata/partialHierarchy/sample/Iface.java org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/AjdtBatchTests.java org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/PartiallyExposedHierarchyTestCase.java weaver/src/org/aspectj/weaver/ResolvedTypeX.java weaver/src/org/aspectj/weaver/WeaverMessages.java weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java
71723	Inconsistency in scoping of protected members in ITDs	"When introducing new member functions to existing classes via inter-typedeclarations, the scoping rules that apply to the ITD bodies are the same as forthe aspect - for example, private members of the target class cannot be accessedunless the aspect is privileged.Similarly, protected members of classes in different packages should not bevisible in ITDs unless the aspect is privileged.This rule is only enforced for protected members declared in the target class -protected members that are inherited are visible from ITDs in aspects indifferent packages.The following is an example of this:----------------------package foo;public class Foo extends AncientFoo {    protected int i() { return 42; }    public static void main(String[] args) {	new Foo().doStuff();    }    public void doStuff() { }    protected int ancientI() { return 42; }}class AncientFoo {    protected int ancientI() { return -42; }    protected int ancientJ() { return 0; }}----------package bar;import foo.Foo;aspect Bar {    public void Foo.doing() {	try {	    System.out.println(i()); // fails in ajc	    System.out.println(ancientI()); // fails in ajc	    System.out.println(ancientJ()); // succeeds	    System.out.println(clone()); // succeeds	}	catch(Throwable t) { }    }    before(Foo f) : call(* doStuff(..)) && target(f) {	f.doing();    }}-------------------All four calls in Foo.doing() should fail, as they refer to protected members offoo.Foo from package bar. However, only the first 2 - the ones directlydeclared/overridden in foo.Foo - are detected as errors, and removing them makesthe rest compile and execute.Best wishes,Pavel adding to my list of fun raised-by-oxford-inter-type-declaration-scoping-bugs to be looked at for 1.2.1 :) Fix committed in tree. Will close bug once this is available in a published build. Fix now available for download. Fix released as part of AspectJ 1.2.1 "	2004-08-10 13:32:45	1092160000.0	resolved fixed	dfb15c1	1092830000.0	tests/bugs/pr71723/foo/Foo.java tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java
71076	Missing Javadoc comments that aren't missing	"Reported in the AJDT newsgroup:Go to Preferences > Java > Compiler > Javadoc and set ""Missing javadoc comments""to ""Warning"".You then get warnings against things you wouldn't expect, such as after advice./** * A comment */public aspect World {	pointcut greeting() : execution(* Hello.sayHello(..));		/**	 * A comment	 */	after() returning : greeting() {		System.out.println(""world"");	}}This gives two warnings, one for the aspect itself, and one for the afterreturning advice. The warnings occur both with and without the existence ofJavadoc comments! ajdoc correctly uses the Javadoc comments, so the warning is valid when there isno Javadoc comment, but of course the warning should go away when the Javadoccomment is added. This is a compiler problem, it also happens when using the comand line.An example aspect:package p1;  /**   * comment   */  public aspect Aspect {	/**	 * comment2	 */	public pointcut myPC(): execution(* *(..));		public void test(){}  }And what happens when compiled on command line:  C:\Project>ajc -warn:allJavadoc -argfile .generated.lst  C:\Project\src\p1\Aspect.aj:6 warning Javadoc: Missing comment for pu  blic declaration  public aspect Aspect {                ^^^^^  C:\Project\src\p1\Aspect.aj:10 warning Javadoc: Missing comment for p  ublic declaration  public pointcut myPC(): execution(* *(..));                  ^^^^^^^^^^^^^^^^^^^^^^^^  2 warningsNote that the compiler believes that ""comment2"" belongs to the public method test(). marked as target 1.2.1 To fix this I have modified our Parser class in the various consumeXXX() methodsso that they grab the recently parsed javadoc (the bug was that it was beinggrabbed by the following declaration).  This had a knock on effect as I then gotcomplaints that some javadoc didn't include @param tags for things likethisJoinPoint/etc which are automatically added as arguments to some generatedmethods for advice.  The fix here was to change the piece of code that policesit (Javadoc.resolveParamTags()) so that when the selector starts 'ajc$' (so itsa bit of advice or some other construct of ours) we don't report missing @paramwarnings for:- thisJoinPoint- thisJoinPointStaticPart- thisEnclosingJoinPointStaticPart- Anything starting ajc$- Anything containing the words 'AroundClosure'There are possibly some cases I've missed but it should behave much better now !fix about to be checked in - will close when (if???) build succeeds. Fix available:BUILD COMPLETE -  build.345Date of build: 08/18/2004 15:01:23Time to build: 94 minutes 39 secondsLast changed: 08/18/2004 14:29:30Latest good AspectJ jar available at:download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar Fix released as part of AspectJ 1.2.1 "	2004-07-29 09:58:13	1091110000.0	resolved fixed	5b90224	1092830000.0	org.aspectj.ajdt.core/testdata/javadoc/World.java org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/AjdtBatchTests.java org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/JavadocTest.java
62642	proper handling of ExceptionInIntializer inside <clinit> in presence of after throwing advice	"When a <clinit> of a class contains after throwing advice that may catchExceptionInInitializer errors due to an embedded advice aspectOf() thatfails,  the ExceptionInIntializer error does not get properly reported.For the example below:public class Main {  static int x = 13;  int y;  public Main() {     y= 14;  }  public static void main(String args[])    { Main m = new Main();      m.y = 3;      System.out.println(""hi"");    }}aspect Aspect {  before () :  within(*)    { System.out.println(""BEFORE "" + thisJoinPointStaticPart.getKind() +                         "" at "" + thisJoinPointStaticPart.getSourceLocation());    }  after ()  : within(*)    { System.out.println(""AFTER "" + thisJoinPointStaticPart.getKind() +                         "" at "" + thisJoinPointStaticPart.getSourceLocation());    }}....  when compiled with ajc, and then run,  the following exception is given,Exception in thread ""main"" java.lang.NoClassDefFoundError        at Main.<clinit>(Main.java:1)when really one wants the following:Exception in thread ""main"" java.lang.ExceptionInInitializerError        at Main. ...Caused by: org.aspectj.lang.NoAspectBoundException: Aspect        at Aspect.aspectOf ..        -------------Here is a fix ... I give the decompiled <clinit> for Main.java and indicate withcomments,  look for ***LJH ****,  what can be woven to fix it.   Basically, the catchblock for after throwing,  when in <clinit>,  should first check if thecaught exception if a ExceptionInInitializerError, and if so just throw it.----------- static    {        org.aspectj.runtime.reflect.Factory r1;        java.lang.Throwable r2, r31;        int $i0;        r1 = new Factory(""Main.java"", Class.forName(""Main""));        ajc$tjp_0 = r1.makeSJP(""field-set"", r1.makeFieldSig(""8-x-Main-int-""), 2);        ajc$tjp_1 = r1.makeSJP(""staticinitialization"",r1.makeInitializerSig(""8--Main-""), 2);        ajc$tjp_10 = r1.makeSJP(""preinitialization"",r1.makeConstructorSig(""1--Main----""), 5);        ajc$tjp_2 = r1.makeSJP(""field-set"", r1.makeFieldSig(""0-y-Main-int-""), 6);        ajc$tjp_3 = r1.makeSJP(""constructor-execution"",r1.makeConstructorSig(""1--Main----""), 6);        ajc$tjp_4 = r1.makeSJP(""constructor-call"",r1.makeConstructorSig(""1--Main----""), 10);        ajc$tjp_5 = r1.makeSJP(""field-set"", r1.makeFieldSig(""0-y-Main-int-""), 11);        ajc$tjp_6 = r1.makeSJP(""field-get"",r1.makeFieldSig(""19-out-java.lang.System-java.io.PrintStream-""), 12);        ajc$tjp_7 = r1.makeSJP(""method-call"",r1.makeMethodSig(""1-println-java.io.PrintStream-java.lang.String:-arg0:--void-""),12);        ajc$tjp_8 = r1.makeSJP(""method-execution"",r1.makeMethodSig(""9-main-Main-[Ljava.lang.String;:-args:--void-""), 10);        ajc$tjp_9 = r1.makeSJP(""initialization"",r1.makeConstructorSig(""1--Main----""), 6); try        {            Aspect.aspectOf().ajc$before$Aspect$1$36f01b1c(ajc$tjp_1);            $i0 = 13;            try            {                Aspect.aspectOf().ajc$before$Aspect$1$36f01b1c(ajc$tjp_0);                x = $i0;            }            catch (Throwable $r30)            {                /*** LJH insert here *****/                if ($r30 instanceof ExceptionInIntializerError) //***                  throw($r30); //***                /***********/                r31 = $r30;                Aspect.aspectOf().ajc$after$Aspect$2$36f01b1c(ajc$tjp_0);                throw r31;            }            Aspect.aspectOf().ajc$after$Aspect$2$36f01b1c(ajc$tjp_0);        }        catch (Throwable $r36)        {           /*** LJH insert here *****/           if ($r36 instanceof ExceptionInIntializerError) //***           throw($r36); //***           /***********/            r2 = $r36;            Aspect.aspectOf().ajc$after$Aspect$2$36f01b1c(ajc$tjp_1);            throw r2;        }        Aspect.aspectOf().ajc$after$Aspect$2$36f01b1c(ajc$tjp_1);    } marked as target 1.2.1 argh!  bcel is a nightmare.  It has taken me ages to program BCEL to generate: if ($r36 instanceof ExceptionInInitializerError)    throw($r36);This is the final incantation for BCEL:        if (this.getEnclosingMethod().getName().equals(""<clinit>"")) {            ResolvedTypeX eiieType =              world.resolve(""java.lang.ExceptionInInitializerError"");            ObjectType eiieBcelType =               (ObjectType)BcelWorld.makeBcelType(eiieType);            InstructionList ih = new InstructionList(InstructionConstants.NOP);            handler.append(exceptionVar.createLoad(fact));            handler.append(fact.createInstanceOf(eiieBcelType));            BranchInstruction bi =                 InstructionFactory.createBranchInstruction(                Constants.IFEQ,ih.getStart());            handler.append(bi);            handler.append(exceptionVar.createLoad(fact));            handler.append(fact.createCheckCast(eiieBcelType));            handler.append(InstructionConstants.ATHROW);            handler.append(ih);        }I put that in the BcelShadow.weaveAfterThrowing() method.  You can see it does acheck to determine if it is in the <clinit> before generating this extra check.Here is the extra bytecode that appears in the method:447: aload_1448: instanceof      #101; //class ExceptionInInitializerError451: ifeq    459454: aload_1455: checkcast       #101; //class ExceptionInInitializerError458: athrow459: nopYes, there is one extra NOP but I don't want to fight with BCEL to remove it.I've put Lauries test program into the test suite to verify it behaves and weget the ExceptionInInitializerError rather than the NoClassDefFoundError.Thanks Laurie for describing the right fix :)fix checked in, waiting for build. Fix available:BUILD COMPLETE -  build.344Date of build: 08/18/2004 11:27:31Time to build: 92 minutes 31 secondsLast changed: 08/18/2004 10:55:59Latest good AspectJ jar available at:download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar Fix released as part of AspectJ 1.2.1 "	2004-05-18 10:23:19	1084890000.0	resolved fixed	84e4e53	1092750000.0	tests/bugs/pr62642.java tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java weaver/src/org/aspectj/weaver/bcel/BcelShadow.java
70241	outline view shows anonymous inner classes in different way than jdt outline	"See screenshots. Created attachment 13368ajdt outlineajdt outline Created attachment 13369jdt outlinejdt outline Assuming that AJDT is not changing the IHierarchy that it gets for this, this fix should happen in the ASM.  I'm moving to AspectJ, reassigning to me and planning on doing it this week. Sorry I've stolen your bug Mik.  Fix checked in, from the testcase in ajde:Left hand side is before the fix, right hand side is after:<root>  InnerClasses.java    import declarations    InnerClasses      A					A        method				  method        1				    new Runnable() {..}          run				      run      main				main      2					  new Runnable() {..}      	  run				    run      3 				  new Object() {..}        toString			    toString      4					  new Runnable        run				    runwhich matches the JDT and looks much nicer :)Waiting for build before closing bug (and then Luzius to confirm it is OK). Fix available:BUILD COMPLETE -  build.343Date of build: 08/17/2004 14:25:48Time to build: 93 minutes 22 secondsLast changed: 08/17/2004 11:16:03Latest good AspectJ jar available at:download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jarLuzius - I will put a new AJDE update in for AJDT sometime today that includesthe fix. Definitely better.  The number convention was something I did to match the way Eclipse worked waaaaay back. Fix released as part of AspectJ 1.2.1 "	2004-07-16 11:41:14	1089990000.0	resolved fixed	a2469c7	1092740000.0	ajde/testdata/extensions/InnerClasses.java ajde/testsrc/org/aspectj/ajde/ExtensionTests.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java
67578	Privileged Aspect Access Problem Across Packages	"From Irum Godil's aspectj-users posting:package a;public class ITD {    private void returnNothing(Object a) {    }}package b;import a.*;privileged aspect B {  public void ITD.newFun() {      returnNothing(""a"");  }}returns:C:\devel\test\priv\b\B.aj:8 error The method returnNothing(Object) from the type ITD is not visiblereturnNothing(""a"");^^^^^^1 errorWhich it should not (and AspectJ 1.0.6 does not give an error)Work around: use this.returnNothing(""a""); It appears to occur only when you have types in different packages and are passing an argument with a type conversion.  marked as target 1.2.1 This was vaguely related to 67579 after all.  The problem is that the error isreported before we check to see if the reference was being made from aprivileged type.  The fix is to make that check (by checking for the existenceof a privileged handler) in org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod()and if there is a privileged handler around, we ask it for an accessor method tothe private method.This works and generates this lovely decompiled code (which I've annotated):In the class we have:===========================================package a;import b.B;public class ITD {    public ITD() {}    private void returnNothing(Object obj) {}    // Generated accessor method for the private returnNothing() method    public void ajc$privMethod$b_B$a_ITD$returnNothing(Object obj) {        returnNothing(obj);    }    // Result of the ITD    public void newFun() {        B.ajc$interMethod$b_B$a_ITD$newFun(this);    }}=================================================package b;import a.ITD;import org.aspectj.lang.NoAspectBoundException;public class B {    B() {}    // Dispatcher for intertype method newFun() dispatches to private method    // accessor in the ITD class    public static void ajc$interMethod$b_B$a_ITD$newFun(ITD ajc$this_) {        ajc$this_.ajc$privMethod$b_B$a_ITD$returnNothing(""a"");    }    public static void ajc$interMethodDispatch1$b_B$a_ITD$newFun(ITD itd) {        itd.newFun();    }    public static void main(String argv[]) {        ajc$interMethodDispatch1$b_B$a_ITD$newFun(new ITD());    }    public static B aspectOf() {        if(ajc$perSingletonInstance == null)            throw new NoAspectBoundException(""b_B"", ajc$initFailureCause);        else            return ajc$perSingletonInstance;    }    public static boolean hasAspect() {        return ajc$perSingletonInstance != null;    }    private static void ajc$postClinit() {        ajc$perSingletonInstance = new B();    }    private static Throwable ajc$initFailureCause;    public static final B ajc$perSingletonInstance;    static {        try {            ajc$postClinit();        } catch(Throwable throwable){            ajc$initFailureCause = throwable;        }    } FIXED!Fix available in:BUILD COMPLETE -  build.342Date of build: 08/16/2004 18:17:03Time to build: 97 minutes 49 secondsLast changed: 08/16/2004 17:44:55Latest good AspectJ jar available at:download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar Fix released as part of AspectJ 1.2.1 "	2004-06-17 01:45:19	1087450000.0	resolved fixed	6b1ef0f	1092670000.0	tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java
71878	Bad injar aspect name on Linux	"If you checkout the ""JarUsingProject"" project from ""org.eclipse.ajdt.test/manualtesting"" in the AJDT 1.1.12 tree, and look at the advised-by entries in theoutline view and the context menu of the gutter annotation, on Windows you get""injar aspect: AbstractAspect.aj"", but on Linux you get ""injar aspect:C:\eclipse30AJDTPluginTest\eclipse\workspace\JarGeneratingProject\src\p1\AbstractAspect.aj"".The Windows-style path indicates the location of the original class files in theJAR file, which was clearly built on Windows. I suspect this is the same path issue we hit the other day.  When utilising aninput jar for anything, if the jar contains debug info then it will containpaths to source files based on the platform on which it was built.  We have tobe careful when processing these paths on a difference platform.  Basically itmeans trying to be platform independent using File.separator isn't enough - youhave to allow for slashes either way around wherever you are ! Fixed.  Fix available in: BUILD COMPLETE -  build.340Date of build: 08/14/2004 10:57:39Time to build: 92 minutes 0 secondsLast changed: 08/14/2004 09:08:57Latest good AspectJ jar available at:download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jarIt has been tested in AJDT and will be in 1.1.13. Fix released as part of AspectJ 1.2.1 "	2004-08-12 12:24:31	1092330000.0	resolved fixed	2dfc738	1092410000.0	asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java
61374	Version the BCEL libraries to allow graceful failure when the wrong version is found.	We have bugs reported like bug 59921 and bug 60389.  These bugs relate to the problem where the compiler locates the wrong version of BCEL libraries - because they are a different version, some of the methods AspectJ calls either don't exist or have different parameter lists.  The error the user sees is a horrible internal compiler error.  if we versioned the BCEL libraries as we changed them, we could check the version found on compiler startup and verify they are as expected.  if the version doesn't match we can report a nice readable error message that tells the user how to fix it. Or we could rename the packages for the version of BCEL that we use to preventfuture clashes. *** Bug 59921 has been marked as a duplicate of this bug. *** *** Bug 66222 has been marked as a duplicate of this bug. *** Ideally need to do something here for the 1.2.1 release. Fixed.  I have modified the bcel-builder project and introduced two new targets:transformToAJ - changes the package structure from org.apache to org.aspectj.apachetransformFromAJ - changes the package structure from org.aspectj.apache toorg.aspectjI didn't do any bytecode transformation to achieve this as I realised I wantedto have a valid src.zip that matched the transformed bytecode.  So I just usedANT.  A mapper to do the renaming of files and introduce the extra level ofpackage naming and then a <replaceregexp> task call to transform referencesinside all the source files.We store our changes to BCEL in a patch.txt file.  This file is still a patchagainst the non-renamed bcel source.  So the order of operations when building anew version of BCEL is:- Extract bcel5.1 into a folder- Patch that bcel- Transform the package names- Package up the transformed codeYou *can* then work on the transformed code, if you make a fix then you will runthe 'diff' target on build.xml to create a new version of the patch, that worksas follows:- Transform the package names back- Diff the source with the original BCEL source to create patch.txtThis works really well !The new names for BCEL classes resulted in a ton of changes in the weaver(import statements).Waiting for build before closing. Fixed version available:BUILD COMPLETE -  build.339Date of build: 08/12/2004 09:42:49Time to build: 92 minutes 32 secondsLast changed: 08/12/2004 09:01:04Last log entry: BCEL rename (enhancement 61374)Latest good AspectJ jar available at:download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar *** Bug 75071 has been marked as a duplicate of this bug. *** Fix released as part of AspectJ 1.2.1 	2004-05-07 08:45:15	1083930000.0	resolved fixed	228fc8d	1092300000.0	weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java weaver/src/org/aspectj/weaver/bcel/BcelAttributes.java weaver/src/org/aspectj/weaver/bcel/BcelCflowAccessVar.java weaver/src/org/aspectj/weaver/bcel/BcelCflowStackFieldAdder.java weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java weaver/src/org/aspectj/weaver/bcel/BcelField.java weaver/src/org/aspectj/weaver/bcel/BcelFieldRef.java weaver/src/org/aspectj/weaver/bcel/BcelMethod.java weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java weaver/src/org/aspectj/weaver/bcel/BcelRenderer.java weaver/src/org/aspectj/weaver/bcel/BcelShadow.java weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java weaver/src/org/aspectj/weaver/bcel/BcelVar.java weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java weaver/src/org/aspectj/weaver/bcel/BcelWorld.java weaver/src/org/aspectj/weaver/bcel/ExceptionRange.java weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java weaver/src/org/aspectj/weaver/bcel/Range.java weaver/src/org/aspectj/weaver/bcel/ShadowRange.java weaver/src/org/aspectj/weaver/bcel/Tag.java weaver/src/org/aspectj/weaver/bcel/UnwovenClassFile.java weaver/src/org/aspectj/weaver/bcel/Utility.java weaver/testsrc/org/aspectj/weaver/bcel/ArgsWeaveTestCase.java weaver/testsrc/org/aspectj/weaver/bcel/MoveInstructionsWeaveTestCase.java weaver/testsrc/org/aspectj/weaver/bcel/WeaveTestCase.java
61768	scope for intertype methods	"/* According to the documentation, the scope rules for   intertype method declarations are interpreted   from the originating aspect. The only exceptions   (I thought) are the use of ""this"" and ""super"" which refer to   the target type.   According to that interpretation, the program below is type correct, but   ajc generates two error messages, shown in comments   at the relevant lines. Note that it's ok to access private static   fields of the aspect, but not to use private classes of the aspect.   If this is a feature and not a bug, what are the   precise scope rules for intertype method declarations?*/aspect Aspect {     private static int y = 5;    private class A { int x = 3; }    private static void B.happy() {	System.out.println(y);          // happy accessing private field y    }    private static void B.foo(A z) { 	System.out.println(z.x); 	// ERROR: The type Aspect.A is not visible    }    public void B.bar() {	B.foo(new A());                 // ERROR: The type A is not visible    }}class B {}public class IT {     public static void main(String[] args) { 	new B().bar();    }  } marked as target 1.2.1 Good bug report, thanks. I added a slightly extended version of your test program to the test suite:aspect Aspect {  private static int y = 5; private class A { int x = 3; }  private static class A2 {} private static void B.happy() {    System.out.println(y);          // happy accessing private field y } private static void B.foo(A z) {     System.out.println(z.x);  }  private static void B.foo2(A2 z) {     System.out.println(z); } public void B.bar() {     B.foo(new A());        // CE L37 : no enclosing instance }  public void B.bar2() {     B.foo2(new A2()); }}class B {}class IT {  public static void main(String[] args) {     new B().bar(); } }This now compiles and correctly finds the types A and A2. Note that line 37 *is still an error* (but not the one previously reported) as a non-static inner class needs to be within an enclosing instance of the aspect, and the body of an ITDM is not such a place.Will close this bug report once the fix is available for download. Fix now available in latest jar from AspectJ download page. Fix released as part of AspectJ 1.2.1 "	2004-05-11 13:35:42	1084300000.0	resolved fixed	8c5d743	1092240000.0	tests/bugs/oxford/PR61768.java tests/bugs/oxford/PR62475.java tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java
54421	Compile time declarations (warning and error) do not accept string concatenation (with +)	"The following code does not compile because the message uses string concatenation (the + operator). public class WarningSample {  public void method() {}  public void anotherMethod() {    this.method();  }}aspect WarningAspect {  pointcut illegalCall(): call(* WarningSample.method())                && within(WarningSample);  // the same thing happens with declare error  declare warning: illegalCall() : ""Hey, don't "" +      ""do that, that is not nice. You should do something else"";} marked as target 1.2.1 Fixed.  Changed Jims home grown parser to allow for '+' and multi-line strings.Here is a sick example that now works:declare warning: call(* *(..)): ""abc"" + ""def"" + // 'def' was here ""ghijklmnopqrstuv"" /* sillyplacefor a comment */ +/* oops */ ""wxyz"";Waiting for build before closing bug. Fix available now:BUILD COMPLETE -  build.337Date of build: 08/11/2004 17:19:19Time to build: 91 minutes 45 secondsLast changed: 08/11/2004 14:18:49Last log entry: Tests and fix for Bugzilla Bug 54421 Compile time declarations(warning and error) do not accept string concatenation (with +)Latest good AspectJ jar available at:download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar Fix released as part of AspectJ 1.2.1 "	2004-03-11 03:00:18	1078990000.0	resolved fixed	d43a391	1092230000.0	tests/bugs/decwStrings.java tests/bugs/decwStringsErroneous.java tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java weaver/src/org/aspectj/weaver/patterns/PatternParser.java
68991	intertype initialisers should match field set pointcuts	"/* initialisers of intertype fields should match field set pointcuts.   In the example below, the output should beset field set(int C.n)set field set(int C.m)get field get(int C.n)set field set(int C.n)   but the first field set (of C.n) is not picked up.*/aspect Aspect {    private int C.n = 13;    before() : get(* C.*) {	System.out.println(""get field ""+thisJoinPointStaticPart);    }    before() : set(* C.*)  {	System.out.println(""set field ""+thisJoinPointStaticPart);    }    public void C.foo() {	n++;    }}class C {    int m = 20;}public class ITFieldsAdvice {    public static void main(String[] args) {	C c = new C();	c.foo();    }} marked as target 1.2.1 Fix checked in, waiting for build.Some AspectJ facts.- When the ITD is a private ITD, the field generated has a 'special' ""ajc$XXX"" name.- *No* ajc$XXX field references are considered join points.- Join points for references to these fields are surfaced as follows.  Eachfield has a set and a get dispatcher method generated.  These methods are taggedwith the 'effective signature' attribute of a FIELD_GET or FIELD_SET shadow. This means when a call to the dispatcher method is found in the code, it ismatched upon as if it was a field get or set join point.- When ITD field initializers are generated, they normally directly set thenamed field.  Field initializer methods are *not* tagged with the effectivesignature attribute.The fix is to change the body of the generated field initializer so that itdelegates to the field set dispatcher method - the call to this method willensure the right field set join point surfaces for the match. Fix available now:BUILD COMPLETE -  build.337Date of build: 08/11/2004 17:19:19Time to build: 91 minutes 45 secondsLast changed: 08/11/2004 14:18:49Latest good AspectJ jar available at:download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar Fix released as part of AspectJ 1.2.1 "	2004-06-30 07:51:21	1088600000.0	resolved fixed	64183c3	1092230000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeFieldDeclaration.java tests/bugs/PR68991/Oxford.java tests/bugs/PR68991/Simple.java tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java
65319	ajc crashes when compiling the following program (binding this() and target())	"class Test{  	public static void main(String args[])	{				new Test().method();	}	public void method()	{		new Test2().method2();	}}class Test2 {	public void method2() {}}aspect Plain {	before(Test x):  call(void *.* (..)) && (this(x) || target(x))	{	}} For this bug I propose the same solution we used for args() (bug 61568) whichwill make this a proper compile time error.  Fundamentally we are saying thatyou aren't allowed to bind more than once to a formal - this doesn't seem *too*unreasonable.Current proposal for the message is:C:\temp\ajcSandbox\ajcTest16749.tmp\PR65319.java:9:0   Cannot use target() to match at this location and bind a formal to type'Test2' - the formal is already bound to type 'Test'.  The secondary sourcelocation points to the problematic target().	see also: C:\temp\ajcSandbox\ajcTest16749.tmp\PR65319.java:16If there is a compelling use case we could look at perhaps supporting thisproperly, but without one we'll stick to outputting an error. Proposed fix checked in.  Message isn't great but its better than a crash atweave time. Fix available in:BUILD COMPLETE -  build.334Date of build: 08/10/2004 18:17:11Time to build: 92 minutes 34 secondsLast changed: 08/10/2004 17:33:42Latest good AspectJ jar available at:download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar Fix released as part of AspectJ 1.2.1 "	2004-06-02 10:29:50	1086190000.0	resolved fixed	b75cd93	1092150000.0	tests/bugs/oxford/PR65319.java tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java weaver/src/org/aspectj/weaver/patterns/ExposedState.java weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java
53981	proceed used as method name in around advice	"Using a method named proceed(..) in around advice confuses the compiler (in atleast the 2-3 ways shown below).  True of the current tree (untested in 1.1.1).  Workaround for now is to renamethe method.  ---- first problem: NPE in compilerjava.lang.NullPointerException	atorg.aspectj.ajdt.internal.compiler.ast.MakeDeclsPublicVisitor.endVisit(MakeDeclsPublicVisitor.java:44)public class Proceeding {    public static void main(String[] args) { }    static aspect A {        interface IProceed {            void proceed(Runnable next);        }        IProceed decorator;        void around() : execution(void main(String[])) {            decorator.proceed(new Runnable() {                public void run() {                    proceed();                }            });        }    }}---- second problem: incorrect error wrt number of argumentspublic class Proceeding {    public static void main(String[] args) {    }    static aspect A {        void around() : execution(void main(String[])) {            Proceeding.proceed(null); // BUG: treated as proceed(Object);        }    }    static void proceed(Object o) {}}---- third hypothetical: we should document how ambiguity is resolvedpublic class Proceeding {    public static void main(String[] args) {    }    static aspect A {        void around() : execution(void main(String[])) {            proceed(); // special form or Proceeding.proceed()?        }    }    void proceed() {}} Sorry - last hypo should be  static void proceed() {}  ^^^^^^ To maintain a simple specification the rule should be that a bare proceed in an aspect is always the special form and can never refer to a method even if one is defined by the aspect.  However, we should support calling proceed with a receiver as in examples 1 and 2 as this is clearly unambiguous.This can probably be fixed fairly easily by modifying the method Proceed.findEnclosingAround to check if Proceed.receiver exists and if so to claim the proceed is not inside an around and therefore should be treated as a normal method. Raising to a P2 bug to increase visibility, but not marking 1.2 as I don't think this should delay a 1.2 release. marked as target 1.2.1 Fixed following Jim's suggestion. Had to make one refinement which is to treat the proceed as the special form in the case when the receiver is null, OR the receiver is non-null and receiver.isThis() returns true.All three of the cases below now work correctly. I also added the following to the semantics appendix:=============Any occurence of proceed(..) within the body of around advice is treated as the special proceed form (even if the aspect defines a method named proceed) unless a target other than the aspect instance is specified as the recipient of the call. For example, in the following program the first call to proceed will be treated as a method call to the ICanProceed instance, whereas the second call to proceed is treated as the special proceed form.   aspect A {     Object around(ICanProceed canProceed) : execution(* *(..)) && this(canProceed) {        canProceed.proceed();         // a method call        return proceed(canProceed);   // the special proceed form     }          private Object proceed(ICanProceed canProceed) {        // this method cannot be called from inside the body of around advice in        // the aspect     }  }==============The wording is slightly cumbersome, but it was very hard to phrase this accurately. Fix now available in latest development jar from AspectJ download page. Fix released as part of AspectJ 1.2.1 "	2004-03-06 22:43:04	1078630000.0	resolved fixed	05dabd1	1092140000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/Proceed.java tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java
59208	Weaver fails in BCEL  for large classes	<Pyinson Data Over Head> Seems like the bug is caused by a truncation of the ConstantPool unsigned short limit of 65535 when BcelClassWeaver writes the bytecode after weaving. I.e. this happens when the ConstantPool size is larger than 65535.There is not much ajc can do about that limit but I propose that a more meaningful error message is generated by the weaver in this case. In both scenarios the compilation will now fail cleanly with an error message:The class Foo exceeds the maximum class size supported by the JVM (constant pool too big).Will close this bug once the fix is available in a published build.Thanks for the clear test case. Fix now available in latest build on AspectJ download page. Fix released as part of AspectJ 1.2.1 	2004-04-20 05:23:13	1082450000.0	resolved fixed	44a92e1	1092140000.0	tests/bugs/pr59208/Foo.java tests/bugs/pr59208/FooProducer.java tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java weaver/src/org/aspectj/weaver/WeaverMessages.java weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java
67592	value in the args[] array of thisjoinpoint can be changed by one advice decl and updated values seen in another advice decl	"In ajc a use of thisJoinPoint corresponds to an object of type JoinPoint, wherea JoinPoint object has four components, which can be retrieved usingaccessor methods.  this                   getThis()  target                 getTarget()  args                   getArgs()  staticJoinPoint        getStaticPart()In the case of args, the object returned is an Object array.  This meansthat an advice decl can overwrite the args,  and then another advice whichshares the same JoinPoint will see the changed args.   Here is asmall example.  In this aspect thebefore advice changes arg[0] to always be ""Laurie"" and then the afteradvice will always say that ""Laurie won a million pounds"".Is this the behaviour that is intended?   I would have thought that theinterface to args[] should be such that the values can only be read.  Otherwisevery strange interactions between advice decls could occur.---------------------------------------------------------------------public class Main {  public static Main v = new Main();  void lottery ( String arg )    { System.out.println(""The arg in lottery is "" + arg);    }  public static void main (String args[])    { v.lottery(""Oege"");      v.lottery(""Ganesh"");    }}---------------------------------------------------------------------public aspect Aspect {  // This pair of advice decls demonstrates that an advice can change to  //   the args of a join point.  before () : call(* lottery(java.lang.String)) && !within(Aspect)    { System.out.println(""BEFORE "" + thisJoinPoint +                         "" at "" + thisJoinPointStaticPart.getSourceLocation());      Object args[] = thisJoinPoint.getArgs();      System.out.println(""arg[0] is "" + args[0]);      args[0] = ""Laurie"";      System.out.println(""... now it is "" + thisJoinPoint.getArgs()[0]);    }  after ()  : call(* lottery(java.lang.String)) && !within(Aspect)    { System.out.println(""AFTER "" + thisJoinPoint +                         "" at "" + thisJoinPointStaticPart.getSourceLocation());      if (thisJoinPoint.getArgs()[0].equals(""Laurie""))        System.out.println(""Laurie wins 1 million pounds!"");    }} will fix this on Monday... simple matter of taking a defensive copy of the args before handing them out. getArgs() now returns an Object[] with the same behaviour as arguments in a method or in advice parameters: any change to an object reference in the array is not visible outside of the advice body, but any change to the state of an argument (calling a method on a referenced arg object) is visible.Will close the defect once this fix is available in a published build. fix now available in latest jar published from the Aspectj download page. Fix released as part of AspectJ 1.2.1 "	2004-06-17 04:06:53	1087460000.0	resolved fixed	f6436e3	1092060000.0	runtime/src/org/aspectj/runtime/reflect/JoinPointImpl.java runtime/testsrc/RuntimeModuleTests.java runtime/testsrc/org/aspectj/runtime/reflect/JoinPointImplTest.java
71377	Cannot advise private method call in around advice	"Pointcuts should match call joint points in advice. However AspectJ does not match calls to _private_ methods in around advice. The same applies to get/set pointcuts for _private fields. This is probably because in the testcase below a call to ""privateMethod()"" in the body of the around advice is a call to an accessor method:        ajc$inlineAccessMethod$bug_nnnn_JoinPointInAroundAdvice$bug_nnnn_JoinPointInAroundAdvice$privateMethod(""around"");public aspect JoinPointInAroundAdvice {	private static Set privateCalls = new HashSet();	private static Set publicCalls = new HashSet();		pointcut internalCall () :		call(* JoinPointInAroundAdvice.privateMethod(..));		before () : internalCall () {		privateCalls.add(thisJoinPoint);	}	pointcut externalCall () :		call(* JoinPointInAroundAdvice.publicMethod(..));		before () : externalCall () {		publicCalls.add(thisJoinPoint);	}		pointcut execTest () :		execution(* JoinPointInAroundAdvice.test());		before () : execTest () {		privateMethod(""before"");		publicMethod(""before"");	}		void around () : execTest () {		privateMethod(""around"");		publicMethod(""around"");		proceed();	}	//	void around () : execTest () {//		Runnable runnable = new Runnable () {//			public void run () {//				privateMethod(""around closure"");//				publicMethod;//				proceed();//			}//		};//		runnable.run();//	}		after () : execTest () {		privateMethod(""after"");		publicMethod(""after"");	}		private static void privateMethod (String from) {		System.out.println(""? privateMethod() "" + from);	}		public static void publicMethod (String from) {		System.out.println(""? publicMethod() "" + from);	}		public static void test () {		System.out.println(""? test()"");		privateMethod(""test"");		publicMethod(""test"");	}		public static void main (String[] args) {		test();				if (privateCalls.size() != publicCalls.size()) {			throw new RuntimeException(""Missing join point"");		}		else {			System.out.println(""Success."");		}	}} I better write up where I am before I forget!!!I thought this was going to be one of those bugs where you start diagnosing itand discover there is a fatal flaw in AspectJ.  I think like this about mosthard bugs, but every single time (including this one) I discover that there is aperfectly ideal framework for solving the bug, someone just forgot to fill inthis piece of it.The compiler has a notion of an effective signature which is used for inter typedeclarations - it enables you to do something clever (like call an accessormethod on another class) but pretend it casts an entirely different join pointshadow (like a field access).As Matthew points out, the problem is that there is a grotty generated accessormethod:ajc$inlineAccessMethod$bug_nnnn_JoinPointInAroundAdvice$bug_nnnn_JoinPointInAroundAdvice$privateMethod(""around"");that is being called which just delegates to the real 'privateMethod()'.My first plan of attack was to work purely in the weaver and when I sawsomething like this I'd try and undo the generated name (i know, i know) andcreate an effective signature of 'privateMethod()' which would then be matched.Yes, it was insane, I was young and foolish yesterday when I was trying that. Little did I know there was a grotty testcase in the suite that would never letme do it that way.  Look at this:aspect EnsureShipIsAlive {    void around (Ship ship): Ship.helmCommandsCut(ship) {        if ( ship.isAlive() ) {            proceed(ship);        }    }}in SpaceWar.  The call 'ship.isAlive()' is another example of a missing shadowthat we haven't been able to match on.  That kind of call created a *ReAlLy*horrible accessor, and isAlive() isn't even declared on ship, it is on thesuperclass of ship, SpaceObject.So, forget that, what I need to do is remember what the accessor was generatedfor at compilation time and use that at weave time when trying to create this'fake shadow'.  All I have to do to make this work is create aneffectivesignature attribute against the generated accessor method and then themagic in BcelClassWeaver.matchInvokeInstruction() will pick up the attribute Istuffed into the file and use it to create a shadow we can match against.This worked perfectly ...and then ...I hit a problem with thisJoinPoint.  Objects that represent TJPs throughout thecode are usually created PRIVATE STATIC FINAL.  The problem is that I had nowsurfaced some new join points in code that might get inlined, and if you advisedthose join points and used thisJoinPoint then in the advice, we attempted toreference a PRIVATE STATIC FINAL TJP instance in the class where the shadowexisted before inlining.  Usually resulting in a verify error.So I modified the code that generates TJP instances to allow them to be publicif the enclosing method for the shadow is inside around advice (I didn't dobefore and after advice as well, because that broke more tests and I believe wedon't inline before or after advice).Was that it?Well, that covers calls to private methods from around advice...what it doesnt cover is sets or gets of private fields in around advice.  Aha, Ithought, this will be easy, I just create an effectivesignature at compile timeand the backend will do the right thing.But no ... at compile time I haven't quite found a way (at the point we generatethe attribute) to know if it is a set or a get.  I know it is a field access butnot what kind.  How about I put in a compile time flag so you can choose whichyou want?  ... only joking - I will get this fixed soon as I can. Fixed.I rejiggled the fix in AspectDeclaration.  Rather than generating new attributesin the generateMethod() method, you can pass an optional set of additionalattributes when you call generateMethod() and these will be attached to thegenerated code.If the method being generated is an inlineAccessMethod for a private methodcall, we have a MethodCall effective signature attribute.  ForinlineAccessMethods that represent field accesses we add either the field_set orfield_get attribute.  Creating the attributes outside of the generateMethod()attribute enabled me to know enough to differentiate between field set and fieldget.Fix checked in, waiting for build before closing. Fix available:BUILD COMPLETE -  build.331Date of build: 08/09/2004 11:57:04Time to build: 117 minutes 38 secondsLast changed: 08/09/2004 11:27:04Last log entry: Fix for Bug 71377: Cannot advise private method call in aroundadviceLatest good AspectJ jar available at:download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar Fix released as part of AspectJ 1.2.1 "	2004-08-04 10:21:05	1091630000.0	resolved fixed	851da68	1092050000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java tests/bugs/AroundAdviceJPs/FieldGetJoinPointsInAroundAdvice.java tests/bugs/AroundAdviceJPs/FieldJoinPointsInAroundAdvice.java tests/bugs/AroundAdviceJPs/JoinPointInAroundAdvice.java tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java
44191	"Need better error message for ""can't find type"""	"I have experienced situations where IAJC outputs a message like this at the end of compilation.    [iajc] can't find type org.xxx.SomeTestIn my case this was one time highly confusing since I did not expect the class in question to be referred anywhere in the project (I have to date still not located the reference). For such cases, it would be extremely nice if the error message would display WHY it need the class (i.e. the name of the refering class(es) or aspect(es) possibly with a reasonable cutoff as there is seldom need to list all referals). So I would like a message like this:    [iajc] can't find type org.xxx.SomeTest referred by org.yyy.SomeClass,org.yy.SomeOtherClass ... This is a good suggestion.  Reassigning as such to compiler. ""can't find type"" is displayed by World.resolve(TypeX,boolean).  The boolean flag specifies if the caller of resolve() can handle the fact that a type is missing - if it can then 'cant find type' is not displayed and instead the caller gets a ResolvedTypeX.MISSING object.  So the problem scenario where we would like more info is when the boolean is false.  Currently there is only one route into this method where the boolean is false, that is through World.resolve(TypeX) where the caller hasn't specified whether they can handle a missing type.Unfortunately there are 63 callers of World.resolve(TypeX).  The options seem to be:1) Modify those 63 places to use the resolve(TypeX,boolean) variant and ensure they cope with ResolvedTypeX.MISSING correctly.2) Pass some 'context' along as an extra parameter on every resolve() call so that 'cant find type' can give more information about what was happening when it attempted to find a type.Neither is ideal ... still thinking ... maybe there is a sensible subset of the 63 cases which are the most common and we can change them to 'resolve(TypeX,true)' and print better messages when ResolvedTypeX.MISSING is returned. It's always hard to deal with 63 method calls.  My quick pass reveals 5 kinds of uses that should be considered separately.1. resolve(TypeX.OBJECT) or some other core runtime type.  I'd suggest changing these either by adding specific methods to world, i.e. getObjectType() or a general getCoreType(TypeX.OBJECT).  If one of these types is missing there's a basic configuration error.2. resolve used in test cases.  There are a fair number of these, and I don't think you need to worry about them.  To simplify the analysis you might want to change these to use resolve(TypeX, true) followed by an assertion that ResolvedTypeX.MISSING wasn't returned.3. A small number of cases where resolve is used where it doesn't really need to be.  i.e. The API for Shadow.getEnclosingType() should probably return a ResolvedTypeX since this is what BcelShadow is already holding onto.  These calls will never fail, but fixing them up will make it easier to see the other calls.4. resolve used in implemention of actual weaving.  These calls usually have an easy context to provide and would be useful to let the user know where the problem is, i.e. can't find type Foo while weaving around advice X into join point shadow Y.  This is a great use of our multiple source locations support in 1.2.5. Once you've done the ones above, there will still be a good number (~20?) remaining that are harder.  These are probably the actual ones leading to the confusing error messages.  These need to be looked at one by one to see where context can be easily supplied.  Most of these calls are used to see if a given join point shadow matches a given pcd.  This is a case where it would sometimes be nice to handle MISSING more carefully. *** Bug 71045 has been marked as a duplicate of this bug. *** I've finally gotten round to starting on this.  I've removed the rogue calls inthe testcases that confuse the situation and added a new method to world thatshould be used when looking for really important types like java.lang.Objectwhich fails with an error other than 'cant find type' to let you know you arereally in trouble.  That seems to have taken me down to around 50 calls toresolve without a boolean.  The quest continues ... for the 1.2.1 release (or as many of the cases as we can) I've fixed a bunch of cases of 'cant find type'.  The rest that remain are hardto fix as they require a lot of state to be passed around in order to say why wecant find it.  Adding all this state to the relevant methods would reallycomplicate the implementation.  I would rather target specific problematic 'cantfind type' scenarios and fix them one-by-one.  The reason I originally tried tofix them *all* is that we don't know which were the problematic ones, but now wehave the AspectJ dump support.  Here is a comment I put in another bug:------------------We have just built a version of AspectJ that includes some rudimentary dumpsupport - this allows us to collect diagnostic information when things go wrong. I'd like to try it out for the first time on this bug.  The version of AspectJrequired is available here (the usual place):BUILD COMPLETE -  build.356Date of build: 08/23/2004 16:06:44Time to build: 125 minutes 0 secondsLast changed: 08/23/2004 14:40:33Latest good AspectJ jar available at:download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jarPlease can you retry your failing Java 1.5 scenario with this version.  AND inorder to cause it to dump on error (it normally just dumps on abort), you willneed to set this property:org.aspectj.weaver.Dump.condition=errorIf that works then when the compiler finishes after reporting your 'Cant findtype' message it will produce an ajcore.XXX file on the disk (XXX is a date/timestamp).  Can you send me the ajcore file?  That will enable me to tell whichroute to can't find type is having problems------So - in future - if anyone hits a really unhelpful 'cant find type' message, weshould tell them to set org.aspectj.weaver.Dump.condition=error and re-run.  Ifthey then send us the ajcore.* file that comes out, we can target thatparticular path to 'cant find type' and fix it with better diagnostics. Fix released as part of AspectJ 1.2.1 "	2003-10-04 20:23:15	1065310000.0	resolved fixed	061395c	1091800000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java weaver/src/org/aspectj/weaver/ResolvedTypeX.java weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java weaver/src/org/aspectj/weaver/bcel/BcelShadow.java weaver/src/org/aspectj/weaver/patterns/DeclareParents.java weaver/src/org/aspectj/weaver/patterns/DeclareSoft.java
42573	.lst file entries not resolved relative to list file: {boot}classpath, extdirs,	My -classpath entry in a config/.lst file was resolved relative to the workingdirectory rather than to the config/.lst file.  BuildArgParser.java looks likethis would also be true for bootclasspath and extdirs, but not for injars,aspectpath, or sourceroots. I'll look at this whilst considering what changes to make wrt. the larger ajdt.core extension for AJDT building. Hmmm... it looks to me like any relative file or path specified in a .lst file (be it source file name, entry in any path - even injars etc..) is resolved relative to the working directory, not to the config file. I could change it (for everything) to make this behaviour relative - which should be backwards compatible because any relative path in such an .lst file now is either (a) broken, or (b) in a .lst file that is in the working directory.Should I switch it? We discussed this on the call today. Consensus is that everything should indeed be relative. I will fix.... Yup the change to make it relative to the .lst file sounds right.  It's too inconsistent and confusing otherwise. Fix committed to tree. Will close bug once this is available in a build. Fix now available in the latest jar from the download page. Fix released as part of AspectJ 1.2.1 	2003-09-04 18:40:22	1062720000.0	resolved fixed	648c0f4	1091730000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java util/src/org/aspectj/util/ConfigParser.java
60015	NPE, Incorrect XLint:unmatchedSuperTypeInCall warning	"(This is an incomplete bug report -- sorry no time not to further isolate.)Running AJDT 1.1.6, I get dozens of these warnings:----------Warning does not match because declaring type is java.lang.Object, if matchdesired use target(st.ata.mc.exim.DatastoreReader)[Xlint:unmatchedSuperTypeInCall] Blah.aj project/src/package/dir line 22----------for something like this code:----------import pack.Interface;...pointcut dsrCall() : call(* Interface.*(..)); // WARNING HERE...----------Each warning points to the pointcut (not the join point shadow).NPE running from the command-line with the latest tree (will attach). Created attachment 9980Command and NPE traceNPE running from the command-line with the current tree. Created attachment 9981initial attempt to reproduce.zip file with initial test case attempt that does not reproduce the bug butdoes reflect the basic structure of the code I'm using (and can't submit). P2 for investigation as NPE Great!I put this line in bug 59596:""I give up!  I can't create a minimal library equivalent to rt.jar that  contains an unresolvable member - so I can't create a testcase in CVS""It turns out that any kind of lint warning would do for showing up the NPE covered in bug 59596.  In this bug report Wes has shown another way to demonstrate the same NPE, and I've played about a bit with his code to create a testcase.  The NPE is due to the same thing as in 59596 - we attempt to make a source context when we don't have a compilation unit.  The source context we are trying to make is the one that gives us information like:public static void main(Bananas[] args) {                        ^^^^^^^which highlights the area of the source at fault.This means the fix for the 59596 NPE that I checked in yesterday covers this bug too.  The important requirement for surfacing this bug is that you are attempting to create a source context for something that came in as binary.  In the case here we are attempting to attach a lint warning.I'm going to attach the zip of my testcase setup.  The key difference between what Wes attached and what I have attached is that I've moved the UnmatchedCallSupertype code so that it comes in as binary when we compile the aspect.  (Incremental compilation is the other way it could come into the system in binary form, on the 2nd compile).  Oh and I added the line: System.err.println(this.toString());to UnmatchedCallSupertype - this is what will cause the lint warning to trigger.  Because toString() is declared on java.lang.Object but inherited by interface ILib - this means a pointcut call(* ILib.*(..)) will warn you because toString() calls won't be matched even though you have said '*' for the method name.  Am I making sense?  I think thats whats happening.If you unzip the attached zip and run:ajc -d out src\*.javaajc -inpath out A.javaYou get (with 1.2rc1):java.lang.NullPointerException        at org.aspectj.ajdt.internal.core.builder.EclipseAdapterUtils.makeLocationContext(EclipseAdapterUtils.java:50)        at org.aspectj.ajdt.internal.core.builder.EclipseAdapterUtils.makeSourceLocation(EclipseAdapterUtils.java:120)        at org.aspectj.ajdt.internal.core.builder.EclipseAdapterUtils.makeMessage(EclipseAdapterUtils.java:129)I'll attach the zip then follow up with more explanation ... Created attachment 9996Testcase zip, shows NPE. But ... that is not quite the end of the story.With the latest from HEAD which fixes the NPE, I can run that code from 60015.zip and get:C:\temp\wes\bugs2\unmatchedCallSupertype\A.java:6 warning does not match because declaring type is java.lang.Object, if match desired use target(lib.ILib) [Xlint:unmatchedSuperTypeInCall](no source information available)	see also: UnmatchedCallSupertype.java:11see also: C:\temp\wes\bugs2\unmatchedCallSupertype\out\UnmatchedCallSupertype.class1 warningThis is giving us all the information we need, but as Wes has noticed, AJDT is only paying attention to the first source location (the pointcut definition).  The new AJDT will need to support the notion of multiple locations for messages.The real problem though is if I compile all the source together:ajc A.java src\*.javabecause that gives an entirely different message:C:\temp\wes\bugs2\unmatchedCallSupertype\src\UnmatchedCallSupertype.java:6 warning does not match because declaring type is java.lang.Object, if match desired use target(lib.ILib) [Xlint:unmatchedSuperTypeInCall]public static void main(String[] args) {^^^^^^^^^^^^^^^^		see also: C:\temp\wes\bugs2\unmatchedCallSupertype\src\UnmatchedCallSupertype.java:111 warningThe first location is wrong.  It points at line 6 of UnmatchedCallSupertype.  What it should say is line 6 of A.java (to match the other variant of the message).  And because that location is wrong, when it prints the source context out, it says:public static void main(String[] args) {^^^^^^^^^^^^^^^^which is nonsense, line 6 of UnmatchedCallSupertype is nothing to do with the pointcut or the shadow.  This is messy.  It is relatively straightforward to adjust the filename used in the 2nd message to be correct (A.java) but because the error arose whilst processing shadows in UnmatchedCallSupertype then when the logic goes looking through the compilation unit for the source context, it still looks at line 6 in UnmatchedCallSupertype which is wrong.  We could swap the locations, so the first argument of this lint warning is the shadow that doesn't get matched.  But then I'm not sure if the message still makes perfect sense.  let me try it... With the switch in locations, here is the output when doing an 'all source' build:C:\temp\wes\bugs2\unmatchedCallSupertype\src\UnmatchedCallSupertype.java:11 warning does not match because declaring type is java.lang.Object, if match desired use target(lib.ILib) [Xlint:unmatchedSuperTypeInCall]System.err.println(this.toString());^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^		see also: C:\temp\wes\bugs2\unmatchedCallSupertype\A.java:6(with a lovely correct source context, although maybe it could have just underlined toString())And here is the output doing a 'binary input' build:UnmatchedCallSupertype.java:11 warning does not match because declaring type is java.lang.Object, if match desired use target(lib.ILib) [Xlint:unmatchedSuperTypeInCall](no source information available)		see also: C:\temp\wes\bugs2\unmatchedCallSupertype\A.java:6	see also: C:\temp\wes\bugs2\unmatchedCallSupertype\out\UnmatchedCallSupertype.classComments?  I'll attach the patch to create this alternative behavior.At the time we create the lint warning we also have the actual shadow signature, in this case:  method-call(java.lang.String java.lang.Object.toString())I wonder if something can be done with that to improve the message because from all the information above (including the source context), it would still take some thinking to work out which shadow on that line wouldn't match.Does anyone think I write too much in these bug reports? Created attachment 9997Patch for the weaver that reverses source locations. (1) IMHO you don't write too much.  It's *very* helpful to understand andencouraging to see things dealt with in their messy complexity, and it raisesthe bar for communications.(2) I am not sure I agree with the xlint message in this context.    warning does not match because declaring type    is java.lang.Object, if match desired use target(lib.ILib)It sounds like we're saying that using the declaring type isrequired, when AFAIK it is not.I assume that (i.e., I thought it used to be that)  call(* Foo.*(..))(where Foo is defined) would result in picking out any call where thecompile-time type of the reference is a subtype of Foo, regardless of thedeclaring type of the method -- e.g.,  Foo foo = null;  foo.toString();  // here, though toString declared by Objecti.e., while the careful programmer can specify the declaring type, s/he mightwant to specify a subtype and limit the calls accordingly.  (There is norequirement to use the declaring type.  This was the suggested workaround beforeJava 1.4 compilers because earlier compilers were setting up the call site withthe declaring type of the method rather than the compile-time type of thereference.)Which means that given  class Bar { void bar(){}}  class Foo extends Bar { void foo() {}}, the pointcut    call(* Foo.bar())will not match the shadows   new Bar().bar()   ((Bar)(new Foo()).bar(), though    call(* Bar.bar())would match the shadow   new Foo().bar(). The problem with the type in call(* type.*()) is that people think it refers tothe object being pointed at, not the reference doing the pointing.  Which is why(I think?) we have an xlint warning for this:    call(* Bar.foo())    call(* Bar.unmatched())Where the member is not defined on the reference type, this will never match,even though it could match if you did this (for some subtype of Bar):   target(Bar) && call(* foo())So in the test case (2004-04-27 04:48), where lib.ILib is in fact defined on theclasspath and properly imported by the aspect, I see no reason to issue thiswarning for any join point, and the before advice on call(* ILib.*(..)) inA.java should apply to this Client.java shadow:  new Lib().run();(And btw, I agree that the compile-time type of the reference is not the kind ofthing that should matter to a programmer when writing aspects.  A small change(e.g., a perfectly safe cast) could result in the pointcut not matching anymore.  Nonetheless, I believe that's what the semantics say, and coupled withcast join points it could be quite useful.)So back to when the warning (bug 41952) should be issued: it seems applicablewhen there is a literal method signature definitely matched and that method isdefined by a supertype.  Then either (a) at the specific method call join pointswhere there is a reference with the compile-time type of a supertype causing thepointcut not to match, the warning would be issued that the advice/pointcut isnot matching because of the specified type, and suggesting target instead; or(b) (once at the pointcut definition only) there should be a warning that itwon't pick out references even to that type if they have a compile-time type ofsome supertype which is itself a subtype of the declaring type.  I personallyprefer (b). What I've just checked solves the basic annoyance of producing the warning forsomething like toString() that is inherited from Object when you have clearlyspecified an interface.This program used to produce the warning on the indicated line:  public void run();}aspect P implements I {  public void run() { }  public static void main(String[]argv) {    aspectOf().run();    aspectOf().toString();  // XLINT WARNING HERE  }  before(): call(* I.*(..)) {}}But with the fix, it doesnt.AJDTs ability to cope with messages that have multiple source locations(discussed in this bug) is being dealt with under bug 71059 and will be in AJDT1.1.12.  That makes me feel more comfortable about the fact that we are stillproducing messages with locations that could be considered to be *the wrong wayround*. Hi Wes,Are you ok if we close this bug now - I've done as much as I currently plan todo.  The original unhelpful warning no longer comes out.  You can download themost recent development driver to test it out.thanks,Andy. Silence is consent! Fix released as part of AspectJ 1.2.1 "	2004-04-26 16:49:10	1083010000.0	resolved fixed	ef7885f	1091540000.0	tests/bugs/IncorrectXlintOnInterface.java weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java
57666	duplicate manifests cause resource-copying to gack	"(Ah, the joy of build infrastructure...)Mostly self-explanatory trace, from a build Monday Apr 5, 2004 at 08:46:01 GMT:duplicate entry: META-INF/MANIFEST.MFduplicate entry: META-INF/MANIFEST.MFjava.util.zip.ZipException: duplicate entry: META-INF/MANIFEST.MF	at java.util.zip.ZipOutputStream.putNextEntry(ZipOutputStream.java:163)	at java.util.jar.JarOutputStream.putNextEntry(JarOutputStream.java:90)	atorg.aspectj.ajdt.internal.core.builder.AjBuildManager.writeResource(AjBuildManager.java:344)	atorg.aspectj.ajdt.internal.core.builder.AjBuildManager.copyResourcesFromJarFile(AjBuildManager.java:288)	atorg.aspectj.ajdt.internal.core.builder.AjBuildManager.copyResourcesToDestination(AjBuildManager.java:253)	atorg.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:195)	atorg.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:94)	at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:102)	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)	at org.aspectj.tools.ajc.Main.run(Main.java:280)	at org.aspectj.tools.ajc.Main.runMain(Main.java:217)	at org.aspectj.tools.ajc.Main.main(Main.java:79) There are several routes into this code. Could you attach a testcase or describe what you were doing when the failure occured.Thanks Sorry, no time now to try to create a test case.  Perhaps the manifest fileautomatically included when the zip is created is not added to the list of knownresources in AjState.   *** Bug 66267 has been marked as a duplicate of this bug. *** Using a JarInputStream is a bit of a minefield. Its behaviour, especially WRT ""getManifest()"", varies accounding to how the JAR file was build: ZIP vs JAR. To ensure the first orginal manfiest encountered is copied injars/inpath to outjar:1. Use JarFile rather than JarInputStream2. Explicitly test for ""META-INF/MANIFEST.MF"" entry3. Add DiplicateManifestTest to weave a JAR built using ZIP Created attachment 13683Testcase and fixajde: testcase & dataajdt: AjBuildManager & BcweaverJarMakerweaver: BcelWeaver1. Apply 3 patches and import ZIP2. Run BcweaverJarMaker and run""ajde/testdata/DuplicateManifestTest/update-injar.xml (Ant) to create injar.jarand aspectjar.jar Matthews fix integrated.  Waiting for build note before closing bug. Fix available:BUILD COMPLETE -  build.325Date of build: 08/02/2004 17:56:01Time to build: 89 minutes 54 secondsLast changed: 08/02/2004 16:47:52Last log entry: Fix for Bugzilla Bug 57666 duplicate manifests causeresource-copying to gack(Contributed by Matthew Webster)Latest good AspectJ jar available at:download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar Fix released as part of AspectJ 1.2.1 "	2004-04-06 17:22:16	1081290000.0	resolved fixed	2b8fa31	1091460000.0	ajde/testsrc/org/aspectj/ajde/AjdeTests.java ajde/testsrc/org/aspectj/ajde/DuplicateManifestTest.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java
67774	Nullpointer-exception in pointcuts using withincode() clause	"<Pyinson Data Over Head> Thanks Michael for privately sending me your source... from all that source I'vefinally recreated the problem with this tiny program:aspect B {  public A.new(String s) { }  declare warning: withincode(void main(..)): ""X"";}class A {  private final static String name = A.class.getName();}I suspected it was an initialization issue but I couldn't recreate it myself. Then I learned from your application that an ITD'd ctor was also in the mix.Anyway, I'll now work on fixing it ... *** Bug 65688 has been marked as a duplicate of this bug. *** Ok.  The problem is to do with the preinitialization join point shadow notcorrectly returning the right signature for the ctor that contains it.  Itreturns null when asked 'where are you?' - which results in an NPE.  Althoughthe pointcuts we are discussing in this bug are looking for other shadows (notin ctors), we still attempt to match against preinitialization shadows from ITDdctors.  The fix is to simply get it to return the signature for the ctorcontaining it.Fix checked in, waiting for build before closing this bug. Fixed, available in dev build:BUILD COMPLETE -  build.324Date of build: 08/02/2004 15:14:37Time to build: 100 minutes 0 secondsLast changed: 08/02/2004 14:43:47Last log entry: Fix for Bugzilla Bug 67774 Nullpointer-exception in pointcutsusing withincode() clauseLatest good AspectJ jar available at:download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar Fix released as part of AspectJ 1.2.1 "	2004-06-18 04:54:37	1087550000.0	resolved fixed	7f19ab4	1091450000.0	tests/bugs/WithincodeNPE01.java weaver/src/org/aspectj/weaver/bcel/BcelShadow.java
70773	AspectJ Error: ConncurrentModificationException thrown: null	"In AspectJ 1.1.11 for Eclipse, build ID 1.2.0 (and also in the previous 1.1.10)on Eclipse version 3.0.0, build ID 200406351208: If I enable incrementalcompilation and make a change to a file (typing a space and deleting it, orediting a comment), I get a ""ConncurrentModificationException thrown: null"" error. <Pyinson Data Over Head> <Pyinson Data Over Head> (BTW, in the direct above comment, the first three [enter]s were with nochanges. The final error, which caused the execption, was when I modified a pureJava file by typing a space and deleting it, and then saved it (and then hit the[enter])). I can half-see what the issue is.  I'd just like to put a testcase in before Ifix it.  Is there any way you can share this code with me?  My tiny testcaseswon't exercise the codepath that is failing.  It is something to do with theincremental compilation logic noticing that it needs to recompile other typesthan the one you modified. My project has ~150 files, so it's difficult to effectively make a smaller testcase, however we could set something up where I can send you the whole thing.-Macneil Thanks for the offer.  Can you possibly send me a zip of the project so I canlook at debugging it on my machine?  (send the zip to clemas@uk.ibm.com)Andy. Hi, thanks for sending me your code.  I have recreated the failure (hurray!).Now I just have to understand it .... Right... I recreated the bug and I have fixed the bug... what I don't have is a nice simple testcase.  It requires changing a type that pulls in other types that pulls in other types that pulls in other types (etc...) - so I'll work on knocking something up (might trim down Macneils code if I can, into something that fails).The fix was to avoid locking a list with an iterator.  If we move to a queue based approach where I just take the first entry of the list whilst it has something on it and process it, the infrastructure is free to add more entries to the list which will be processed eventually. Well, I'm glad I gave up early on the idea of coming up with a minimal test caseto show it. :-) I want to move on to the next bug, so I'm committing my fix for this one.FYI, using Macneils application, I put a trace statement in the AjLookupEnvironment.createBinaryTypeFrom() method that indicates the type for which we are creating a binary type binding.  So, if I do an incremental build of his project, it then waits with the usual incremental prompt.  If I make a change to Menus.java (just adding or deleting a blank line) and save it, then press enter against the incremental prompt, I get this list of types:javax/swing/JMenuBarjavax/swing/JComponentjava/awt/Containerjava/awt/Componentjava/lang/Objectjava/io/Serializablejava/awt/MenuContainerjava/awt/image/ImageObserverjavax/swing/MenuElementjavax/accessibility/Accessiblejava/awt/event/ActionListenerjava/util/EventListenerjavax/swing/JMenuBar$AccessibleJMenuBarjavax/swing/JComponent$ReadObjectCallbackjavax/swing/JComponent$KeyboardStatejavax/swing/JComponent$IntVectorjavax/swing/JComponent$EnableSerializationFocusListenerjavax/swing/JComponent$ActionStandinjavax/swing/JComponent$AccessibleJComponentjava/awt/Container$MouseEventTargetFilterjava/awt/Container$EventTargetFilterjava/awt/Container$DropTargetEventTargetFilterjava/awt/Container$AccessibleAWTContainerjava/awt/Component$SingleBufferStrategyjava/awt/Component$NativeInLightFixerjava/awt/Component$FlipBufferStrategyjava/awt/Component$BltBufferStrategyjava/awt/Component$AccessibleAWTComponentjava/awt/Component$AWTTreeLockjavax/swing/AbstractActionjava/lang/Cloneablejavax/swing/Actionjavax/swing/AbstractAction$ArrayTablejava/awt/Eventjava/util/Vectorjavax/swing/JMenuItemjavax/swing/JCheckBoxMenuItemedu/ucsd/nebulous/Sessionedu/ucsd/nebulous/SessionEventsedu/ucsd/nebulous/SessionEventRoutingjava/util/Listedu/ucsd/nebulous/TraversalTypeComboBoxedu/ucsd/nebulous/TraversalTypeComboBoxMediatingedu/ucsd/nebulous/FileViewRootCursorMediatingedu/ucsd/nebulous/AtlasButtonPaneledu/ucsd/nebulous/AtlasButtonPanelMediatingedu/ucsd/nebulous/NFileViewRootedu/ucsd/nebulous/NFileViewRootSessionMediatingedu/ucsd/nebulous/TreePaneledu/ucsd/nebulous/TreePanelMediatingedu/ucsd/nebulous/ExternalEditorMediatoredu/ucsd/nebulous/ExternalEditorMediatingedu/ucsd/nebulous/ExternalEditoredu/ucsd/nebulous/SessionMediatingjava/awt/Coloredu/ucsd/nebulous/ColorSequenceGenerationjava/util/Randomjava/io/PrintWriteredu/ucsd/nebulous/ProjectIOjava/util/SetAt the point 'Set' is printed we are making that concurrentmodification to the list we are iterating over and we go bang.  As you can see, it is not a small list that lends itself easily to recreation - there are inner aspects/inner classes and awt/swing dependencies that all seem to complicate the situation.I will update this bug when there has been a successful build with my fix in - can you then try it Macneil and let me know if it definetly fixes the problem for you? (And that the application when built incremenally, continues to run correctly?).thanks. *** Bug 68483 has been marked as a duplicate of this bug. *** Fixed and available in build:BUILD COMPLETE -  build.323Date of build: 08/02/2004 12:13:46Time to build: 115 minutes 29 secondsLast changed: 08/02/2004 11:14:39Last log entry: Fix for Bugzilla Bug 70773 AspectJ Error:ConncurrentModificationException thrown: nullLatest good AspectJ jar available at:download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jarMacneil, can you give that version of AJ a try? thanks. I'm closing this bug just to try and get my bug list under control ;)  Feel freeto reopen if it turns out that it does not fix the problem. Fix released as part of AspectJ 1.2.1 "	2004-07-23 21:07:15	1090630000.0	resolved fixed	9aed31d	1091440000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java
30439	"spurious ""circular dependency"" error"	"AspectJ Compiler 1.1beta4This program:aspect Foo {   pointcut p1(): execution(void f()) && cflow(execution(void f1()));  pointcut p2(): execution(void f()) && cflow(execution(void f2()));  before(): p1() { }  after():  p1() { }  before(): p2() { }  after():  p2() { }}class A {  void f1() { f(); }  void f2() { f(); }  void f() { }}results in these errors:circular dependency at method-execution(void A.f())circular dependency at method-execution(void A.f())circular dependency at method-execution(void A.f())circular dependency at method-execution(void A.f())4 errorsIf I comment out any one of the four pieces of advice, all the errors go away.Also, assuming that there is a valid reason for printing this error sometimes, how come there's no line number?--Doug *** Bug 30438 has been marked as a duplicate of this bug. *** The error message needs much work.  It should say something closer to:  can't determine precedence between two pieces of advice that apply to the same join point (method-execution(void A.f()))  after@2 > before@1 > before@3 > after@2I'll leave this as a bug until the error message is improved; however, otherwise the compiler is correct to prohibit this particular aspectYou should be able to fix this problem by grouping both of your after advice together lexically, i.e.before p1before p2after p1after p2The reasons for this are fairly complicated, but have to do with the rules forordering multiple pieces of advice that can apply to the same join point.  See the section on ""Advice precedence"" in the semantics secton of the programming guide for what might be an explanation.  If you still don't fully understand or agree with the issue, please send a message to aspectj-users and either Erik or I will explain in more detail. Lowering priority and severity as this is only about a better error message. *** Bug 40655 has been marked as a duplicate of this bug. *** This program now outputs the following:/home/colyer/tmp/Doug.java:5 error can't determine precedence between two or more pieces of advice that apply the same join point: method-execution(void A.f())before(): p1() { }^^^^^^^^^^^	/home/colyer/tmp/Doug.java:6 error can't determine precedence between two or more pieces of advice that apply the same join point: method-execution(void A.f())after():  p1() { }^^^^^^^^^^^	/home/colyer/tmp/Doug.java:7 error can't determine precedence between two or more pieces of advice that apply the same join point: method-execution(void A.f())before(): p2() { }^^^^^^^^^^^	/home/colyer/tmp/Doug.java:8 error can't determine precedence between two or more pieces of advice that apply the same join point: method-execution(void A.f())after():  p2() { }^^^^^^^^^^^	4 errorsWill close the defect once this is available in a published build. *** Bug 57993 has been marked as a duplicate of this bug. *** The even better version.../home/colyer/tmp/Doug.java:5 [error] can't determine precedence between two or more pieces of advice that apply to the same join point: method-execution(void A.f())before(): p1() { }^^^^^^^^^^^	/home/colyer/tmp/Doug.java:6 [error] can't determine precedence between two or more pieces of advice that apply to the same join point: method-execution(void A.f())after():  p1() { }^^^^^^^^^^^	/home/colyer/tmp/Doug.java:7 [error] can't determine precedence between two or more pieces of advice that apply to the same join point: method-execution(void A.f())before(): p2() { }^^^^^^^^^^^	/home/colyer/tmp/Doug.java:8 [error] can't determine precedence between two or more pieces of advice that apply to the same join point: method-execution(void A.f())after():  p2() { }^^^^^^^^^^^	4 errorsThanks :) Fix now available from AspectJ download page. Fix released as part of AspectJ 1.2.1 "	2003-01-28 16:20:10	1043790000.0	resolved fixed	4feb835	1091110000.0	weaver/src/org/aspectj/weaver/Advice.java weaver/src/org/aspectj/weaver/Lint.java weaver/src/org/aspectj/weaver/NewConstructorTypeMunger.java weaver/src/org/aspectj/weaver/ResolvedTypeX.java weaver/src/org/aspectj/weaver/Shadow.java weaver/src/org/aspectj/weaver/WeaverMessages.java weaver/src/org/aspectj/weaver/WeaverStateInfo.java weaver/src/org/aspectj/weaver/World.java weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java weaver/src/org/aspectj/weaver/bcel/ClassPathManager.java weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java weaver/src/org/aspectj/weaver/patterns/DeclareParents.java weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java weaver/src/org/aspectj/weaver/patterns/DeclareSoft.java weaver/src/org/aspectj/weaver/patterns/IfPointcut.java weaver/src/org/aspectj/weaver/patterns/PerFromSuper.java weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java weaver/src/org/aspectj/weaver/patterns/TypePattern.java weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java weaver/testsrc/org/aspectj/weaver/BcweaverTests.java weaver/testsrc/org/aspectj/weaver/WeaverMessagesTestCase.java
61536	Front-end bug,  shouldn't allow patterns of the form  foo.., should be foo..*	"See following code:public class Test2 {  public static void main(String args[])    { System.out.println(""Hi"");    }}aspect Aspect2 {  // shouldn't one have to say,  java..* instead of java.. in the following??  // Note that the first advice (incorrect one) passes the front-end, but does  // not match,  whereas the second one does match.   I believe the front-end  // should reject the first one.  before () : call( * java..(..)) && within(Test2)    { System.out.println(        ""Incorrect One: Before a call of method in a java package "");    }  before () : call( * java..*(..)) && within(Test2)    { System.out.println(        ""Correct One: Before a call of method in a java package "");    }} Thanks for another clear bug report.  This is also a valid bug, but not a super serious one.  This should be fixed after the emminent 1.2 release.This should be an easy bug to fix from the code in org.aspectj.weaver.patterns.PatternParser.  That's a fairly simple hand-coded LL(k) recursive decent parser for pointcut patterns.  Fixing this bug should be a straightforward process and completely contained within that single file. I think this a potentially dangerous bug because I did find some old examplesor documentation around that seemed to use the form  java.. (sorry I don'tremember where I saw it).  It is a minor bug to accept something like ""java.."" when the programmerreally means ""java..*"".  However, if it ""java.."" is silently accepted by thefront-end,  but not matched by the back-end (as my example bug report shows),then I think it is more serious.If it is simple to fix, I think you should fix it for 1.2. Fixed in CVS, waiting for build then I'll close the bug.I also fixed the case of ending a name pattern with a '.' that isn't included inthe original bug report.  That is less common as you typically get a messageabout not finding a type that matches.  (You now get a message saying its anbadly formed pattern).Parser errors that can come out now include:""name pattern cannot finish with ..""                          ""name pattern cannot finish with ."" Fixed in developer build available from our download page.BUILD COMPLETE -  build.320Date of build: 07/29/2004 17:22:44Time to build: 120 minutes 38 secondsLast changed: 07/29/2004 16:51:45Latest good AspectJ jar available at: download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar Fix released as part of AspectJ 1.2.1 "	2004-05-09 12:50:40	1084120000.0	resolved fixed	45bce91	1091100000.0	tests/bugs/EllipsesStar.java weaver/src/org/aspectj/weaver/patterns/PatternParser.java
48990	Special case if(false) to not require a dynamic test	"FastMatch, the efficient pattern matching for pointcuts on the constant pool, iscurrrently only implemented for the within pointcut. I am planning to providefurther oimplementations for other pointcuts by release 1.2. I've marked this bug as target 1.2 so that we remember to track anything you can do here as part of the 1.2 release. Created attachment 8114Implements recognition of if(false) during FastMatchWith this patch if(false) is evaluated to FuzzyBoolean.NEVER during FastMatch. I submitted a small patch for FastMatch of IfPointcut. This adresses the idiom ""somePointcut() && if(false)"" which is often used to temporarily exclude certain pointcuts for debug purposes. Such a pointcut is now automatically evaluated to  ""NEVER"" match. Created attachment 8118Part two of the patch for handling of if(false)This prevents a method to be generated at all for if(false). First off I've renamed this bug to reflect what you're working on.  This is not a fast match issue and that's somewhat confused your solution.The right way to implement this feature is to modify IfPseudoToken to return a Pointcut.MatchesNothing object for the special case of if(false).  This will produce a pointcut that has all of its methods correctly implemented to handle a pcd that can matches no join points.There are several problems with your solution.  Starting with the fastMatch change:FuzzyBoolean.NEVER is a very special value that isn't correct here.  You should just use FuzzyBoolean.NO as is used in the WithinPointcut that I pointed you at as the canonical example for fastmatch.  This is important for the case where someone uses !if(false) either directly or through a named pointcut.You also can't just modify fastMatch without making similar modifications to the core match routine.  Because of things like !if(false) you need to be prepared to handle a normal match call -- I believe your solution would create a call to a non-existant method in this case.I can't believe that you wrote this code:  if (this.expr.getClass()==FalseLiteral.class) return;Reflection should be used sparingly and only when really needed.  Use ""this.expr instanceof FalseLiteral"" if you must test for type.  Even better would be to use methods on Expression if those are available. I've implemented a variation on Jim's suggestion for if(false) and if(true).Will resolve the bug as fixed once these are available in a build. Fix available in latest build from www.eclipse.org/aspectj. Fix released as part of AspectJ 1.2.1 "	2003-12-17 06:29:52	1071660000.0	resolved fixed	10c6de6	1091030000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/IfPseudoToken.java weaver/src/org/aspectj/weaver/patterns/IfPointcut.java weaver/src/org/aspectj/weaver/patterns/Pointcut.java
64331	java.lang.NullPointerException  in WeaverMessageHandler class	I've got an java.lang.NullPointerException while running the aspectJ 1.2compiler. That's the stack trace:     [iajc] If you don't find the exception below in a bug, please add a new bug     [iajc] at http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJ     [iajc] To make the bug a priority, please include a test program     [iajc] that can reproduce this exception.     [iajc] null     [iajc] java.lang.NullPointerException     [iajc]     atorg.aspectj.ajdt.internal.compiler.WeaverMessageHandler.buildSeeAlsoProblems(WeaverMessageHandler.java:172)     [iajc]     atorg.aspectj.ajdt.internal.compiler.WeaverMessageHandler.handleMessage(WeaverMessageHandler.java:100)     [iajc]     atorg.aspectj.weaver.ResolvedTypeX.checkInterTypeMungers(ResolvedTypeX.java:989)     [iajc]     at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:716)     [iajc]     atorg.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:689)     [iajc]     atorg.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:615)     [iajc]     at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:563)     [iajc]     atorg.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:239)     [iajc]     atorg.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:114)     [iajc]     atorg.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:376)     [iajc]     atorg.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:601)     [iajc]     atorg.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:160)     [iajc]     atorg.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:94)     [iajc]     at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:102)     [iajc]     at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)     [iajc]     at org.aspectj.tools.ajc.Main.run(Main.java:280)     [iajc]     at org.aspectj.tools.ajc.Main.runMain(Main.java:217)     [iajc]     atorg.aspectj.tools.ant.taskdefs.AjcTask.executeInSameVM(AjcTask.java:1157)     [iajc]     at org.aspectj.tools.ant.taskdefs.AjcTask.execute(AjcTask.java:954)     [iajc]     at org.apache.tools.ant.Task.perform(Task.java:341)     [iajc]     atorg.apache.tools.ant.taskdefs.Sequential.execute(Sequential.java:117)     [iajc]     at org.apache.tools.ant.Task.perform(Task.java:341)     [iajc]     at net.sf.antcontrib.logic.IfTask.execute(Unknown Source)     [iajc]     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)     [iajc]     atsun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)     [iajc]     atsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)     [iajc]     at java.lang.reflect.Method.invoke(Method.java:324)     [iajc]     at org.apache.tools.ant.TaskAdapter.execute(TaskAdapter.java:147)     [iajc]     atorg.apache.tools.ant.UnknownElement.execute(UnknownElement.java:193)     [iajc]     at org.apache.tools.ant.Task.perform(Task.java:341)     [iajc]     at org.apache.tools.ant.Target.execute(Target.java:309)     [iajc]     at org.apache.tools.ant.Target.performTasks(Target.java:336)     [iajc]     at org.apache.tools.ant.Project.executeTarget(Project.java:1339)     [iajc]     at org.apache.tools.ant.Project.executeTargets(Project.java:1255)     [iajc]     at org.apache.tools.ant.Main.runBuild(Main.java:609)     [iajc]     at org.apache.tools.ant.Main.start(Main.java:196)     [iajc]     at org.apache.tools.ant.Main.main(Main.java:235)       [if] Error in class net.sf.antcontrib.logic.IfTaskSorry, i have no simple test case for that problem... This error occurs because type mungers don't remember their source location.In this particular case, a type munger is ITDing an abstract method onto a classand then a subclass of that class is not implementing the ITDed method.  The NPEoccurs if, at the point the subclass is compiled, the aspect containing theinter type declaration is in binary source form rather than real source form. When it is in binary source form the ITD doesn't know its originating sourcelocation and when we want to put out an error message that says 'subclass needsto implement abtract intertype declaration' we pass a null location as the 'seealso' location.Until type mungers remember their source location, the fix is to say that if wehave no source location for the munger, use the source location of thecontaining aspect.I have also put some code in the message handling code that will barf if anyonepasses a null location again, so it will be more obvious what the problem is infuture bugs.fix checked in - waiting for build. Fix available in latest dev build from www.eclipse.org/aspectj. *** Bug 71148 has been marked as a duplicate of this bug. *** Fix released as part of AspectJ 1.2.1 	2004-05-27 09:58:21	1085670000.0	resolved fixed	573741c	1091030000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverMessageHandler.java tests/bugs/abstractITDs/A.java tests/bugs/abstractITDs/C.java weaver/src/org/aspectj/weaver/ResolvedTypeX.java
58681	-X should output available -X options	"ajc should emit the available -X options on -help or -X request (the latter likejava) to get more traffic and feedback on the experimental options. Fixed following java compiler conventions.==> ajc -?AspectJ Compiler	Usage: <options> <source file | @argfile>..AspectJ-specific options:	-inpath <list>      use classes in dirs and jars/zips in <list> as source	                    (<list> uses platform-specific path delimiter)	-injars <jarList>   use classes in <jarList> zip files as source	                    (<jarList> uses classpath delimiter)	                    deprecated - use inpath instead.	-aspectpath <list>  weave aspects from <list> zip files into sources	                    (<list> uses classpath delimiter)	-outjar <file>      put output classes in zip file <file>	-argfile <file>     specify line-delimited list of source files	-incremental        continuously-running compiler, needs -sourceroots	                    (reads stdin: enter to recompile and 'q' to quit)	-sourceroots <dirs> compile all .aj and .java files in <dirs>	                    (<dirs> uses classpath delimiter)	-emacssym           generate .ajesym symbol files for emacs support	-Xlint              same as '-Xlint:warning'	-Xlint:<level>      set default level for crosscutting messages	                    (<level> may be ignore, warning, or error)	-Xlintfile <file>   specify properties file to set per-message levels	                    (cf org/aspectj/weaver/XlintDefault.properties)	-X                  print help on non-standard optionsStandard Eclipse compiler options: Options enabled by default are prefixed with '+'... ==> ajc -XAspectJ Compiler non-standard options:	-XnoInline          don't inline advice	-XlazyTjp           create thisJoinPoint objects lazily	-Xreweavable        create class files that can be subsequently rewoven	                    by AspectJ	-Xreweavable:compress as above, but also compress the reweaving information	-XnoWeave           compile classes but do not weave. Deprecated, use	                    reweavable instead.	 and I even managed to mess it up. -XserializableAspects now added too... Fix released as part of AspectJ 1.2.1 "	2004-04-15 12:19:15	1082050000.0	resolved fixed	6ea8300	1090940000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/AjdtCommand.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java org.aspectj.ajdt.core/testsrc/EajcModuleTests.java org.aspectj.ajdt.core/testsrc/org/aspectj/tools/ajc/MainTest.java
69459	Hiding of Instance Methods by static methods	Using Introduction it is possible to hide instance methods by static methods.Example:class Super {  public void m(){};}class Sub {}aspect A {  public static void Sub.m(){}}Acccording to the Java Language Specification this is not allowed. Is thisbehaviour desired ??It is also possible to override static methods by instance methods, wich causesa compile time error in java. Fix checked in - waiting for build. Fixed BUILD COMPLETE -  build.317Date of build: 07/28/2004 12:16:33Time to build: 121 minutes 44 secondsLast changed: 07/27/2004 18:38:25Latest good AspectJ jar available at:download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar Fix released as part of AspectJ 1.2.1 	2004-07-07 09:10:42	1089210000.0	resolved fixed	b184363	1090940000.0	tests/bugs/intertypeOverrides/Aspect1.java tests/bugs/intertypeOverrides/Aspect2.java tests/bugs/intertypeOverrides/IntertypeOverrides.java tests/bugs/intertypeOverrides/IntertypeOverrides2.java tests/bugs/intertypeOverrides/Subclass.java tests/bugs/intertypeOverrides/Superclass.java weaver/src/org/aspectj/weaver/ResolvedTypeX.java
53999	"""can't bind type"" message has $ for . in type name for declare soft"	"cosmetic mistake in error message...expected: can't bind type name 'unknown.Error'  actual: can't bind type name 'unknown$Error'(not sure why it would ever be munged with $)public class Test {	public static void main(String[] args) {		test();	}	static void test() {		throw new Error(""hello"");	}	static aspect A {		declare soft : unknown.Error : call(void test()); // CE	}} This error message is caused by first looking for a type Error in the unknown package and then looking for the inner type Error in the class unknown.  This second check uses the binary format for inner type names of unknown$Error.I'm leaving as a bug until the cosmetic error is fixed. fix integrated - waiting for build. Fixed as of:BUILD COMPLETE -  build.317Date of build: 07/28/2004 12:16:33Time to build: 121 minutes 44 secondsLast changed: 07/27/2004 18:38:25Latest good AspectJ jar available at:download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar Fix released as part of AspectJ 1.2.1 "	2004-03-07 22:07:22	1078720000.0	resolved fixed	936459c	1090920000.0	tests/bugs/Cosmetic.java weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java
70619	"compiler aborts with ""conflicting dominates orders"" with circular declare precedences"	"The following program causes ajc 1.2 to abort:public class Conflict { public static void main(String[] args) { } }aspect Conflict1 {  declare precedence: Conflict1, Conflict2;   before(): execution(* *(..)) { }}aspect Conflict2 {  declare precedence: Conflict2, Conflict1;  after(): execution(* *(..)) { }} The code was actually throwing a BCException() in this case (very unhelpful). The exception on compiling the supplied testcase was:C:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\bug70619>ajc Precedence.javatrouble in:ABORTException thrown from AspectJ DEVELOPMENTThis might be logged as a bug already -- find current bugs at  http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&component=CompilerBugs for exceptions thrown have titles File:line from the top stack,e.g., ""SomeFile.java:243""If you don't find the exception below in a bug, please add a new bugat http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJTo make the bug a priority, please include a test programthat can reproduce this exception.conflicting dominates ordersconflicting dominates ordersorg.aspectj.weaver.BCException: conflicting dominates orders        at org.aspectj.weaver.World.compareByDominates(World.java:309)        at org.aspectj.weaver.bcel.BcelAdvice.compareTo(BcelAdvice.java:379)        atorg.aspectj.util.PartialOrder$SortObject.addDirectedLinks(PartialOrder.java:68)        atorg.aspectj.util.PartialOrder.addNewPartialComparable(PartialOrder.java:88)        at org.aspectj.util.PartialOrder.sort(PartialOrder.java:121)        at org.aspectj.weaver.Shadow.sortMungers(Shadow.java:330)        at org.aspectj.weaver.Shadow.implement(Shadow.java:323)        atorg.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:1153)        at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:361)        at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:82)        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:726)        at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:691)        at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:617)        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:565)        atorg.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:239)        atorg.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:114)        at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:376)        atorg.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:717)        atorg.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:170)        atorg.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:100)        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:102)        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)        at org.aspectj.tools.ajc.Main.run(Main.java:287)        at org.aspectj.tools.ajc.Main.runMain(Main.java:224)        at org.aspectj.tools.ajc.Main.main(Main.java:79)1 fail|abortI've now fixed it to do correct error handling.  When you get these kinds ofconflict it now says:C:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\bug70619\Precedence.java errorconflicting declare precedence orderings for aspects: Conflict1 and Conflict2(no source information available)	see also: C:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\bug70619\Precedence.java:10see also: C:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\bug70619\Precedence.java:41 errorThe 'see also' locations are the conflicting locations of the declare precedencestatements.  We cannot use one of these locations as the primary location in theerror message because the primary error location for a message must be in thefile that was being processed when the error occurred.  In the case of havingeverything in one file this is not an issue, but if the class was in A, and theaspects were in B and C - we cannot add an error message to B or C whilstprocessing A - just in case we have already dealt with B/C and have alreadyreported all of its errors. fixed:BUILD COMPLETE -  build.315Date of build: 07/26/2004 21:28:08Time to build: 305 minutes 55 secondsLast changed: 07/26/2004 14:30:19Last log entry: Fix for Bug 70619 compiler aborts with ""conflicting dominatesorders"" with circular declare precedencesLatest good AspectJ jar available at:download.eclipse.org/technology/ajdt/dev/aspectj-DEVELOPMENT.jar Fix released as part of AspectJ 1.2.1 "	2004-07-22 10:11:01	1090510000.0	resolved fixed	75852d7	1090850000.0	tests/bugs/bug70619/Conflict.java tests/bugs/bug70619/Precedence.java weaver/src/org/aspectj/weaver/World.java
70008	problem with ajdoc -public	"Using the spacewar example, the following works fine:    ajdoc -private -d doc spacewar coordinationbut the following breaks:    ajdoc -public -d doc spacewar coordinationThe end of the failing output is below. Display.html andDisplay.DisplayAspect.html were not generated as the types are not public, sopresumably the decorator shouldn't be looking for them in this case.> Decorating html files...> Decorating C:\aspectj1.2\doc\examples\doc\spacewar\Debug.html...> Decorating C:\aspectj1.2\doc\examples\doc\spacewar\Display.DisplayAspect.html...An internal error occured in ajdocPlease copy the following text into an email message and send it,along with any additional information you can add to:       aspectj-dev@eclipse.orgjava.io.FileNotFoundException: C:\aspectj1.2\doc\examples\doc\spacewar\Display.DisplayAspect.html (The system cannot find the file specified)java.io.FileNotFoundException: C:\aspectj1.2\doc\examples\doc\spacewar\Display.DisplayAspect.html (The system cannot find the file specified)        at java.io.FileInputStream.open(Native Method)        at java.io.FileInputStream.<init>(FileInputStream.java:106)        at java.io.FileReader.<init>(FileReader.java:55)        at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFile(HtmlDecorator.java:142)        at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromDecl(HtmlDecorator.java:115)        at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromDecls(HtmlDecorator.java:54)        at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromInputFiles(HtmlDecorator.java:43)        at org.aspectj.tools.ajdoc.Main.main(Main.java:210) Fixed.This turned out to be a trickier problem, and I expanded the CoverageTestCase and SpacewarTestCase tests to cover it more thoroughly.  In a nutshell, the compiler's AST makes any nested aspect ""public"" accessiblity, whether it is declared ""package"" or ""private"" visibility.  This results in a mismmatch between the structure model and the source code.I was tempted to fix this by making the structure model treat those aspects as private.  However, this would be a somewhat time consuming operation since it would need to parse the original source code rather than relying on the AST.  So instead I made ajdoc treat this case correctly.PLEASE NOTE THE SIDE-EFFECT of keeping this behavior: the outline view will continue to show private/package nested aspects as public, sine that's what's in the bytecode. Matt - I've just checked in a new org.aspectj.ajde with Miks fix in it - can youtest it? I've verified the fix from AJDT. Thanks guys. Fix released as part of AspectJ 1.2.1 "	2004-07-14 07:16:55	1089800000.0	resolved fixed	8dc0845	1089840000.0	ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java ajdoc/testdata/coverage/foo/PkgVisibleClass.java ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java ajdoc/testsrc/org/aspectj/tools/ajdoc/SpacewarTestCase.java
69011	ajdoc fails when using default package	"When trying to document classes that are in the default package, the following error occurs:> Calling ajc...> Building signature files...> Calling javadoc...Loading source file C:\eclipse_RC3\eclipse\ajdocworkingdir\A.java...C:\eclipse_RC3\eclipse\ajdocworkingdir\A.java:1: <identifier> expectedpackage ;        ^1 error> Decorating html files...> Decorating C:\doc\classX.html...An internal error occured in ajdocPlease copy the following text into an email message and send it,along with any additional information you can add to:                                                                                    aspectj-dev@eclipse.org                                                                                            java.io.FileNotFoundException: C:\doc\classX.html (The system cannot find the file specified)java.io.FileNotFoundException: C:\doc\classX.html (The system cannot find the file specified)	at java.io.FileInputStream.open(Native Method)	at java.io.FileInputStream.<init>(FileInputStream.java:106)	at java.io.FileReader.<init>(FileReader.java:55)	at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFile(HtmlDecorator.java:142)	at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromDecl(HtmlDecorator.java:115)	at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromDecls(HtmlDecorator.java:54)	at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromInputFiles(HtmlDecorator.java:43)	at org.aspectj.tools.ajdoc.Main.main(Main.java:210) Fixed.  The problem was in the generation of the stub files, which created an improper package declaration for compilation units in the default package.org.aspectj.tools.ajdoc/CoverageTestCase.java has been expanded to test for this. Fix released as part of AspectJ 1.2.1 "	2004-06-30 10:22:51	1088610000.0	resolved fixed	2cc4826	1089050000.0	ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java ajdoc/testdata/coverage/InDefaultPackage.java ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java
68494	ajdoc does not support .aj files	In addition to accepting .java source files ajdoc needs to accept .aj files. Fixed.  Someone should verify that this works in AJDT. Luzius has confirmed this is fixed in AJDT 1.1.11, well done Mik ! cool :) that's a great piece of team work. thanks for the speedy turnaround mik Fix released as part of AspectJ 1.2.1 	2004-06-24 12:04:22	1088090000.0	resolved fixed	3707411	1088120000.0	ajdoc/src/org/aspectj/tools/ajdoc/Main.java ajdoc/src/org/aspectj/tools/ajdoc/StructureUtil.java ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java ajdoc/testdata/coverage/foo/UseThisAspectForLinkCheck.java ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java
61411	AJDoc launch script on Windows can lose arguments	"Using AspectJ 1.2rc1 on Windows XPThis report highlights a problem that I've seen using ajdoc.bat on Windows butthe issue applies equally to the ajc.bat and ajbrowser.bat files as well.The %ASPECTJ_HOME%\bin\ajdoc.bat file that users run to launch the ajdoc toolimposes a limit of only 9 command line arguments that may be passed to theclass org.aspectj.tools.ajdoc.Main. In scenarios where there the -sourcepath,-classpath, -d etc options are used it is easy for these to ""eat up"" the listof arguments that are passed into the JVM. A long list of packages enteredat the end of the ajdoc.bat command can be truncated or possibly even ignored(in which case an error message will be output telling the user that noclasses or packages have been specified).In order to prevent a limit being put on the number of arguments passed tothe launched JVM, the invocation line needs to end with %* rather than the%1 %2 %3 %4 %5 %6 %7 %8 %9 list it currently uses.The proposed fix also *seems* (could somebody else confirm this ?) to sortout another problem regarding the ajdoc.bat file which is this : long semi-colon delimited paths supplied as the arguments for the -sourcepath and -classpath options seem to get split apart and passed into the JVM as separate arguments unless the entire path list is supplied inside quotes. This shouldnot be necessary. It seems that the batch file processor interprets thesemi-colons in a path list as delimiters between arguments. Consequentlyeach element in the path list is treated as a separate argument insteadof being part of one big string representing the sourcepath or classpath. Created attachment 10400One line change to include WinXP in the definition of a ""new"" Windows platform.Will need a replacement build.jar to be built for lib/build . Fix checked in and verified. Fix released as part of AspectJ 1.2.1 "	2004-05-07 12:00:01	1083950000.0	resolved fixed	39c3a3b	1085760000.0	build/src/$installer$/org/aspectj/Main.java
62227	Load Time Weaving aborts on any kind of warning (declare/xlint)	The message handler in the weaving adapter for load time weaving says:public boolean handleMessage(IMessage message) throws AbortException {  if (!isIgnoring(message.getKind())) {    if (verbose) System.err.println(message.getMessage());    throw new AbortException(message);  }  return true;}This means for warnings it goes bang.  So, even a declare warning that is meant to tell the user something informational during a LTW will cause the code to blow up.  The fix is straightforward and simply to log warning messages and only fail for error messages.  I am waiting for a testcase from Matthew before checking in the fix. Created attachment 10642Tescases for declare warning declare errorPlease run the modified BcweaverJarMaker for running BcweaverModuleTests. Thereshould be one failure for declare warning fix and testcases checked in. 	2004-05-14 05:34:16	1084530000.0	resolved fixed	9ebfc84	1084540000.0	org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java weaver/src/org/aspectj/weaver/WeavingURLClassLoader.java weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java
59599	Race condition in test suite for incremental	"On faster machines (my linux desktop, andy's home pc) several of the tests inajcTests.xml are failing (suite attached). This appears to be due to a race condition between checking directory contents and waiting for the compilation to complete. I have an environment in which I can test candidate fixes if you can give me a pointer for what to tweak... Created attachment 9838test suite containing failing tests (first one passes 'occasionally') Thanks for reporting; UTR on my R40.  Assuming you checked after this wasenabled (3/30, DirChanges.java:1.5), I updated DirChanges.java:1.6 to delaybefore checking by .01 second.  You can increase the delay by defining""-Ddir-changes.delay=50"" (in milliseconds).  Please verify fixed or let me knowhow to reproduce otherwise.  tx I believe the tests are now running happily on all machines. Fix released as part of AspectJ 1.2.1 "	2004-04-22 06:03:23	1082630000.0	resolved fixed	bd16033	1083750000.0	testing/src/org/aspectj/testing/harness/bridge/DirChanges.java
59909	CFlowStack removesThreads to late	"Problem:The current implementation of CFlowStack (Version 1.1-till 1.2 rc1) stores all threads in a hashtable. These Threads are removes after several calls to the methods getThreadStack(). (In our cases >70 calls.)In our project, this cycle is much to long. We have soveral long running threads, which grap quite a lot of lot of memory. This memory can only be freed after the threads have been removed from the CFlowStack. In our production code we sum up to more than 300 Threads stored in different CFlowStack Varaibles. Often this results in out of memory Errors.Added patch provides an improved freeing scheme.It checks if the size of the table has grown, if it has, it checks if it can remove some threads. Created attachment 9938Patch which solves the problem Created attachment 9939SampleA short sample, which demonstrates the problem.if run with the patch the number of threads never exceeded 5. (in most runs itdidn´t if run without the thread, the number of threads exceeds easily 100. I've verified the test program behaves as described - I see the threads getting up to ~140 before being cleaned up.  With the patch it never goes above 4 for me.  It gets to ~140 because when it reaches that level, the line:if (change_count > Math.max(MIN_COLLECT_AT, COLLECT_AT/size)) {returns true which causes a tidyup (since COLLECT_AT is 20000)It seems the static fields COLLECT_AT and MIN_COLLECT_AT are for configuring the frequency of tidying up (although they can't currently be 'set' by a user).  The patch adds another variable oldsize - and the behavior then seems to be tidy up as soon as the stack grows by even 1 element - so if I then trace the tidying-up code it seems to run almost constantly against the test program.  I think I could achieve the same result by setting both of the COLLECT_AT fields to 1.  That doesn't seem to be quite what we want.  It is a bit awkward because different users/applications are likely to have different requirements on the space/performance trade off. I knew I'd realise something as soon as I appended to the bug ;)You can't quite replicate what the patch does by setting COLLECT_AT, MIN_COLLECT_AT to 1 - if they were set to 1 then we would frequently be checking whether all the threads we currently know about are alive.  With the patch we only go through all the threads checking for liveness if a new one is added to the system or if the current test triggers it:(change_count > Math.max(MIN_COLLECT_AT, COLLECT_AT/size))This means if the system reaches a steady state (no new threads are being started) then we behave how we behave today, but if the system is constantly seeing new threads start then it trims the hashtable more frequently.So I think what I'm saying is that the proposal in the patch is a good one.  The reason it looks a bit extreme on first inspection is because the sample program is a little contrived and just fires off threads, never reaching a steady state.Anyone want to comment? The current implementation of CFlowStack was built by a PARC summer intern as a 1 week project many, many years ago (~version 0.7).  I don't believe the implementation has been either carefully evaluated or changed since then.Last week Matthew asked me about using ThreadLocals here for performance reasons, and I replied:I think that it would be good to switch the cflow per-thread implementation in rt.jar to use ThreadLocal when run on a VM that supports this.  This might have some performance benefit, but I'm doubtful it would be very large right away.  The main benefit I see is that the current version has some memory leak issues with holding on to thread objects after they've terminated.  I've never heard a report of this being a real problem in the field, but it is a nagging issue.Well, now I've heard about this being a real problem in the field ;-)The only reason not to just use a ThreadLocal is that it is a 1.2 feature.  Currently rt.jar only uses 1.1 features.I see several reasonable technical solutions, all of which have different tradeoffs.1. Make Arno's proposed change.  This is the simplest change to the code and clearly fixes Arno's problem.  However, you'd need to spend some time understanding the performance issues where there are a lare number of ""stable"" threads and a small number being consistently created and destroyed.  For example, if you have 300 threads in the system (and the hashtable), then every time the table grows all 300 threads will be checked for liveness.  This could be expensive for some use cases.2. Switch the design of CFlowStack to use a ThreadLocal instead of the hashtable.  This is obviously the most efficient and precise way of mapping a perthread field.  This would also be a fairly simple implementation.  The major downside of this approach is that it would mean that AspectJ programs that use cflow would only run under 1.2 or later VMs.3. Build a dual implementation of CFlowStack that uses ThreadLocal if its available and falls back to a simple hashtable when running under 1.1.  This is a slightly more challenging implementation to make sure that the 1.2 code is kept well separate from the 1.1 code.  However, this would give all of the benefits of #2 while still maintaining compatibility with 1.1 VMs.There are additional compromise solutions such as building two different rt.jars, one of which will run on 1.1; or making a CFlowStack11 class and requiring a compile-time flag to select its use.I'd recommend implementing solution #3 and spinning one more release candidate with this change and a couple of others.  At this stage, solution #3 should ideally be implemented by a pair or should have a thorough code review process of people looking at the solution.This change clearly has the potential to cause stability problems.  However, Arno's bug looks serious enough to me that it should be solved for 1.2 (and I've raised the severity to note that).  This kind of bug can be very frustrating to developers because it only manifests itself as an OutOfMemoryError.  All of the possible solutions have the potential to break existing AspectJ programs if implemented incorrectly; however, #3 is the only solution that I can say with confidence won't break anything so long as it's implemented correctly. Created attachment 10255ThreadLocal fix for this bugArno, please can you try this version of aspectjrt.jar.  It is animplementation of Jims idea to use a ThreadLocal implementation for the stackwhen on a JVM that supports it.  I've done some testing and it seems OK and itpasses all the tests in the harness - but I'm not sure how much they validatethe cflow behavior I have changed.In case you aren't sure if it is doing anything at all - you can invoke yourprogram with system property ""debugcflow=yes"" and this will tell you throughSystem.err whether it is trying to use the ThreadLocal implementation.Are you at all able to run your program on a 1.1 JVM to see if it works 'asbefore' ? Fix checked in.  If there is one piece of the implementation that needs a review, it is this one method in CFlowStack:private static void selectFactoryForVMVersion() {  String override = System.getProperty    (""aspectj.runtime.cflowstack.usethreadlocal"",""unspecified"");    boolean useThreadLocalImplementation = false;  if (override.equals(""unspecified"")) {    String v = System.getProperty(""java.class.version"",""0.0"");    // Java 1.2 is version 46.0 and above    useThreadLocalImplementation = (v.compareTo(""46.0"") >= 0);  } else {    useThreadLocalImplementation = override.equals(""yes"") ||                                    override.equals(""true"");  }  // System.err.println(""Trying to use thread local implementation? ""+  //  useThreadLocalImplementation);  if (useThreadLocalImplementation) {    tsFactory = getThreadLocalStackFactory();  } else {    tsFactory = getThreadLocalStackFactoryFor11();  }}The area I am concerned about is that I've decided to introduce a system property override which *might* prove useful for debugging in the field:  aspectj.runtime.cflowstack.usethreadlocalEffectively allowing you to turn off the Thread Local implementation if you don't want it.  I've mainly done this because I've yet to have it confirmed by anyone other than my own test program that all this new code is working as expected.I don't plan on publicising this setting beyond this bug report... Created attachment 10331Variant of the submitted test program.This is a modified test program that actually measures something (at least onmy SUN142 JVM it does).  It creates a 1000 threads which each grab a load ofmemory and then terminate.  It checks whether the use of the thread localstorage for managing the CFlowStacks makes a difference.  Here are my(reproduceable) measurements:>java TestThreadRunnerUsing ThreadLocal mgmt = trueMax memory used through the run = 1005544Time to execute the program = 16078>java -Daspectj.runtime.cflowstack.usethreadlocal=false TestThreadRunnerUsing ThreadLocal mgmt = falseMax memory used through the run = 11926560Time to execute the program = 36359So it does appear to help:-Time to execute is reduced from 36seconds to run the program down to16seconds.-Storage is reduced from 11Meg to 1Meg.However, I'd still like proof that the thread stacks we are now managing in adifferent way are completely correct. Add Noel CC Fixed - could do with verifying by Arno though... "	2004-04-26 05:40:05	1082970000.0	resolved fixed	5f6b18b	1083750000.0	runtime/src/org/aspectj/runtime/internal/CFlowStack.java runtime/src/org/aspectj/runtime/internal/cflowstack/ThreadStack.java runtime/src/org/aspectj/runtime/internal/cflowstack/ThreadStackFactory.java runtime/src/org/aspectj/runtime/internal/cflowstack/ThreadStackFactoryImpl.java runtime/src/org/aspectj/runtime/internal/cflowstack/ThreadStackFactoryImpl11.java runtime/src/org/aspectj/runtime/internal/cflowstack/ThreadStackImpl11.java
54238	Restore build cancelling to Swing-based IDEs	Core compiler implementation changes have resulted in an incompatability with AJDE's build cancelling mechanism.  Once the core canceling behavior stabilizes this needs to be restored. This didn't work in 1.1 and has not been reported by a user.  As such I'm marking it as an enhancement.  It won't take me long to implement and I may be able to get to it this week, but I don't want to hold up 1.2 on it. Done.  Andy's fix did most of the work. 	2004-03-09 22:52:18	1078890000.0	resolved fixed	a17b51b	1083090000.0	ajbrowser/src/org/aspectj/tools/ajbrowser/BasicEditor.java
59596	Null pointer exception while weaving java.awt.Label	"I tried to add an Aspect to java.awt.Label. I compile the aspect via:ajc -inpath /usr/local/j2sdk_nb/j2sdk1.4.2/jre/lib/rt.jar Timestamp.javaHere is the aspect Timestamp.java:aspect Timestamp {    private int java.awt.Label._ts_read = 0;    private int java.awt.Label._ts_write = 0;    pointcut writeOp():    call (void java.awt.Label.setText (String));    pointcut readOp():    call (String java.awt.Label.getText());	    after (java.awt.Label b) returning: readOp() && target (b)    {	b._ts_read++;    }        after (java.awt.Label b) returning: writeOp() && target (b)    {	b._ts_write++;	System.out.println (b._ts_write);    }    public static void main (String[] args)    {	java.awt.Label b1 = new java.awt.Label();	b1.setText (""abc"");    }}Here is the error message I get from ajc:nulljava.lang.NullPointerException        atorg.aspectj.ajdt.internal.core.builder.EclipseAdapterUtils.makeLocationContext(EclipseAdapterUtils.java:50)        atorg.aspectj.ajdt.internal.core.builder.EclipseAdapterUtils.makeSourceLocation(EclipseAdapterUtils.java:120)        atorg.aspectj.ajdt.internal.core.builder.EclipseAdapterUtils.makeMessage(EclipseAdapterUtils.java:129)        atorg.aspectj.ajdt.internal.core.builder.AjBuildManager$4.acceptResult(AjBuildManager.java:663)        atorg.aspectj.ajdt.internal.compiler.AjCompilerAdapter.acceptResult(AjCompilerAdapter.java:178)        atorg.aspectj.ajdt.internal.compiler.WeaverAdapter.finishedWith(WeaverAdapter.java:203)        atorg.aspectj.ajdt.internal.compiler.WeaverAdapter.weaveCompleted(WeaverAdapter.java:167)        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:570)        atorg.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:239)        atorg.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:114)        at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:376)        atorg.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:600)        atorg.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:160)        atorg.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:94)        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:102)        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)        at org.aspectj.tools.ajc.Main.run(Main.java:280)        at org.aspectj.tools.ajc.Main.runMain(Main.java:217)        at org.aspectj.tools.ajc.Main.main(Main.java:79)1 fail|abort The NPE occurs whilst error reporting - if I sort out the NPE, I get the errors shown below.  The NPE occurs whilst trying to determine a nice source range against which to report the problem.  I'm now trying to determine if these new errors are reasonable ?? (i.e. what makes a member unresolvable...)C:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\Timestamp.java:7 warning can not resolve this member: java.lang.String org.apache.crimson.tree.ParentNode.getNodeName() [Xlint:unresolvableMember](no source information available)		see also: C:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\rt.jarC:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\Timestamp.java:7 warning can not resolve this member: short org.apache.crimson.tree.ParentNode.getNodeType() [Xlint:unresolvableMember](no source information available)		see also: C:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\rt.jarC:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\Timestamp.java:7 warning can not resolve this member: void javax.swing.text.TextAction.actionPerformed(java.awt.event.ActionEvent) [Xlint:unresolvableMember](no source information available)		see also: C:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\rt.jarC:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\Timestamp.java:7 warning can not resolve this member: java.lang.String org.apache.crimson.tree.ParentNode.getNodeName() [Xlint:unresolvableMember](no source information available)		see also: C:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\rt.jarC:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\Timestamp.java:7 warning can not resolve this member: void javax.swing.text.TextAction.actionPerformed(java.awt.event.ActionEvent) [Xlint:unresolvableMember](no source information available)		see also: C:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\rt.jarC:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\Timestamp.java:7 warning can not resolve this member: short org.apache.crimson.tree.NamespacedNode.getNodeType() [Xlint:unresolvableMember](no source information available)		see also: C:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\rt.jarC:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\Timestamp.java:10 warning can not resolve this member: void javax.swing.text.TextAction.actionPerformed(java.awt.event.ActionEvent) [Xlint:unresolvableMember](no source information available)		see also: C:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\rt.jarC:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\Timestamp.java:10 warning can not resolve this member: void javax.swing.text.TextAction.actionPerformed(java.awt.event.ActionEvent) [Xlint:unresolvableMember](no source information available)		see also: C:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\rt.jarC:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\Timestamp.java:10 warning can not resolve this member: java.lang.String org.apache.crimson.tree.ParentNode.getNodeName() [Xlint:unresolvableMember](no source information available)		see also: C:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\rt.jarC:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\Timestamp.java:10 warning can not resolve this member: short org.apache.crimson.tree.ParentNode.getNodeType() [Xlint:unresolvableMember](no source information available)		see also: C:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\rt.jarC:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\Timestamp.java:10 warning can not resolve this member: java.lang.String org.apache.crimson.tree.ParentNode.getNodeName() [Xlint:unresolvableMember](no source information available)		see also: C:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\rt.jarC:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\Timestamp.java:10 warning can not resolve this member: short org.apache.crimson.tree.NamespacedNode.getNodeType() [Xlint:unresolvableMember](no source information available)		see also: C:\Eclipse\212\eclipse\aspectj_ws2\tests\bugs\rt.jar13 warnings Andys definition - is this anywhere near right?An unresolvable member is a member (method declaration) we have found in some inheritance hierarchy (its on some interface somewhere) that has no implementation within that hierarchy, apparently due to the use of abstract classes that provide no implementation for it.Without the concrete implementation it can't be successfully 'resolved' and so we can't match on it. This is the patch for the NPE (just capturing it here so anyone else can try it before we decide about committing it):========================================================================================================================================================Index: EclipseAdapterUtils.java===================================================================RCS file: /home/technology/org.aspectj/modules/org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseAdapterUtils.java,vretrieving revision 1.6diff -u -r1.6 EclipseAdapterUtils.java--- EclipseAdapterUtils.java	2 Apr 2004 12:47:35 -0000	1.6+++ EclipseAdapterUtils.java	22 Apr 2004 15:07:56 -0000@@ -40,7 +40,8 @@         int endPosition = problem.getSourceEnd();                  if ((startPosition > endPosition)-            || ((startPosition <= 0) && (endPosition <= 0)))+            || ((startPosition <= 0) && (endPosition <= 0))+            || compilationUnit==null)             //return Util.bind(""problem.noSourceInformation""); //$NON-NLS-1$         	return ""(no source information available)""; ========================================================================================================================================================I think I have convinced myself that the unresolvable member messages are fine - they are just a quirk of some of the classes in rt.jar.  It doesn't affect the actual woven result in this case.Actually, if you change the pointcuts to set a scope in which to look for set/get join points:	pointcut writeOp():within(java.awt.Label) &&	call (void java.awt.Label.setText (String));	pointcut readOp():within(java.awt.Label) &&	call (String java.awt.Label.getText());then the program runs faster and doesn't hit the NPE. I give up!  I can't create a minimal library equivalent to rt.jar that contains an unresolvable member - so I can't create a testcase in CVS (since I can't check in rt.jar!).  I am going to integrate the fix because it passes all the tests and fixes the case discussed in this bug:ajc -inpath /usr/local/j2sdk_nb/j2sdk1.4.2/jre/lib/rt.jar Timestamp.javaDoes anyone know how to create a scenario resulting in an unresolvable member warning? Fix checked in.  A related bug (causing the NPE on the same line) gave us the testcase we needed to verify the fix is OK. *** Bug 60862 has been marked as a duplicate of this bug. *** "	2004-04-22 05:11:34	1082630000.0	resolved fixed	a97f3b6	1082740000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseAdapterUtils.java
57436	Java 1.5 fails to run classes produced by ajc	"Java 1.5 beta reports a ClassFormatError when running programs (e.g., spacewar)compiled by ajc 1.1.1 and the latest CVS head.  Sun's Java 1.5 betabinary-compatibility docs say that some obfuscators violated the .class formatspecification, so those .class files will fail when run under 1.5.  (The docsalso say they are still incomplete.)  Although 1.5 is still beta, we would want to submit a bug to Sun if ourimplementation techniques are valid, so we don't have to change thosetechniques.  For 1.2, we should at document if we don't fix, since many peopleare using 1.5. P2/1.2: Recommending for investigation before the 1.2 release, at least todocument the results. Created attachment 9217HelloWorld + loggingReproduce problem:java version ""1.5.0-beta""Java(TM) 2 Runtime Environment, Standard Edition (build 1.5.0-beta-b32c)Java HotSpot(TM) Client VM (build 1.5.0-beta-b32c, mixed mode)java.lang.ClassFormatError: Invalid index 0 in LocalVariableTable in class fileras/HelloWorldLogging	at java.lang.ClassLoader.defineClass1(Native Method)	at java.lang.ClassLoader.defineClass(ClassLoader.java:604)	atjava.security.SecureClassLoader.defineClass(SecureClassLoader.java:123)	at java.net.URLClassLoader.defineClass(URLClassLoader.java:260)	at java.net.URLClassLoader.access+100(URLClassLoader.java:56)	at java.net.URLClassLoader+1.run(URLClassLoader.java:195)	at java.security.AccessController.doPrivileged(Native Method)	at java.net.URLClassLoader.findClass(URLClassLoader.java:188)	at java.lang.ClassLoader.loadClass(ClassLoader.java:289)	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:279)	at java.lang.ClassLoader.loadClass(ClassLoader.java:235)	at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:302)Exception in thread ""main"" Here is a simple test program that causes the problem:public class H {  public static void main(String[] argv) { }}aspect A {  before(): execution(* *(..)) { }}Now, I'm not saying this is the actual problem but there have always been issues with 'decompiling' the aspectOf() method. Running jad against the A.class file produced after compiling the above code, jad says it has problems - it can't understand the aspectOf() method.  And indeed the gumpf that is produced looks like this on decompilation:    public static A aspectOf()    {        ajc$perSingletonInstance;        if(ajc$perSingletonInstance == null) goto _L2; else goto _L1_L1:        return;_L2:        throw new NoAspectBoundException(""A"", ajc$initFailureCause);    }When it perhaps ought to read    public static A aspectOf()    {       if(ajc$perSingletonInstance != null) return ajc$perSingletonInstance;       throw new NoAspectBoundException(""A"", ajc$initFailureCause);    }It could be that JVM 1.5 is being more strict in what it allows in - I'm not sure how to find out if thats actually whats happening ! I've checked in a fix for this.  It works for my testcase and it passes all the tests I can find.  I will write it up when I get back from my run. <Pyinson Data Over Head> fixed by Andy "	2004-04-05 05:42:29	1081160000.0	resolved fixed	b0d32ca	1081420000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java
57430	exception printing	"Exceptions thrown from the compiler used to be printed once, with the submit-bugheader.  Now they are printed twice, without and with the header.  True of CVSversion. Just an info note ... The testcode you checked in for 57432 demonstrates this double exception printing.   I believe the duplicate is printed by the line:internalException.printStackTrace() withinCompiler.handleInternalException() (line 452 to be precise)continuing to investigate... Fix checked in.The fix is to wrap (at the appropriate point) the NPE exception inside an AbortCompilation exception which is then rethrown.  If the JDT compiler sees an AbortCompilation exception it behaves differently - we can prevent it from being logged by the JDT code *knowing* that it will be logged by the original calling AspectJ code.  The JDT will unwrap the AbortException and throw the nested NPE.Here is the output from the code in bug 57432 with the fix in (there is no 'extra' logging of the NPE):------------------------------------------ABORT	Exception thrown from AspectJ DEVELOPMENTThis might be logged as a bug already -- find current bugs at  http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&component=CompilerBugs for exceptions thrown have titles File:line from the top stack, e.g., ""SomeFile.java:243""If you don't find the exception below in a bug, please add a new bugat http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJTo make the bug a priority, please include a test programthat can reproduce this exception.nulljava.lang.NullPointerException	at org.eclipse.jdt.internal.compiler.CompilationResult.computePriority(CompilationResult.java:110)	at org.eclipse.jdt.internal.compiler.CompilationResult.quickPrioritize(CompilationResult.java:336)	at org.eclipse.jdt.internal.compiler.CompilationResult.getProblems(CompilationResult.java:230)	at org.eclipse.jdt.internal.compiler.CompilationResult.getAllProblems(CompilationResult.java:118)	at org.aspectj.ajdt.internal.core.builder.AjBuildManager$4.acceptResult(AjBuildManager.java:661)	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.acceptResult(AjCompilerAdapter.java:176)	at org.aspectj.ajdt.internal.compiler.WeaverAdapter.finishedWith(WeaverAdapter.java:203)	at org.aspectj.ajdt.internal.compiler.WeaverAdapter.weaveCompleted(WeaverAdapter.java:167)	at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:570)	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:237)	at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:114)	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:376)	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:600)	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:160)	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:94)	at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:104)	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)	at org.aspectj.tools.ajc.Main.run(Main.java:280)	at org.aspectj.tools.ajc.Main.runMain(Main.java:217)	at org.aspectj.tools.ajc.Main.main(Main.java:79)1 fail|abort--------------------------------------------- fixed by Andy. "	2004-04-05 04:58:49	1081160000.0	resolved fixed	e7ac54f	1081330000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java
55341	error Type mismatch: cannot convert from java.lang.String to java.lang.String	"When compiling a binary concrete aspect library (for later LTW) consisting ofmore than one aspect that performs an ITD on a target class not exposed to the weaver I get the following error:error Type mismatch: cannot convert from java.lang.String to java.lang.StringThe error does not oocur if a complete build & weave is performed. Testcase attached. Created attachment 8683Testcase The message comes out of ReturnStatement.resolve().  The return statement is 'return message' and the problem occurs comparing the type of the return value with the return type declared for the method.When it goes wrong, the method return type is a valid resolved java.lang.String whilst the expressionType field in the ReturnStatement object is 'Unresolved type java.lang.String'.  These two are classed as incompatible so it fails with the error ""cannot convert from java.lang.String to java.lang.String"" Here is a simpler failing testcase:Here is HW.java (which could be a bit simpler actually..)==========================import java.util.ArrayList;import java.util.Iterator;import java.util.Properties;public class HW extends ArrayList {  String message = ""Hello World!"";	private void check (String args) {	}	public void println () {		System.out.println(message);	}	public static void main(String[] args) {		HW hw = new HW();		hw.println();				for (int i = 0; i < args.length; i++) {			String jp = args[i];			if (!hw.contains(jp)) {				throw new RuntimeException(jp + "" missing""); 			}		}	}}============================And here are a pair of aspects in a single file X.java:============================aspect F {        private int HW.intField = 999;}aspect M {        public String HW.getMessage () {                return message;        }}==========================With these files, you can reproduce the failure as followsajc -outjar helloworld.jar HW.javaajc -classpath ""helloworld.jar;c:\aspectj1.1\lib\aspectjrt.jar"" X.javaThe failure with the 2nd intertype declaration only occurs if the first aspect containing an intertype on the same type is also being passed in...  It is as if the first intertype declaration pulls in the class (HW) upon which it is intertyping but doesn't bother resolving all of its contents - and when the second intertype comes along, we then don't bother to ensure the bits of the required class are fully resolved that the second intertype declaration needs.======I have fixed it by putting an extra bit of code in ReturnStatement.getBinding():if (fieldBinding.type instanceof UnresolvedReferenceBinding)   fieldBinding.type = ((UnresolvedReferenceBinding) fieldBinding.type).resolve(environment());which ensures that if we do come across something unresolved, we resolve it there and then.BUT - I still don't understand why we only end up with the unresolved version of 'String message' if I use an intertype declaration before the failing one ???FYI: When we are in getBinding() and trying to obtain the binding for 'message', the enclosingtype field looks like this (notice that message is unresolved):public class HW	extends java.util.ArrayList/*   fields   */Unresolved type java.lang.String message/*   methods   */void <init>() void check(Unresolved type java.lang.String) void println() void main(java.lang.String[])  I've done some more investigation.  The whole problem here hinges on the order in which things are resolved (as expected).  Whether the error message occurs entirely depends on whether 'String' has been resolved before 'HW' is loaded into the system.If String has been resolved then HW is loaded with a 'java.lang.String message' field and the code all works.If String has not been resolved then HW is loaded with an 'unresolved java.lang.String' field and the code fails.We can verify this as follows.  Add a new method to our pair of failing aspects:aspect F {  public String a() {return ""abc"";}  <---- New method refers to 'String'  private int HW.intField = 999;}aspect M {  public String HW.getMessage () {    return message;  }}The inclusion of our new method ensures String is fully resolved before HW is brought into the system. and so the intertype declaration in aspect M works perfectly.  What we have here is someone not checking that something is unresolved before using it.  Resolution around the system is done lazily, see the javadoc for: LookupEnvironment.getTypeFromConstantPoolName():/* Answer the type corresponding to the name from the binary file.* Does not ask the oracle for the type if its not found in the cache...* instead an unresolved type is returned which must be resolved before used.*/So the fix is to correctly resolve String when the intertype declaration needs to refer to it. eureka.The fix is actually to address something marked 'XXX' in the code !!!This line:// XXX may need to get the correct value for second parameter in the futureFieldBinding retField = sourceTypeBinding.getFieldBase(fieldName, false);  in InterTypeMemberFinder.getField()In the failing case we should be passing true rather than false - as it indicates whether to ensure the result of the get is resolved.  I just need to work out how to pass the flag into the method from the caller. FIX CHECKED IN.Having looked at the paths into this method, I can't see why we would ever not want to ensure the field is fully resolved.  I have changed the line:FieldBinding retField = sourceTypeBinding.getFieldBase(fieldName, false);  toFieldBinding retField = sourceTypeBinding.getFieldBase(fieldName, true);This fixes the bug.  The tests all still pass.  The only impact would be on performance but as this only affects a path when using intertype declarations of a particular sort.  The alternative would be to expand the signature of the method InterTypeMemberFinder.getField() which would require extending the signature of the JDT internal interface that it implements - that would be too messy (with an imminent 1.2 RC to be shipped..)I have left the XXX in at the moment, since we are still hard wiring the value (but now to true) - I've annotated it with this bug number so in future someone doesn't come and try changing it back to false !I have added a new testcase to the harness and uncommented the tests of Matthews that were impacted by it. fixed by andy clement "	2004-03-19 04:32:28	1079690000.0	resolved fixed	0521e79	1080910000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeMemberFinder.java org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java tests/bugs/StringToString/HW.java tests/bugs/StringToString/X.java weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java
31460	Weaving class loader	"Hi!As discussed on the mailing list a few days ago I implemented a weaving classloader to enable bytecode based weaving at class loading time. The class loaderis based on the URLClassLoader and can be used like any other URLClassLoader. Inaddition to that you can add aspects to the weaving loader. These aspects gotwoven into each class that is loaded. The test cases for the class loader aren'timplemented yet, I am still thinking about how to implement them. I willcontribute them later, okay?-Martin Created attachment 3388WeavingURLClassLoader zip file The implementation needs the changes of bug no 30794 to compile. <Pyinson Data Over Head> Sorry, this example is wrong since we're not implementing callee-side call join points now:> ...Let's say my aspect advises calls to {Runnable}.run() and that > I load some classes implementing Runnable > before and after I register the  aspect.but you probably got the idea... I see the point and totally agree with it. The class loader should not load anyclasses before he knows all the aspects that should be woven into them. Then theclass loader should weave any classes he loads (aside of the classes loaded bythe parent loader).The question is how to archieve that. One possiblity (that you mentioned) is togive all the aspects to the class loader via a constructor parameter. This isthe cleanest way from my point of view.Unfortunately this does not work for me inside my project. The reason is that Ineed to have an instance of the class loader before I can figure out whataspects are available. Therefore I originally implemented the ""addAspect"" method.Okay, here is the second try: I changed my original implementation of the classloader following your argumentation. Now the constructors have two additionalarguments: One for the aspect URLs and a second one for additional classpathentries which got not be loaded but are needed for the weaver to resolve typesduring the weaving process.All other methods to add URLs (with or without aspects) are private andtherefore not usable from outside. There is only one exception: The addAspectmethod is protected to let subclasses refine and/or use it. This allows me touse the WeavingURLClassLoader as it is. What do you think? Created attachment 3663WeavingURLClassLoader version 2 Hi,meanwhile I adapted my weaving Eclipse runtime to Eclipse 2.1 final and slightlychanged the architecture of the integration. The result is that I do no longerneed the specialized weaving class loader for it. I separated the functionalityinto a bytecode transformer component interface that is called by a specialclass loader if a class is loaded. There is one AspectJ-specific implementationto that interface that directly uses the weaving functionality I formerlyinserted into the class loader.The result is: I do no longer need this weaving class loader for the weavingEclipse runtime integration. Therefore I am free to skip the dependencyAddedmethod, for example, to make this a real general purpose AspectJ load-timeweaving class loader. moved to target = 1.2 Any way to refactor to allow for post-build-but-pre-classload-time bytecode weaving?  I'd like to be able to compile with javac/jikes, then weave with an AspectJ enhancer, then run with no classload-time bytecode weaving.It appears possible since you've separated the ""bytecode transformer component interface""....thoughts? I think this is already possible with the standard AspectJ compiler using the-injar option. This allows you to weave existing bytecode with aspects. Doesthat match your case? Rules for weaving class loader:1.	All aspects must be known to the weaver before any classes are loaded. Any aspects subsequently presented to the weaver should either be ignored or cause an exception to be thrown.2.	Only classes defined by the class loader can be woven i.e. in a loader hierarchy neither classes loaded by a parent loader (which are visible) nor a child (which aren’t) are woven.3.	Aspects defined by a parent weaving class loader are available for extension or weaving i.e. both abstract and concrete pointcuts may be used. The plan is to provide a command line tool ""aj"" that will perform load-time weaving using a supplied WeavingURLClassLoader and WeavingAdaptor to wrap the existing BcelWorld and BcelWeaver APIs. It will use CLASSPATH and ASPECTPATH (which will be some subset of CLASSPTH or absent of no weaving is required). Hierarchies of weaving loaders should be supported as described in the previous append.As Wes as pointed out the new java.lang.instrument package can be exploited when 1.5 is supported. A new WeavingAdaptor subclass can connect to this API.While using Martins sample WeavingURLClassLoader as a guide I am doing some reimplementation to avoid copyright and licensing issues with Sun source code. Created attachment 8311UML diagram Created attachment 8312UML diagram Have you looked at java.lang.instrument package in JDK1.5 beta1 ? I know that weaving support is aimed for 1.4 compatibility, but IMHO 1.5 instrumentation is more powerful tool - especially because it allows to modify most core classes (except really basic ones). Maybe it could be done in way which would support both ways - explicit classloaders and jvm instrumentation, with classloader solution being a subset of instrumentation ? 1.5 is still in beta and not fully supported yet by AspectJ. We will need to support 1.4 for a while. However I have a subclass of the WeavingAdaptor written for this enhancement, that can go into future versions of AspectJ, that can attach to existing class loaders using the ClassFileTransformer interface in Instrumentation class.WRT to modifying system classes this breaks one of the rules of weaving class loaders discussed in this enhancement: a class loader must know about all aspects before loading a class. This is not possible for the bootstrap class loader. How do you take care of classes that are generated by the weaver (for example torealize around closures)? I just struggled into that problem with by load-timeweaving implementation because I completely forgot to think of that for my firstimplementation that is still attached to this bug.I think the weaving class loader needs to add those generated classes somehow tohis class path. >How do you take care of classes that are generated by the weaverI don't but have a testcase now to work with. Thanks for pointing that out. I believe a small change to the WeavingAdaptor will allow the class to be defined by the class loader.I am having mixed success with ITDs and perthis/target() aspects. What is your experience. Hm, haven't tried perthis/target stuff yet. Tried successfully someintroductions some month ago (for example adding an interface to an existingclass). But my most exhaustive test case uses mostly advices (I currently adviceevery method of the complete eclipse system at load-time, several thousandclasses, etc.) I now have around closure advice, including the generated weaver class, working along with ITDs and perthis/pertarget aspects. What was the problem with perthis/pertarget and some IDTs and how did you solve it? Adrian has restructured the BcelWeaver so ""weaveWithouDump()"" is no longer appropraite for LTW. There is a new ""weave()"" method which I use and it works. It also accounts for weaver-generated files. The WeavingAdaptor will make this all much easier! Created attachment 8728Beta implementationWeavingAdaptor, WeavingURLClassLoader, tests, javadoc, scripts, examples Created attachment 8738Updated patch to include missing weaver files Created attachment 9146Addtional testcase missing from patchPlease add to org.aspectj.ajdt.core module, run BcweaverJarMarker and checkresulting weaver/testdate/ltw-XXX.jar files into CVS. Fixed by patch contributed my Matthew Webster, incorporating contributions my Martin Lippert also. "	2003-02-10 10:35:35	1044890000.0	resolved fixed	33d8ee9	1080910000.0	org.aspectj.ajdt.core/testdata/src1/LTWHelloWorld.java org.aspectj.ajdt.core/testdata/src1/ltw/LTWPackageTest.java org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java util/src/org/aspectj/util/FileUtil.java weaver/src/org/aspectj/weaver/ExtensibleURLClassLoader.java weaver/src/org/aspectj/weaver/WeavingURLClassLoader.java weaver/src/org/aspectj/weaver/tools/GeneratedClassHandler.java weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java weaver/src/org/aspectj/weaver/tools/WeavingClassLoader.java weaver/testsrc/BcweaverModuleTests.java weaver/testsrc/org/aspectj/weaver/BcweaverTests.java weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java
53012	declare precedence on a class should be a compile-time error	"The compiler silently accepts----public class DeclarePrecedence {public static void main(String[] args) {    System.out.println(""hello"");}}aspect DP {    declare precedence: DeclarePrecedence, DP;    before() : staticinitialization(DeclarePrecedence) {        System.out.println(""ok"");     }}----Since this is likely to be a mistake, an error would be nice.  However, thatwould mean saying (!TargetClass && TargetClass+) to pick out the aspect subtypesof TargetClass. Created attachment 8210Patch for: weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.javaThis will produce a compile time error message if a declare precedencestatement includes a non-aspect type. I'm a little worried that this change would prevent the use of marker interfaces for precendence, something like this:public aspect Priority {    public interface Highest {}    public interface Lowest {}    declare precedence: Highest+, *, Lowest+;}aspect Security implements Priority.Highest {}I'd suggest modifying Andy's patch to check if pi.isIncludeSubtypes() and if so not to produce an error since it is possible for an aspect to match any such pattern.Otherwise, I'm assigning this to Andy to implement his patch and add both Wes's original positive test case and my negative test case to the test suite. Fix checked in.  I modified my patch to allow for non-aspect types where the subtypes are included.  Both test cases are now in ajcTests.xml.  Here is the error message that now comes out whilst compiling Wes' test.  Wording is ok I hope?""Non-aspect types can only be specified in a declare precedence statement when subtypes are included.  Non-aspect type is : DeclarePrecedenceTestClass"" updating target flag to indicate inclusion in 1.2 release. "	2004-02-24 19:43:32	1077670000.0	resolved fixed	0a01759	1079690000.0	tests/bugs/declarePrecedenceWithClasses/DeclarePrecedenceTestClass.java weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java
52928	Private members introduced via an interface are visible to the class	"If private members are introduced via an interface to classes, the introduced members are visible inside the classes themselves, although the visibility is supposed to be relative to the aspect. Here's a sample:public class Sample {   public static void main(String[] args) {      Sample s = new Sample();      s.aMethod();   }   public void aMethod() {      // x is introduced by the following aspect as private      // so it should not be accessible here      System.out.println(""I have "" + x);   }}aspect SampleAspect {   private interface Tag {};      private int Tag.x = 0;      declare parents: Sample implements Tag;} I've confirmed this bug but don't have a fix yet.  I'm setting the target milestone to 1.2 to see if we can get it fixed before that release.  I'm assigning to Adrian as this is a bug in the compiler front-end. The problem was a missed case in Scope.findField() [in the shadows). Whenever we find a field, we in addition check to see that it is actually visible via a call to field.getVisibleBinding(). I'm guessing 30 M6 added a new route for field finding that wasn't in 2.1.1, and so we didn't pick up the new case during the 3-way merge. Simple fix is to add the call field = field.getVisibleBinding(.....) after finding the field.Will commit fix once all tests are passing etc.... Tests clear. Fix committed to tree. "	2004-02-24 08:25:36	1077630000.0	resolved fixed	5795b4a	1079650000.0	tests/bugs/VisiblePrivateInterfaceITDs.java
55134	Incremental compilation does not delete weaver-generated class files	During incremental compilation, AjState records classes generated from source files following the initial compile phase, but before weaving. (So that these can be passed to the weaver on a subsequent iteration if we need to reweave the world). During weaving of a given class file, the weaver may generate additional class files (for e.g. around closures) that get written to the output. If the orginal source file is deleted, these additional weaver generated classes are not deleted from the output since AjState does not know about them. Fixed in tree. UnwovenClassFile.deleteRealFile now deletes the class file plus any $Ajc*.class extensions of it. 	2004-03-17 14:09:38	1079550000.0	resolved fixed	7d6b500	1079620000.0	tests/incremental/initialTests/classWAroundClosureRemoved/AdviceOnIntroduced.delete.20.java tests/incremental/initialTests/classWAroundClosureRemoved/AdviceOnIntroduced.java tests/incremental/initialTests/classWAroundClosureRemoved/Main.java weaver/src/org/aspectj/weaver/bcel/UnwovenClassFile.java
40192	build cancel during weaving	The build can not be cancelled during the bytecode weaving stage. Two options that I can see:Extend the IProgressListener interface  boolean isCanceled()Which we then check in the BcelWeaverExtend the IMessageHandler interface  boolean cancelRequested()Which we can check in multiple places - probably BcelWeaver and below (BcelClassWeaver).---The first case makes sense if we consider the only cancellation use case to be via some kind of UI/IDE that is monitoring the compilation and may want to stop it.The second case makes sense if we think cancellation is a more general kind of request that any compiler/weaver user might request.---any comments Mik? I just spent some time on this since in AJDE we still have a bunch of the infrastructure that made canceling work properly in 1.0.x.  So I'll need to clean that up, since the cancelling functionality already exists in other places (and AJBrowser, JBuidler, and NetBeans are coupled to it).Wh don't you go ahead with your first option and extend IProgressListener, probably with setCancelledRequested(boolean) and isCancelledRequested() methods.  I believe that this is actually general enough, and that any client capable of cancelling builds/weaves should be aware of that progress listener.  The IMessageHandler is not appropriate for this.  Note that you'll need to add an implementation to AJDE's BuildNotifierAdapter -- just make that a stub since that's part of what I need to clean up.Please update the report you've added the checks and have a test case in AJDE that checks the cancel during both compile and weave.  I wonder if the test case needs to check that there are no partly-written classfiles on disk.  But proper error/abort handling in the weaver should have ensured of that already.After that I'll update AJDE accordingly, clean out the old canceling logic from the buld and compile manager and make sure it works in the Swing clients.  After that making it work for AJDT will be trivial. As Mik suggests, I have extended IProgressListener.  I then picked some key points that seemed sensible valid states in which to check for cancellation:1) Between file compilations2) Between file weavesIn either of these states we are 'consistent' and can exit cleanly knowing what is on the disk and we are not half way through doing anything.Aborting half way through weaving a file or half way through compiling an individual file is risky.So, for each case:1) Between file compilationsAjBuildManager.acceptResult() is called.  At the end of acceptResult() check if cancel is requested, throw    new AbortCompilation(true,new CompilationCancelledException());AbortCompilation is a valid mechanism for the JDT compiler to exit, true means silently, the CompilationCancelledException is a new AJ type that will be thrown from the AbortCompilation handling code that will percolate up to performCompilation().  We simply put a catch around the compiler.compile() call in the performCompilation method and just return.2) Between file weavesThe least intrusive change here is to check for cancellation at the start of the BcelWeaver.weave(UnwovenClassFile,BcelObjectType,boolean) method and have a WeavingCancelledException thrown which is then caught at the top level weave() method that has a try...catch around all of its activities.  The weave() method is defined to return a Collection of files that were successfully woven - and putting the try..catch and exception throwing logic at the places suggested ensures weave() still returns correctly with the list of files it managed to weave successfully. (Just in case the code calling weave() makes some assumption about the results it gets back).  Of course, any caller of the compiler/weaver that used the cancellation mechanism will know that it cannot rely on the results.Anyway, all the changes above total about 30lines of code so they don't get in the way of understanding what the compiler/weaver are doing today.  But I'm not checking this feature in right now - principally because Adrian is changing the whole compile/weave flow and that will impact this design. I think your points to interrupt compilation sound right.  I'd implement it a little bit differently.For the weaver I'd modify the BcelWeaver.weave() method to insert this check in its various loops.  This feels much cleaner to me than throwing an exception.For the compiler I think you want to understand how the JDT interrupts compilations.  You'll need to be compatible with this anyway for the IDE work.  Whatever mechanism is used there is probably the right one to use to interrupt ajdt compilation. This was more straightforward after Adrians changes to the compilation/weaving process.  Now there is a single catch block around compiler.compile() that catchs OperationCancelledException.  When we wish to abort either compilation or weaving, we throw an AbortException containing an OperationCancelledException - this is the JDT way of doing things.  JDT unwraps it and the OperationCancelledException percolates out to where we can see it and catch it.  There are two points where we check for cancellation:- After compiling a file- After weaving a fileBuildCancellingTest has been added to ajde tests to verify the behavior is as expected.In the process of getting the progresslistener into the right place in the weaver for checking cancellation I added some suitable progress feedback (percentages and messages) for weaving. Changes now building successfully on our build machine. 	2003-07-16 06:57:36	1058350000.0	resolved fixed	183fc23	1079610000.0	ajde/src/org/aspectj/ajde/internal/BuildNotifierAdapter.java ajde/testdata/BuildCancelling/Cl1.java ajde/testdata/BuildCancelling/Cl2.java ajde/testdata/BuildCancelling/Cl3.java ajde/testdata/BuildCancelling/HW.java ajde/testsrc/org/aspectj/ajde/AjdeTests.java ajde/testsrc/org/aspectj/ajde/BuildCancellingTest.java bridge/src/org/aspectj/bridge/IProgressListener.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverAdapter.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
47910	ajc -outjar jarfile does not contain MANIFEST.MF	I call ajc -sourceroots <mydir> -outjar <my.jar> and an output file is created with a .jar extension, but it is not a valid jar file because there is no MANIFEST.MF file. I see that the text for ajc says:-outjar <file>      put output classes in zip file <file>which might imply that it is supposed to be a zip file, but a parameter called -outjar which creates a zip file doesn't really make sense. If -outjar is used, the resulting file should be a valid jar file, i.e. with a META-INF/MANIFEST.MF file inside. Matthew - another variation of the jar files and manifests problem, do you think you could take a look please? Thks :) When using the “-outjar” option and not binary weaving a simple default manifest, similar to that produced by other tools like jar and ant, should be generated:    Manifest-Version: 1.0    Created-By: AspectJ 1.2If this is insuffiecent it can be replaced later by the user with:    jar –mf … Created attachment 8628FixWhen -outjar specified a manfiest is either copied from the FIRST JAR in-injars/-inpath or one is created. If writing to a directory the manifest iscopied but one is NOT created. Fixed by patch contributed by Matthew. 	2003-12-02 13:35:01	1070390000.0	resolved fixed	34dbb0c	1079530000.0	ajde/testdata/JarManifestTest/src/Main.java ajde/testsrc/org/aspectj/ajde/AjdeTests.java ajde/testsrc/org/aspectj/ajde/InpathTestcase.java ajde/testsrc/org/aspectj/ajde/JarManifestTest.java ajde/testsrc/org/aspectj/ajde/ResourceCopyTestCase.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java
54625	Incremental support does not work with outjar	Either fix the class file deleting etc. to work with jars, or always do a batch build when working with outjars. zip files don't support adding or updating files in an existing jar (you need to take a copy and move everything across). This can be done, but is a bit of work. I'm reluctant to do it because the test harness does not support both incremental and outjar at the same time (and it was getting too difficult to make it work effectively) so I can't write a good test suite around it. Therefore for 1.2 I've added a simple test in AjState.prepareForNextBuild() that returns false (can't do incremental) if an outjar is specified. This ensures that results are at least always correct. We can do better post 1.2 when we have more time to update the test harness. updating target flag to indicate inclusion in 1.2 release. 	2004-03-12 09:43:12	1079100000.0	resolved fixed	1a4c02c	1079450000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java
54965	Incremental compilation does twice as much work as necessary	"When I added support for -outjar in the test harness, I was surprised to find duplicate entry exceptions coming from the output file writing to the outjar. I traced it through, and found that every source file passed to an incremental compile is in fact compiled twice!The first time round we note the references, and of course each file has a reference to itself. Then we call ""AjState.getFilesToCompile"" looking to see if there are any further files to compile in another iteration. This method does not remember the set of files it just compiled, so since we have referenced each type we just compiled, and we have no reord of that fact, we compile them again. Second time around, the bytecodes are identical to the previous go, so recordClassFile doesn't note their dependents - and thus this time we terminate. Fixed by remembering list of files we compiled on the last iteration in AjState. "	2004-03-16 10:08:56	1079450000.0	resolved fixed	41c6f6d	1079450000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java
51322	Introduce Unknown Type to class causes Null pointer exception	<Pyinson Data Over Head> Now fixed in tree. 	2004-02-07 17:11:16	1076190000.0	resolved fixed	5c67166	1079390000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java tests/bugs/Pr51322.java
44272	"retitle warning to ""circular {advice} dependency at ..."""	"When writing aspects with cycles in the advice precedence, get warning ""circulardependency at {join point}"" -- should be ""circular advice dependency..."" or""circular advice precedences at {join point} -- reorder the advice in the aspect"".FWIW, here's an example of circularity in advice precedence:----aspect A {    pointcut crun() : execution (void run()) ;    before() : crun() {}    after() returning : crun() {}    void around() : crun() { proceed(); }}----See programming guide for more discussion of circularity in advice precedence. This will be an easy change to incorporate in 1.2 Fixed in tree:sample new message:C:\ColyerRoot\...\tests\bugs\CircularAdvicePrecedence.java:6:0 circular advice dependency at method-execution(void Runner.run())also fixed a related problem whereby the message for declare precedence circularities was out of date:FROM: circularity in declare dominates, '*' occurs more than onceTO: circularity in declare precedence, '*' occurs more than once "	2003-10-07 00:05:59	1065500000.0	resolved fixed	0109534	1079370000.0	tests/bugs/CircularAdvicePrecedence.java weaver/src/org/aspectj/weaver/Shadow.java weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java
50776	fail in compiling aspect with overriding method introduction with different throws clause	A first class (class A) declares only one method with some exceptions in thethrows clause ( void m() throws Exception ).A second class (class B) extends it without redefinig the method. An aspect declares a method introduction in the class B, with the same name,signature and return type of the one in class A, but without throws clause; thisis a legal override.In the second class (class B) each invocation to the overriden method doesn'tneed a try-catch block, because it refers to his hown method that raises noexception.This code compiles using ajc version 1.0.6 (built Jul 24, 2002 6:21 PM PST) running on java 1.4.0But not usingAspectJ Compiler 1.1.1 AspectJ Compiler 1.1.0class A{  public A(){}  public void m() throws Exception{}}class B extends A{  public B(){}  public void some_code(){    m();}}aspect C{  public void B.m(){}} Assigning to Andy, but including a tip.This is probably a bug in InterTypeMemberFinder.getExactMethod.  If you look at the corresponding getMethods method that one checks to see if there are any intertype methods declared and if so adds them to the base set that comes from the pure jdt logic.  For this method, instead it assumes that if the base method returned from the jdt code is valid then there's no reason to check for any intertype declarations.  Set a break point here and run the given test to see if this is the right diagnosis. Jim was write (as usual!) - when getExactMethod() found a method existing on the type, it did not check for intertype declarations that may be overriding it.  Basically, it did not allow for the case where the method was inherited from a supertype and overridden via an ITD.  Fix checked in. updating target flag to indicate inclusion in 1.2 release. I really am updating the target flag this time... 	2004-01-28 12:21:31	1075310000.0	resolved fixed	c798923	1078480000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeMemberFinder.java tests/bugs/IntertypeDifferentThrows.java
52394	inter-type declarations cause JRockit Crash	BEA's JRockit JVM (version:8.1sp2-1.4.1_05-Load10-viking-win32-sthqa29-20031105-1554) crashes on simpleinter-type declarations. (Obviously I have also submitted this bug to BEA, butthe AJ team may be able to shed some light on what is going on and where (ifanywhere) BEA's JVM is behaving wrong.)The cannonical example lies below:public class SimpleClass {    public static void main(String[] args) {        SimpleClass simple = new SimpleClass();    }}public aspect SimpleAspect {    public int SimpleClass.foo;}When running SimpleClass I get a JVM crash with the following thread stack trace.Thread Stack Trace:    at _exprPush+112 ()@0082FF70    at COM.jrockit.vm.RNI.toNative(Native Method)@32520000    at COM.jrockit.vm.RNI.clinitTrampoline(Native Method)@325200FA    at com.vms.adbase.jvmcrashtest.SimpleClass.<init>(SimpleClass.java:4)@344B0055    at com.vms.adbase.jvmcrashtest.SimpleClass.main(SimpleClass.java:6)@344B0034    --- End of stack traceFeel free to ask me for further details. JRockit can be downloaded at:http://commerce.bea.com/showallversions.jsp?family=WLJR. I reproduced this erroron Windows XP, but it also happend on RedHat.Is it worth adding JRockit to AspectJ's compatibility test suite? We need to investigate this in the 1.2 timeframe and if it can be fixed in AspectJ tree, do so. Removed 1.2 milestone and changed priority to P4.  This problem is unlikely to be addressed by the core AspectJ developers.  However, we would welcome a patch from either BEA or the user community to address this.  Rationale follows:AspectJ should always generate legal Java bytecode that can run on any correctly implemented JVM.  If you can't run AspectJ generated bytecode then it is likely the result of a bug in your JVM.  Any time AspectJ can be shown to generate illegal bytecode that is a high-priority bug and will usually be handled by the core team.  I spent this morning fixing one such bug dealing with an interaction between around advice and Java's complicated rules for protected access: https://bugs.eclipse.org/bugs/show_bug.cgi?id=51929.The harder question is what to do about bugs in popular JVMs.  These are not bugs in the implementation of AspectJ; however, they can cause problems for AspectJ's users.  Your bug report appears to clearly show this as a problem with the JRockit VM and therefore a bug that it is BEA's job to fix.  However, when resources are available we do try to fix these bugs on the AspectJ side.I do all of my testing and development work on SUN's JVMs and will develop workarounds to bugs in those VMs if needed (the infamous Miranda methods are one example where we've done this in the past).  Several other core AspectJ developers work primarily on IBM's JVMs and will test and develop work-arounds for bugs found in those VMs.We don't currently have any developers who work with JRockit.  We would love to accept patches and/or new developers who are focused on JRockit and can improve both testing and work-around any bugs in that platform.  I'm also open to contract work to address these kinds of specific low-level challenges (http://hugunin.net/consulting.html) but I'm personally not going to spend my free time dealing with the bugs of yet another JVM. I just discovered that I was actually running the compiler shipped with the1.1.6 (development) AJDT release. I am a bit embarrassed. (I hadn't realizedthat the development AJDT came with a development compiler). Based on Jim’scompatibility stance, I am pursuing this bug with BEA/JRockit and hope that theywill either prove that the bytecode is illegal or fix their bug. I'll leave thiscase open until this bug is fixed by one party or another (unless that'sinconvenient). Nick wrote:>>This means (as far as I know) AspectJ 1.1.1 (as distinct from>>AJDT-packaged-DEV 1.1.6) *does* work with JRockit. (Apologies for earlier>>statement to the contrary.)If you can verify that the AspectJ 1.1.1 generated .class file works ok, and can add both the offending class file and its 1.1.1 equivalent as attachments to this bug that would be very helpful in identifying the likely source of the problem and if nothing else enable us to give the JRocket guys a little more of a clue as to what the problem might be...Thanks, Adrian.-- assigning bug to me as I'm curious enough to do the next level of analysis given the attachments. Created attachment 8138Files generated with 1.1.1 compiler: workThese files were generated with the 1.1.1 compiler and work as expected (print3 to standard out when SimpleClass's main is run) Created attachment 8141Files generated with DEV compiler: crashThese class files were generated with the development version of ajc downloadedin conjunction with AJDT 1.1.6. When I run SimpleClass, JRockit crashes. (Sun1.4.2 works as expected) I've attached the two cases, working and non. Thanks for looking into this Adrian. Looking at the disassembled bytecode, we have the following.  In the working case the static initializer looks like this:static {};  Code:   0:   invokestatic    #12; //Method ajc$postClinit:()V   3:   returnIn the failing case (where we try and cope with exceptions in ajc$postClinit) - it looks like this:static {};  Code:   0:   invokestatic    #14; //Method ajc$postClinit:()V   3:   goto    9   6:   putstatic       #16; //Field ajc$initFailureCause:Ljava/lang/Throwable;   9:   return  Exception table:   from   to  target type     0     3     6   Class java/lang/ThrowableThere is much more logic in it now.  But this looks valid and indeed runs in the JVMs in which we've tried it.  Interestingly I have two decompilers that cannot make sense of the code in this method.So, now, if we code the Java that is equivalent to what we are trying to achieve:    static    {        try {                ajc$postClinit();        } catch (Throwable t) {                ajc$initFailureCause = t;        }    }And compile it with javac, then disassemble that, we have:static {};  Code:   0:   invokestatic    #10; //Method ajc$postClinit:()V   3:   goto    11   6:   astore_0   7:   aload_0   8:   putstatic       #6; //Field ajc$initFailureCause:Ljava/lang/Throwable;   11:  return  Exception table:   from   to  target type     0     3     6   Class java/lang/ThrowableNotice the 'extra' astore_0, aload_0.  This appears to be a pattern that we aren't following in the code we are generating.  If I add the generation of astore and aload to AspectJ then I generate a static initializer that looks just like the one above *and* both of my decompilers can make sense of it and show me what I expect to see.I'm attaching a zip containing a SimpleAspect.class and SimpleClass.class built using my patched AspectJ.Nick, can you possibly try running the classes from that zip on a JRockit JVM?thanks,Andy. Created attachment 8267Zip containing class files generated by a patched AspectJContains a new SimpleAspect.class and SimpleClass.class - let me know if theywork on JRockit.thanks. Adding myself to cc: I tested the classes compiled by the patched AspectJ. They passed on both sp1and sp2 JRockit JVMs. I also had at least two decompilers (cavaj and decafe) crash on SimpleAspectbefore the patch. They can both digest the class file comfortably now.As far as I'm concerned, this particular bug is fixed--though there may be otherinstances of similar code generated by AspectJ elsewhere. I'll let you know ifwe run into any.Test runs:C:\ajtest\simple>\bea\jrockit81sp1_141_03\bin\java -cp . SimpleClass3C:\ajtest\simple>\bea\jrockit81sp2_141_05\bin\java -cp . SimpleClass3 Thanks for testing those classes :)  I've just checked the fixes in - they should be available from our brand new best-so-far download process in about 5-6 hours time.I don't think we've made this kind of change anywhere else in AspectJ in the run up to 1.2 so hopefully all the rest of our generated bytecode will still be working fine in JRockit and the various decompilers. I'm glad Andy was able to come up with a work-around for this bug in JRockit.  I hope that the folks at BEA are still working on fixing this bug in their VM as well.This bug reminds me of another decompiler bug -- #46298.  This is another case where AspectJ is generating bytecode that confuses some disassemblers and has to do with exception handlers as well.Nick - If you have the time could you run Ron's test case on JRockit to see if the same problem is present here as well.  If so that might raise the priority of fixing that bug. Fixed by Andy Clement, as per his comment on Mar 02. updating target flag to indicate inclusion in 1.2 release. 	2004-02-18 13:35:38	1077130000.0	resolved fixed	5d73494	1078420000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectClinit.java weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java
51320	ClasscastException on concretization of if(false)	"I get the following exception when weaving the attached aspect on the dev build.java.lang.ClassCastException	at org.aspectj.weaver.patterns.IfPointcut.concretize1(IfPointcut.java:156)	at org.aspectj.weaver.patterns.IfPointcut.concretize(IfPointcut.java:143)	at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:119)	at org.aspectj.weaver.Checker.concretize(Checker.java:35)	at org.aspectj.weaver.CrosscuttingMembers.addShadowMunger(CrosscuttingMembers.java:78)	at org.aspectj.weaver.CrosscuttingMembers.addDeclare(CrosscuttingMembers.java:102)	at org.aspectj.weaver.CrosscuttingMembers.addDeclares(CrosscuttingMembers.java:92)	at org.aspectj.weaver.CrosscuttingMembersSet.addAdviceLikeDeclares(CrosscuttingMembersSet.java:65)	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.addAdviceLikeDeclares(AjLookupEnvironment.java:147)	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:122)	at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:300)	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:314)	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:384)	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:125)	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:70)	at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:104)	at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)	at org.aspectj.tools.ajc.Main.run(Main.java:234)	at org.aspectj.tools.ajc.Main.runMain(Main.java:170)	at org.aspectj.tools.ajc.Main.main(Main.java:81) Created attachment 7721Aspect additional comments:1.) The object ""advice"" is of type Checker, which is _not_ a subtype of Advice.2.) I do realize that the declare warning statement is not necessarily supposed to work with an if pointcut. Though a decent error should be given. It would be good to improve the error handling here for 1.2 if we can. Marked with target = 1.2 for now pending investigation. Fix checked in.  As per the discussion on the list, the use of PCDs that may have dynamic residue is policed and you will get an error message if you try to use them in deow statements.C:\Eclipse\212\eclipse\aspectj_ws\tests\bugs>ajc DecwClassCastException.javaC:\Eclipse\212\eclipse\aspectj_ws\tests\bugs\DecwClassCastException.java:27 if() pointcut designator cannot be used in declare statementC:\Eclipse\212\eclipse\aspectj_ws\tests\bugs\DecwClassCastException.java:29 if() pointcut designator cannot be used in declare statementC:\Eclipse\212\eclipse\aspectj_ws\tests\bugs\DecwClassCastException.java:31 cflow() pointcut designator cannot be used in declare statementC:\Eclipse\212\eclipse\aspectj_ws\tests\bugs\DecwClassCastException.java:33 cflow() pointcut designator cannot be used in declare statementC:\Eclipse\212\eclipse\aspectj_ws\tests\bugs\DecwClassCastException.java:35 cflowbelow() pointcut designator cannot be used in declare statementC:\Eclipse\212\eclipse\aspectj_ws\tests\bugs\DecwClassCastException.java:37 cflowbelow() pointcut designator cannot be used in declare statementC:\Eclipse\212\eclipse\aspectj_ws\tests\bugs\DecwClassCastException.java:39 this() pointcut designator cannot be used in declare statementC:\Eclipse\212\eclipse\aspectj_ws\tests\bugs\DecwClassCastException.java:41 this() pointcut designator cannot be used in declare statementC:\Eclipse\212\eclipse\aspectj_ws\tests\bugs\DecwClassCastException.java:43 target() pointcut designator cannot be used in declare statementC:\Eclipse\212\eclipse\aspectj_ws\tests\bugs\DecwClassCastException.java:45 target() pointcut designator cannot be used in declare statementC:\Eclipse\212\eclipse\aspectj_ws\tests\bugs\DecwClassCastException.java:47 args() pointcut designator cannot be used in declare statementC:\Eclipse\212\eclipse\aspectj_ws\tests\bugs\DecwClassCastException.java:49 args() pointcut designator cannot be used in declare statement12 errorsThe line number in the error is always the line number of the declare statement. "	2004-02-07 12:26:00	1076170000.0	resolved fixed	fbc0aa3	1077710000.0	tests/bugs/DecwClassCastException.java weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java weaver/src/org/aspectj/weaver/patterns/IfPointcut.java weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java
36430	Support -Xreweavable option	"Adding a RFE as Wes suggested...Wes' reply:There are some issues with the -Xnoweave option that we won'thave the time to carefully resolve for 1.1, even though, as you suggest, there may be times when it would be useful.The workaround at present is to weave tracing into transactions when the transactions jar is compiled. e.g.,-- do the build  ajc @tracing.lst -outjar tracing.jar  ajc @transactions.lst -aspectpath tracing.jar \      -outjar transactions.jar  ajc @app.lst -aspectpath ""tracing.jar;transactions.jar"" \      -outjar app.jar-- build the jar  mkdir final  cd final  jar xf ../tracing.jar  jar xf ../transactions.jar  jar xf ../app.jar  # fixup manifest, etc?  jar cf ../final.jar *What if you don't have the sources for the transactions.jar?This is a case of getting binary transactions aspects from a vendor who won't provide source and wanting to weave your tracing into it.  I would hope that by the time that problem becomes prevalent, we will have a solution for it.If you'd like to keep this on the radar, please submit thisdiscussion as an RFE for the compiler at  http://dev.eclipse.org/bugs/enter_bug.cgi?product=AspectJThank you -WesP.S. - Personally, I think this case> > ajc -injars app.jar;transaction.jar>       -aspectpath transaction.jar;tracing.jardoesn't make sense.  Things on the aspectpath are defined,whereas things in injars will be woven into and redefined.It's not clear from this command which variant the user expects when refering to a type in transactions.jar.Ramnivas Laddad wrote:> > Hello,> > I think I have a use case that cannot be implemented> (at least elegantly, anyway) without noweave/XnoWeave> option (and thus I request to make it a regular option> instead of experimental -X).> > Basically, I want to have my tracing.jar (> contains tracing aspect) weave into transaction.jar> (contains abstract transaction mangement aspects,> concrete policy enforcement aspects, and supporting> classes). Assume app.jar contain business classes> and interfaces. Each of the jar is created using> -ourjar (but not -noweave or -XnoWeave).> > To build the final system I issue the following> command:> > ajc -injars app.jar;transaction.jar>       -aspectpath transaction.jar;tracing.jar> > Now compiler gives me error due to multiply woven> classes and aspects in transaction.jar.> > Everything works fine if I create the original jar> files using -noweave.> > I could workaround by creating multiple jars, but> I hink -noweave is the right approach as> I really don't want to ship multiple jars that are> needed to implement a single concern and expect the> users to correctly specify jar files in -injars> and -aspectpath.> > -Ramnivas Marking this as an enhancement request for consideration in 1.1.1 We should add a –Xreweavable option to generate classfiles that will have enough additional information in them that they can be rewoven.  The goal is that in AspectJ-1.3 (or maybe even 1.2.1) this option can become a standard option and the –Xnoweave option can either be removed or left as an X option forever.In addition to Ramnivas’ example, this option is very important as we start to provide standard support in AspectJ for load-time weaving.  In this case we definitely need a standard supported option for building libraries with AspectJ that can be safely passed to a load-time weaver.The reweavable option is better than the noweave option in many ways.  The most significant benefit is that it will produce classfiles that can be legally loaded by a JVM.  The noweave option makes it much too easy to produce verify errors.  In addition, the reweavable option will make it easier to weave code many times without having to decide which weave is the final one.Ideally, producing reweavable classfiles should be the default mode for ajc.  There is at least one major space issue that needs to be resolved before that can happen.The implementation of –Xreweavable for 1.2 is straightforward.  The org.aspectj.weaver.WeaverStateInfo attribute needs to be extended to have a reweavable variant.  This reweavable variant will include two new field.1. A list of the fully qualified type names for all aspects that modified the classfile during weaving.  BcelClassWeaver will need some minor changes to populate this list.  When reweaving, the weaver will check that all of these aspects can be found and issue an error if any are missing.2. Enough binary information to recover the original unwoven classfile for the current classfile.  An initial naïve implementation should simply include all of the bytes from the original classfiles in this slot.  This is the potential major space issue.  A more advanced version of this implementation should use a binary diff library to minimize the bytes required by only encoding the difference between the woven classfile and the unwoven one.  In general, this diff should be very small.  Some thought needs to go into making sure that this attribute works well for multiple reweaving steps.BTW – The ability to reweave classfiles opens up the possibility of some very different incremental compilation models in the command-line ant world.  If this attribute goes well those should be explored in the future. Fixed - as per Jims design.  Implementation overview document in CVS:modules/docs/design-Xreweavable.doc "	2003-04-13 03:35:26	1050220000.0	resolved fixed	16a0abd	1077630000.0	ajde/testdata/ReweavableTest/CalculatePI.java ajde/testdata/ReweavableTest/tjp/Demo.java ajde/testdata/ReweavableTest/tjp/GetInfo.java ajde/testsrc/org/aspectj/ajde/AjdeTests.java ajde/testsrc/org/aspectj/ajde/ReweavableTestCase.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java testing/src/org/aspectj/testing/harness/bridge/CompilerRun.java weaver/src/org/aspectj/weaver/Advice.java weaver/src/org/aspectj/weaver/CrosscuttingMembers.java weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java weaver/src/org/aspectj/weaver/Shadow.java weaver/src/org/aspectj/weaver/WeaverStateInfo.java weaver/src/org/aspectj/weaver/bcel/BcelCflowStackFieldAdder.java weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java
51929	Advice calling protected super method causing java.lang.VerifyError 'Bad access to protected data'	A java.lang.VerifyError is thrown at runtime complaining about 'Bad access to  protected data' when advice, on a sub-aspect, that calls a protected method, on  the super-aspect, is woven into a class. However another call to the same method woven into the same class but due to  advice declared in the super-aspect works fine.  The aspects were woven into precompiled (by sun's 1.4 javac) classes. The verify error occurs under both sun's 1.4 and blackdowns 1.3 VMs, and presumably all VMs.  Workaround: Making the protected method public fixes the verify error.  A test case is available in CVS: tests/bugs/protectedvf/... tests/ajcTestFailing.xml Any verify error is serious so marking for investigation in 1.2 timeframe. Thanks for the simple and clear test case.This is now fixed in the tree.  I also expanded the test to cover protected field access as well as methods.Fix required getting the correct receiver type for both field access and methodcalls to correspond to Java's complicated rules for accessing protectedmembers (JLSv2 6.6.2 and mentioned in passing in JVMv2 5.4.4).  This only matters for code in the body of around advice that may potentially be inlinedat join point shadows. 	2004-02-12 21:13:29	1076640000.0	resolved fixed	6ddae42	1077230000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InlineAccessFieldBinding.java tests/bugs/protectedvf/main/Driver.java
45489	Structure model is wrong when re-opened	"Some elements have the wrong kinds when a saved structure model is loaded.  E.g. if I close then re-open the eclipse workbench classes are shown as interface in the outline view.  Also if I traverse the tree with the code below I get the wrong kinds assigned to classed, interfaces, aspects and import declarations.List list = StructureModelUtil.getPackagesInModel();for(Iterator i = list.iterator(); i.hasNext();){    Object[] o = (Object[])i.next();    IProgramElement node = (IProgramElement)o[0];List files = StructureModelUtil.getFilesInPackage(node);			for(Iterator i2 = files.iterator(); i2.hasNext();){				IProgramElement file = (IProgramElement)i2.next();				System.out.println(""file "" + file.getKind().toString() + "", "" + file.getName());				boolean added2 = false;								List file_children = file.getChildren();					// file children can be classes, aspects or other things				for(Iterator i3 = file_children.iterator(); i3.hasNext();){					IProgramElement file_child = (IProgramElement)i3.next();					System.out.println(""kind: "" + file_child.getKind().toString() +"", "" + file_child.getName()); *** Bug 45488 has been marked as a duplicate of this bug. *** curious... without looking at the source I'd guess there might be some type-safe enum patterns used that haven't been extended properly to allow for serialization? I have committed a fix for this.  The problem was indeed with the type-safe enum patterns.  I added a test case that compares all of the nodes in a test model before and after the build:ajde/testsrc/org/aspectj/ajde/SavedModelConsistencyTest updating target flag to indicate inclusion in 1.2 release. "	2003-10-24 06:34:59	1066990000.0	resolved fixed	669cd7c	1077210000.0	ajde/testsrc/org/aspectj/ajde/AjdeTests.java ajde/testsrc/org/aspectj/ajde/SavedModelConsistencyTest.java asm/src/org/aspectj/asm/IProgramElement.java
50570	CatchClauseSignature has broken operation	"It looks like the getParameterName() operation on org.aspectj.lang.reflect.CatchClauseSignature is not working. Instead of returning the name of the exception as declared in the matched handler, returns the string value ""<missing>"".Here is a test case that shows the problem :-------START OF TEST CASE CODE-----------public class MyApp {    public void doSomething() {        // Get around ""unreachable code error...        if (true)        {            throw new BusinessException(""Surprise!!"");        }        System.out.println(""Busy doing something."");    }    public static void main(String[] args) {        try {            MyApp m = new MyApp();            m.doSomething();        } catch (BusinessException be) {            System.out.println(""Exception caught : "" + be.getMessage());         }    }}class BusinessException extends RuntimeException {    BusinessException(String message) {        super(message);    }}aspect AppMonitor {    pointcut problemHandling() : handler(Throwable+);    before() : problemHandling() {        CatchClauseSignature cSig =            (CatchClauseSignature) thisJoinPointStaticPart.getSignature();        System.out.println(            ""MONITOR::\tCaught a ""                + cSig.getParameterType().getName()                + "" called ""                + cSig.getParameterName());    }}------END OF TEST CASE CODE-----------The output from running the above was ...MONITOR::	Caught a BusinessException called <missing>Exception caught : Surprise !!!!Operating system : Windows XPAspectJ : 1.1.1 final and also on latest from CVS HEAD This is fixed in the tree for simple cases.  The parameter name will be correct when a store instruction is the first bytecode of the handler.  This appears to always be true for javac and the eclipse compiler.  Other compilers have not been tested.  Also, the code must have been compiled with -g mode for this parameter name to be visible in the bytecode.  If -g is not used or the handler doesn't match the typical pattern, then this name will revert to <missing> as before. "	2004-01-25 11:47:31	1075050000.0	resolved fixed	19bac86	1075250000.0	tests/bugs/HandlerSig.java weaver/src/org/aspectj/weaver/Member.java weaver/src/org/aspectj/weaver/ResolvedMember.java weaver/src/org/aspectj/weaver/bcel/BcelShadow.java
48091	Lazy instantiation of thisJoinPoint	In cases where the body of advice refers to a non-statically evaluable portion of thisJoinPoint (so that it can't be optimized by the compiler to thisJoinPointStaticPart), the JoinPoint object is currently always created before entering the advice body - even if the JoinPoint object would never actually be accessed (because of a test within the advice for example). Sincea) thisJoinPoint is often used in tracing applicationsb) tracing applications tend to be very pervasive,c) they must have low overhead when tracing is disabled, and d) creation of thisJoinPoint objects is expensive (v. expensive compared to just testing a flag)it would be nice if there was a way to create JoinPoint objects lazily on first actual reference within the advice body. Implemented in tree with unit test in ajdt.core test sources under PerformanceTestCase.  Speed-ups of 10-100X are measured even when running a small test case with minimal GC issues.The actual feature implemented is that thisJoinPoint objects are only created just before calling the method for advice that requires them.  To take advantage of this feature you must use an if PCD or some other dynamic test that occurs in the PCD not the advice body to guard the expensive creation of the thisJoinPoint object.-XlazyTjp flag must be passed to compiler to enable this feature.If any around advice is present on the joinpoint then lazy instantiationwill be disabled.  An Xlint warning will be displayed in this case.As a related optimization, several helper methods were added toFactory.makeJP to reduce the code size when thisJoinPoint is used. I discovered When trying to write a new logging aspect to exploit this enhancement that the new -X option is difficult to use. Although accepted by AJDT it is ignore and the Ant task also ignores it because it has its own option parsing. The only ways are to use the command line or an entry in an argfile. I was surprised at how many placed we police options. 	2003-12-04 12:18:33	1070560000.0	resolved fixed	0c83343	1074910000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/AjdtBatchTests.java org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/CommandTestCase.java org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/PerformanceTestCase.java runtime/src/org/aspectj/runtime/reflect/Factory.java weaver/src/org/aspectj/weaver/Lint.java weaver/src/org/aspectj/weaver/World.java weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java weaver/src/org/aspectj/weaver/bcel/BcelShadow.java
48072	Complete relationship information in the structure model	"Complete the set of relationships surfaced by the structure model (e.g. including support for declare parents etc.) - Mik you had a document listing the things yet to be done here? The document is in CVS under ""docs/developer/asm.doc"".  However, parts are still in a skeleton stage and need revising.  I'm going to update the priority of this to P1 for myself (keeping in mind that it is an enhancement). I've put in a very skeletal beginning of a cross-reference solution for AJDT (and others), based on passing an ICrossReferenceHandler into the world in conjuction with an IMessageHandler. See the trivial implementation currently in weaver. (But it works :) ). removing target 1.2 marker AJDT is now showing all the crosscutting structure afaik. I'm closing out this 2-year-old enhancement, to be replaced by more specific ones if we discover other failings in the structure model in the future. "	2003-12-04 10:54:27	1070550000.0	resolved fixed	f24286d	1074850000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java weaver/src/org/aspectj/weaver/Checker.java weaver/src/org/aspectj/weaver/ICrossReferenceHandler.java weaver/src/org/aspectj/weaver/Shadow.java weaver/src/org/aspectj/weaver/World.java weaver/src/org/aspectj/weaver/bcel/BcelWorld.java
50200	aspectjrt.jar manifest file name needs changing to upper case	"The name of the aspectjrt.jar's manifest file should be changed from META-INF/manifest.mfto META-INF/MANIFEST.MFAccording to the Jar file specification (see http://java.sun.com/products/jdk/1.2/docs/guide/jar/manifest.html) the name of the manifest file needs to be all upper case. It's beyond trivial, I know, but it does cause an unnecessary warning in at least one popular IDE for J2EE development (IBM WebSphere Studio)when the aspectjrt.jar is packaged in an EAR file.If there was an option to assign this a ""very, very trivial"" severity level I would. Georges fix has been integrated but I can't change the state of this bug to fixed.  Can someone else? thanks. Fixed by George. updating target flag to indicate inclusion in 1.2 release. "	2004-01-19 06:01:56	1074510000.0	resolved fixed	6f099df	1074770000.0	build/src/org/aspectj/internal/tools/ant/taskdefs/AntBuilder.java
42515	NPE When compiling intertype declaration	"<Pyinson Data Over Head> I am able to reproduce this on windows xp, although with slightly differenterrors.  The os is probably relevant because the bug has to do with casesensitivity in file and package names.There is a bug in your program.  The cases of the directories and package namesdon't match between these files.  You appear to be using both 'uniqueid' and'uniqueId' inconsistently.  ajc should handle this much more gracefully and I'mleaving this open as a P3 bug because we need to improve this hideous errormessage.  You should just get a simple error that the type ""uniqueId.Numbered""can't be found"" when compiling Bug.aj which is in the ""uniqueid"" package.If you fix the cases in your own code and directories then the bug should nolonger trouble you. I tested this against the current tree. I believe the problem has been fixed by the improved error reporting we inherited from the switch to the latest jdt.core.Instead of the failure in the bug report, ajc will now report:uniqueId\Bug.aj:4:0 Numbered cannot be resolved or is not a typeThis is the correct message since ajc allows source files to be placed in packages that do not match directory names. As uniqueid.Bug is in a different package to uniqueId.Numbered, and Numbered is not imported, the Numbered type cannot be resolved.Test case added to ajcTests.xml "	2003-09-04 07:12:20	1062670000.0	resolved fixed	6d2abc1	1074170000.0	tests/bugs/caseSensitivity/uniqueId/Numbered.java
36234	out of memory error when compiling	"Getting an out of memory error when compiling with Ajc 1.1 RC1. I know this is not very descriptive, but maybe you can point me into a direction of getting more output.here some additional information though:Code base is medium size (about 1500 classfiles)I removed all my aspects and still receive the error.Running it from the command line: ajc -classpath whateveritis -sourceroots whateveritis -d whateveritis I believe this is a duplicate bug that says we need to handle OutOfMemory in a friendlier way.  Hopefully you can resolve this by following the instructions in the FAQ:http://dev.eclipse.org/viewcvs/indextech.cgi/~checkout~/aspectj-home/doc/faq.html#q:ajcoom*** This bug has been marked as a duplicate of 35636 *** Occurs on fresh install of winXP with one simple aspectpackage com.x.y;public aspect CurrTableUpdateAspect{     pointcut printouts();     before(): printouts() {       System.out.println(""*** Entering printMessage ***"");     }     after():  printouts() {       System.out.println(""*** Exiting printMessage ***"");     }}There are 687 java files in the default.lst. I've made a small update to the compiler to handle OutOfMemoryError in a muchmore graceful way.An ajc compile running out of memory will now produce the following message and then exit:AspectJ <version> ran out of memory during compilation:Please increase the memory available to ajc by editing the ajc script found in your AspectJ installation directory. The -Xmx parameter valueshould be increased from 64M (default) to 128M or even 256M.See the AspectJ FAQ available from the documentation linkon the AspectJ home page at http://www.eclipse.org/aspectj updating target flag to indicate inclusion in 1.2 release. "	2003-04-08 14:04:10	1049830000.0	resolved fixed	b3b1eec	1074170000.0	org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java
47952	SoftException.printStackTrace(..) should print  wrapped throwable too	SoftExceptions should print not only their trace but also that of the wrappedthrowable.We should be able to set a flag on class initialization whether we are runningunder 1.4 and then implement it under 1.4 using initCause() and otherwise bydirect delegation.  I can do this fix if we're agreed. I think it would be simpler to just fix this so that we do the correct thing under 1.4 which supports this notion of nested exceptions, but not to change our behavior under 1.3.However, I have no objections to your fix so long as you're careful to not break the runtime on earlier VMs.  We're still promising that aspectjrt.jar will work on 1.1. fixed in tree.  JUnit test passes under 1.1, 1.3, and 1.4. forgot target 1.2M1I must say I thought we should use initCause:-----public SoftException(Throwable inner) {  super();  this.inner = inner;  if (HAVE_JAVA14 && (null != inner)) {     initCause(inner);  }}-----but since you-all didn't when implementing getCause(),I left it as-is. updating target flag to indicate inclusion in 1.2 release. 	2003-12-03 00:43:54	1070430000.0	resolved fixed	ad2fb7a	1074140000.0	runtime/src/org/aspectj/lang/SoftException.java runtime/testsrc/RuntimeModuleTests.java
38824	Anomalous handling of inter-type declarations to abstract base classes in aspectj 1.1	Version 1.1 of aspectj does not handle correctly inter-type declarations toabstract base classes.This appears when the following pattern is present in the code:Suppose there is an interface InterfaceA, another interface InterfaceB and athird interface InterfaceC extending InterfaceA and InterfaceB and containingsome method declarations of its own. Suppose also there is an aspect AConcretisingAspect that contains inter-typedeclarations providing default implementations for all InterfaceC's methods(both own and inherited).Now suppose we have a class hierarchy emanating from an abstract classBaseClass, and an aspect BaseClassAspect declaring that BaseClass implementsInterfaceC:aspect BaseClassAspect {     declare parents: BaseClass implements InterfaceC;}Unfortunately, during compilation iajc complains for each offspring of BaseClassthat it does not implement any of the abstract methods of InterfaceA andInterfaceB (but not of InterfaceC's own!).This does not happen when BaseClass is not abstract; and it does not occur inversion 1.0.6 of aspectj. This bug needs a self-contained example in order to be verified and fixed.  Hereare two examples of bug reports for similar bugs that contained good examples:https://bugs.eclipse.org/bugs/show_bug.cgi?id=39462https://bugs.eclipse.org/bugs/show_bug.cgi?id=41123It would be very valuable to us if you could provide a similar example for thisbug.  Thanks for your help. Created attachment 6786exampleI think the bug is much simpler, see attached source. Fixed by patch contributed by George Harley 	2003-06-12 05:35:45	1055410000.0	resolved fixed	0071cb4	1074100000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java tests/bugs/AbstractBaseAndInterTypeInterface.java weaver/src/org/aspectj/weaver/ResolvedTypeX.java
44587	Erroneous exception conversion	"The following code results in an incorrect exception NoClassDefFoundError being thrown (and without a stack trace). Here is the output when running after compiling with AspectJ from head (and AspectJ 1.1.1):C:\devel\test\excHandling\interType>java client.MainException in thread ""main"" java.lang.NoClassDefFoundError        at client.Main.main(Main.java:6)AspectJ 1.0.6 doesn't exhibit this problem; it produces the following output:C:\devel\test\excHandling\interType>java client.MainException in thread ""main"" java.lang.ExceptionInInitializerError        at client.Main.main(Main.java;client/ExceptionHandling.java[1k];library/LogManager.java[2k]:1004)Caused by: java.lang.RuntimeException: evil        at client.ExceptionHandling.doGetLogger_library_LogManager(ExceptionHandling.java;library/LogManager.java[1k]:1009)        at client.ExceptionHandling.<init>(ExceptionHandling.java;library/LogManager.java[1k]:1006)        at client.ExceptionHandling.<clinit>(ExceptionHandling.java;library/LogManager.java[1k]:3)        ... 1 moreThis example is probably related to bug #44586.If you change the after throwing advice in client/ExceptionHandling.java to remove the execution OR initialization part, you get similar the following output to the AspectJ 1.0.6 case; the exception isn't swallowed.Here is our test code:package client;public aspect ExceptionHandling {    after() throwing (Throwable t) : execution(* Main.*(..)) || initialization(Main.new(..)) {	System.err.println(""exception thrown at ""+thisJoinPointStaticPart);	t.printStackTrace(System.err);    }}---package client;import library.Loggable;public aspect LogManager {    declare parents: client..* implements Loggable;}---package client;public class Main {    public static void main(String args[]) {	new Main();    }}---package library;import java.util.logging.Logger;public aspect LogManager {    private Logger Loggable.logger = doGetLogger();    public Logger Loggable.getLogger() { return logger; }    private Logger Loggable.doGetLogger() {	throw new RuntimeException(""evil"");	//return Logger.getLogger(""main"");    }}---package library;public interface Loggable {} Fixed in tree.All exceptions that occur during the static intialization of a persingletonaspect will be swallowed.  When using that aspect (via aspectOf()) a NoAspectBoundException will be thrown with the original exceptionfrom the staitc initializer as the cause. updating target flag to indicate inclusion in 1.2 release. "	2003-10-09 13:58:19	1065720000.0	resolved fixed	5834de9	1074090000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectClinit.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java runtime/src/org/aspectj/lang/NoAspectBoundException.java runtime/testsrc/RuntimeModuleTests.java tests/bugs/ErroneousExceptionConversion.java tests/bugs/ErroneousExceptionConversion1.java tests/new/ConstructorExecInitFails.java weaver/src/org/aspectj/weaver/AjcMemberMaker.java weaver/src/org/aspectj/weaver/NameMangler.java weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java
46280	compiler issues error on inner aspects when privilieged	"The compiler complains that ""inner aspects must be static"" whenever I try to qualify an inner (and static) aspect as privileged, no matter what the enclosing type is (aspect, interface or class).I was using j2sdk1.4.0_02, AspectJ 1.1, eclipse 2.1 (with AJDT 1.1.3).Test case:------------------BASE CLASS:public class Capsule {   private int hidden;   public int visible;   public Capsule(int priv, int pub) {      hidden = priv;      visible = pub;   }   public void doSomething() {      System.out.println("""""" + hidden + "", "" + visible + """""");   }   public static void main(String[] args) {      Capsule capsule = new Capsule(1, 1);      capsule.doSomething();   }}------------------ASPECT:public aspect Outer {   static //privileged <== JUST TRY TO UNCOMMENT THIS!   aspect Inner {      pointcut call2doSomething(Capsule capsule):         call(void Capsule.doSomething())         && target(capsule);      before(Capsule capsule): call2doSomething(capsule) {         capsule.visible++;         //capsule.hidden++;      }   }}------------------INTERFACE:public interface Marker {   static //privileged <== JUST TRY TO UNCOMMENT THIS!   aspect Inner {      pointcut call2doSomething(Capsule capsule):         call(void Capsule.doSomething())         && target(capsule);      before(Capsule capsule): call2doSomething(capsule) {         capsule.visible++;         //capsule.hidden++;      }   }} As a workaround try reversing the static and privileged modifiers i.e.public aspect Outer {   privileged static   aspect Inner {	  pointcut call2doSomething(Capsule capsule):		 call(void Capsule.doSomething())		 && target(capsule);	  before(Capsule capsule): call2doSomething(capsule) {		 capsule.visible++;		 capsule.hidden++;	  }   }}This compiles cleanly and runs. Fixed in tree.  The bug was caused by an unusual grammar for privileged aspects to be as compatibile with the existing Java grammar as possible. "	2003-11-07 11:32:21	1068220000.0	resolved fixed	7bbd1f4	1074080000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/parser/AjParser.java tests/bugs/PrivilegedParsing.java
44586	After throwing advice on ctors doesn't execute for inter-type decls	"The following code doesn't work in Ajc 1.1.1, in Ajc built from CVS HEAD (as of yesterday), nor in Ajc 1.0.6:Output:C:\devel\test\excHandling>java AfterThrowingCtorException in thread ""main"" java.lang.IllegalStateException: crash        at Foo.initVal(AfterThrowingCtor.java:21)        at AfterThrowingCtor.ajc$interFieldInit$AfterThrowingCtor$Foo$val(AfterThrowingCtor.java:9)        at Foo.<init>(AfterThrowingCtor.java:13)        at AfterThrowingCtor.main(AfterThrowingCtor.java:6)Correct Output:threw java.lang.IllegalStateException: crash at execution(Foo())Exception in thread ""main"" java.lang.IllegalStateException: crash        at Foo.initVal(AfterThrowingCtor.java:21)        at AfterThrowingCtor.ajc$interFieldInit$AfterThrowingCtor$Foo$val(AfterThrowingCtor.java:9)        at Foo.<init>(AfterThrowingCtor.java:13)        at AfterThrowingCtor.main(AfterThrowingCtor.java:6)Input source:public aspect AfterThrowingCtor {    after() throwing (Throwable t) : execution(Foo.new(..)) {	System.err.println(""threw ""+t+"" at ""+thisJoinPointStaticPart);    }    public static void main(String args[]) {	new Foo();    }    private Object Foo.val = Foo.initVal();}class Foo {    Foo() {     }    // if you uncomment this line and comment out the inter-type decl.    // the advice runs correctly    //private Object val = initVal();    static Object initVal() {	throw new IllegalStateException(""crash"");     }}---AspectJ 1.1.1 runs the after throwing advice correctly if the field is declared normally (AspectJ 1.0.6 fails to do even this). This is a subtle problem.The issue surrounds the treatment of field initialization with respect to the scope of execution and initialization join points. Field initialization within a class was considered part of the constructor execution join point with the change to 1.1 (seehttp://dev.eclipse.org/viewcvs/indextech.cgi/~checkout~/aspectj-home/doc/README-11.html#CONSTRUCTOR_EXECUTION_IS_BIGGER) as there was no principled way in bytecode to detect otherwise.Field initialization outside of the class is not considered part of the constructor execution join point (the field belongs to the aspect), so it is correct that the advice does not run. Changing the advice to initialization rather than execution will cause it to execute in both cases.See the test case in tests/bugs/AfterThrowingCtor.java for an example that illustrates both of these cases. "	2003-10-09 13:53:43	1065720000.0	resolved fixed	87db1e7	1074010000.0	tests/bugs/AfterThrowingCtor.java
49814	ConfigParser.java:132	"I have a directory structure such that D:\java\aop\benchmark\strategy\aspectj\ca\ubc\ca\spl\pattern\libraryexists, and contains source files. The command I issued wasajc ca\ubc\cs\spl\patterns\library\*.java examples\strategy\aspectj\*.javaThe difference is the directory is actually called 'pattern', but I mistyped andtried to compile in the directory 'patterns'. Here's the output after calling this:build config error: can't find D:\java\aop\BENCHM~1\strategy\aspectj\ca\ubc\cs\spl\patterns\libraryABORTException thrown from AspectJ 1.1.1This might be logged as a bug already -- find current bugs at  http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&component=CompilerBugs for exceptions thrown have titles File:line from the top stack,e.g., ""SomeFile.java:243""If you don't find the exception below in a bug, please add a new bugat http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJTo make the bug a priority, please include a test programthat can reproduce this exception.nulljava.lang.NullPointerException        at org.aspectj.util.ConfigParser.addFiles(ConfigParser.java:132)        at org.aspectj.util.ConfigParser.addFileOrPattern(ConfigParser.java:110)        at org.aspectj.util.ConfigParser.parseOneArg(ConfigParser.java:194)        at org.aspectj.util.ConfigParser.parseArgs(ConfigParser.java:157)        at org.aspectj.util.ConfigParser.parseCommandLine(ConfigParser.java:35)        at org.aspectj.ajdt.ajc.BuildArgParser.genBuildConfig(BuildArgParser.java:109)        at org.aspectj.ajdt.ajc.BuildArgParser.genBuildConfig(BuildArgParser.java:88)        at org.aspectj.ajdt.ajc.AjdtCommand.genBuildConfig(AjdtCommand.java:131)        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:89)        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)        at org.aspectj.tools.ajc.Main.run(Main.java:217)        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)        at org.aspectj.tools.ajc.Main.main(Main.java:72)1 fail|abort, 1 error After reporting the error about the directory missing (""... can't find ...""), the code (ConfigParser) still attempts to look for files in the missing directory.  This results in a null list and the NPE.  We should only attempt to look for files in the directory if it exists.Test added to the org.eclipse.ajdt.core module tests - alongside the tests related to parsing the configuration. Fixed in tree based on patch from Andy Clement "	2004-01-10 17:46:43	1073770000.0	resolved fixed	a4a1234	1073910000.0	org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java util/src/org/aspectj/util/ConfigParser.java
49638	exception logging: after() throwing advice can't convert Throwable obj to string and ajc aborts	<Pyinson Data Over Head> The reason for the compiler failure is a transcription error in the program:    after() thowing(Throwable ex) : exceptionLogMethods() {should be    after() throwing(Throwable ex) : exceptionLogMethods() {(there is an 'r' missing int throwing). However the compiler should issue a syntax error rather than aborting. Fixed to produce nice parser error message based on patch from Matthew Webster. 	2004-01-07 12:31:34	1073500000.0	resolved fixed	7b081f2	1073640000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/parser/AjParser.java tests/bugs/AfterThrowingAdviceSyntaxError.java
41952	XLint warning for call PCD's using subtype of defining type	Some would like an XLint compiler warning when the user in a call PCD specifiesa declaring type that is not the defining type, because that constrains the joinpoints to those whose bytecode signature contain the specified type as thedeclaring type.  e.g., ----class A { void run() {} }class B extends A {}aspect C {    before() : call(void B.run()) { } // warn here}public class Main {    public static void main(String[] args) {        // ok with -1.4; otherwise, becomes A.run in bytecode        new B().run();                // never works - compile-time type of reference is A, not B        ((A) new B()).run();}----This warning is useful for two reasons.  First, the user probably intended thatany call to an instance of that object be picked out (regardless of thecompile-time type of the reference used to make the call), and thus should use   target(B) && call(void run())(This suggestion could be in the XLint message.)Second, older compilers (i.e., compilers not using -1.4) would incorrectlyspecify the declaring type of the method call as the first type in the hierarchywhich defined the method, so even if the user meant to constrain the join pointby the compile-time reference type, the bytecode signature could be incorrectand the pointcut fail to pick out the join point.One problem with this XLint warning is that is also picks out valid declarewarning/error statements enforcing requirements at compile-time about the typeof the reference used to invoke a method (e.g., when using a static reference ofthe wrong type).  So perhaps the default level should be ignore.See also bug 41888. Created attachment 5851adds requested XLint warningThis works but seem expensive and like there are probably utilities elsewhereto do this kind of matching (the signature matches are not quite right). Created attachment 5852minimal test case for the patch, to install in tests/bugs *** Bug 49371 has been marked as a duplicate of this bug. *** fixed in tree based on patch from George Harley and Matthew Webster see previous comment 	2003-08-26 05:38:20	1061890000.0	resolved fixed	97ab1e9	1073490000.0	bridge/src/org/aspectj/bridge/IMessage.java bridge/src/org/aspectj/bridge/Message.java bridge/src/org/aspectj/bridge/MessageUtil.java bridge/src/org/aspectj/bridge/SourceLocation.java org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java testing/src/org/aspectj/testing/xml/SoftMessage.java tests/bugs/DeclaringTypeWarning.java tests/new/CallTypesI.java tests/new/IndeterminateArg.java tests/new/IndeterminateArgType.java weaver/src/org/aspectj/weaver/Checker.java weaver/src/org/aspectj/weaver/Lint.java weaver/src/org/aspectj/weaver/patterns/AndPointcut.java weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java weaver/src/org/aspectj/weaver/patterns/NotPointcut.java weaver/src/org/aspectj/weaver/patterns/OrPointcut.java weaver/src/org/aspectj/weaver/patterns/Pointcut.java weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java
47754	illegal method modifier	"the attached example throws this at class load time.please note that this bug results in a different exception when happens in a different setup, and when the class is loaded by JBoss. (more cryptic, talking about generic class format error)Exception in thread ""main"" java.lang.ClassFormatError: com/netvisor/nvsr/client/InvalidByteCodeBug$Test$ITest (Illegal method modifiers: 0x409)        at java.lang.ClassLoader.defineClass0(Native Method)        at java.lang.ClassLoader.defineClass(ClassLoader.java:537)        at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:123)        at java.net.URLClassLoader.defineClass(URLClassLoader.java:251)        at java.net.URLClassLoader.access$100(URLClassLoader.java:55)        at java.net.URLClassLoader$1.run(URLClassLoader.java:194)        at java.security.AccessController.doPrivileged(Native Method)        at java.net.URLClassLoader.findClass(URLClassLoader.java:187)        at java.lang.ClassLoader.loadClass(ClassLoader.java:289)        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:274)        at java.lang.ClassLoader.loadClass(ClassLoader.java:235)        at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:302)        at java.lang.ClassLoader.defineClass0(Native Method)        at java.lang.ClassLoader.defineClass(ClassLoader.java:537)        at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:123)        at java.net.URLClassLoader.defineClass(URLClassLoader.java:251)        at java.net.URLClassLoader.access$100(URLClassLoader.java:55)        at java.net.URLClassLoader$1.run(URLClassLoader.java:194)        at java.security.AccessController.doPrivileged(Native Method)        at java.net.URLClassLoader.findClass(URLClassLoader.java:187)        at java.lang.ClassLoader.loadClass(ClassLoader.java:289)        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:274)        at java.lang.ClassLoader.loadClass(ClassLoader.java:235)        at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:302)        at com.netvisor.nvsr.client.InvalidByteCodeBug.run(InvalidByteCodeBug.java:15)        at com.netvisor.nvsr.client.InvalidByteCodeBug.main(InvalidByteCodeBug.java:8) Created attachment 7008bad bytecode is generated for this classresults in bad bytecode due to a static inter-type method declaration with theCVS version of ajc. (sorry if i catched a checked-in half-done implementationwith this, as it was not supported before) The AspectJ compiler was not signalling an error when attempting to declare a static method on an interface (via an inter-type declaration).Fixed by ACAC. "	2003-11-29 03:48:15	1070100000.0	resolved fixed	7322131	1073490000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java tests/bugs/StaticInterfaceMethods.java
49250	alias getCause for getWrappedThrowable in SoftException	SoftException should implement getCause():   public Throwable getCause() {       return inner;   }(As pointed out by Ramnivas, misc mail messages, code comments...)Using getCause() means the chain should print as expected in 1.4+, esp. whenSoftException is itself wrapped as a RemoteException.  Since getCause()replicates getWrappedThrowable(), we could deprecate that, but we must continueto support it to maintain upwards binary compatibility in the runtime classes. getCause() on SoftException has been added.  Testcase added to verify it works as expected on 1.3 JVMs.  Adrian is integrating the patch right now ... 	2003-12-21 15:01:36	1072040000.0	resolved fixed	eac16ae	1073480000.0	runtime/src/org/aspectj/lang/SoftException.java
49457	No error on overloaded pointcuts unless binding variables	"The compiler might not be detecting overloaded pointcut names when parametersare not bound, and/or might not be implementing the pointcut correctly.  Belowis the context from my reply to Ron Bodkin on aspectj-dev ""Proper behavior ofoverloaded pointcut definitions"".  (I have not checked this code recently orsubmitted a test case, nor have I evaluated whether my code below actuallyreplicates Ron's bug.)---- context from the emailThe programming guide says,  It is an error for two pointcuts to be named with the same  name in the same class or aspect declaration.When I compile with overloaded pointcut names, I do get an error.    pointcut pc(Runnable r) : target(r) && call(void run());    pointcut pc(SubRunnable r) : target(r) && call(void run()); $ aspectj-1.1.1 -classpath $ajrt11 OverloadedPointcut.java ...\OverloadedPointcut.java:14 duplicate pointcut name: pc ...\OverloadedPointcut.java:15 duplicate pointcut name: pc...When I use these pointcuts with bound parameters, I get an error.    before(Runnable r) : pc(r) { log(""pc(Runnable r)""); }    before(SubRunnable r) : pc(r) { log(""pc(SubRunnable r)""); }When I use these pointcuts with type parameters, I get no errors.    before() : pc(Runnable) { log(""pc(Runnable)""); }    before() : pc(SubRunnable) { log(""pc(SubRunnable)""); }    before() : pc(*) { log(""pc(*)""); }[...]---- my codepublic class OverloadedPointcut {    public static void main(String[] args) {        new C().run();    }}class C { public void run() {} }aspect A {    declare parents: C implements Runnable;    declare parents: C implements SubRunnable;    interface SubRunnable extends Runnable {}    pointcut pc(Runnable r) : target(r) && call(void run());    pointcut pc(SubRunnable r) : target(r) && call(void run());    before(Runnable r) : pc(r) { log(""pc(Runnable r)""); }    before(SubRunnable r) : pc(r) { log(""pc(SubRunnable r)""); }    before() : pc(Runnable) { log(""pc(Runnable)""); }    before() : pc(SubRunnable) { log(""pc(SubRunnable)""); }    before() : pc(*) { log(""pc(*)""); }    void log(String s) { System.out.println(s); }} ---- Ron's code[...] the following program compiles with no warnings, produces no output whenrun under AspectJ 1.1.1.  It appears to behave as if the more specificdefinition is the only definition of the pointcut[...]Here is a simple program that illustrates the question and odd behavior:package lib;public class RunnablePointcuts {    public pointcut runnableCalls(Runnable runnable, Object caller) :        call(* run(..)) && target(runnable) && this(caller);    //public pointcut specialRunnableCalls(SpecialRunnable runnable, Objectcaller) :    public pointcut runnableCalls(SpecialRunnable runnable, Object caller) :        call(* run(..)) && target(runnable) && this(caller);}---package lib;public interface SpecialRunnable extends Runnable {}---package client;import lib.RunnablePointcuts;import lib.SpecialRunnable;public aspect Use {    before(Object caller) : RunnablePointcuts.runnableCalls(*, caller) &&target(MyRunnable) {        System.out.println(""my runnable called from ""+caller);    }    public static void main(String args[]) {	Use.aspectOf().doIt();    }    public void doIt() {        new MyRunnable().run();    }}// the advice will run if you make this implement SpecialRunnable//class MyRunnable implements SpecialRunnable {class MyRunnable implements Runnable {    public void run() {}} The bug is that the compiler is not policing the case when two pointcuts with the same name are declared in a CLASS.  In Rons program he should get errors against his RunnablePointcuts class at compile time.  The fix is to add behaviour to AjLookupEnvironment.resolvePointcutDeclarations such that if the ClassScope being processed has pointcut definitions in it, we do the check. Patch sent to Adrian. *** Bug 42842 has been marked as a duplicate of this bug. *** "	2004-01-02 00:21:30	1073020000.0	resolved fixed	c517e85	1073480000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java tests/bugs/OverloadedPointcutsInAspect.java tests/bugs/OverloadedPointcutsInClass.java
47318	org.aspectj.asm.IRelationship.Kind.ALL does not contain all kinds	org.aspectj.asm.IRelationship.Kind.ALL is an array that should contain all kindsthat an IRelationship may have. There are three possible kinds defined inIRelationship.java: ADVICE, DECLARE and DECLARE_INTER_TYPE. The Kind[] ALL doesonly contain ADVICE and DECLARE. This can lead to an ArrayIndexOutOfBoundsException. This is now fixed in the current tree.  Thanks for the report!Also, consider letting us know how you're using the ASM APIs in case there are other improvements needed for your application.  We want to make the ASM more complete so that we can invite more extensions to be built on it. 	2003-11-23 16:18:11	1069620000.0	resolved fixed	bdc79f1	1069620000.0	asm/src/org/aspectj/asm/IRelationship.java
43783	AJDT not very stable when confronted with java/aspect errors.	"AJDT is not very stable when an eclipse project contains errors likemissing classes, wrong package statements etc. etc. This may occurs whenrefactoring a project (sometimes by changing the source outside eclipse).Note I am using Eclipse 2.1.1, AJDT 1.1.4 + incremental compilation.Generally a lot of exceptions will occur (mostly nullpointer). Here are some of them:I:java.lang.NullPointerException	at org.aspectj.asm.internal.ProgramElement.toLinkLabelString(ProgramElement.java:403)	at org.eclipse.ajdt.internal.core.AJDTStructureViewNode.getLabel(AJDTStructureViewNode.java:171)	at org.eclipse.ajdt.internal.core.AJDTStructureViewNodeAdapter.getLabel(AJDTStructureViewNodeAdapter.java:89)	at org.eclipse.ui.model.WorkbenchLabelProvider.getText(WorkbenchLabelProvider.java:142)II:java.lang.NullPointerException	at org.eclipse.ajdt.internal.ui.editor.AspectJEditor$1.run(AspectJEditor.java:242)	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)III:java.lang.NullPointerException	at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:79)	at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:165)! Error I is a duplicate of bug#43709 and has been fixed.  It is a result of the inability for the document outline to point to injars, and has no bad sideffects (after you click away the NPE dialog).Error II is a duplicate of bug#43662, currently assigned to Andy Clement.Error III is the result of AJDT invoking a build with a null config file (String parameter to the build method).  This needs to get fixed and I will keep this bug report open for it.  But could you please send a concise description of what triggers this behavior?   I'm raising this to P2, and adding Andy to the CC since it refers to a report currently assigned to him. 43662 (referred to below as part II) is fixed now.  Leaving open for work to look at null config file problem. I fixed the config file problme (III) by reporting to the user that there was an attempt to build a null config file.  That still corresponds to bad behavior in the UI, so it would still be good to know what can trigger such an event.  Morten: if you are still able to generate the NullPointerException in III please submit another report describing or attaching a minimal way to get it to fail to this report.   >please submit another report describing or attaching a minimal way to get it >to fail to this report.I am sorry, but I do not have a test case or a clear memory of what I exactly did in order to produce the bugs :-) The only thing that I recall for sure is that I rename/moved some java files outside eclipse, started eclipse with AJDT and tried to fix my compilation problems in eclipse. The bugs reported here appeared while trying to fixing my sources. Consquently, the only thing I can do is to recommend that you try to do the same.  Let me know if you can reproduce the bugs yourself in the old version (thus being able to check if they are fixed). Otherwise I will try to find time to help you check for it in the next version you release.P.S. :-) Smily error above (:-) should have been :-() "	2003-09-26 19:36:57	1064620000.0	resolved fixed	3e4b59a	1066840000.0	ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java
44117	NPE on compile	java.lang.NullPointerExceptionat org.aspectj.weaver.AsmRelationshipProvider.checkerMunger(AsmRelationshipProvider.java:51)at org.aspectj.weaver.Checker.match(Checker.java:58)at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:985)at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:791)at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:291)at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:77)at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:417)at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:390)at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:316)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.weaveAndGenerateClassFiles(AjBuildManager.java:256)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:156)at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:70)at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:103)at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:165) I've fixed this NPE.  I'm guessing that it was the result of relationships trying to map into JARs that they couldn't produce an accurate sourceline for.  We may need to improve upon the structure in the model in this case.Reports like this are much more useful when they're submitted with either a test case or at least some code triggering this to fail.  Due to limited time and the difficulty of determining the cause from a stack trace alone, I will be marking reports without a description of what causes them to fail down to P4 (unless they are blockers). 	2003-10-03 01:17:43	1065160000.0	resolved fixed	3117255	1066320000.0	weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java
43709	structure view crash when extending library aspects	"<Pyinson Data Over Head> The bad news is that the NPE shows in the typical uninformative Eclipse dialog.  The good news is that once the user click's ""OK"" there are no problems other than the lack of a label for that node.  The problem stems from the fact that I never implemented the case of structure model elements living inside JARs.I've fixed this, added a corresponding test project to AJDT, and added some UI support to make it clear when something is being advised by an aspect in an injar.  Since navigating to the sourceline of the aspect in the injar is not possible the label is grayed-out.  Also note that I finally added hyperlink style coloring to the link nodes in the outline (by adding an AspectJLabelProvider).So it's all working in CVS.  But the label for injar could be improved (e.g. give the path to the injar, and the full signature of the advice).  That's doable but might require us to change the IProgramElement String handle format, since elements in bytecode aren't naturally identified by sourcelines--so at the moment we can only look up the sourcefile containing the aspect. "	2003-09-25 18:30:52	1064530000.0	resolved fixed	426d89b	1064550000.0	asm/src/org/aspectj/asm/internal/ProgramElement.java
43033	Compiler crash in ajc head (post 1.1.1 rc1) on erroneous program	<Pyinson Data Over Head> Created attachment 6145Minor fix to avoid the NPE Andy seems to be on top of this one. I've sent the test suite changes direct to Adrian to integrate.  They consist of the programs Ron provided.- Andy. Fixed by patch and test cases contributed by Andy Clement. 	2003-09-12 13:34:02	1063390000.0	resolved fixed	5357086	1063960000.0	tests/bugs/concretizeNpe/base/ExceptionHandling.java tests/bugs/concretizeNpe/model/ModelExceptionHandling.java weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java
43194	java.lang.VerifyError in generated code	"See the attached file VerifyBug.jar for the source files. You won't need anything else to compiler and reproduce this bug:~/bug> lsAbstractCaching.java   TreeNode.java         VerifyBug.jarContainerCaching.java  TreeNodeFolding.java  WorkspaceGroup.javaContainerLoader.java   TreePanel.java        WorkspaceNode.javaMakefile               TreeWorkspace.java~/bug> gmake   /cygdrive/c/aspectj1.1.1/bin/ajc -classpath ""C:\aspectj1.1.1\lib\aspectjrt.jar"" -versionAspectJ Compiler 1.1.1/cygdrive/c/aspectj1.1.1/bin/ajc -classpath ""C:\aspectj1.1.1\lib\aspectjrt.jar"" *.javajava -classpath ""C:\aspectj1.1.1\lib\aspectjrt.jar;."" TreeNodejava.lang.VerifyError: (class: TreeNode, method: doShowAction signature: ()V) Unable to pop operand off an empty stackException in thread ""main"" make: *** [all] Error 1 Created attachment 61249 source files, plus a Makefile for cygwinThe makefile isn't necessary, you just need to do a ""ajc *.java"" with the filesunjarred in a new directory. Then, run java as in the report. Erik and I pair fixed this in the tree.  The bug was caused byReferencePointcut.concretize mutating state rather than behavingproperly functionally.After removing the layers of after advice and cflow entry/exits, theminimal test case is below.  The multiple levels of indirection, aswell as the concretization with a typename in the first advice followedby concretization with a parameter name in the second are all requiredto cause the bug.class C {        public void m1() {}    public void m2() {}}aspect A {        pointcut exec1(C c): this(c) && execution(void m1());    pointcut execs(C c): exec1(c);         before (): execs(*) {}    before (C c):  execs(c) {}} "	2003-09-16 23:21:32	1063770000.0	resolved fixed	fc0d2af	1063910000.0	tests/bugs/AdviceInteraction.java weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java
42993	Language regression, or possible language improvement?	"The file AspectBug.java:public aspect AspectBug extends AbstractCachingperthis(execution(ContainerLoader+.new(..))){	declare parents: ContainerDescriptor implements AbstractCaching.Key;	protected pointcut loadExecutions( Key key ):		ContainerLoader.containerLoads( *, key );}abstract aspect AbstractCaching  {	interface Key {}	protected abstract pointcut loadExecutions(Key key);}class Key {}class ContainerDescriptor {}class ActiveContainer {}class ContainerLoader {	public ActiveContainer createContainer(ContainerDescriptor c) {		return null;	}    public pointcut containerLoads(ContainerLoader loader,								   ContainerDescriptor containerDesc ):        this(loader) && args(containerDesc)        && execution(ActiveContainer ContainerLoader.createContainer(ContainerDescriptor));}        First, here are the versions of AspectJ I'm using (this is a bash        shell under cygwin on Windows XP):~> CLASSPATH='C:\aspectj1.0\lib\aspectjrt.jar' /cygdrive/c/aspectj1.0/bin/ajc -versionajc version 1.0.6 (built Jul 24, 2002 6:21 PM PST) running on java 1.4.1_02~> CLASSPATH='C:\aspectj1.1\lib\aspectjrt.jar' /cygdrive/c/aspectj1.1/bin/ajc -versionAspectJ Compiler 1.1.0~> CLASSPATH='C:\aspectj1.1.1rc1\lib\aspectjrt.jar' /cygdrive/c/aspectj1.1.1rc1/bin/ajc -versionAspectJ Compiler 1.1.1rc1~> CLASSPATH='C:\aspectj1.1.1\lib\aspectjrt.jar' /cygdrive/c/aspectj1.1.1/bin/ajc -versionAspectJ Compiler 1.1.1        For all four of these compilers, I give them the AspectBug.java file	(which is attached):~> CLASSPATH='C:\aspectj1.0\lib\aspectjrt.jar' /cygdrive/c/aspectj1.0/bin/ajc AspectBug.java~> CLASSPATH='C:\aspectj1.1\lib\aspectjrt.jar' /cygdrive/c/aspectj1.1/bin/ajc AspectBug.java~> CLASSPATH='C:\aspectj1.1.1rc1\lib\aspectjrt.jar' /cygdrive/c/aspectj1.1.1rc1/bin/ajc AspectBug.java~> CLASSPATH='C:\aspectj1.1.1\lib\aspectjrt.jar' /cygdrive/c/aspectj1.1.1/bin/ajc AspectBug.javaC:\Documents and Settings\Macneil Shonle\AspectBug.java:7 incompatible type, expected ContainerDescriptor found BindingTypePattern(AbstractCaching$Key, 0)1 error        As you can see, only the final run (with the Sept 11 build of	ajc) do we see the ""incompatible type"" error. If this is not a	regression but a desirable result, how should the code be ported? This is a regression bug, and was easily reproduced from the nice self-containedtest included below.  It's marked as P1 because it is a regression from 1.1.0and 1.1.1rc1.  This test is now in HEAD, along with a fix for the bug.The problem was caused by moving name binding in pointcut declarations to happenbefore declare parents are evaluated.  Because of this, the compiler doesn'tknow that ContainerDescriptor isa Key when resolving theContainerLoader.containerLoads reference.The change in ordering was made to fix a bug reported in declare error anddeclare soft whose pcds where being evaluated before name binding had happenedin the pointcut declarations.  Unfortunately, declare error and declare soft areconcretized at the same time as declare parents (and all other declares , sothis move also led to the regression noted above.  "	2003-09-12 04:26:44	1063360000.0	resolved fixed	b512738	1063390000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java tests/bugs/ParentsAndPointcuts.java weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java weaver/src/org/aspectj/weaver/ResolvedTypeX.java
42740	declare error fails on pointcuts composed from multiple classes	"This error occurs in both 1.1.0 and in the head of CVS as of 9/8/03. The compiler crash output from the CVS head version is at the end. It may be related to 42739, but they may be distinct problems.Sample source:/* * Created on Sep 8, 2003 * * Copyright (c) 2003 New Aspects of Security. All Rights Reserved. */aspect Library {    public pointcut executionsThrowingChecked() :         execution(* *(..) throws (Exception+ && !RuntimeException));}public aspect SampleExceptionHandling {    public pointcut scope() : within(org.atrack.model..*);        public pointcut executionsThrowingChecked() :         Library.executionsThrowingChecked() && scope();    declare error : executionsThrowingChecked():         ""no checked exceptions"";}sample compile:C:\eclipse\workspace\atrack>ajc src\SampleExceptionHandling.javajava.lang.Exception: Stack trace        at java.lang.Thread.dumpStack(Thread.java:1071)        at org.aspectj.weaver.patterns.ReferencePointcut.concretize1(ReferencePointcut.java:215)        at org.aspectj.weaver.patterns.AndPointcut.concretize1(AndPointcut.java:88)        at org.aspectj.weaver.patterns.ReferencePointcut.concretize1(ReferencePointcut.java:272)        at org.aspectj.weaver.patterns.AndPointcut.concretize1(AndPointcut.java:88)        at org.aspectj.weaver.patterns.ReferencePointcut.concretize1(ReferencePointcut.java:272)        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:127)        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:120)        at org.aspectj.weaver.Checker.concretize(Checker.java:37)        at org.aspectj.weaver.CrosscuttingMembers.addShadowMunger(CrosscuttingMembers.java:78)        at org.aspectj.weaver.CrosscuttingMembers.addDeclare(CrosscuttingMembers.java:102)        at org.aspectj.weaver.CrosscuttingMembers.addDeclares(CrosscuttingMembers.java:92)        at org.aspectj.weaver.ResolvedTypeX.collectCrosscuttingMembers(ResolvedTypeX.java:332)        at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect(CrosscuttingMembersSet.java:50)        at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTypeAndPerClause(AspectDeclaration.java:754)        at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildInterTypeAndPerClause(AjLookupEnvironment.java:124)        at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:91)        at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:310)        at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:324)        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:373)        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:125)        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:70)        at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:99)        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53)        at org.aspectj.tools.ajc.Main.run(Main.java:217)        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)        at org.aspectj.tools.ajc.Main.main(Main.java:72)C:\eclipse\workspace\atrack\src\SampleExceptionHandling.java:15 circular pointcut declaration involving: executionsThrowingChecked()1 error If you change the pointcut in the library aspect to have a different name, then the compiler fails to see that pointcut at all:C:\eclipse\workspace\atrack>ajc src\SampleExceptionHandling.javaC:\eclipse\workspace\atrack\src\SampleExceptionHandling.java:15 can't find pointcut 'execs' on SampleExceptionHandling1 error/* * Created on Sep 8, 2003 * * Copyright (c) 2003 New Aspects of Security. All Rights Reserved. */aspect Library {    public pointcut execs() :         execution(* *(..) throws (Exception+ && !RuntimeException));}public aspect SampleExceptionHandling {    public pointcut scope() : within(org.atrack.model..*);        public pointcut executionsThrowingChecked() :         Library.execs() && scope();    declare error : executionsThrowingChecked():         ""no checked exceptions"";} An even more minimal test case:/* * Created on Sep 8, 2003 * * Copyright (c) 2003 New Aspects of Security. All Rights Reserved. */aspect Library {    public pointcut execs(): within(*);}public aspect SampleExceptionHandling {    public pointcut executionsThrowingChecked() : Library.execs();    declare error : executionsThrowingChecked():         ""no checked exceptions"";}output:C:\eclipse\workspace\atrack>ajc src\SampleExceptionHandling.javaC:\eclipse\workspace\atrack\src\SampleExceptionHandling.java:11 can't find pointcut 'execs' on SampleExceptionHandling1 error Hi Ron.  I'd like to include the test cases you've submitted here and for otherbug reports in the AspectJ test suite; however, I'm uncomfortable doing thatwith the copyright all rights reserved notice that you've put on them.  Can youplease resubmit your test cases either with no copyright or with the fulleclipse CPL header?  Thanks. Contributing the sources per the CPL:/** @author Ron Bodkin */aspect Library {    public pointcut executionsThrowingChecked() :         execution(* *(..) throws (Exception+ && !RuntimeException));}/** @author Ron Bodkin */public aspect SampleExceptionHandling {    public pointcut scope() : within(org.atrack.model..*);        public pointcut executionsThrowingChecked() :         Library.executionsThrowingChecked() && scope();    declare error : executionsThrowingChecked():         ""no checked exceptions"";}---/** @author Ron Bodkin */aspect Library {    public pointcut execs(): within(*);}/** @author Ron Bodkin */public aspect SampleExceptionHandling {    public pointcut executionsThrowingChecked() : Library.execs();    declare error : executionsThrowingChecked():         ""no checked exceptions"";} the test provided below is now in the tree under bugs/declareBindingthis bug is also fixed in cvs head fixing target milestone "	2003-09-08 22:47:35	1063080000.0	resolved fixed	d78d9ed	1063150000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PointcutDeclaration.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java tests/bugs/declareBinding/SampleExceptionHandling1.java tests/bugs/declareSoftWithin/test/NoSoftener.java weaver/src/org/aspectj/weaver/ResolvedPointcutDefinition.java
42539	throw derivative pointcuts not advised.	"Given the following point cut and advice:public aspect ExceptionAspect{    pointcut exceptionThrower() : execution(public * ExceptionBugTest.*(..)throws Exception+);    declare warning : exceptionThrower() : ""throws Exception+"";}And the to be aspected code:public class ExceptionBugTest{    class MyException extends Exception    {    }    public void method1() throws Exception    {    }    public void method2() throws MyException    {    }}listing file default.lst:C:\temp\AJC Bug\ExceptionAspect.ajC:\temp\AJC Bug\ExceptionBugTest.javaAJC does not advise ExceptionBugTest.method2().  The output from the compilationis the following:C:\temp\AJC Bug>ajc -argfile default.lst -classpath %ASPECTJ_HOME%\lib\aspectjrt.jarC:\eclipse\workspace\AJC Bug\ExceptionBugTest.java:11 throws Exception+From the aspect-j mailing list, contributed by Jim Hugunin:&lt;detail&gt;The bug was caused because the code for ThrowsPattern mistakenlyused the internal protected method TypePattern.matchesExactly instead of theexternal public method TypePattern.matchesStatically.  Because the classes werein the same package, Java's accessibility rules allowed this.  It would be niceif there was an easy way to specifiy that a method could only be accessed fromsubtypes.&lt;/detail&gt; Created attachment 5985A to be advised class Created attachment 5986The offending aspect and pointcut Created attachment 5987listing file for ajc The test provided has been added to tests/bugs/throwsSignature.  This bug is nowfixed in the tree for the 1.1.1 release.  Thanks for the clear and easy toreproduce bug report. "	2003-09-04 11:15:58	1062690000.0	resolved fixed	8660cc1	1062690000.0	tests/bugs/throwsSignature/ExceptionAspect.java tests/bugs/throwsSignature/ExceptionBugTest.java weaver/src/org/aspectj/weaver/patterns/ThrowsPattern.java
41359	percflow aspects compiled from jars share one instance for all entry points	When a percflow aspect is woven into source code from a jar using the aspectPathcompiler option, it produces only one instance of the aspect for each entrypointdefined in the source code. This bug needs a self-contained example in order to be verified and fixed.  Hereare two examples of bug reports for similar bugs that contained good examples:https://bugs.eclipse.org/bugs/show_bug.cgi?id=39462https://bugs.eclipse.org/bugs/show_bug.cgi?id=41123It would be very valuable to us if you could provide a similar example for thisbug.  Thanks for your help. Created attachment 5863test project with build.xmlHere's a test case that demonstrates the bug.  The default ant target tests theaspect code first compiled along with the test and then tests a second timewith the aspect in a jar and the testcase compiled with the jar in the aspectpath.To use the build.xml in this project, you'll need to create a lib folder in theproject containing aspectjrt.jar, aspecttools.jar, and junit.jar.  Also, inorder for the ant tasks to work, it will be a good idea to drop junit jar inANT_HOME/libThe results of both tests can be found in html form under ./dist/junit_output Created attachment 5898decompiled normally compiled codeShows attached (normally compiled) test code after being decompiled Created attachment 5899decompiled jar compiled codeShows attached (compiled from jar) test code after being decompiled This is a great test case and easy to reproduce.  I've raised this to a P2 bug. The general problem is that any code that extends an abstract aspect from a.jar file does not inherit the per-clause from the super-aspect, so all suchaspects behave like persingletons.  This is true for percflow, pertarget andperthis.The simple work-around is to explicitly include the per-clause in the concreteaspects declaration, i.e.:    aspect MyTestPerCFlowEntryPoint extends PerCFlowCompileFromJar                  percflow(topOfFlow())  {The bug is now fixed in the tree and should be in the 1.1.1 release. 	2003-08-09 11:19:18	1060440000.0	resolved fixed	5a07dce	1062110000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java tests/bugs/perCflowAndJar/PerCFlowCompileFromJar.java tests/bugs/perCflowAndJar/PerCFlowCompileFromJarTest.java
41888	call PCD fails when given subtype of defining type	"AspectJ 1.0 and 1.1 are behaving differently with respect to the qualifying typein a method call PCD. See the test case  tests/bugs/CallReference.javaAspectJ 1.1 is not picking out join points when a subtype of the defining typeis used.I assume 1.0 is correct (but see [1]) because it tracks the programming guide(and the JLS). Because this might involve questions about what's correct, I'llinclude (my understanding of) the definition here in case the fix is to correctmy interpretation or the programming guide.The programming guide says, ----At a method call join point, the signature is a method signature whose qualifying type is the static type used to access the method.----So given  class Super { void run() {} }  class Sub extends Super { }  class SubSub extends Sub { }Super is the declaring and defining type for run().  For the call  new SubSub().run()SubSub is the qualifying type because the reference type qualifies the call. (i.e., because method dispatch occurs at runtime, with a search up the hierarchyif a method is not implemented directly in the class of the object.  i.e., theguide intends to follow the definition of qualifying type for methods used inJLS 13.1.)Further, I understood from Erik that AspectJ accounts for polymorphism by havingthe pointcut match if one specifies a supertype of the signature type, so longas the method was defined in the specified supertype (or one of its supertypes). So to pick out all calls to that method, one should use the declaring type (inthis case, Super); to restrict the calls matched, use a subtype.  Indeed, forthis reason, the locution     target(Sub) && call(void run())evolved to address the situation where the method was being invoked through asupertype reference, e.g.,   ((Super) new SubSub()).run()which would only be picked out by  call(void Super.run())and not by   call(void SubSub.run())even when the method was implemented in SubSub.This is the behavior of AspectJ 1.0.By contrast, AspectJ 1.1, given   call(void Sub.run())fails to pick out the invocations   new Sub().run()   new SubSub().run()though it would pick out   new Sub().run()if the method were also defined in Sub, and not just in Super.Side notes:[1] In AspectJ 1.0, if I print the signature of the join point, it emits thedefining type of the method as the type, and does not change depending on thestatic type used to access the method. That would seem to be a 1.0 (and 1.1?)limitation of the JoinPoint signature.  [2] This should not be related to the case where older compilers use thedeclaring type of the method as the qualifying type, since this bug occurs whenall sources are presented to ajc. I.e., the programming guide alreadyincorporates the Java 1.0-1.1 change described in ""Compilation of SymbolicReferences"": http://java.sun.com/docs/books/jls/clarify.html http://java.sun.com/docs/books/jls/public-symref-compilation-rules.html Adding keyword ""info"" since, if true, this is a limitation of our implementationof the language.Raising priority to P2 mainly to get confirmation before the next releasewhether the bug is valid or reflects my misinterpretation. This is a manifestation of your issue [2] below, and you can probably fix it bycompiling with -target 1.4.  You should use javap to look at the bytecodegenerated by different compilers to see when the signature of the call isSuper.run and when it is Sub.run.You're right in that we could fix this in the case where all of the sources arepresented to ajc.  We could do this in one of two ways:1. Modify the compiler to always generate the ""correct"" declaring type even whennot in 1.4 mode.  I suspect that this would have unexpected consequences inolder JVMs that were not expecting this -- which is why it is only enabled in1.4 mode.2. Modify the compiler to add some attributes to the .class file indicating the""correct"" signatures for these method calls.  This would require substantialwork and isn't possible before 1.2.  If we do this, it could be part of ageneral approach to passing information from the compiler to the weaver, such asthe source line for method declarations, or the end bytecode for an exceptionhandler.As I stated in mail to users, I consider any call PCD that uses a declaring typewhich isn't the top-most type for that signature to be potentially veryconfusing to the programmer and something that should be discouraged except forvery specialized cases. Since we switched the default mode of the compiler to -1.4, this is only anissue for people who compile with -1.3.  We're never going to go back anddo a large amount of work to fix this situation for the 1.3 mode, so I'm resolving the bug now. "	2003-08-23 00:20:38	1061610000.0	resolved wontfix	9df9062	1061610000.0	tests/bugs/CallReference.java
39436	[Tasks] No summary shown in status line	*** Bug 44726 has been marked as a duplicate of this bug. *** I believe this was fixed in the Dec 9 integration build. Thanks Stefan.  Changing to FIXED. Fix available I200312109+. Verified fixed in the Problems View in I20031216 (8am).  Note this no longer applies to the Tasks View. build I20030625The old tasks view showed a summary of the number of tasks, errors, warnings and infos in the status line.  This is missing in the reworked view. This is a regression from 2.1. *** Bug 41213 has been marked as a duplicate of this bug. *** Created attachment 6212Proposed fix Created attachment 6217Proposed fix incorporating comments Created attachment 6276Proposed fix with Javadoc Code released in time for I20030930.  Javadoc altered slightly and released for post-I20030930. This fix appears to cause severe degradation of performance with Problems Views containing 1000+ markers that are filtered through a working set or selection list.  See bug 44069. 	2003-06-27 14:32:14	1056740000.0	verified fixed	d90acdc	1061480000.0	weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java
41254	revise asm and create interfaces	The org.aspectj.asm API exposes implementation detail, does not have interfaces, and has needless generalization and indirection (Association<->Relation<->RelationNode and LinkNode<->StructureNode).  The following is a first pass at an improved interface:- IProgramElement  * getName  * getAccessibility : Accessiblity  * getModifiers : Modifiers  * getKind : Kind    * getFormalComment : String  * isImplementor  * isOverrider  * isRunnable  + getRelationships  + getDeclaringType : IAspectJElement   + getPackage : IAspectJElement   + getType : IAspectJElement (can be null)  + getParameters : List /*IAspectJElement*/ (can be null)  + toString -> name  + toSignatureString -> full signature/**   * uni-directional 1..* relationships  */- IRelationship  + getName  + getKind  + getSource  + getTargets Fixed for 1.1.1 updated target milestone field to 1.1.1 	2003-08-07 09:00:15	1060260000.0	resolved fixed	f1deb9c	1060340000.0	ajbrowser/src/org/aspectj/tools/ajbrowser/BrowserManager.java ajbrowser/src/org/aspectj/tools/ajbrowser/TopFrame.java ajde/src/org/aspectj/ajde/internal/LstBuildConfigManager.java ajde/src/org/aspectj/ajde/ui/AbstractIconRegistry.java ajde/src/org/aspectj/ajde/ui/BuildConfigModel.java ajde/src/org/aspectj/ajde/ui/BuildConfigNode.java ajde/src/org/aspectj/ajde/ui/StructureModelUtil.java ajde/src/org/aspectj/ajde/ui/StructureSearchManager.java ajde/src/org/aspectj/ajde/ui/StructureView.java ajde/src/org/aspectj/ajde/ui/StructureViewManager.java ajde/src/org/aspectj/ajde/ui/StructureViewNode.java ajde/src/org/aspectj/ajde/ui/StructureViewNodeFactory.java ajde/src/org/aspectj/ajde/ui/StructureViewProperties.java ajde/src/org/aspectj/ajde/ui/internal/NavigationHistoryModel.java ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java ajde/src/org/aspectj/ajde/ui/swing/AjdeUIManager.java ajde/src/org/aspectj/ajde/ui/swing/BrowserStructureViewToolPanel.java ajde/src/org/aspectj/ajde/ui/swing/BrowserView.java ajde/src/org/aspectj/ajde/ui/swing/BrowserViewManager.java ajde/src/org/aspectj/ajde/ui/swing/BrowserViewTreeListener.java ajde/src/org/aspectj/ajde/ui/swing/BuildConfigPopupMenu.java ajde/src/org/aspectj/ajde/ui/swing/IconRegistry.java ajde/src/org/aspectj/ajde/ui/swing/PointcutWizard.java ajde/src/org/aspectj/ajde/ui/swing/SimpleStructureViewToolPanel.java ajde/src/org/aspectj/ajde/ui/swing/StructureTreeManager.java ajde/src/org/aspectj/ajde/ui/swing/StructureViewPanel.java ajde/src/org/aspectj/ajde/ui/swing/SwingTreeViewNode.java ajde/src/org/aspectj/ajde/ui/swing/SwingTreeViewNodeFactory.java ajde/src/org/aspectj/ajde/ui/swing/SwingTreeViewNodeRenderer.java ajde/src/org/aspectj/ajde/ui/swing/TreeViewBuildConfigEditor.java ajde/testdata/examples/coverage/ModelCoverage.java ajde/testdata/examples/coverage/pkg/InPackage.java ajde/testsrc/org/aspectj/ajde/AjdeTests.java ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java ajde/testsrc/org/aspectj/ajde/AsmRelationshipsTest.java ajde/testsrc/org/aspectj/ajde/NullIdeErrorHandler.java ajde/testsrc/org/aspectj/ajde/NullIdeManager.java ajde/testsrc/org/aspectj/ajde/NullIdeProgressMonitor.java ajde/testsrc/org/aspectj/ajde/NullIdeTaskListManager.java ajde/testsrc/org/aspectj/ajde/NullIdeUIAdapter.java ajde/testsrc/org/aspectj/ajde/StructureModelRegressionTest.java ajde/testsrc/org/aspectj/ajde/StructureModelTest.java ajde/testsrc/org/aspectj/ajde/ui/StructureModelUtilTest.java ajde/testsrc/org/aspectj/ajde/ui/StructureSearchManagerTest.java ajde/testsrc/org/aspectj/ajde/ui/StructureViewManagerTest.java asm/src/org/aspectj/asm/AdviceAssociation.java asm/src/org/aspectj/asm/Association.java asm/src/org/aspectj/asm/HierarchyWalker.java asm/src/org/aspectj/asm/IProgramElement.java asm/src/org/aspectj/asm/IRelationship.java asm/src/org/aspectj/asm/IStructureModelListener.java asm/src/org/aspectj/asm/InheritanceAssociation.java asm/src/org/aspectj/asm/IntroductionAssociation.java asm/src/org/aspectj/asm/LinkNode.java asm/src/org/aspectj/asm/ModelWalker.java asm/src/org/aspectj/asm/ProgramElementNode.java asm/src/org/aspectj/asm/ReferenceAssociation.java asm/src/org/aspectj/asm/Relation.java asm/src/org/aspectj/asm/RelationNode.java asm/src/org/aspectj/asm/StructureModel.java asm/src/org/aspectj/asm/StructureModelListener.java asm/src/org/aspectj/asm/StructureModelManager.java asm/src/org/aspectj/asm/StructureNode.java asm/src/org/aspectj/asm/StructureNodeFactory.java asm/src/org/aspectj/asm/internal/ProgramElement.java asm/src/org/aspectj/asm/internal/Relationship.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmNodeFormatter.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EmacsStructureModelManager.java org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AsmBuilderTest.java testing/src/org/aspectj/testing/ajde/CompileCommand.java weaver/src/org/aspectj/weaver/AsmAdaptor.java
41123	Weaving failure when using injars	"Sample run that fails using injars:C:\devel\test\libraryWeave>ajc ajee\testing\ExecutionMonitor.ajC:\devel\test\libraryWeave>jar cf ajee.jar ajee\testing\*.classC:\devel\test\libraryWeave>ajc -injars ajee.jar model\BusObj.java model\MonitorBusObj.javaC:\devel\test\libraryWeave\model\BusObj.java:3 Class must implement the inherited abstract method ExecutionMonitor.MonitoredItem.ajc$interMethodDispatch2$ajee_testing_ExecutionMonitor$record(String, String)public class BusObj {             ^^^^^^1 errorIt works in a single pass compilation:C:\devel\test\libraryWeave>ajc ajee\testing\ExecutionMonitor.aj model\BusObj.java model\MonitorBusObj.javaC:\devel\test\libraryWeave>Sample source code:package ajee.testing;public aspect ExecutionMonitor {    public interface MonitoredItem {}    private void MonitoredItem.record(String eventType, String eventName) {}}         ---package model;public class BusObj {}---package model;import ajee.testing.ExecutionMonitor;public aspect MonitorBusObj {    declare parents: BusObj implements ExecutionMonitor.MonitoredItem;} I uncovered this bug in trying to track down the following compiler crash, which may or may not be related:Kind	Status	Priority	Description	Resource	In Folder	LocationError			Internal compiler errorjava.lang.NullPointerException	at org.aspectj.weaver.patterns.CflowPointcut.concretize1(CflowPointcut.java:126)	at org.aspectj.weaver.patterns.ReferencePointcut.concretize1(ReferencePointcut.java:270)	at org.aspectj.weaver.patterns.AndPointcut.concretize1(AndPointcut.java:88)	at org.aspectj.weaver.patterns.AndPointcut.concretize1(AndPointcut.java:88)	at org.aspectj.weaver.patterns.AndPointcut.concretize1(AndPointcut.java:88)	at org.aspectj.weaver.patterns.ReferencePointcut.concretize1(ReferencePointcut.java:270)	at org.aspectj.weaver.patterns.AndPointcut.concretize1(AndPointcut.java:88)	at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:127)	at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:120)	at org.aspectj.weaver.Advice.concretize(Advice.java:216)	at org.aspectj.weaver.CrosscuttingMembers.addShadowMunger(CrosscuttingMembers.java:78)	at org.aspectj.weaver.CrosscuttingMembers.addShadowMungers(CrosscuttingMembers.java:72)	at org.aspectj.weaver.ResolvedTypeX.collectCrosscuttingMembers(ResolvedTypeX.java:328)	at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect(CrosscuttingMembersSet.java:50)	at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTypeAndPerClause(AspectDeclaration.java:747)	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildInterTypeAndPerClause(AjLookupEnvironment.java:120)	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildInterTypeAndPerClause(AjLookupEnvironment.java:136)	at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:87)	at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:310)	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:324)	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:372)	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:133)	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:78)	at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)	at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:164)	ClaimForm.java	ClaimsSample/src/com/newaspects/claimsSample/ui/controller	 I *think* the NPE that Ron mentions is a dup of another bug Jim fixed recently to do with concretizing advice too early when it was coming from a library.  I can recreate Rons initial bug with the currently available version of 1.1 - I'm going to retry it on a development build of 1.1.1. Also fails in the same way if I change it to:ajc -aspectpath ajee.jar model\BusObj.java model\MonitorBusObj.javaOrset CLASSPATH=ajee.jarajc model\*.javaDoes that mean the method:ExecutionMonitor.MonitoredItem.ajc$interMethodDispatch2$ajee_testing_ExecutionMonitor$record(String, String)is not being made synthetic when it is written out? Andy was right on both counts.  Ron's original stack-trace issue has beenresolved.  This bug is caused by the weaver not putting the Synthetic attributeon methods with mangled names, which can cause problems for code that extendsthose classes/interfaces.In addition to adding the Synthetic attribute, I also added several checks inthe eclipse compiler phase to produce errors when a class implements aninterface that has either non-abstract methods or non-static fields -- and theaspect that produced those is not on the source or aspectpath.  Without thiserror, it is easy for ajc to generate code that will have unimplemented methodexceptions thrown at runtime from the VM. updated target milestone field to 1.1.1 "	2003-08-05 00:39:51	1060060000.0	resolved fixed	3e59745	1060310000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java tests/bugs/moreInterfaceLibrary/model/BusObj.java tests/bugs/moreInterfaceLibrary/model/MonitorBusObj.java weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java
40534	Declare warning/error output - more detail required.	"At present the declare warning and declare error functionality of the compiler provides no detailed information about what it is in the user code that has led to the generation of the compile-time warning or error. Consider the following test case...public class A{  public static void main(String[] args)  {    A a = new A();    a.doSomething();    System.out.println(""All done"");  }  void doSomething()  {    System.out.println(""Doing something"");  }} // end of class Apublic aspect MyAspect{  pointcut noDoing() :    call(* *.doSomething(..));  declare warning : noDoing() :    ""Don't do it!"";} When I compile these two files I get the following warning ...c:\src\A.java:16 Don't do it!..which is great if all I want to know is where the offending code is. But not nearly enough if I want to know what it is on the line that is contravening the policy (or policies) that I have specified in my aspect. In the above example it would be even more useful if the warning message was something like ...c:\src\A.java:16 Don't do it! : calling method : void A.doSomething()For large projects where there is an architectural imperative to reduce or completely remove coupling between certain components declare warning/error would be of far greater use if it could return more detailed info to say *why* not just *where* the desired enforcement rules have been broken. Is this different from 31724?  It seems to be part of the residual issue keepingthat bug open.  (The issue is more general: *any* warning or error (not justdeclare warning/error) generated during weaving rather than during the compilerpass will produce a message without source context.)  I actually prefer this bugpriority, so if Mik has a fix perhaps 31724 should be closed with a note sayingthis bug is to deal with the remaining issue.  If that bug is closed, anycontext-related failing test cases should be associated instead with this bug(and/or more tests written...).  But since we originally thought this was anissue that Jim/Erik would have to think together about since the source contextinfo is not available to the weaver, perhaps this should be closed as aduplicate of 31724.   Fixed in 1.1.1 updated target milestone field to 1.1.1 "	2003-07-20 12:16:58	1058720000.0	resolved fixed	684c9c1	1060250000.0	bridge/src/org/aspectj/bridge/IMessage.java bridge/src/org/aspectj/bridge/Message.java testing/src/org/aspectj/testing/xml/SoftMessage.java weaver/src/org/aspectj/weaver/Checker.java
40257	"parsing of ""../"" paths in LST files is broken"	"Relative paths (e.g. ""../"") are no longer parser properly in AJDE 1.1.0. Fixed in 1.1.1 updated target milestone field to 1.1.1 "	2003-07-16 15:06:12	1058380000.0	resolved fixed	acdf688	1060240000.0	ajbrowser/testsrc/org/aspectj/tools/ajbrowser/BrowserManagerTest.java ajbrowser/testsrc/org/aspectj/tools/ajbrowser/InteractiveBrowserTest.java ajde/src/org/aspectj/ajde/ui/swing/CompilerMessagesCellRenderer.java org.aspectj.ajdt.core/testdata/bug-40257/d1/A.java org.aspectj.ajdt.core/testdata/bug-40257/d1/d2/B.java org.aspectj.ajdt.core/testdata/bug-40257/d3/C.java org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/AjdtAjcTests.java org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java
41170	-classpath entries in .lst files overwrite command-line -classpath entries	"If the command-line specifies both a -classpath entry and a .lst file with a-classpath entry, the .lst file entry seems to replace rather than supplementthe command-line entry.  I expect options to be cumulative. Seetests/bugs/options/classpath Upgrading to P2 because merging config files and options is going to be commonfor libraries and ant -- I find myself doing it all the time.  I'm also nervousthat we haven't explored this area at all, so I'd like to at least explorewhether there's a systematic problem with merging the command line with multipleconfig files.  E.g., this might be the problem seen by Chris Orvitz. Whether or not it is desirable, this is implemented as originally specified ("".lst"" file options shadow those passed on the command line"").  I've updated the severity to ""enhancement"".Also, today is the day of the preview and I can not accept any more P2s for the 1.1.1rc1 release.  We should get around to implementing this soon.  But I'd like to know more about the behavior that you want.  First of all, can you detail the use case for why you can't put your entire classpath into the "".lst"" file?  Are the similar uses for the other options?  Also, what else should be merged (e.g. if source files are passed to both, are the lists merged)?  What dominates (e.g. if an option in the "".lst"" file conflicts with one on the command line)?   If/since it won't be fixed, the workaround is to put the command-line into a.lst file, or to extract any -classpath entries from all .lst files.  I understand that it's a P3 for now, but I'm not sure this is how it used towork.  Was this bug introduced with the -classpath workaround for the eclipsebatch compiler bug?  As for motivation, consider base applications defined by .lst files and aspectsets defined by .lst files, each with their own required libraries.  Thenconsider an Ant task or command-line or test case that assembles these withother ad-hoc aspects as part of exploring the ad-hoc aspects.  What you'resuggesting is that once you use a .lst file to contain a -classpath entry, thenyou can't use command line or test case or ant script.  As for the spec (bug) and the larger issue of merging options, the semantics arestandard (merge in order) and conflict detection can be prioritized to focus on core options: output dir or jar, classpath, aspectpath, injars, source filesand source roots, and spec levels (target, compliance, source).   This behaviour has now been stable for at least the last 2 years with no new reported user issues in this area that I'm aware of so I'm going to close this request out. "	2003-08-05 20:19:15	1060130000.0	resolved wontfix	40fb451	1060130000.0	tests/bugs/options/classpath/Client.java tests/bugs/options/classpath/lib/Library.java
38717	""".lst"" file parsing errors should include sourceline information"	"To check for this bug add an erroneous line to an "".lst"" file and compile it with AJDE.  The error message returned is project-specific.  It should be specific to the "".lst"" file in which the error originated (i.e. the message needs a SourceLocation). Fixed for 1.1.1. "	2003-06-10 12:03:37	1055260000.0	resolved fixed	a26cac9	1059590000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/AjdtCommand.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java
39974	Some strange error when compiling the observer example with JBuilder7 integrated AJDE	"When I compiled the observer/subject protocol example with JBuilder7 integrated AJDE,there was a strange internal errorC:/JBuilder7/extras/aspectj-110/doc/examples/observer/Observer.java:0: Internal compiler errorjava.lang.NullPointerException	at org.aspectj.ajdt.internal.compiler.lookup.EclipseWorld.makeResolvedMember(Unknown Source)	at org.aspectj.ajdt.internal.core.builder.AsmBuilder.visit(Unknown Source)	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(Unknown Source)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(Unknown Source)	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(Unknown Source)	at org.aspectj.ajdt.internal.core.builder.AsmBuilder.internalBuild(Unknown Source)	at org.aspectj.ajdt.internal.core.builder.AsmBuilder.build(Unknown Source)	at org.aspectj.ajdt.internal.compiler.lookup.EclipseWorld.finishedCompilationUnit(Unknown Source)	at org.aspectj.ajdt.internal.compiler.AjCompiler.process(Unknown Source)	at org.eclipse.jdt.internal.compiler.Compiler.compile(Unknown Source)	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(Unknown Source)	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(Unknown Source)	at org.aspectj.ajdt.internal.core.builder.AjBuildManager$BatchBuilder.run(Unknown Source)	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(Unknown Source)	at org.aspectj.ajde.internal.CompilerAdapter.compile(Unknown Source)	at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(Unknown Source)I firstly fix it by changing the interface Subject and Observer like this:interface Observer {    void update();}interface Subject { Object getData(); }then it could compile successfully ,however,I immediately got another confusing.The compiler only made Display.java Observer.java Subject.java SubjectObserverProtocol.java and SubjectObserverProtocolImpl.java but ignoring the others.I don't know why,it seems to be a bug.Meanwhile, I use ajc command-line  to compile this example ,it can get through without any exceptions. Correcting erroneous re-assignment. Fixed for 1.1.1 by improving the ASMBuilder's error handling for this case.However, we could not reproduce the test case with the observer example.  If you could email or attach the exact source code that produced this we could take a closer look. "	2003-07-12 06:00:12	1058000000.0	resolved fixed	f5d31ba	1059560000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java
39626	Compiler error when compiling a buggy class	I use AspectJ 1.1 from within eclipse.After some time of developing, I get following stack trace (Wrapped in the eclipse gui), when I try to compile a java file with a huge amount of syntax errors, missing variables, and other problems.As soon as I have fixed these issues, I can comnpile normally as ever.Unfortunatly I can not provide any more detailed information because:this errors pops up randomly,disappears when the bug is fixed, I have neither the time nor the permission to create a more accurate samplejava.lang.NullPointerException    at java.lang.String.<init>(String.java:214)    at org.aspectj.ajdt.internal.core.builder.AsmBuilder.visit(AsmBuilder.java:231)    at org.aspectj.ajdt.internal.core.builder.AsmBuilder.visit(AsmBuilder.java:259)    at org.eclipse.jdt.internal.compiler.ast.AnonymousLocalTypeDeclaration.traverse(AnonymousLocalTypeDeclaration.java:138)    at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.traverse(QualifiedAllocationExpression.java:342)    at org.eclipse.jdt.internal.compiler.ast.MessageSend.traverse(MessageSend.java:299)    at org.eclipse.jdt.internal.compiler.ast.Block.traverse(Block.java:147)    at org.eclipse.jdt.internal.compiler.ast.ForStatement.traverse(ForStatement.java:347)    at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:157)    at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:946)    at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:303)    at org.aspectj.ajdt.internal.core.builder.AsmBuilder.internalBuild(AsmBuilder.java:169)    at org.aspectj.ajdt.internal.core.builder.AsmBuilder.build(AsmBuilder.java:66)    at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.finishedCompilationUnit(EclipseFactory.java:303)    at org.aspectj.ajdt.internal.compiler.AjCompiler.process(AjCompiler.java:67)    at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:338)    at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:372)    at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:133)    at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:78)    at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117)    at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:164)    LoadTest.java   CrefoClient/src/com/dcbank/scoring/socketserver  kind regards   Arno Schmidmeier This appears to be caused by an invalid local type declaration causing the asm builder to be confused.  I'm assigning this to Mik in the hopes that he'll have the time to isolate this into a test case.  The fix is almost certainly to add a null check on AsmBuilder.java:231; however, I'd like to get a test case that reproduces the bug before fixing it. Added AsmBuilderTest class that tests handling for this and related null parameters. 	2003-07-04 05:26:04	1057310000.0	resolved fixed	7886970	1059560000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AjdtBuilderTests.java org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AsmBuilderTest.java
39959	AJC Compiler generates invalid class files under certain circunstances.	"I made a package (I will attach it to this bug with the name bug.zip) whichshows a sample Java program that correctly runs when compiled with javac andhave classloading problems every time it is compiled with ajc.Please see the file README.TO.DEMONSTRATE.BUG inside the bug.zip archive fordetailed (although simple) instructions on reproducing the bug.There are two shell scripts attached to make things easier.Please keep me informed of the status of this issue. Created attachment 5431PART 1 of 3 - Sample code and scripts to demonstrate ajc compiler bug.See the contained file README.TO.DEMONSTRATE.BUG for information. Created attachment 5432PART 2 of 3 - Sample code and scripts to demonstrate ajc compiler bug.See the contained file README.TO.DEMONSTRATE.BUG for information Created attachment 5433PART 3 of 3 - Sample code and scripts to demonstrate ajc compiler bug.See the contained file README.TO.DEMONSTRATE.BUG for information. Sorry for the big files. I wanted to make something easy to reproduce andself-contained. What version of the compiler are you using?  I can't reproduce this with the 1.1.0 released compiler.  When I run compile_and_test_class_with_ajc, I see ""The test case worked!"".  Are you using an older version of ajc? I am using j2sdk1.4.1_01 and I just noticed something which might help you toreproduce the bug:The JAVA_HOME environment variable must be set to<place-where-java-is-located>/j2sdk1.4.1_01for the problem to appear.* The version I am using is really 1.1.0...* You should have seen an exception instead of the ""The test case worked!"" message.* If you still cannot reproduce the bug, I will happily provide access to mysystem to show it if you wish. I still can't duplicate this bug.  The only difference I can see with our systems is that I'm running under Windows XP instead of Linux.  My detailed Java version info is:C:\aspectj\scratch\bug>java -versionjava version ""1.4.1_01""Java(TM) 2 Runtime Environment, Standard Edition (build 1.4.1_01-b01)Java HotSpot(TM) Client VM (build 1.4.1_01-b01, mixed mode)Under this configuration I can't duplicate this bug.  I'm cc'ing this to George Harley who I know has easy access to both Windows and Linux boxes to see if he has better luck reproducing it on one or both of those systems. OK, I can look at this one tomorrow (Thursday 24th July). My Linux Java is :java version ""1.4.1_05""Java(TM) 2 Runtime Environment, Standard Edition (build 1.4.1_05-b01)Java HotSpot(TM) Client VM (build 1.4.1_05-b01, mixed mode) Raising to P2 to be sure that we investigate before 1.1.1 release.  Investigation may result either in a fix or a lowering of priority. I couldn't resist trying to see if the error showed up for me before I left the office for the day. Using the test case supplied in the zip files all went OK when it was compiled and run with the 1.4.1 JDK. However, when I compiled it with the 1.1.0 ajc and ran it on the 1.4.1 JVM I got the following ...Exception in thread ""main"" java.lang.NoClassDefFoundError: org/apache/xerces/parsers/AbstractDOMParser        at testcase.ShowBug.main(ShowBug.java:49)I saw the same runtime behaviour when running the class with a 1.3.1 JVM.Like I said, I can look into this further tomorrow. Is the above exception what you are seeing in your environment ? George, I don't want to keep you any later tonight, but tommorrow could you do the same test on a Windows XP box to verify if this is a Linux-only bug or if I'm somehow special in not being able to reproduce it?    The exception reported by George is exactly what I got running thebug-reproducer now. However, In the original environment (I am working in thedevelopment of software which source code I unfortunately cannot disclose) thecompiler generated invalid class files some times.   Again, if any of you need a test environment in which the bug shows up everytime access the http://pinheiros.ic.unicamp.br:40000 address in any java-enabledbrowser and mail me for the password - I have a X session (inside VNC) laying there. <Pyinson Data Over Head> This problem occurred when a command line compile did not specify a ""-classpath"" option.  In that case BuildArgParser loaded System.getProperty(""java.class.path"").  However, in the launch script aspectjtools.jar is already added to the VM's classpath.  We remove all occurrences of ""aspectjtools.jar"" from the detected classpath.  This should enable bootstrapping ajc. "	2003-07-11 16:01:33	1057950000.0	resolved fixed	ee03a3e	1059480000.0	tests/bugs/bootstrapClasspath/UsesDOMParser.java
40824	"asm treats ""declare parents"" as methods"	"""declare parents"" member declarations report their kind as ""method"" instead of what they are. Problem was in AsmBuilder handling. updated target milestone field to 1.1.1 "	2003-07-28 05:55:44	1059390000.0	resolved fixed	58e3cb2	1059480000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java
39842	allow use of an environment variable to set compiler arguments	"I'm trying to create a special jsp compilation servlet in Tomcat 4.x that uses the aspectj compiler. I can plug in the compiler adapter, but I don't have control of the ant code they use to invoke the compiler, so I'd like to use an environment variable to do this (apparently the only mechanism they do support).I'm doing this so I can pass an aspectpath in to weave aspects into the compiled jsp servlet. Done for 1.1.1.  To rewrite the command-line arguments, specify an ICommandEditor class nameeither in the environment or dynamically in the task invocation.i.e., implement ICommandEditor in com.company.CommandEditor...------package org.aspectj.tools.ant.taskdefs;public interface ICommandEditor {    String[] editCommand(String[]);}------define the environment variable on the command line:  -Dorg.aspectj.tools.ant.taskdefs.AjcTask.COMMAND_EDITOR=com.company.CommandEditoror specify it in the task invocation:   <iajc ... commandEditorClass=""com.company.CommandEditor""(task specifications take precedence) updated target milestone field to 1.1.1 "	2003-07-09 19:31:03	1057790000.0	resolved fixed	2502ee5	1059190000.0	taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java taskdefs/src/org/aspectj/tools/ant/taskdefs/ICommandEditor.java taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.java
40771	ajde apis are unnecessariy coupled to swing	The AJDE APIs are coupled to javax.swing by org.aspectj.ajde.EditorManager.  The EditorManager needs to be refactored, have swing specific parts moved to org.aspectj.ajde.ui.swing and org.aspectj.ajbrowser. Probably related to bug#37628, since AJDT might be crashing when Swing is unnecessarily loaded. Fixed.  Now only org.aspectj.ajde.ui.swing is coupled to javax.swing. updated target milestone field to 1.1.1 	2003-07-25 10:47:43	1059140000.0	resolved fixed	bbd832b	1059150000.0	ajbrowser/src/org/aspectj/tools/ajbrowser/BasicEditor.java ajbrowser/src/org/aspectj/tools/ajbrowser/BrowserManager.java ajbrowser/src/org/aspectj/tools/ajbrowser/BuildConfigPopupMenu.java ajbrowser/src/org/aspectj/tools/ajbrowser/CompilerMessagesPanel.java ajbrowser/src/org/aspectj/tools/ajbrowser/EditorManager.java ajbrowser/src/org/aspectj/tools/ajbrowser/TopFrame.java ajde/src/org/aspectj/ajde/Ajde.java ajde/src/org/aspectj/ajde/ui/EditorManager.java ajde/src/org/aspectj/ajde/ui/StructureModelUtil.java ajde/src/org/aspectj/ajde/ui/StructureViewManager.java ajde/src/org/aspectj/ajde/ui/swing/AjdeUIManager.java ajde/src/org/aspectj/ajde/ui/swing/BasicEditor.java ajde/src/org/aspectj/ajde/ui/swing/BrowserViewManager.java ajde/src/org/aspectj/ajde/ui/swing/BrowserViewTreeListener.java ajde/src/org/aspectj/ajde/ui/swing/BuildConfigPopupMenu.java ajde/src/org/aspectj/ajde/ui/swing/PointcutWizard.java ajde/src/org/aspectj/ajde/ui/swing/StructureViewPanel.java ajde/testsrc/AjdeModuleTests.java ajde/testsrc/org/aspectj/ajde/CompilerMessagesTest.java ajde/testsrc/org/aspectj/ajde/NullIdeEditorAdapter.java ajde/testsrc/org/aspectj/ajde/NullIdeManager.java
40380	AspectJ does not honour libraries defined via Project Properties	"AJDT 1.1.3, Eclipse 2.1To build a JDK 1.4. program under Eclipse using JDK 1.3 the appropriate build library should be selected in the Project Properties ""Java Build Path"". However AspectJ continues to use the JDK associated with Eclipse so errors result from using 1.4 APIs. The same will occur running Eclipse under 1.4 and compiling programs for 1.5Testcase:1. Run Eclipse under JDK 1.32. Create a Java project which uses a 1.4 JDK3. Write a Java classes that uses 1.4 APIs e.g.public class TestStringBuffer {	public  static void main(String[] args) {		new StringBuffer(""Test"").indexOf(""T"");  	}}4. Convert to AspectJ project Fixed.  The problem was not with project settings, but with the fact that the AspectJ compiler was always getting the user's classpath and prepending it to the classpath set by the IDE. updated target milestone to 1.1.4 "	2003-07-17 11:08:28	1058450000.0	resolved fixed	d5ea336	1058980000.0	ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/AjdtCommand.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java
39993	ajc stack trace on declaring hashcode() method in aspect	"From an email sent to the user's list 6/26/2003:------------------------------------------ajc 1.1 NPE when an aspect declares hashcode() as follows:     interface Identifiable {         void setId(Id id);         Id getId();     }      aspect IdentifiableAspect {         private Id Identifiable.id = null;         public Id Identifiable.getId() { 		return this.id; 	  }         public void Identifiable.setId(Id id) {             this.id = id;         }          public int Identifiable.hashCode() {             return (this.getId() == null)                 ? super.hashCode()                 : this.getId().hashCode();         }     }A workaround for callers the compiler controls is to replace the declarationwith around advice:     int around(Identifiable i): target(i)         && call(public int hashCode())     {         return (i.getId() == null)             ? proceed(i)             : i.getId().hashCode();     } *** Bug 40589 has been marked as a duplicate of this bug. *** Raising to P2 based on second independent report of problem.  I'm working on a fix. tests and fix in treeHandle use of super inside of inter-type declaration on an interface.  If the interface has more than one super interface, that is a compile-time errorbecause super can not be resolved. updated target milestone field to 1.1.1 *** Bug 43163 has been marked as a duplicate of this bug. *** "	2003-07-13 15:02:03	1058120000.0	resolved fixed	026b272	1058910000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterSuperFixerVisitor.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterSuperReference.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeDeclaration.java tests/bugs/MultipleSuperCf.java tests/bugs/OverridingInterfaceObjectMethod.java weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java
39458	Compiler crash in ajc 1.1	<Pyinson Data Over Head> Raised priority because this awful error message was simple to fixtest in bugs/NewVoid.java, fix in cvs updated target milestone field to 1.1.1 	2003-06-29 23:42:42	1056940000.0	resolved fixed	ba41fae	1057190000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AdviceDeclaration.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/PrivilegedHandler.java tests/bugs/MissingImport.java tests/bugs/NewVoid.java
38131	ajc needs -d . option while correctly compiling classes from subpackage	"I am using 1.1rc1. This is a regression since rc1 and a deviation from javac.I am guessing this may have to do something with change in the underlyingEclipse compiler.Create a class in a subpackage such as:package subpackage;public class Test {    public static void main(String[] args) {	System.out.println(""Hello"");    }}Then compile using following command:> ajc subpackage\Test.javaYou will see a directory ""subpackage"" created under the existing ""subpackage""directory. The test.class is then put in subpackage\subpackage directory.This means running java command results in Exception in thread ""main"" java.lang.NoClassDefFoundError: subpackage/TestRunning either of the following command fixes the problem:> ajc -d . subpackage\Test.javaor > javac subpackage\Test.javaNo big deal, really. But it will be nice to have same behavior as javac. This was a significant regression from 1.1rc1.  It is now fixed in the tree with a test in org.aspectj.ajdt.core/*/BasicCommandTestCase.  The behavior should exactly mimic that of javac (and the eclipse command-line compiler) when -d is not passed.We had no test cases for this behavior because all of our testing infrastructure explicitly passes in an output directory to keep class files out of the source tree. "	2003-05-27 01:46:58	1054010000.0	resolved fixed	c509c6f	1054060000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java org.aspectj.ajdt.core/testdata/src1/WrongPackage.java org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BasicCommandTestCase.java
37739	Unexpected Xlint:unresolvableMember warning with withincode	"The following code produces an Xlint:unresolvableMember warning:class A {    A(Class type) {}    A() {        this(String.class);    }}class B {    public void test() {    }    public void test2() {        test();    }}aspect C {    void around() :        (call (void B.test()) &&         withincode (void B.test2())) {        proceed();    }}The warning text is:Warning.java:22 can not resolve this member:void A.<catch>(java.lang.ClassNotFoundException) [Xlint:unresolvableMember]Line 22 is the line in the aspect that says ""withincode"".  If I comment out the aspect, the warning goes away.  Also, if I comment out A's default constructor, it goes away.  The ""String.class"" seems to have something to do with the warning.  I can reproduce this with 1.1rc1 and 1.1rc2. fixed in cvs, test in bugs/CatchSig.javaThis issue is with any code in the special pre-initialization position.  This is code that runs in a constructor before either this or super has been called.  This code doesn't have an enclosing execution join point because it is defined to run before constructor execution starts.  The String.class reference in class A is in this position and includes both method calls and an exception handler under AspectJ-1.1. "	2003-05-15 21:20:16	1053050000.0	resolved fixed	2072ac1	1053370000.0	tests/bugs/CatchSig.java weaver/src/org/aspectj/weaver/bcel/BcelShadow.java
37021	source path wrong in declare warning on binary files	"In declare warning messages when targeting .class files from -injars, the source path is listed in the form ""app.Main.class"" rather than ""app/Main.[java|aj]"".See tests/new/binaryWarnings/.. for code to run to see the problem.Limitations of the tests:- These tests return false positives when detecting this error because filename checking is not enabled in harness verification of messages.- I have also see the filenames not appear at all, but these tests do not reproduce that problem.  (I saw it in AJDT, so perhaps if the filename makes no sense to AJDT, AJDT simply omits it.) This is fixed in the tree, but the test harness still needs to be updated to verify the fix.  So, I'm assigning this to Wes and lowering the priority. Harness and tests updated; source paths verified correct.  (Other knownlimitations are reflected in tests in tests/ajcTests{Failing}.xml.) "	2003-04-28 15:03:42	1051560000.0	resolved fixed	9b30f9f	1051560000.0	tests/new/binaryWarnings/src/app/Main.java tests/new/binaryWarnings/src/aspects/MainWarnings.java
30663	"lame error message: ""negation doesn't allow binding"""	"AspectJ Compiler 1.1beta4This program:public aspect Foo {  pointcut p(int i): call(void f(i));}produces these error messages:negation doesn't allow bindingformal unbound in pointcut2 errorsIt should say something like ""binding is only allowed in state-based pointcuts"", and it should print the file and line number.--Doug fixed in tree, and test in bugs/BadBindingError.java "	2003-01-30 15:48:08	1043960000.0	resolved fixed	7d14432	1051490000.0	tests/bugs/BadBindingError.java weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java weaver/src/org/aspectj/weaver/patterns/TypePattern.java weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java
36936	Error when introducing members of type Class	"Using AspectJ 1.1 RC1  public aspect Asp { 	public Class Trg.member = String.class; }  public class Trg { 	public static void main(String args[]) { 		new Trg(); 		System.out.println(""All ok""); 	} }  Compiling with ""ajc Asp.java Trg.java"" and running Trg, prints ""All ok"", as it should.  Compiling with ""ajc Trg.java Asp.java"" and running Trg gives: Exception in thread ""main"" java.lang.NoSuchFieldError: class$0         at Asp.ajc$interFieldInit$Asp$Trg$member(Asp.java:2)         at Trg.<init>(Trg.java:1)         at Trg.main(Trg.java:3)  Note, introduced field must be of type Class, or array of Classes, works fine else. fixed in tree with test in bugs/interSpecialsThis issue is with the reference String.class, not with the type of the field. "	2003-04-25 16:36:56	1051300000.0	resolved fixed	8d793a3	1051490000.0	tests/bugs/interSpecials/Asp.java tests/bugs/interSpecials/Trg.java
34951	NPE compiling without aspectjrt.jar	"Compiling spacewar without specifying aspectjrt.jar on the classpath causes a NPE.  Expected an error message ""aspectjrt.jar required"".Steps to reproduce1) install latest2) cd doc/examples3) java -jar ../../lib/aspectjtools.jar -verbose @spacewar/debug.lstRESULT:NPE in attached log Created attachment 4113log of verbose messages, NPE; also version This should be fixed and has a unit test in org.aspectj.ajdt.core/BasicCommandTestCase.The fix hasn't been verified on the command-line yet. "	2003-03-13 14:38:58	1047580000.0	resolved fixed	f236927	1051490000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BasicCommandTestCase.java
36803	BCException thrown by AspectJ 1.1rc1	[iajc] expected state: resolved got: concrete     [iajc] expected state: resolved got: concrete     [iajc] org.aspectj.weaver.BCException: expected state: resolved got: concrete     [iajc]     at org.aspectj.weaver.patterns.Pointcut.assertState(Pointcut.java:236)     [iajc]     at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:126)     [iajc]     at org.aspectj.weaver.patterns.CflowPointcut.concretize1(CflowPointcut.java:143)     [iajc]     at org.aspectj.weaver.patterns.NotPointcut.concretize1(NotPointcut.java:94)     [iajc]     at org.aspectj.weaver.patterns.AndPointcut.concretize1(AndPointcut.java:88)     [iajc]     at org.aspectj.weaver.patterns.ReferencePointcut.concretize1(ReferencePointcut.java:270)     [iajc]     at org.aspectj.weaver.patterns.AndPointcut.concretize1(AndPointcut.java:88)     [iajc]     at org.aspectj.weaver.patterns.ReferencePointcut.concretize1(ReferencePointcut.java:270)     [iajc]     at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:127)     [iajc]     at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:120)     [iajc]     at org.aspectj.weaver.Advice.concretize(Advice.java:207)     [iajc]     at org.aspectj.weaver.CrosscuttingMembers.addShadowMunger(CrosscuttingMembers.java:78)     [iajc]     at org.aspectj.weaver.CrosscuttingMembers.addShadowMungers(CrosscuttingMembers.java:72)     [iajc]     at org.aspectj.weaver.ResolvedTypeX.collectCrosscuttingMembers(ResolvedTypeX.java:328)     [iajc]     at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect(CrosscuttingMembersSet.java:54)     [iajc]     at org.aspectj.weaver.bcel.BcelWeaver.prepareForWeave(BcelWeaver.java:164)     [iajc]     at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:214)     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.weaveAndGenerateClassFiles(AjBuildManager.java:394)     [iajc]     at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:149)     [iajc]     at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:55)     [iajc]     at org.aspectj.tools.ajc.Main.run(Main.java:216)     [iajc]     at org.aspectj.tools.ajc.Main.runMain(Main.java:155)     [iajc]     at org.aspectj.tools.ant.taskdefs.AjcTask.execute(AjcTask.java:646)     [iajc]     at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:193)     [iajc]     at org.apache.tools.ant.Task.perform(Task.java:341)     [iajc]     at org.apache.tools.ant.Target.execute(Target.java:309)     [iajc]     at org.apache.tools.ant.Target.performTasks(Target.java:336)     [iajc]     at org.apache.tools.ant.Project.executeTarget(Project.java:1339)     [iajc]     at org.apache.tools.ant.Project.executeTargets(Project.java:1255)     [iajc]     at org.apache.tools.ant.Main.runBuild(Main.java:609)     [iajc]     at org.apache.tools.ant.Main.start(Main.java:196)     [iajc]     at org.apache.tools.ant.Main.main(Main.java:235) Can you come up with a short self-contained test case that will reproduce this bug?  That would help us a lot in tracking it down and fixing it.  With such a test case, I believe this bug will be fixed for the 1.1rc2 release, otherwise it might take longer. Created attachment 4703test file to make compiler throw BCExceptionI pared this down to something small that still gets the exception.I emailed it as well before I noticed the facility to add it to the bug report. fixed in tree, test in bugs/CflowConcrete.javaThis was easily reproduced from the provided test case.  FYI - for nice small test cases like this one, it is easiest if you can just provide the test inline with your comments rather than as an attachment. 	2003-04-23 12:56:03	1051120000.0	resolved fixed	1e502f5	1051290000.0	tests/bugs/CflowConcrete.java weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java weaver/src/org/aspectj/weaver/patterns/Pointcut.java weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java
29665	Inconsistant stack height	"Using AspectJ1.1b4 running the following program crashes it with this message:""Inconsistent stack height 0 != 2"". While reducing my original program to theminimum example below I had also stack height 0 != 1, but I guess that isrelated, so I didn't reproduce it (mail me if this you need this, too).mport java.lang.reflect.Method;public class StackError {	public static void main(String args[]) {}	void assertTrue(String msg, boolean b) {}	public void testEqualsNull() {		StackError one = new StackError();		StackError two = new StackError();		assertTrue(""equal"", one.equals(two));	// does not work		boolean yes = one.equals(two);			// works	}		public boolean equals(Object other) {		return true;	}}aspect EqualsContract {	pointcut equalsCall(Object thisOne, Object otherOne):		target(Object+) &&  	target(thisOne) &&		call(public boolean equals(Object+)) &&		args(otherOne) &&		!within(EqualsContract);		boolean around(Object thisOne, Object otherOne):	equalsCall(thisOne, otherOne) {		boolean result = proceed(thisOne, otherOne);		Class cls = thisOne.getClass();		String name = cls.getName();		boolean hasHashCode = false;		try {			Method m = cls.getDeclaredMethod(""hashCode"", null);			String lookFor = ""public int "" + name + "".hashCode()"";			hasHashCode = lookFor.equals(m.toString());		}		catch (NoSuchMethodException nsme) {}		return result;	}}The program does not crash if you comment out the line indicated with the ""doesnot work"" comment. Note the line below that (comment ""works"") does work. This looks like a bug in the implementation of around advice inlining (available for the first time in this release).  You should try compiling with -XnoInline to see if this works-around the bug. As Jim Hugunin suggested the problem does not occur if I use -xnoInline Erik, can you please move this to a P1 or P2 major bug to make sure we don't miss it for 1.1final?  Now that it's assigned to you I can't make that kind of change. This is now fixed in the current tree with a test in bugs/StackError.java.The problem is that the body of the around method was being inlined into a location where the stack height was not zero.  This had a bad interaction with the exception handler in the around advice that will remove everything on the stack and replace it with the exception that was raised.The simple fix was to switch to using the closure style of around advice whenever the around body has an exception handler and the join point is in stack (rather than frame) context.A much better fix would be to add one more level of indirection by putting the around advice in a method to avoid these stack issues.  This will require significant bytecode work and since it is just a performance optimization, it is unlikely to happen until after 1.1.0.Erik, please take a look at these fixes and if you're happy with them, mark the bug as fixed. the fix is conservative and correct, exactly right for this stage of development. "	2003-01-16 15:18:00	1042750000.0	resolved fixed	6c9118b	1051050000.0	tests/bugs/StackError.java tests/bugs/messyAround/cap/OptionList.java weaver/src/org/aspectj/weaver/bcel/BcelShadow.java weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java
36564	Internal compiler error	"Eclipse: 2.1.0, 200302211557AspectJ: 1.1.1I get the following internal error when using ""thisJoinPoint.getStaticPart()"" in around advice at a call joinpoit (source below). Using just ""thisJoinPoint"" is fine.java.lang.NullPointerException	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:40)	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:44)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.analyseCode(AbstractMethodDeclaration.java:106)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:445)	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:76)	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:539)	at org.aspectj.ajdt.internal.compiler.AjCompiler.process(AjCompiler.java:65)	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:340)	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:232)	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:171)	at org.aspectj.ajdt.internal.core.builder.AjBuildManager$BatchBuilder.run(AjBuildManager.java:655)	at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:139)	at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:92)	at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:213)	Exceptions.java	AspectJ Bugs/src/compiler	Source:package compiler;import java.io.*;/** * @author websterm * * To change this generated comment go to  * Window>Preferences>Java>Code Generation>Code and Comments */public class Test {	public static void main(String[] args) throws Exception{		FileInputStream in = new FileInputStream(""test"");	}}/* * Created on 14-Apr-03 * * To change this generated comment go to  * Window>Preferences>Java>Code Generation>Code and Comments */package compiler;import java.io.*;import org.aspectj.lang.*;/** * @author websterm * * To change this generated comment go to  * Window>Preferences>Java>Code Generation>Code and Comments */public aspect Exceptions {		pointcut exceptionMethods () :		call(* java.io.*.*(..) throws IOException);			Object around () throws IOException : exceptionMethods() && !within(Exceptions) {		Object obj = proceed();		System.out.println(thisJoinPoint.getStaticPart());		return obj;		}} fixed in current tree, test in bugs/tjpStaticPart (test was easily produced from that provided in the bug report)This bug was caused by a failed attempt to optimize thisJoinPoint.getStaticPart() to just be thisJoinPointStaticPart so that the dynamic join point object would not have to be created if it wasn't needed.  The fix was to remove any attempt at this particular optimization.If you want this performance optimization, you should just use thisJoinPointStaticPart directly in your code. "	2003-04-16 08:42:21	1050500000.0	resolved fixed	0a8dbde	1051030000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ThisJoinPointVisitor.java tests/bugs/tjpStaticPart/Exceptions.java tests/bugs/tjpStaticPart/Test.java
35725	Inter type declaration to base class not seen by derived class	"The following code shows what I believe is an incorrect error - the base class AImpl is made concrete by the aspect Af, but the compilation of BImpl does not recognize this fact. This problem is for version 1.1rc1 and is not seen in 1.0.6.// ---------------------// A.javapackage a_intf;public interface A{  A f();}// ---------------------// AImpl.javapackage a_impl;import a_intf.A;public class AImpl  implements A{}// ---------------------// Af.javapackage a_impl;import a_intf.A;aspect Af{  public A AImpl.f()  {    System.out.println( ""f called"" );    return null;  }}// ---------------------// B.javapackage b_intf;import a_intf.A;public interface B  extends A{  B g();}// ---------------------// BImpl.javapackage b_impl;import a_impl.AImpl;import b_intf.B;public class BImpl  extends AImpl  implements B{  public B g()  {    System.out.println( ""g called"" );    return null;  }}// Compiler Error:// BImpl.java:7 Class must implement the inherited abstract method a_intf.A.f() you're correct, this was a bug and was easy to reproduce with your test belowthis is now fixed in the current tree with test in bugs/interInherit "	2003-03-26 15:16:24	1048710000.0	resolved fixed	11b3b07	1050010000.0	tests/bugs/interInherit/a_impl/AImpl.java tests/bugs/interInherit/a_impl/Af.java tests/bugs/interInherit/a_intf/A.java tests/bugs/interInherit/b_impl/BImpl.java tests/bugs/interInherit/b_intf/B.java
36046	inter-type declaration bug with abstract classes	"This error occurs when you do an inter-type declaration on an interface, use declare parents to make an abstract base class implement it, and then try to use the declared (method), it fails. If you make the base class concrete, then this doesn't fail.The following code demonstrates the error. If you run java Driver you get:java.lang.AbstractMethodError: Derived.getExecutions(Ljava/lang/String;)I	at Driver.main(Driver.java:23)Exception in thread ""main"" public class Driver {    public static void main(String args[]) {        Derived generator = new Derived();        System.out.println(generator.getExecutions(""processEvents""));    }    static aspect MonitorBase {        declare parents: Base implements ExecutionMonitor.MonitoredItem;    }    }class Derived extends Base {    public String getName() {        return null;    }}abstract class Base {    abstract public String getName();}aspect ExecutionMonitor {    /** marker interface to indicate the execution monitor should track calls and executions on this class. */    public interface MonitoredItem {        int getExecutions(String methodName);    }    /** a Map of events to mutable integers */    public int MonitoredItem.getExecutions(String methodName) {        return 0;    }} fixed in current tree, revealed a more serious problem in overriding existingabstract methods with concrete inter-type declarations.  test in bugs/interAbstract. "	2003-04-03 18:21:57	1049410000.0	resolved fixed	808bae8	1050010000.0	tests/bugs/interAbstract/Driver.java weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java
33474	bad source locations for declare error/warning	"[Submitted on behalf of Adrian Colyer and Jim Hugunin]> ...- there's one thing in the weaver I> couldn't solve tonight (Jim/Mik) : org.aspectj.weaver.Checker.match(..) is> called when checking whether a declare warning /error pointcut matches a> given shadow. If t does, a Message is created whose sourceLocation is> shadow.getSourceLocation(). The implementation of getSourceLocation in> BcelShadow returns the unqualified file name rather than the qualified one> (e.g ""Point.java"" rather than> ""org.eclipse.ajdt.demo/src/figures/Point.java"") which means that later on> eclipse can't find the resource the marker is supposed to be attached to.> I've patched it in AJDT by scanning the project for the first resource> that> ends in the given name and using that, which we will get away with for> many> projects. I couldn't find an easy way to fix it properly in the weaver.This is an issue with the weaver operating on bytecode, where the only information about the actual source file is the FILENAME attribute in the .class file which just contains the final unqualified portion of the name.  I can think of three solutions to this:1. Change the code for getSourceLocation to use the current package in order to produce a more complete filename, i.e. figures/Point.java instead of just Point.java.  This should be a relatively straightforward and localized change and is the only solution that would help the case of weaving into .jar files.2. Pass some additional information from the eclipse compiler phase to the bytecode weaver to let it know the actual source locations of files.  This could give you the actual source file, but is a crosscutting change that would affect a lot of the system.3. Handle declare error and warning in a special pass that performs weaving on the AST rather than the .class file.  This is the only solution that will give you correct column information which can make these messages easier to understand, but it is a LOT of work.I'd recommend that you consider doing #1 in order to improve the quality of your hack in the short-term.  I plan to look at #2 as part of a final clean-up of the incremental compilation code before the candidate1 release.  I think that ultimately #3 is the right answer, but it would be a very large amount of work and could only happen post-1.1. I implemented solution #2 below which I believe fixes the bug, but...This bug needs a test case that verifies the correct information is being passed to AJDT.  Either Mik or Adrian should write that.  I'm assigning this to Adrian since Mik is already the reporter. Test case has been added (and verifies that the fix works :-) ).I extended the Ajde test suite capability to capture messages produced during a build and record them for checking post-compilation. Seems to be a generally useful capability beyond just this one bug. I couldn't put the test case in ajcTests.xml since I can only validate that a message is produced on a given line using that route, whereas for this bug I needed to verify the message content.The testcase itself which shows how compiler messages can be verified is in ajde/testsrc/org/aspectj/ajde/CompilerMessagesTest.java. "	2003-02-27 14:03:15	1046370000.0	resolved fixed	989aaf7	1048780000.0	ajde/testdata/examples/declare-warning/apackage/InitCatcher.java ajde/testdata/examples/declare-warning/apackage/SomeClass.java ajde/testsrc/org/aspectj/ajde/AjdeTestCase.java ajde/testsrc/org/aspectj/ajde/AjdeTests.java ajde/testsrc/org/aspectj/ajde/CompilerMessagesTest.java ajde/testsrc/org/aspectj/ajde/NullIdeManager.java ajde/testsrc/org/aspectj/ajde/NullIdeTaskListManager.java
34925	compiler crash on yesterday's rc1 build	<Pyinson Data Over Head> I actually ran this test against the latest rc1 build (I pulled it from cvs on my home machine and didn't realize there was a new build til I read my email)... This bug is easily reproduced.  The bug means that declare soft can notbe used in a system that has explicit throw statements which throw checked exceptions that are not permitted except through the declare soft.This particular example could be worked-around by making PersistenceException aRuntimeException.  This clearly seems to be the right choice in this minimal test case.  However, the bug would still be revealed if the rest of the code contains an explicit 'throw IOException' that was not declared by the enclosing method.This bug is right on the border-line for delaying the RC1 release and we are currently evaluating that.  It will be fixed shortly in the active cvs tree. resolved in tree and for 1.1rc1 release 	2003-03-13 11:58:52	1047570000.0	resolved fixed	56cc4f2	1047580000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseShadow.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java tests/bugs/ConvertToUnchecked.java
34858	Weaver crash	"this test file (Test.java) crashes the weaver:public class Test {    static aspect MockProcessing {        pointcut testFlow(final Thread thread) :             cflow(execution(void run()) && this(thread) && within(Thread)); // the within is an optimization        Object around() :                call(* DummyConfiguration.createRootApplicationModule(..)) && testFlow(Thread)        {            return null;        }    }}class Bar {    void foo() {        DummyConfiguration.createRootApplicationModule();    }}class DummyConfiguration {    static Object createRootApplicationModule() {        return null;    }}prompt>ajc -d 11bin -1.4 Test.javaException thrown from AspectJ 1.1rc1This might be logged as a bug already -- find current bugs at  http://bugs.eclipse.org/bugs/buglist.cgi?product=AspectJ&component=CompilerBugs for exceptions thrown have titles File:line from the top stack,e.g., ""SomeFile.java:243""If you don't find the exception below in a bug, please add a new bugat http://bugs.eclipse.org/bugs/enter_bug.cgi?product=AspectJTo make the bug a priority, please include a test programthat can reproduce this exception.00java.lang.ArrayIndexOutOfBoundsException: 0        at org.aspectj.weaver.IntMap.get(IntMap.java:109)        at org.aspectj.weaver.patterns.CflowPointcut.concretize1(CflowPointcut.java:170)        at org.aspectj.weaver.patterns.ReferencePointcut.concretize1(ReferencePointcut.java:270)        at org.aspectj.weaver.patterns.AndPointcut.concretize1(AndPointcut.java:88)        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:127)        at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:120)        at org.aspectj.weaver.Advice.concretize(Advice.java:207)        at org.aspectj.weaver.CrosscuttingMembers.addShadowMunger(CrosscuttingMembers.java:78)        at org.aspectj.weaver.CrosscuttingMembers.addShadowMungers(CrosscuttingMembers.java:72)        at org.aspectj.weaver.ResolvedTypeX.collectCrosscuttingMembers(ResolvedTypeX.java:328)        at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect(CrosscuttingMembersSet.java:54)        at org.aspectj.weaver.bcel.BcelWeaver.prepareForWeave(BcelWeaver.java:164)        at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:214)        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.weaveAndGenerateClassFiles(AjBuildManager.java:394)        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:149)        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:55)        at org.aspectj.tools.ajc.Main.run(Main.java:216)        at org.aspectj.tools.ajc.Main.runMain(Main.java:155)        at org.aspectj.tools.ajc.Main.main(Main.java:72)1 fail|abort I've reproduced this bug easily from the submitted test.  It should be fixed today for the rc1 release. fixed in tree, tests in bings/CflowBinding*.javaissue was with cflow capturing state that was not actually exposed to any advice "	2003-03-12 14:50:32	1047500000.0	resolved fixed	7746fcb	1047510000.0	tests/bugs/CflowBinding.java tests/bugs/CflowBindingOrig.java weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java
34820	ajc -aspectpath  fails with NPE for cflow pointcuts	<Pyinson Data Over Head> this is now fixed in the tree and tested in the unit tests for org.aspectj.ajdt.core package under BinaryFormsTestCaseyour fix worked perfectly and is the right thing to do right now before thecandidate release.  for a future release we might reconsider whether or notthis method should be allowed to return null.i'm very happy to see you building successfully from the latest version of cvsand helping us catch bugs before a release goes out! 	2003-03-12 10:36:41	1047480000.0	resolved fixed	db37189	1047500000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseAdvice.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java
29934	runtime NullPointerException when applying around advice to other around advice	"When the program below is run, it produces a NullPointerException...java.lang.NullPointerException	at A2.ajc$around$A2$3b6proceed(CflowCycles.java)	at A2.ajc$around$A2$3b6_aroundBody3(CflowCycles.java:35)	at Target.run(CflowCycles.java:24)	at CflowCycles.run_aroundBody4(CflowCycles.java:8)	at CflowCycles.main_aroundBody6(CflowCycles.java:24)	at CflowCycles.main(CflowCycles.java:24)---(in new/CflowCycles.java and in ajcTestsFailing.xml)import org.aspectj.testing.Tester; /** @testcase cflow cycles in advice from different aspects */public class CflowCycles {  public static void main( String args[] ) {        Tester.expectEvent(""target A1"");        Tester.expectEvent(""target A2"");        new Target().run();        Tester.checkAllEventsIgnoreDups();  }}class Target {    public void run(){ }}aspect A1 {    pointcut TargetRunFlow ()         // ok if no cflow: within(Target) && execution(* *(..)) && !within(A1+);        : !within(A1+) && !preinitialization(new(..)) && !initialization(new(..))//cflow(within(Target) && execution(* *(..))) && !within(A1+)        ;    Object around () : TargetRunFlow() {        Tester.event(""target A1"");        return proceed();    }    // ok if in the same class}aspect A2 {    pointcut TargetRun ()         : within(Target) && execution(* *(..)) && !within(A2+);        ;    Object around () : TargetRun() {        Tester.event(""target A2"");        return proceed();    }} fixed in current tree, fix is to not inline around advice that hasother around advice applied to it "	2003-01-21 20:13:59	1043200000.0	resolved fixed	0fb5f69	1047430000.0	weaver/src/org/aspectj/weaver/bcel/BcelShadow.java
32239	Dumps assembly code if Object[] used in args (BcelRenderer.java:152)	<Pyinson Data Over Head> This is a critical bug that I'm assigning to Erik.  I think this should bean easy fix. Fixed in CVS.  This was a bug with Array types making it through all the staticchecking to require runtime-residualized checks.  For no discernable reason,these residualized checks (which eventually emit the INSTANCEOF bytecode) required an ObjectType as input.  This is now fixed to accept any ReferenceType. 	2003-02-19 10:07:28	1045670000.0	resolved fixed	ae0ef30	1047360000.0	weaver/src/org/aspectj/weaver/bcel/BcelRenderer.java weaver/src/org/aspectj/weaver/bcel/Utility.java
32421	can't resolve nested public interfaces	"This may be caused by the bug as 32399file TransactionTest.java:import sub.ExecutionMonitor;public class TransactionTest {    static Transaction theTransaction;    private void assertCommitted() {        theTransaction.getCount(""method-execution"", ""commit"");    }    static aspect MonitorTest {        declare parents: Transaction implements ExecutionMonitor.MonitoredItem;    }}class Transaction {}file sub/ExecutionMonitor.aj:package sub;public aspect ExecutionMonitor {    public interface MonitoredItem {        int getCount(String eventType, String eventName);    }    public int MonitoredItem.getCount(String eventType, String eventName) {            return 0;    } }         sample compilation:C:\devel>ajc -1.4 TransactionTest.java sub\ExecutionMonitor.ajcan't bind type name 'ExecutionMonitor$MonitoredItem'C:/devel/TransactionTest.java:7: The method getCount(java.lang.String, java.lang.String) is undefined for the type TransactiontheTransaction.getCount(""method-execution"", ""commit"");               ^^^^^^^^2 errors fixed in current tree, test in bugs/interfaceNames/* "	2003-02-20 17:33:37	1045780000.0	resolved fixed	0a175d2	1046990000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseScope.java tests/bugs/InnerPointcut.java tests/bugs/interfaceNames/TransactionTest.java tests/bugs/interfaceNames/sub/ExecutionMonitor.java tests/new/EachObjectInDeepPackage.java
33948	inter-type no-arg constructor declaration conflict with compiler-generated constructor	"Get error  ""inter-type declaration from A conflicts with existing member""when declaring a no-arg constructor in an aspect on another type which has no constructors.  Likely the compiler is generating a default constructor which collides in the weaver.  See test case:  tests/bugs/ConstructorDeclaration.javaCan the weaver reliably check that a default constructor was generated by the compiler (ours or javac or ...)?  Otherwise, this could be a known limitation. Erik and I discussed this (in November or December, 2002) and decided that this is the correct behavior for the 1.1 compiler.  In Java, when you declare a class without explicitly writing a constructor, that is equivalent to declaring a zero-argument constructor.  If you want to change the behavior of that constructor you can do it with advice, but you can't stomp on this implicit constructor with an introduction.  If this isn't in the changes/1.1 spec it should be there. to be folded into documentation added to the semantics section of the programming guide dealing with inter-type constructor declarations. "	2003-03-06 02:48:01	1046940000.0	resolved fixed	6a8fa08	1046940000.0	tests/bugs/ConstructorDeclaration.java
32463	ajc reports error when encountering static declaration of nested classes	"Version: AspectJ Compiler 1.1beta4The ajc compiler issues a spurious error message and exits with a negative error code when weaving code containing static declaration of a nested class. The compiler seem to write the classfiles correctly but the negative exit status causes problems when e.g. using the AjcCompilerAdapter in ant.To reproduce:1) Extract the following two files into an empty directory:// File: A.aj:aspect A  {    pointcut withinTest(): within(Test);    pointcut callToHandleOrder() : (withinTest() &&                             call(* handleOrder(..)));    Object around(): callToHandleOrder() {      return ""DUMMY inserted by ASPECT"" ;   }}// End of File A.aj// File : Test.javapublic class Test{    // Commenting out the static declaration makes everything work OK    static    {        class StaticNestedClass        {        }    }        public static void main(String[] args)    {      System.out.println(new Test().handleOrder(""test""));    }    private String handleOrder(String t)    {      return t;    }}// End of Test.java2) Compile the files    ajc -sourceroots . -verboseOutput:-----compiling c:/aspectj1.1/doc/examples/bug/./A.ajcompiling c:/aspectj1.1/doc/examples/bug/./Test.javaweavingmight need to weave [UnwovenClassFile(null, Test$1$StaticNestedClass), UnwovenClassFile(null, A), UnwovenClassFile(null, Test)](world=true)wrote class file: c:\aspectj1.1\doc\examples\bug\A.classcan't find type Test$1wrote class file: c:\aspectj1.1\doc\examples\bug\Test$1$StaticNestedClass.classwrote class file: c:\aspectj1.1\doc\examples\bug\Test.class1 error------ fixed in current tree, test in bugs/WeaveLocal.javaThis bug had been reported before on the mailing list, but by includinga small self-contained test case, this report made the bug easy to reproduceand hence easy to fix.  Thanks. "	2003-02-21 05:59:47	1045830000.0	resolved fixed	d1e5c0a	1046910000.0	tests/bugs/WeaveLocal.java weaver/src/org/aspectj/weaver/NameMangler.java weaver/src/org/aspectj/weaver/ResolvedTypeX.java weaver/src/org/aspectj/weaver/TypeX.java weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java weaver/testsrc/org/aspectj/weaver/TypeXTestCase.java
33635	Negation of if pointcut does not work	"In ""!if(expression)"" the negation part is ignored. I am using beta4.How to reproduce:public class Test {    public static void main(String args[]) {    }}aspect NotIfBugAspect {    before() : execution(* main(..)) && !if(true) {	System.out.println(""NotIfBugAspect message"");    }}> ajc *.java> java TestNotIfBugAspect messageIf I change the pointcut in before advice to move negation inside if(), everything works fine:aspect NotIfBugAspect {    before() : execution(* main(..)) && if(!true) {	System.out.println(""NotIfBugAspect message"");    }}> ajc *.java> java Test  <no output> fixed in tree, test in bugs/NotIf.javaThis bug was caused by a previous fix for handling the interaction between args and if pcd's.  This interaction is much messier than it should be andis a prime opportunity for a better design. "	2003-03-02 20:01:54	1046650000.0	resolved fixed	cb77524	1046900000.0	tests/bugs/NotIf.java weaver/src/org/aspectj/weaver/patterns/IfPointcut.java
30026	NullPointerException when compiling	With the following program I get a NullPointerException during compiling and awarning that the source code of Object is not available for weaving:public class NullPtr {    public static void main(String args[]) {        NullPtr np = new NullPtr();        np = null;    }    public void finalize() throws Throwable {    }}aspect FinalizeContract {    pointcut finalizeCall(Object o):        this(Object+) &&        this(o) &&        execution(void finalize());    void around(Object o) throws Throwable: finalizeCall(o) {        o.finalize();               // error        ((NullPtr) o).finalize();   // ok        proceed(o);    }}It works if I comment out the line indicated by the // error comment or if Ideclare the aspect as privileged. The correct behavior is for the compiler to signal that the finalize method is not visible to the aspect because its a protected method on Object.  This is the behavior that I observe for 1.1beta4.Can you confirm that you're seeing it with the latest version of the compiler, and if so include the text of the stack trace and warning? <Pyinson Data Over Head> fixed in current cvs tree, test case in bugs/Finalizer.javathanks for confirming that this bug was found in 1.1beta4.  it is now fixed in the current cvs tree. 	2003-01-22 17:06:50	1043270000.0	resolved fixed	8e6cef0	1045190000.0	tests/bugs/Finalizer.java
31423	Pointcut adviceexecution() does not work	"Pointcut adviceexecution() does not seem to pick advice executionjoin points in beta4. Here is a program that shows the problem:public class Test {    public static void main(String[] args) {    }}aspect Aspect1 {    before() : execution(* Test.*(..)) {	System.out.println(""Reached "" + thisJoinPoint);    }}aspect Aspect2 {    before() : adviceexecution() && !within(Aspect2) {	System.out.println(""Reached "" + thisJoinPoint);    }}F:\aop\bugs\1.1\b4\adviceexecution>ajc -versionAspectJ Compiler 1.1beta4F:\aop\bugs\1.1\b4\adviceexecution>ajc Test.javaF:\aop\bugs\1.1\b4\adviceexecution>java TestReached execution(void Test.main(String[])) Fixed in current cvs tree, test in bugs/AdviceExec.javaThanks for catching this rather embarassingly obvious bug. "	2003-02-09 12:29:28	1044810000.0	resolved fixed	19c3e16	1045180000.0	tests/bugs/AdviceExec.java weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java
30168	Error with certain combination of advice	<Pyinson Data Over Head> This is now fixed in the current cvs tree with a test in bugs/crashes.This was a fascinating bug, and you did an excellent job of reducing it to a minimal test case.  The problem had to do with ajc's attempts to optimize away the creation of dynamic JoinPoint objects, which can be very expensive.  Your code managed to confuse this optimization and caused it to generate a call to the method ThisJoinPoint.StaticPart.getSignature on an object that was statically typed to ThisJoinPoint.  This is illegal bytecode.You should consider reporting this as a bug to SUN.  While ajc did generate illegal bytecode here, the correct VM behavior should have been to produce a VerifyError when loading the classes.  Neither the Solaris or Windows VM is handling this case at all well.  The Solaris VMs behavior is particularly troubling as it causes such a hard crash. 	2003-01-24 07:25:03	1043410000.0	resolved fixed	d15eb32	1045170000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ThisJoinPointVisitor.java tests/bugs/crashes/test/Test3.java
29959	super call in intertype method declaration body causes VerifyError	"AspectJ Compiler 1.1beta4This program:aspect Foo {  void A.foo() { }  void B.foo() { super.foo(); }}class A { }class B extends A { }class Main {  public static void main(String[] args) {    new B();  }}causes this error at runtime:Exception in thread ""main"" java.lang.VerifyError: (class: B, method: ajc$superDispatch$B$foo signature: ()V) Illegal use of nonvirtual function call	at Main.main(Foo.java:11)Note that foo is never even called; the error happens at load time when the new B() expression causes class B to be loaded.  There's no error if either one of the foo methods is declared in its class directly.This is kind of a showstopper...--Doug fixed in current cvs tree with test in bugs/SuperToIntro.java "	2003-01-22 07:10:28	1043240000.0	resolved fixed	3e2801a	1045170000.0	org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeConstructorDeclaration.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/SuperFixerVisitor.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeMethodBinding.java org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java tests/bugs/SuperToIntro.java
29769	Ajde does not support new AspectJ 1.1 compiler options	"The org.aspectj.ajde.BuildOptionsAdapter interface does not yet support the new AspectJ 1.1 compiler options. These need to be added to the interface, any old or renamed options deprecated, and then the correct processing needs to happen within Ajde to pass these options to the compiler.This enhancement is needed by the various IDE projects for there AspectJ 1.1support. Created attachment 3075Patch for ajbrowser project Created attachment 3076Patch for Ajde project Created attachment 3077Patch for org.aspcetj.ajdt.core project As ever, turned into a bigger task than you would intially think. The attachedpatches bring Ajde up to speed with the new AspectJ 11 options.In opts11.ajde.patch.txt:=========================Patch for the ajde project.First off, a set of fixes for the AjdeModuleTests -these were broken evenbefore I started work, so I had to fix them first! They now run successfullyusing a Junit Launcher in eclipse from the ajde project. There are a lot ofrelative directory paths specified throughout the tests, so I worry that thesemay not work in an automated Ant run without further mods, but since they werebroken anyway, I figure they can't have been included for the time being. Three tests in the suite still fail, one of which at least I think is waiting for Mik's additional structure to be generated. The other two look like suspicious tests, but I've left them in (not related to my options processing work). Secondly, a comprehensive set of new tests to exercise all the new options. Primarily in BuildConfigurationTests.java (run at least this test suite after applying the patch to verify that all has gone well).Thirdly, the new BuildOptionsAdapter and ProjectPropertiesAdapter interfaces, and the relevant updates (quite a few!) inside Ajde to correctly populate an AjBuildConfig based on them.In opts11.ajbrowser.patch.txt:==============================Patch for the ajbrowser projectAn update to ajbrowser.BrowserProperties to support the new interfacesIn opts11.org.aspectj.ajdt.core.patch.txt:==========================================Patch for the org.aspectj.ajdt.core projectExtension to the test case, and updates to the BuildArgParser and AjBuildConfig.Notes:=======* The BuildArgParser currently accepts ""-Xlintfile somefile.properties"", but NOT""-Xlintfile:somefile.properties"". The latter style is specified in the 11 readme, but I didn't change it as thsi would have affected command-line optionsprocessing too.* I added -XnoWeave as a valid option in the BuildArgParser* When -sourcedirs are specified, Ajde now sets the source dirs in AjBuildConfigcorrectly - it does NOT add all of the (*.java,*.aj) files in those directories into the list of files returned by AjBuildConfig.getFiles(). The comment inAjBuildConfig surrounding that method suggests it should, but this wasn't being done previously so I've followed suit. Let me know if I should change to populate the files list. These patches are now integrated. "	2003-01-19 11:42:17	1042990000.0	resolved fixed	85a827a	1043460000.0	ajbrowser/src/org/aspectj/tools/ajbrowser/BrowserProperties.java ajde/src/org/aspectj/ajde/BuildOptionsAdapter.java ajde/src/org/aspectj/ajde/ProjectPropertiesAdapter.java ajde/src/org/aspectj/ajde/internal/AspectJBuildManager.java ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.java ajde/testdata/examples/figures-coverage/figures/Figure.java ajde/testsrc/org/aspectj/ajde/AjdeTests.java ajde/testsrc/org/aspectj/ajde/BuildConfigurationTests.java ajde/testsrc/org/aspectj/ajde/BuildOptionsTest.java ajde/testsrc/org/aspectj/ajde/NullIdeManager.java ajde/testsrc/org/aspectj/ajde/NullIdeProperties.java ajde/testsrc/org/aspectj/ajde/StructureModelRegressionTest.java ajde/testsrc/org/aspectj/ajde/StructureModelTest.java ajde/testsrc/org/aspectj/ajde/ui/StructureViewManagerTest.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java
29662	VerifyError on accessing objects not accessible to the weaver: Incompatible object argument for invokespecial	"I use aspectj1.1b4 (the version list box did not let me choose, it offered only""unspecified"").Compiling the program below yields a warning that a affected type is not exposedto the weaver. Running it crashes the program with this message:""java.lang.VerifyError: (class: VerifyError, method: finalize signature: ()V)Incompatible object argument for invokespecial""public class VerifyError {    public static void main(String args[]) {        VerifyError ve = new VerifyError();    }    protected void finalize() {}}aspect FinalizeContract {    pointcut finalizeCall(Object o):        this(Object+) &&        this(o) &&        execution(void finalize());    void around(Object o) throws Throwable: finalizeCall(o) {        super.finalize();        proceed(o);    }} fixed in current cvs tree, test in bugs/AroundAccess.javathis bug motivated a redesign of the code to make the bodies of around advice inlinable that no longer shares code with the implementation of privileged access to external members "	2003-01-16 15:12:47	1042750000.0	resolved fixed	2d297d7	1043190000.0	tests/bugs/AroundAccess.java
29186	ajc -emacssym chokes on pointcut that includes an intertype method	<Pyinson Data Over Head> This bug just touched on the surface of many problems with structure model generation.  The worst of those bugs are now all fixed in the current tree.  The testcase for these is to run the standard test suite with the -emacssym flag so that model will be generated for every test case in the suite.This bug shows up in all of the ide support implementations, and using -emacssym is a good way of testing all of them minimally. 	2003-01-08 21:22:48	1042080000.0	resolved fixed	c1260e6	1042580000.0	asm/src/org/aspectj/asm/StructureModel.java org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java weaver/src/org/aspectj/weaver/AsmAdaptor.java weaver/src/org/aspectj/weaver/Lint.java weaver/src/org/aspectj/weaver/ResolvedTypeX.java weaver/src/org/aspectj/weaver/Shadow.java weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java
28919	waever tries to weave into native methods ...	If you don't find the exception below in a bug, please add a new bugTo make the bug a priority, please include a test programthat can reproduce this exception.bad non-abstract method with no code: private native int nativeMessagePumpInitialize() on public class plc.comm.pvi.PviCom$LinkEventHandlerImplbad non-abstract method with no code: private native int nativeMessagePumpInitialize() on public class plc.comm.pvi.PviCom$LinkEventHandlerImpljava.lang.RuntimeException: bad non-abstract method with no code: private native int nativeMessagePumpInitialize() on public class plc.comm.pvi.PviCom$LinkEventHandlerImpl        at org.aspectj.weaver.bcel.LazyMethodGen.<init>(Unknown Source)        at org.aspectj.weaver.bcel.LazyClassGen.<init>(Unknown Source)        at org.aspectj.weaver.bcel.BcelObjectType.getLazyClassGen(Unknown Source)        at org.aspectj.weaver.bcel.BcelWeaver.weave(Unknown Source)        at org.aspectj.weaver.bcel.BcelWeaver.weave(Unknown Source)        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.weaveAndGenerateClassFiles(Unknown Source)        at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(Unknown Source)        at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(Unknown Source)        at org.aspectj.tools.ajc.Main.run(Unknown Source)        at org.aspectj.tools.ajc.Main.runMain(Unknown Source)        at org.aspectj.tools.ajc.Main.main(Unknown Source) The problem was an over-eager debugging guard that throws an exception whengiven seriously malformed classfiles.  Seriously malformed, in this particularcase, being non-abstract with no code.  This has now been properly relaxed tonon-(abstract or native) with no code. 	2002-12-30 16:40:03	1041280000.0	resolved fixed	2781720	1042570000.0	weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java
28974	"Compiler error when introducing a ""final"" field"	"The aspect below fails to compile with 1.1b2, producing the compilation error: --------------------$ ajc com/ibm/amc/*.java com/ibm/amc/ejb/*.javad:/eclipse/runtime-workspace-ajsamples/Mock EJBs/com/ibm/amc/DemoBeanEJB.java:1: Cannot assign a value to the final field com.ibm.amc.DemoBean.ajc$interField$com_ibm_amc$verbose!! no source information available !!1 error---------------------------package com.ibm.amc;import com.ibm.amc.ejb.SessionBean;/** * @author colyer * * To change this generated comment edit the template variable ""typecomment"": * Window>Preferences>Java>Templates. * To enable and disable the creation of type comments go to * Window>Preferences>Java>Code Generation. */public aspect DemoBeanEJB {	declare parents: DemoBean implements SessionBean;	        // THIS NEXT LINE IS THE CULPRIT	static final boolean DemoBean.verbose = true;		private transient String DemoBean.ctx;		public void DemoBean.ejbActivate( ) {		if ( verbose ) {			System.out.println( ""ejbActivate Called"" );			}		}}-------------------Making the inter-type declaration non-final solves the problem... Created attachment 2885Mini-project that reproduces the error This seems like it could be reduced to a much smaller minimal test case thatwould be easier to add to our test suite.  Can you reproduce this with just 2 classes an no external dependencies? Created attachment 2918Smallest possible test that reproduces the problem:-). Yes, here's a 5-line program that reproduces the problem.Thanks, Adrian. fixed cvs tree, testcase in new/finalfield/*The fix involved a minor change to org.aspectj.weaver.AjcMemberMaker.makePublic to makePublicNonFinalThis means that all introduced fields are always implemented with a non-final field in the target class.  The compiler's checking rules still operate on the inter-type declaration which remains final.  The test case was extended to ensure that this checking still works to signal errors when final fields are assigned to. "	2003-01-03 10:28:23	1041610000.0	resolved fixed	99a873c	1042570000.0	weaver/src/org/aspectj/weaver/AjcMemberMaker.java
